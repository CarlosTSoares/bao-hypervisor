
/home/carlos/thesis/wrkdir/src/bao-hypervisor/bin/qemu-aarch64-virt/linux_pcie/bao.elf:     file format elf64-littleaarch64


Disassembly of section .boot:

0000fd8000000000 <_el2_entry>:
	 *		x1 -> contains image base load address
	 * Register x9 is reserved to indicate if the current cpu is master (negated).
	 * Register x1 is reserved to contain the cpu root page table address.
	 */

	mrs  x0, MPIDR_EL1
    fd8000000000:	d53800a0 	mrs	x0, mpidr_el1
	adrp x1, _image_start
    fd8000000004:	90000001 	adrp	x1, fd8000000000 <_el2_entry>

	/*
	 * Install vector table physical address early, in case exception occurs during this
	 * initialization.
	 */
	adr	x3, _hyp_vector_table
    fd8000000008:	10007fc3 	adr	x3, fd8000001000 <_hyp_vector_table>
	msr	VBAR_EL2, x3
    fd800000000c:	d51cc003 	msr	vbar_el2, x3
	 * only considering two levels of affinity.
	 * TODO: this should be done some other way. We shouldn't depend on the platform description
	 * this early in the initialization.
	 */

	mov x3, x0, lsr #8
    fd8000000010:	aa4023e3 	orr	x3, xzr, x0, lsr #8
	and x3, x3, 0xff
    fd8000000014:	92401c63 	and	x3, x3, #0xff
	adr x4, platform
    fd8000000018:	100948c4 	adr	x4, fd8000012930 <platform>
	ldr x4, [x4, PLAT_ARCH_OFF+PLAT_ARCH_CLUSTERS_OFF+PLAT_CLUSTERS_CORES_NUM_OFF]
    fd800000001c:	f9413884 	ldr	x4, [x4, #624]
	ldr x5, =BAO_VAS_BASE
    fd8000000020:	58000a85 	ldr	x5, fd8000000170 <set_loop+0x30>
	sub x4, x4, x5
    fd8000000024:	cb050084 	sub	x4, x4, x5
	add x4, x4, x1
    fd8000000028:	8b010084 	add	x4, x4, x1
	mov x5, xzr
    fd800000002c:	aa1f03e5 	mov	x5, xzr
	mov x7, xzr
    fd8000000030:	aa1f03e7 	mov	x7, xzr
1:
	cmp x5, x3
    fd8000000034:	eb0300bf 	cmp	x5, x3
	b.ge	2f
    fd8000000038:	540000ca 	b.ge	fd8000000050 <_el2_entry+0x50>  // b.tcont
#if PLAT_CLUSTERS_CORES_NUM_SIZE != 8
#error "struct platform cluster core_num field type size is not 8"
#endif
	ldr w6, [x4]
    fd800000003c:	b9400086 	ldr	w6, [x4]
	add x4, x4, #PLAT_CLUSTERS_CORES_NUM_SIZE
    fd8000000040:	91002084 	add	x4, x4, #0x8
	add x5, x5, #1
    fd8000000044:	910004a5 	add	x5, x5, #0x1
	add x7, x7, x6
    fd8000000048:	8b0600e7 	add	x7, x7, x6
	b 	1b
    fd800000004c:	17fffffa 	b	fd8000000034 <_el2_entry+0x34>
2:
	and x0, x0, #0xff
    fd8000000050:	92401c00 	and	x0, x0, #0xff
	add x0, x0, x7
    fd8000000054:	8b070000 	add	x0, x0, x7
 */
 .pushsection .data
_master_set:
	.8byte 	0
.popsection
	mov x5, #1
    fd8000000058:	d2800025 	mov	x5, #0x1                   	// #1
	adr	x3, _master_set
    fd800000005c:	1008fd63 	adr	x3, fd8000012008 <_master_set>

0000fd8000000060 <_set_master_cpu>:
_set_master_cpu:
	ldr w9, [x3]
    fd8000000060:	b9400069 	ldr	w9, [x3]
	cbnz w9, 1f
    fd8000000064:	35000089 	cbnz	w9, fd8000000074 <_set_master_cpu+0x14>
	str w5, [x3]
    fd8000000068:	b9000065 	str	w5, [x3]
#endif
	adr x3, CPU_MASTER
    fd800000006c:	100916e3 	adr	x3, fd8000012348 <CPU_MASTER>
	str x0, [x3]
    fd8000000070:	f9000060 	str	x0, [x3]
	 * TODO: bring the system to a well known state. This includes disabling the MMU (done),
	 * all caches (missing i$), BP and others... and invalidating them.
	 */

	/* boot_clear stack pointer to avoid unaligned SP exceptions during boot */
	mov x3, xzr
    fd8000000074:	aa1f03e3 	mov	x3, xzr
	mov sp, x3
    fd8000000078:	9100007f 	mov	sp, x3

	/* Invalidate caches */
	/* Should we also clean ? */
	mov x19, x0
    fd800000007c:	aa0003f3 	mov	x19, x0
	mov x20, x1
    fd8000000080:	aa0103f4 	mov	x20, x1

	mov x0, #0
    fd8000000084:	d2800000 	mov	x0, #0x0                   	// #0
	bl	boot_cache_invalidate
    fd8000000088:	94000023 	bl	fd8000000114 <boot_cache_invalidate>
	cbnz x9, 1f
    fd800000008c:	b5000069 	cbnz	x9, fd8000000098 <_set_master_cpu+0x38>
	mov x0, #2
    fd8000000090:	d2800040 	mov	x0, #0x2                   	// #2
	bl	boot_cache_invalidate
    fd8000000094:	94000020 	bl	fd8000000114 <boot_cache_invalidate>
1:
	mov x0,	x19
    fd8000000098:	aa1303e0 	mov	x0, x19
	mov x1,	x20
    fd800000009c:	aa1403e1 	mov	x1, x20

	ic iallu
    fd80000000a0:	d508751f 	ic	iallu

	bl boot_arch_profile_init
    fd80000000a4:	94000041 	bl	fd80000001a8 <boot_arch_profile_init>

	mov x3, xzr
    fd80000000a8:	aa1f03e3 	mov	x3, xzr
	msr CPTR_EL2, x3
    fd80000000ac:	d51c1143 	msr	cptr_el2, x3

	/* set up cpu stack */
	mov x3, SPSel_SP
    fd80000000b0:	d2800023 	mov	x3, #0x1                   	// #1
	msr SPSEL, x3
    fd80000000b4:	d5184203 	msr	spsel, x3
	mrs x3, tpidr_el2
    fd80000000b8:	d53cd043 	mrs	x3, tpidr_el2
	ldr x4, =(CPU_STACK_OFF + CPU_STACK_SIZE)
    fd80000000bc:	580005e4 	ldr	x4, fd8000000178 <set_loop+0x38>
	add x3, x3, x4
    fd80000000c0:	8b040063 	add	x3, x3, x4
	mov SP, x3
    fd80000000c4:	9100007f 	mov	sp, x3


	/* If this is bsp (cpu 0) boot_clear bss */
	cbnz x9, 1f
    fd80000000c8:	b50000e9 	cbnz	x9, fd80000000e4 <_set_master_cpu+0x84>
	ldr	x16, =_bss_start
    fd80000000cc:	580005b0 	ldr	x16, fd8000000180 <set_loop+0x40>
	ldr	x17, =_bss_end
    fd80000000d0:	580005d1 	ldr	x17, fd8000000188 <set_loop+0x48>
	bl	boot_clear
    fd80000000d4:	9400000b 	bl	fd8000000100 <boot_clear>

	adr x5, _boot_barrier
    fd80000000d8:	1008f945 	adr	x5, fd8000012000 <_boot_barrier>
	mov x4, #2
    fd80000000dc:	d2800044 	mov	x4, #0x2                   	// #2
	stlr x4, [x5]
    fd80000000e0:	c89ffca4 	stlr	x4, [x5]

1:
	/* wait for bsp to finish boot_clearing bss */
	ldr x4, =_boot_barrier
    fd80000000e4:	58000564 	ldr	x4, fd8000000190 <set_loop+0x50>
2:
	ldar x5, [x4]
    fd80000000e8:	c8dffc85 	ldar	x5, [x4]
	cmp x5, #2
    fd80000000ec:	f10008bf 	cmp	x5, #0x2
	b.lt 2b
    fd80000000f0:	54ffffcb 	b.lt	fd80000000e8 <_set_master_cpu+0x88>  // b.tstop

	isb
    fd80000000f4:	d5033fdf 	isb

	b init
    fd80000000f8:	140024d2 	b	fd8000009440 <init>

	/* This point should never be reached */
	b	.
    fd80000000fc:	14000000 	b	fd80000000fc <_set_master_cpu+0x9c>

0000fd8000000100 <boot_clear>:

.global boot_clear
.func boot_clear
boot_clear:
2:
	cmp	x16, x17
    fd8000000100:	eb11021f 	cmp	x16, x17
	b.ge 1f
    fd8000000104:	5400006a 	b.ge	fd8000000110 <boot_clear+0x10>  // b.tcont
	str	xzr, [x16], #8
    fd8000000108:	f800861f 	str	xzr, [x16], #8
	b	2b
    fd800000010c:	17fffffd 	b	fd8000000100 <boot_clear>
1:
	ret
    fd8000000110:	d65f03c0 	ret

0000fd8000000114 <boot_cache_invalidate>:
 * x0 - cache level to be invalidated (0 - dl1$, 1 - il1$, 2 - l2$)
 */
.global boot_cache_invalidate
.func boot_cache_invalidate
boot_cache_invalidate:
	msr csselr_el1, x0
    fd8000000114:	d51a0000 	msr	csselr_el1, x0
	mrs x4, ccsidr_el1 // read cache size id.
    fd8000000118:	d5390004 	mrs	x4, ccsidr_el1
	and x1, x4, #0x7
    fd800000011c:	92400881 	and	x1, x4, #0x7
	add x1, x1, #0x4 // x1 = cache line size.
    fd8000000120:	91001021 	add	x1, x1, #0x4
	ldr x3, =0x7fff
    fd8000000124:	580003a3 	ldr	x3, fd8000000198 <set_loop+0x58>
	and x2, x3, x4, lsr #13 // x2 = cache set number – 1.
    fd8000000128:	8a443462 	and	x2, x3, x4, lsr #13
	ldr x3, =0x3ff
    fd800000012c:	580003a3 	ldr	x3, fd80000001a0 <set_loop+0x60>
	and x3, x3, x4, lsr #3 // x3 = cache associativity number – 1.
    fd8000000130:	8a440c63 	and	x3, x3, x4, lsr #3
	clz w4, w3 // x4 = way position in the cisw instruction.
    fd8000000134:	5ac01064 	clz	w4, w3
	mov x5, #0 // x5 = way counter way_loop.
    fd8000000138:	d2800005 	mov	x5, #0x0                   	// #0

0000fd800000013c <way_loop>:
way_loop:
	mov x6, #0 // x6 = set counter set_loop.
    fd800000013c:	d2800006 	mov	x6, #0x0                   	// #0

0000fd8000000140 <set_loop>:
set_loop:
	lsl x7, x5, x4
    fd8000000140:	9ac420a7 	lsl	x7, x5, x4
	orr x7, x0, x7 // set way.
    fd8000000144:	aa070007 	orr	x7, x0, x7
	lsl x8, x6, x1
    fd8000000148:	9ac120c8 	lsl	x8, x6, x1
	orr x7, x7, x8 // set set.
    fd800000014c:	aa0800e7 	orr	x7, x7, x8
	dc cisw, x7 // clean and invalidate cache line.
    fd8000000150:	d5087e47 	dc	cisw, x7
	add x6, x6, #1 // increment set counter.
    fd8000000154:	910004c6 	add	x6, x6, #0x1
	cmp x6, x2 // last set reached yet?
    fd8000000158:	eb0200df 	cmp	x6, x2
	ble set_loop // if not, iterate set_loop,
    fd800000015c:	54ffff2d 	b.le	fd8000000140 <set_loop>
	add x5, x5, #1 // else, next way.
    fd8000000160:	910004a5 	add	x5, x5, #0x1
	cmp x5, x3 // last way reached yet?
    fd8000000164:	eb0300bf 	cmp	x5, x3
	ble way_loop // if not, iterate way_loop
    fd8000000168:	54fffead 	b.le	fd800000013c <way_loop>
	ret
    fd800000016c:	d65f03c0 	ret
    fd8000000170:	00000000 	.word	0x00000000
    fd8000000174:	0000fd80 	.word	0x0000fd80
    fd8000000178:	00002000 	.word	0x00002000
    fd800000017c:	00000000 	.word	0x00000000
    fd8000000180:	00013000 	.word	0x00013000
    fd8000000184:	0000fd80 	.word	0x0000fd80
    fd8000000188:	0001bd98 	.word	0x0001bd98
    fd800000018c:	0000fd80 	.word	0x0000fd80
    fd8000000190:	00012000 	.word	0x00012000
    fd8000000194:	0000fd80 	.word	0x0000fd80
    fd8000000198:	00007fff 	.word	0x00007fff
    fd800000019c:	00000000 	.word	0x00000000
    fd80000001a0:	000003ff 	.word	0x000003ff
    fd80000001a4:	00000000 	.word	0x00000000

0000fd80000001a8 <boot_arch_profile_init>:

.section ".boot", "ax"
.global boot_arch_profile_init
boot_arch_profile_init:

    mov x20, x30
    fd80000001a8:	aa1e03f4 	mov	x20, x30

	/*
     * Register x18 contains the size of the allocated physical memory between the loadable
	 * sections of the image and the non-loadable.
     */
    ldr x18, =extra_allocated_phys_mem
    fd80000001ac:	580018b2 	ldr	x18, fd80000004c0 <_enter_vas_warm+0x34>

	/* Disable caches and MMU */
	mrs x3, SCTLR_EL2 
    fd80000001b0:	d53c1003 	mrs	x3, sctlr_el2
	bic x3, x3, #0x7	
    fd80000001b4:	927df063 	and	x3, x3, #0xfffffffffffffff8
	msr SCTLR_EL2, x3 
    fd80000001b8:	d51c1003 	msr	sctlr_el2, x3
        
	/* Skip initialy global page tables setup if not bsp (boot cpu) */
	cbnz	x9, wait_for_bsp
    fd80000001bc:	b5000709 	cbnz	x9, fd800000029c <wait_for_bsp>

	adr	x16, _page_tables_start	
    fd80000001c0:	100df210 	adr	x16, fd800001c000 <_page_tables_start>
	adr	x17, _page_tables_end	
    fd80000001c4:	100ff1f1 	adr	x17, fd8000020000 <_dmem_beg>
	add x16, x16, x18
    fd80000001c8:	8b120210 	add	x16, x16, x18
	add x17, x17, x18
    fd80000001cc:	8b120231 	add	x17, x17, x18
	bl	boot_clear		
    fd80000001d0:	97ffffcc 	bl	fd8000000100 <boot_clear>

	/* Set temporary flat mapping to switch to VAS. */

	adr x4, root_l1_flat_pt
    fd80000001d4:	100f7164 	adr	x4, fd800001f000 <root_l1_flat_pt>
	add x4, x4, x18
    fd80000001d8:	8b120084 	add	x4, x4, x18
	PTE_INDEX_ASM x5, x1, 1 
    fd80000001dc:	d35efc25 	lsr	x5, x1, #30
    fd80000001e0:	924020a5 	and	x5, x5, #0x1ff
    fd80000001e4:	d37df0a5 	lsl	x5, x5, #3
	add x6, x1, #(PTE_HYP_FLAGS | PTE_SUPERPAGE)
    fd80000001e8:	911d1426 	add	x6, x1, #0x745
	str x6, [x4, x5]
    fd80000001ec:	f8256886 	str	x6, [x4, x5]
	
	/* Set global root mappings for hypervisor image */

	adr x4, root_l1_pt
    fd80000001f0:	100df084 	adr	x4, fd800001c000 <_page_tables_start>
	add x4, x4, x18
    fd80000001f4:	8b120084 	add	x4, x4, x18
	ldr x5, =(PTE_INDEX(1, BAO_VAS_BASE)*8)
    fd80000001f8:	58001685 	ldr	x5, fd80000004c8 <_enter_vas_warm+0x3c>
	adr x6, root_l2_pt
    fd80000001fc:	100e7026 	adr	x6, fd800001d000 <root_l2_pt>
	add x6, x6, x18
    fd8000000200:	8b1200c6 	add	x6, x6, x18
	add x6, x6, #(PTE_HYP_FLAGS | PTE_TABLE)
    fd8000000204:	911d1cc6 	add	x6, x6, #0x747
	str x6, [x4, x5]
    fd8000000208:	f8256886 	str	x6, [x4, x5]

	adr x4, root_l2_pt
    fd800000020c:	100e6fa4 	adr	x4, fd800001d000 <root_l2_pt>
	add x4, x4, x18
    fd8000000210:	8b120084 	add	x4, x4, x18
	ldr x5, =(PTE_INDEX(2, BAO_VAS_BASE)*8)
    fd8000000214:	580015a5 	ldr	x5, fd80000004c8 <_enter_vas_warm+0x3c>
	adr x6, root_l3_pt
    fd8000000218:	100eef46 	adr	x6, fd800001e000 <root_l3_pt>
	add x6, x6, x18
    fd800000021c:	8b1200c6 	add	x6, x6, x18
	add x6, x6, #(PTE_HYP_FLAGS | PTE_TABLE)
    fd8000000220:	911d1cc6 	add	x6, x6, #0x747
	str x6, [x4, x5]
    fd8000000224:	f8256886 	str	x6, [x4, x5]

	adr x4, root_l3_pt
    fd8000000228:	100eeec4 	adr	x4, fd800001e000 <root_l3_pt>
	add x4, x4, x18
    fd800000022c:	8b120084 	add	x4, x4, x18
	ldr x7, =_image_start
    fd8000000230:	58001507 	ldr	x7, fd80000004d0 <_enter_vas_warm+0x44>
	ldr x8, =_image_load_end
    fd8000000234:	58001528 	ldr	x8, fd80000004d8 <_enter_vas_warm+0x4c>
	adr x6, _image_start
    fd8000000238:	10ffee46 	adr	x6, fd8000000000 <_el2_entry>
	add x6, x6, #(PTE_HYP_FLAGS | PTE_PAGE)
    fd800000023c:	911d1cc6 	add	x6, x6, #0x747
1:
	cmp	x7, x8
    fd8000000240:	eb0800ff 	cmp	x7, x8
	b.ge 2f
    fd8000000244:	5400010a 	b.ge	fd8000000264 <boot_arch_profile_init+0xbc>  // b.tcont
	//lsr x5, x7, #(PTE_INDEX_SHIFT(3)-3)
	PTE_INDEX_ASM x5, x7, 3
    fd8000000248:	d34cfce5 	lsr	x5, x7, #12
    fd800000024c:	924020a5 	and	x5, x5, #0x1ff
    fd8000000250:	d37df0a5 	lsl	x5, x5, #3
	str x6, [x4, x5]
    fd8000000254:	f8256886 	str	x6, [x4, x5]
	add x6, x6, #PAGE_SIZE
    fd8000000258:	914004c6 	add	x6, x6, #0x1, lsl #12
	add x7, x7, #PAGE_SIZE
    fd800000025c:	914004e7 	add	x7, x7, #0x1, lsl #12
	b	1b
    fd8000000260:	17fffff8 	b	fd8000000240 <boot_arch_profile_init+0x98>
2:
	ldr x8, =_image_end
    fd8000000264:	580013e8 	ldr	x8, fd80000004e0 <_enter_vas_warm+0x54>
	cmp x7, x8
    fd8000000268:	eb0800ff 	cmp	x7, x8
	b.ge 3f
    fd800000026c:	540000ea 	b.ge	fd8000000288 <boot_arch_profile_init+0xe0>  // b.tcont
    ldr x6, =_image_noload_start
    fd8000000270:	580013c6 	ldr	x6, fd80000004e8 <_enter_vas_warm+0x5c>
    ldr x10, =BAO_VAS_BASE
    fd8000000274:	580013ea 	ldr	x10, fd80000004f0 <_enter_vas_warm+0x64>
    sub x6, x6, x10
    fd8000000278:	cb0a00c6 	sub	x6, x6, x10
    add x6, x6, x1
    fd800000027c:	8b0100c6 	add	x6, x6, x1
	add x6, x6, #(PTE_HYP_FLAGS | PTE_PAGE)
    fd8000000280:	911d1cc6 	add	x6, x6, #0x747
	b 1b
    fd8000000284:	17ffffef 	b	fd8000000240 <boot_arch_profile_init+0x98>
3:
	adr x5, _boot_barrier
    fd8000000288:	1008ebc5 	adr	x5, fd8000012000 <_boot_barrier>
	mov x4, #1
    fd800000028c:	d2800024 	mov	x4, #0x1                   	// #1
	str x4, [x5]
    fd8000000290:	f90000a4 	str	x4, [x5]
	//	dsb // arguments?
	sev
    fd8000000294:	d503209f 	sev
	b 	map_cpu
    fd8000000298:	14000005 	b	fd80000002ac <map_cpu>

0000fd800000029c <wait_for_bsp>:

wait_for_bsp:	
/* wait fot the bsp to finish up global mappings */
	wfe
    fd800000029c:	d503205f 	wfe
	ldr x4, _boot_barrier
    fd80000002a0:	5808eb04 	ldr	x4, fd8000012000 <_boot_barrier>
	cmp x4, #1
    fd80000002a4:	f100049f 	cmp	x4, #0x1
	b.lt wait_for_bsp
    fd80000002a8:	54ffffab 	b.lt	fd800000029c <wait_for_bsp>  // b.tstop

0000fd80000002ac <map_cpu>:
	 *    x7 -> virt addr
	 *    x8 -> aux 
	 */

	/* get cpu root pt */
    adrp x3, _dmem_phys_beg
    fd80000002ac:	f001ab63 	adrp	x3, fd800356f000 <_dmem_phys_beg>
	mov x8, #(CPU_SIZE + (PT_SIZE*PT_LVLS))
    fd80000002b0:	d28c0008 	mov	x8, #0x6000                	// #24576
	madd x3, x0, x8, x3
    fd80000002b4:	9b080c03 	madd	x3, x0, x8, x3
	
	mov	x16, x3	
    fd80000002b8:	aa0303f0 	mov	x16, x3
	add	x17, x3, x8
    fd80000002bc:	8b080071 	add	x17, x3, x8
	bl	boot_clear
    fd80000002c0:	97ffff90 	bl	fd8000000100 <boot_clear>

	/* Get pointer to root page table */
	add x4, x3, #CPU_SIZE
    fd80000002c4:	91400864 	add	x4, x3, #0x2, lsl #12

	/* map original bootstrap flat mappings */
	PTE_INDEX_ASM x5, x1, 0 
    fd80000002c8:	d367fc25 	lsr	x5, x1, #39
    fd80000002cc:	924020a5 	and	x5, x5, #0x1ff
    fd80000002d0:	d37df0a5 	lsl	x5, x5, #3
	adr x6, root_l1_flat_pt
    fd80000002d4:	100f6966 	adr	x6, fd800001f000 <root_l1_flat_pt>
	add x6, x6, x18
    fd80000002d8:	8b1200c6 	add	x6, x6, x18
	add x6, x6, #(PTE_HYP_FLAGS | PTE_TABLE)
    fd80000002dc:	911d1cc6 	add	x6, x6, #0x747
	str x6, [x4, x5]
    fd80000002e0:	f8256886 	str	x6, [x4, x5]
	
	ldr x5, =(PTE_INDEX(0, BAO_VAS_BASE)*8)
    fd80000002e4:	580010a5 	ldr	x5, fd80000004f8 <_enter_vas_warm+0x6c>
	adr x6, root_l1_pt
    fd80000002e8:	100de8c6 	adr	x6, fd800001c000 <_page_tables_start>
	add x6, x6, x18
    fd80000002ec:	8b1200c6 	add	x6, x6, x18
	add x6, x6, #(PTE_HYP_FLAGS | PTE_TABLE)
    fd80000002f0:	911d1cc6 	add	x6, x6, #0x747
	str x6, [x4, x5]
    fd80000002f4:	f8256886 	str	x6, [x4, x5]

	ldr x5, =(PTE_INDEX(0, BAO_CPU_BASE)*8)
    fd80000002f8:	58001045 	ldr	x5, fd8000000500 <_enter_vas_warm+0x74>
	add x6, x4, #PT_SIZE
    fd80000002fc:	91400486 	add	x6, x4, #0x1, lsl #12
	add x6, x6, #(PTE_HYP_FLAGS | PTE_TABLE)
    fd8000000300:	911d1cc6 	add	x6, x6, #0x747
	str x6, [x4, x5]
    fd8000000304:	f8256886 	str	x6, [x4, x5]

	add x4, x4, #PT_SIZE
    fd8000000308:	91400484 	add	x4, x4, #0x1, lsl #12
	ldr x5, =(PTE_INDEX(1, BAO_CPU_BASE)*8)
    fd800000030c:	58000de5 	ldr	x5, fd80000004c8 <_enter_vas_warm+0x3c>
	add x6, x4, #PT_SIZE
    fd8000000310:	91400486 	add	x6, x4, #0x1, lsl #12
	add x6, x6, #(PTE_HYP_FLAGS | PTE_TABLE)
    fd8000000314:	911d1cc6 	add	x6, x6, #0x747
	str x6, [x4, x5]
    fd8000000318:	f8256886 	str	x6, [x4, x5]

	add x4, x4, #PT_SIZE
    fd800000031c:	91400484 	add	x4, x4, #0x1, lsl #12
	ldr x5, =(PTE_INDEX(2, BAO_CPU_BASE)*8)
    fd8000000320:	58000d45 	ldr	x5, fd80000004c8 <_enter_vas_warm+0x3c>
	add x6, x4, #PT_SIZE
    fd8000000324:	91400486 	add	x6, x4, #0x1, lsl #12
	add x6, x6, #(PTE_HYP_FLAGS | PTE_TABLE)
    fd8000000328:	911d1cc6 	add	x6, x6, #0x747
	str x6, [x4, x5]
    fd800000032c:	f8256886 	str	x6, [x4, x5]

	add x4, x4, #PT_SIZE
    fd8000000330:	91400484 	add	x4, x4, #0x1, lsl #12
	ldr x7, =BAO_CPU_BASE
    fd8000000334:	58000ea7 	ldr	x7, fd8000000508 <_enter_vas_warm+0x7c>
	add x8, x7, #(CPU_SIZE+PT_SIZE)
    fd8000000338:	91400ce8 	add	x8, x7, #0x3, lsl #12
	mov x6, x3
    fd800000033c:	aa0303e6 	mov	x6, x3
	add x6, x6, #(PTE_HYP_FLAGS | PTE_TABLE)
    fd8000000340:	911d1cc6 	add	x6, x6, #0x747
1:
	cmp	x7, x8
    fd8000000344:	eb0800ff 	cmp	x7, x8
	b.ge setup_cpu
    fd8000000348:	5400010a 	b.ge	fd8000000368 <setup_cpu>  // b.tcont
	PTE_INDEX_ASM x5, x7, 3
    fd800000034c:	d34cfce5 	lsr	x5, x7, #12
    fd8000000350:	924020a5 	and	x5, x5, #0x1ff
    fd8000000354:	d37df0a5 	lsl	x5, x5, #3
	str x6, [x4, x5]
    fd8000000358:	f8256886 	str	x6, [x4, x5]
	add x6, x6, #PAGE_SIZE
    fd800000035c:	914004c6 	add	x6, x6, #0x1, lsl #12
	add x7, x7, #PAGE_SIZE
    fd8000000360:	914004e7 	add	x7, x7, #0x1, lsl #12
	b	1b
    fd8000000364:	17fffff8 	b	fd8000000344 <map_cpu+0x98>

0000fd8000000368 <setup_cpu>:
	 * The operation is purposely commented out.  We are assuming monitor code already enabled smp
	 * coherency.
	 */ 

	/* setup translation configurations */
	ldr x3, =TCR_EL2_DFLT
    fd8000000368:	58000d43 	ldr	x3, fd8000000510 <_enter_vas_warm+0x84>
	msr	TCR_EL2, x3
    fd800000036c:	d51c2043 	msr	tcr_el2, x3

	/* set hypervisor default memory attributes */
	ldr x3, =MAIR_EL2_DFLT
    fd8000000370:	58000d43 	ldr	x3, fd8000000518 <_enter_vas_warm+0x8c>
	msr	MAIR_EL2, x3
    fd8000000374:	d51ca203 	msr	mair_el2, x3

    /* set cpu thread pointer */
    ldr x3, =BAO_CPU_BASE
    fd8000000378:	58000c83 	ldr	x3, fd8000000508 <_enter_vas_warm+0x7c>
    msr tpidr_el2, x3
    fd800000037c:	d51cd043 	msr	tpidr_el2, x3

    adrp x3, _dmem_phys_beg
    fd8000000380:	f001ab63 	adrp	x3, fd800356f000 <_dmem_phys_beg>
	mov x8, #(CPU_SIZE + (PT_SIZE*PT_LVLS))
    fd8000000384:	d28c0008 	mov	x8, #0x6000                	// #24576
	madd x3, x0, x8, x3
    fd8000000388:	9b080c03 	madd	x3, x0, x8, x3
	add x3, x3, #CPU_SIZE
    fd800000038c:	91400863 	add	x3, x3, #0x2, lsl #12
	msr TTBR0_EL2, x3
    fd8000000390:	d51c2003 	msr	ttbr0_el2, x3

	/**
	 * TODO: invalidate caches, TLBs and branch prediction. Need for barriers?
	 */

	ldr x5, =_enter_vas
    fd8000000394:	58000c65 	ldr	x5, fd8000000520 <_enter_vas_warm+0x94>

	/* Enable MMU and caches */
	ldr x4, =(SCTLR_RES1 | SCTLR_M | SCTLR_C | SCTLR_I)
    fd8000000398:	58000c84 	ldr	x4, fd8000000528 <_enter_vas_warm+0x9c>
	msr	SCTLR_EL2, x4
    fd800000039c:	d51c1004 	msr	sctlr_el2, x4
	
	tlbi	alle2
    fd80000003a0:	d50c871f 	tlbi	alle2
	dsb	nsh
    fd80000003a4:	d503379f 	dsb	nsh
	isb
    fd80000003a8:	d5033fdf 	isb
	
	br  x5
    fd80000003ac:	d61f00a0 	br	x5

0000fd80000003b0 <_enter_vas>:

_enter_vas:

	/* Install vector table virtual address*/
	ldr	x3, =_hyp_vector_table
    fd80000003b0:	58000c03 	ldr	x3, fd8000000530 <_enter_vas_warm+0xa4>
	msr	VBAR_EL2, x3
    fd80000003b4:	d51cc003 	msr	vbar_el2, x3

	/* Remove temporary mapping - the L1 page holding it leaks */
	ldr x4, =BAO_CPU_BASE
    fd80000003b8:	58000a84 	ldr	x4, fd8000000508 <_enter_vas_warm+0x7c>
	add x4, x4, #CPU_SIZE
    fd80000003bc:	91400884 	add	x4, x4, #0x2, lsl #12
	PTE_INDEX_ASM x5, x1, 0 
    fd80000003c0:	d367fc25 	lsr	x5, x1, #39
    fd80000003c4:	924020a5 	and	x5, x5, #0x1ff
    fd80000003c8:	d37df0a5 	lsl	x5, x5, #3
	str xzr, [x4, x5]
    fd80000003cc:	f825689f 	str	xzr, [x4, x5]

    tlbi	alle2
    fd80000003d0:	d50c871f 	tlbi	alle2
	dsb	nsh
    fd80000003d4:	d503379f 	dsb	nsh
	isb
    fd80000003d8:	d5033fdf 	isb

    sub x20, x20, x1
    fd80000003dc:	cb010294 	sub	x20, x20, x1
    ldr x3, =_image_start
    fd80000003e0:	58000783 	ldr	x3, fd80000004d0 <_enter_vas_warm+0x44>
    add x30, x20, x3
    fd80000003e4:	8b03029e 	add	x30, x20, x3
    ret
    fd80000003e8:	d65f03c0 	ret

0000fd80000003ec <psci_boot_entry>:
.global psci_boot_entry
.func psci_boot_entry
psci_boot_entry:
warm_boot:

	adr	x3, _hyp_vector_table
    fd80000003ec:	100060a3 	adr	x3, fd8000001000 <_hyp_vector_table>
	msr	VBAR_EL2, x3
    fd80000003f0:	d51cc003 	msr	vbar_el2, x3

	/* save x0 which contains pointer to saved state psci context */
	mov x19, x0
    fd80000003f4:	aa0003f3 	mov	x19, x0
    /* invalidate l1$ */
	mov x0, #0
    fd80000003f8:	d2800000 	mov	x0, #0x0                   	// #0
	bl	boot_cache_invalidate
    fd80000003fc:	97ffff46 	bl	fd8000000114 <boot_cache_invalidate>

    /* set cpu thread pointer */
    ldr x3, =BAO_CPU_BASE
    fd8000000400:	58000843 	ldr	x3, fd8000000508 <_enter_vas_warm+0x7c>
    msr tpidr_el2, x3
    fd8000000404:	d51cd043 	msr	tpidr_el2, x3

	/* restore all needed register state */
	ldp x5, x6, [x19, #0]
    fd8000000408:	a9401a65 	ldp	x5, x6, [x19]
	msr TCR_EL2, x5
    fd800000040c:	d51c2045 	msr	tcr_el2, x5
	msr TTBR0_EL2, x6
    fd8000000410:	d51c2006 	msr	ttbr0_el2, x6
	ldp x5, x6, [x19, #16]
    fd8000000414:	a9411a65 	ldp	x5, x6, [x19, #16]
	msr MAIR_EL2, x5
    fd8000000418:	d51ca205 	msr	mair_el2, x5
	msr CPTR_EL2, x6
    fd800000041c:	d51c1146 	msr	cptr_el2, x6
	ldp x5, x6, [x19, #32]
    fd8000000420:	a9421a65 	ldp	x5, x6, [x19, #32]
	msr HCR_EL2, x5
    fd8000000424:	d51c1105 	msr	hcr_el2, x5
	msr VMPIDR_EL2, x6
    fd8000000428:	d51c00a6 	msr	vmpidr_el2, x6
	ldp x5, x6, [x19, #48]
    fd800000042c:	a9431a65 	ldp	x5, x6, [x19, #48]
	msr VTCR_EL2, x5
    fd8000000430:	d51c2145 	msr	vtcr_el2, x5
	msr VTTBR_EL2, x6
    fd8000000434:	d51c2106 	msr	vttbr_el2, x6
    ldp x0, x5, [x19, #64]   /* wake up reason is the arg of the later psci_wake call */
    fd8000000438:	a9441660 	ldp	x0, x5, [x19, #64]

	/* map original bootstrap flat mappings */
	mrs x3, TTBR0_EL2
    fd800000043c:	d53c2003 	mrs	x3, ttbr0_el2
	adrp x1, _image_start
    fd8000000440:	90000001 	adrp	x1, fd8000000000 <_el2_entry>
	PTE_INDEX_ASM x1, x1, 0 
    fd8000000444:	d367fc21 	lsr	x1, x1, #39
    fd8000000448:	92402021 	and	x1, x1, #0x1ff
    fd800000044c:	d37df021 	lsl	x1, x1, #3
	add x3, x3, x1
    fd8000000450:	8b010063 	add	x3, x3, x1
	dc civac, x3  //we invalidated l1$, but make sure the pte is not in l2$
    fd8000000454:	d50b7e23 	dc	civac, x3
	add x5, x5, #(PTE_HYP_FLAGS | PTE_TABLE)
    fd8000000458:	911d1ca5 	add	x5, x5, #0x747
	str x5, [x3]
    fd800000045c:	f9000065 	str	x5, [x3]

	/* Install vector table virtual address*/
	ldr	x3, =_hyp_vector_table
    fd8000000460:	58000683 	ldr	x3, fd8000000530 <_enter_vas_warm+0xa4>
	msr	VBAR_EL2, x3
    fd8000000464:	d51cc003 	msr	vbar_el2, x3

    tlbi	alle2 
    fd8000000468:	d50c871f 	tlbi	alle2
	dsb	nsh
    fd800000046c:	d503379f 	dsb	nsh
	isb
    fd8000000470:	d5033fdf 	isb

	/* Enable MMU and caches */
	ldr x4, =(SCTLR_RES1 | SCTLR_M | SCTLR_C | SCTLR_I)
    fd8000000474:	580005a4 	ldr	x4, fd8000000528 <_enter_vas_warm+0x9c>
	msr	SCTLR_EL2, x4
    fd8000000478:	d51c1004 	msr	sctlr_el2, x4

	dsb	nsh
    fd800000047c:	d503379f 	dsb	nsh
	isb
    fd8000000480:	d5033fdf 	isb
	
	ldr x5, =_enter_vas_warm
    fd8000000484:	580005a5 	ldr	x5, fd8000000538 <_enter_vas_warm+0xac>
	br  x5		
    fd8000000488:	d61f00a0 	br	x5

0000fd800000048c <_enter_vas_warm>:

_enter_vas_warm:
	/* Unmap bootstrat flat mappings */
	ldr x4, =BAO_CPU_BASE
    fd800000048c:	580003e4 	ldr	x4, fd8000000508 <_enter_vas_warm+0x7c>
	add x3, x4, #(CPU_STACK_OFF+CPU_STACK_SIZE)
    fd8000000490:	91400883 	add	x3, x4, #0x2, lsl #12

	add x4, x4, #CPU_SIZE
    fd8000000494:	91400884 	add	x4, x4, #0x2, lsl #12
	PTE_INDEX_ASM x5, x1, 0 
    fd8000000498:	d367fc25 	lsr	x5, x1, #39
    fd800000049c:	924020a5 	and	x5, x5, #0x1ff
    fd80000004a0:	d37df0a5 	lsl	x5, x5, #3
	str xzr, [x4, x5]
    fd80000004a4:	f825689f 	str	xzr, [x4, x5]
    tlbi	alle2
    fd80000004a8:	d50c871f 	tlbi	alle2
	dsb	nsh
    fd80000004ac:	d503379f 	dsb	nsh
	isb
    fd80000004b0:	d5033fdf 	isb

    /* Initialize stack pointer */
    mov sp, x3
    fd80000004b4:	9100007f 	mov	sp, x3

	bl	psci_wake
    fd80000004b8:	94000606 	bl	fd8000001cd0 <psci_wake>
	b 	.
    fd80000004bc:	14000000 	b	fd80000004bc <_enter_vas_warm+0x30>
    fd80000004c0:	0354f000 	.word	0x0354f000
	...
    fd80000004d4:	0000fd80 	.word	0x0000fd80
    fd80000004d8:	00013000 	.word	0x00013000
    fd80000004dc:	0000fd80 	.word	0x0000fd80
    fd80000004e0:	00020000 	.word	0x00020000
    fd80000004e4:	0000fd80 	.word	0x0000fd80
    fd80000004e8:	03562000 	.word	0x03562000
    fd80000004ec:	0000fd80 	.word	0x0000fd80
    fd80000004f0:	00000000 	.word	0x00000000
    fd80000004f4:	0000fd80 	.word	0x0000fd80
    fd80000004f8:	00000fd8 	.word	0x00000fd8
    fd80000004fc:	00000000 	.word	0x00000000
    fd8000000500:	00000fe0 	.word	0x00000fe0
	...
    fd800000050c:	0000fe00 	.word	0x0000fe00
    fd8000000510:	80853510 	.word	0x80853510
    fd8000000514:	00000000 	.word	0x00000000
    fd8000000518:	0004ff00 	.word	0x0004ff00
    fd800000051c:	00000000 	.word	0x00000000
    fd8000000520:	000003b0 	.word	0x000003b0
    fd8000000524:	0000fd80 	.word	0x0000fd80
    fd8000000528:	30c51835 	.word	0x30c51835
    fd800000052c:	00000000 	.word	0x00000000
    fd8000000530:	00001000 	.word	0x00001000
    fd8000000534:	0000fd80 	.word	0x0000fd80
    fd8000000538:	0000048c 	.word	0x0000048c
    fd800000053c:	0000fd80 	.word	0x0000fd80

Disassembly of section .text:

0000fd8000000800 <vcpu_arch_entry>:

.endm

.global vcpu_arch_entry
vcpu_arch_entry:
    mrs x0, tpidr_el2
    fd8000000800:	d53cd040 	mrs	x0, tpidr_el2
    ldr x0, [x0, #CPU_VCPU_OFF]
    fd8000000804:	f9402800 	ldr	x0, [x0, #80]
    add x0, x0, #VCPU_REGS_OFF
    fd8000000808:	91004000 	add	x0, x0, #0x10
    mov sp, x0
    fd800000080c:	9100001f 	mov	sp, x0

    ldp x0, x1, [sp, #(8*31)]
    fd8000000810:	a94f87e0 	ldp	x0, x1, [sp, #248]
    msr ELR_EL2, x0
    fd8000000814:	d51c4020 	msr	elr_el2, x0
    msr SPSR_EL2, x1
    fd8000000818:	d51c4001 	msr	spsr_el2, x1

    ldp x0, x1,   [sp, #(8*0)]
    fd800000081c:	a94007e0 	ldp	x0, x1, [sp]
    ldp x2, x3,   [sp, #(8*2)]
    fd8000000820:	a9410fe2 	ldp	x2, x3, [sp, #16]
    ldp x4, x5,   [sp, #(8*4)]
    fd8000000824:	a94217e4 	ldp	x4, x5, [sp, #32]
    ldp x6, x7,   [sp, #(8*6)]
    fd8000000828:	a9431fe6 	ldp	x6, x7, [sp, #48]
    ldp x8, x9,   [sp, #(8*8)]
    fd800000082c:	a94427e8 	ldp	x8, x9, [sp, #64]
    ldp x10, x11, [sp, #(8*10)]
    fd8000000830:	a9452fea 	ldp	x10, x11, [sp, #80]
    ldp x12, x13, [sp, #(8*12)]
    fd8000000834:	a94637ec 	ldp	x12, x13, [sp, #96]
    ldp x14, x15, [sp, #(8*14)]
    fd8000000838:	a9473fee 	ldp	x14, x15, [sp, #112]
    ldp x16, x17, [sp, #(8*16)]
    fd800000083c:	a94847f0 	ldp	x16, x17, [sp, #128]
    ldp x18, x19, [sp, #(8*18)]
    fd8000000840:	a9494ff2 	ldp	x18, x19, [sp, #144]
    ldp x20, x21, [sp, #(8*20)]
    fd8000000844:	a94a57f4 	ldp	x20, x21, [sp, #160]
    ldp x22, x23, [sp, #(8*22)]
    fd8000000848:	a94b5ff6 	ldp	x22, x23, [sp, #176]
    ldp x24, x25, [sp, #(8*24)]
    fd800000084c:	a94c67f8 	ldp	x24, x25, [sp, #192]
    ldp x26, x27, [sp, #(8*26)]
    fd8000000850:	a94d6ffa 	ldp	x26, x27, [sp, #208]
    ldp x28, x29, [sp, #(8*28)]
    fd8000000854:	a94e77fc 	ldp	x28, x29, [sp, #224]
    ldr x30,      [sp, #(8*30)]
    fd8000000858:	f9407bfe 	ldr	x30, [sp, #240]
    
    eret
    fd800000085c:	d69f03e0 	eret
    b   .
    fd8000000860:	14000000 	b	fd8000000860 <vcpu_arch_entry+0x60>
    fd8000000864:	d503201f 	nop
    fd8000000868:	d503201f 	nop
    fd800000086c:	d503201f 	nop
    fd8000000870:	d503201f 	nop
    fd8000000874:	d503201f 	nop
    fd8000000878:	d503201f 	nop
    fd800000087c:	d503201f 	nop
    fd8000000880:	d503201f 	nop
    fd8000000884:	d503201f 	nop
    fd8000000888:	d503201f 	nop
    fd800000088c:	d503201f 	nop
    fd8000000890:	d503201f 	nop
    fd8000000894:	d503201f 	nop
    fd8000000898:	d503201f 	nop
    fd800000089c:	d503201f 	nop
    fd80000008a0:	d503201f 	nop
    fd80000008a4:	d503201f 	nop
    fd80000008a8:	d503201f 	nop
    fd80000008ac:	d503201f 	nop
    fd80000008b0:	d503201f 	nop
    fd80000008b4:	d503201f 	nop
    fd80000008b8:	d503201f 	nop
    fd80000008bc:	d503201f 	nop
    fd80000008c0:	d503201f 	nop
    fd80000008c4:	d503201f 	nop
    fd80000008c8:	d503201f 	nop
    fd80000008cc:	d503201f 	nop
    fd80000008d0:	d503201f 	nop
    fd80000008d4:	d503201f 	nop
    fd80000008d8:	d503201f 	nop
    fd80000008dc:	d503201f 	nop
    fd80000008e0:	d503201f 	nop
    fd80000008e4:	d503201f 	nop
    fd80000008e8:	d503201f 	nop
    fd80000008ec:	d503201f 	nop
    fd80000008f0:	d503201f 	nop
    fd80000008f4:	d503201f 	nop
    fd80000008f8:	d503201f 	nop
    fd80000008fc:	d503201f 	nop
    fd8000000900:	d503201f 	nop
    fd8000000904:	d503201f 	nop
    fd8000000908:	d503201f 	nop
    fd800000090c:	d503201f 	nop
    fd8000000910:	d503201f 	nop
    fd8000000914:	d503201f 	nop
    fd8000000918:	d503201f 	nop
    fd800000091c:	d503201f 	nop
    fd8000000920:	d503201f 	nop
    fd8000000924:	d503201f 	nop
    fd8000000928:	d503201f 	nop
    fd800000092c:	d503201f 	nop
    fd8000000930:	d503201f 	nop
    fd8000000934:	d503201f 	nop
    fd8000000938:	d503201f 	nop
    fd800000093c:	d503201f 	nop
    fd8000000940:	d503201f 	nop
    fd8000000944:	d503201f 	nop
    fd8000000948:	d503201f 	nop
    fd800000094c:	d503201f 	nop
    fd8000000950:	d503201f 	nop
    fd8000000954:	d503201f 	nop
    fd8000000958:	d503201f 	nop
    fd800000095c:	d503201f 	nop
    fd8000000960:	d503201f 	nop
    fd8000000964:	d503201f 	nop
    fd8000000968:	d503201f 	nop
    fd800000096c:	d503201f 	nop
    fd8000000970:	d503201f 	nop
    fd8000000974:	d503201f 	nop
    fd8000000978:	d503201f 	nop
    fd800000097c:	d503201f 	nop
    fd8000000980:	d503201f 	nop
    fd8000000984:	d503201f 	nop
    fd8000000988:	d503201f 	nop
    fd800000098c:	d503201f 	nop
    fd8000000990:	d503201f 	nop
    fd8000000994:	d503201f 	nop
    fd8000000998:	d503201f 	nop
    fd800000099c:	d503201f 	nop
    fd80000009a0:	d503201f 	nop
    fd80000009a4:	d503201f 	nop
    fd80000009a8:	d503201f 	nop
    fd80000009ac:	d503201f 	nop
    fd80000009b0:	d503201f 	nop
    fd80000009b4:	d503201f 	nop
    fd80000009b8:	d503201f 	nop
    fd80000009bc:	d503201f 	nop
    fd80000009c0:	d503201f 	nop
    fd80000009c4:	d503201f 	nop
    fd80000009c8:	d503201f 	nop
    fd80000009cc:	d503201f 	nop
    fd80000009d0:	d503201f 	nop
    fd80000009d4:	d503201f 	nop
    fd80000009d8:	d503201f 	nop
    fd80000009dc:	d503201f 	nop
    fd80000009e0:	d503201f 	nop
    fd80000009e4:	d503201f 	nop
    fd80000009e8:	d503201f 	nop
    fd80000009ec:	d503201f 	nop
    fd80000009f0:	d503201f 	nop
    fd80000009f4:	d503201f 	nop
    fd80000009f8:	d503201f 	nop
    fd80000009fc:	d503201f 	nop
    fd8000000a00:	d503201f 	nop
    fd8000000a04:	d503201f 	nop
    fd8000000a08:	d503201f 	nop
    fd8000000a0c:	d503201f 	nop
    fd8000000a10:	d503201f 	nop
    fd8000000a14:	d503201f 	nop
    fd8000000a18:	d503201f 	nop
    fd8000000a1c:	d503201f 	nop
    fd8000000a20:	d503201f 	nop
    fd8000000a24:	d503201f 	nop
    fd8000000a28:	d503201f 	nop
    fd8000000a2c:	d503201f 	nop
    fd8000000a30:	d503201f 	nop
    fd8000000a34:	d503201f 	nop
    fd8000000a38:	d503201f 	nop
    fd8000000a3c:	d503201f 	nop
    fd8000000a40:	d503201f 	nop
    fd8000000a44:	d503201f 	nop
    fd8000000a48:	d503201f 	nop
    fd8000000a4c:	d503201f 	nop
    fd8000000a50:	d503201f 	nop
    fd8000000a54:	d503201f 	nop
    fd8000000a58:	d503201f 	nop
    fd8000000a5c:	d503201f 	nop
    fd8000000a60:	d503201f 	nop
    fd8000000a64:	d503201f 	nop
    fd8000000a68:	d503201f 	nop
    fd8000000a6c:	d503201f 	nop
    fd8000000a70:	d503201f 	nop
    fd8000000a74:	d503201f 	nop
    fd8000000a78:	d503201f 	nop
    fd8000000a7c:	d503201f 	nop
    fd8000000a80:	d503201f 	nop
    fd8000000a84:	d503201f 	nop
    fd8000000a88:	d503201f 	nop
    fd8000000a8c:	d503201f 	nop
    fd8000000a90:	d503201f 	nop
    fd8000000a94:	d503201f 	nop
    fd8000000a98:	d503201f 	nop
    fd8000000a9c:	d503201f 	nop
    fd8000000aa0:	d503201f 	nop
    fd8000000aa4:	d503201f 	nop
    fd8000000aa8:	d503201f 	nop
    fd8000000aac:	d503201f 	nop
    fd8000000ab0:	d503201f 	nop
    fd8000000ab4:	d503201f 	nop
    fd8000000ab8:	d503201f 	nop
    fd8000000abc:	d503201f 	nop
    fd8000000ac0:	d503201f 	nop
    fd8000000ac4:	d503201f 	nop
    fd8000000ac8:	d503201f 	nop
    fd8000000acc:	d503201f 	nop
    fd8000000ad0:	d503201f 	nop
    fd8000000ad4:	d503201f 	nop
    fd8000000ad8:	d503201f 	nop
    fd8000000adc:	d503201f 	nop
    fd8000000ae0:	d503201f 	nop
    fd8000000ae4:	d503201f 	nop
    fd8000000ae8:	d503201f 	nop
    fd8000000aec:	d503201f 	nop
    fd8000000af0:	d503201f 	nop
    fd8000000af4:	d503201f 	nop
    fd8000000af8:	d503201f 	nop
    fd8000000afc:	d503201f 	nop
    fd8000000b00:	d503201f 	nop
    fd8000000b04:	d503201f 	nop
    fd8000000b08:	d503201f 	nop
    fd8000000b0c:	d503201f 	nop
    fd8000000b10:	d503201f 	nop
    fd8000000b14:	d503201f 	nop
    fd8000000b18:	d503201f 	nop
    fd8000000b1c:	d503201f 	nop
    fd8000000b20:	d503201f 	nop
    fd8000000b24:	d503201f 	nop
    fd8000000b28:	d503201f 	nop
    fd8000000b2c:	d503201f 	nop
    fd8000000b30:	d503201f 	nop
    fd8000000b34:	d503201f 	nop
    fd8000000b38:	d503201f 	nop
    fd8000000b3c:	d503201f 	nop
    fd8000000b40:	d503201f 	nop
    fd8000000b44:	d503201f 	nop
    fd8000000b48:	d503201f 	nop
    fd8000000b4c:	d503201f 	nop
    fd8000000b50:	d503201f 	nop
    fd8000000b54:	d503201f 	nop
    fd8000000b58:	d503201f 	nop
    fd8000000b5c:	d503201f 	nop
    fd8000000b60:	d503201f 	nop
    fd8000000b64:	d503201f 	nop
    fd8000000b68:	d503201f 	nop
    fd8000000b6c:	d503201f 	nop
    fd8000000b70:	d503201f 	nop
    fd8000000b74:	d503201f 	nop
    fd8000000b78:	d503201f 	nop
    fd8000000b7c:	d503201f 	nop
    fd8000000b80:	d503201f 	nop
    fd8000000b84:	d503201f 	nop
    fd8000000b88:	d503201f 	nop
    fd8000000b8c:	d503201f 	nop
    fd8000000b90:	d503201f 	nop
    fd8000000b94:	d503201f 	nop
    fd8000000b98:	d503201f 	nop
    fd8000000b9c:	d503201f 	nop
    fd8000000ba0:	d503201f 	nop
    fd8000000ba4:	d503201f 	nop
    fd8000000ba8:	d503201f 	nop
    fd8000000bac:	d503201f 	nop
    fd8000000bb0:	d503201f 	nop
    fd8000000bb4:	d503201f 	nop
    fd8000000bb8:	d503201f 	nop
    fd8000000bbc:	d503201f 	nop
    fd8000000bc0:	d503201f 	nop
    fd8000000bc4:	d503201f 	nop
    fd8000000bc8:	d503201f 	nop
    fd8000000bcc:	d503201f 	nop
    fd8000000bd0:	d503201f 	nop
    fd8000000bd4:	d503201f 	nop
    fd8000000bd8:	d503201f 	nop
    fd8000000bdc:	d503201f 	nop
    fd8000000be0:	d503201f 	nop
    fd8000000be4:	d503201f 	nop
    fd8000000be8:	d503201f 	nop
    fd8000000bec:	d503201f 	nop
    fd8000000bf0:	d503201f 	nop
    fd8000000bf4:	d503201f 	nop
    fd8000000bf8:	d503201f 	nop
    fd8000000bfc:	d503201f 	nop
    fd8000000c00:	d503201f 	nop
    fd8000000c04:	d503201f 	nop
    fd8000000c08:	d503201f 	nop
    fd8000000c0c:	d503201f 	nop
    fd8000000c10:	d503201f 	nop
    fd8000000c14:	d503201f 	nop
    fd8000000c18:	d503201f 	nop
    fd8000000c1c:	d503201f 	nop
    fd8000000c20:	d503201f 	nop
    fd8000000c24:	d503201f 	nop
    fd8000000c28:	d503201f 	nop
    fd8000000c2c:	d503201f 	nop
    fd8000000c30:	d503201f 	nop
    fd8000000c34:	d503201f 	nop
    fd8000000c38:	d503201f 	nop
    fd8000000c3c:	d503201f 	nop
    fd8000000c40:	d503201f 	nop
    fd8000000c44:	d503201f 	nop
    fd8000000c48:	d503201f 	nop
    fd8000000c4c:	d503201f 	nop
    fd8000000c50:	d503201f 	nop
    fd8000000c54:	d503201f 	nop
    fd8000000c58:	d503201f 	nop
    fd8000000c5c:	d503201f 	nop
    fd8000000c60:	d503201f 	nop
    fd8000000c64:	d503201f 	nop
    fd8000000c68:	d503201f 	nop
    fd8000000c6c:	d503201f 	nop
    fd8000000c70:	d503201f 	nop
    fd8000000c74:	d503201f 	nop
    fd8000000c78:	d503201f 	nop
    fd8000000c7c:	d503201f 	nop
    fd8000000c80:	d503201f 	nop
    fd8000000c84:	d503201f 	nop
    fd8000000c88:	d503201f 	nop
    fd8000000c8c:	d503201f 	nop
    fd8000000c90:	d503201f 	nop
    fd8000000c94:	d503201f 	nop
    fd8000000c98:	d503201f 	nop
    fd8000000c9c:	d503201f 	nop
    fd8000000ca0:	d503201f 	nop
    fd8000000ca4:	d503201f 	nop
    fd8000000ca8:	d503201f 	nop
    fd8000000cac:	d503201f 	nop
    fd8000000cb0:	d503201f 	nop
    fd8000000cb4:	d503201f 	nop
    fd8000000cb8:	d503201f 	nop
    fd8000000cbc:	d503201f 	nop
    fd8000000cc0:	d503201f 	nop
    fd8000000cc4:	d503201f 	nop
    fd8000000cc8:	d503201f 	nop
    fd8000000ccc:	d503201f 	nop
    fd8000000cd0:	d503201f 	nop
    fd8000000cd4:	d503201f 	nop
    fd8000000cd8:	d503201f 	nop
    fd8000000cdc:	d503201f 	nop
    fd8000000ce0:	d503201f 	nop
    fd8000000ce4:	d503201f 	nop
    fd8000000ce8:	d503201f 	nop
    fd8000000cec:	d503201f 	nop
    fd8000000cf0:	d503201f 	nop
    fd8000000cf4:	d503201f 	nop
    fd8000000cf8:	d503201f 	nop
    fd8000000cfc:	d503201f 	nop
    fd8000000d00:	d503201f 	nop
    fd8000000d04:	d503201f 	nop
    fd8000000d08:	d503201f 	nop
    fd8000000d0c:	d503201f 	nop
    fd8000000d10:	d503201f 	nop
    fd8000000d14:	d503201f 	nop
    fd8000000d18:	d503201f 	nop
    fd8000000d1c:	d503201f 	nop
    fd8000000d20:	d503201f 	nop
    fd8000000d24:	d503201f 	nop
    fd8000000d28:	d503201f 	nop
    fd8000000d2c:	d503201f 	nop
    fd8000000d30:	d503201f 	nop
    fd8000000d34:	d503201f 	nop
    fd8000000d38:	d503201f 	nop
    fd8000000d3c:	d503201f 	nop
    fd8000000d40:	d503201f 	nop
    fd8000000d44:	d503201f 	nop
    fd8000000d48:	d503201f 	nop
    fd8000000d4c:	d503201f 	nop
    fd8000000d50:	d503201f 	nop
    fd8000000d54:	d503201f 	nop
    fd8000000d58:	d503201f 	nop
    fd8000000d5c:	d503201f 	nop
    fd8000000d60:	d503201f 	nop
    fd8000000d64:	d503201f 	nop
    fd8000000d68:	d503201f 	nop
    fd8000000d6c:	d503201f 	nop
    fd8000000d70:	d503201f 	nop
    fd8000000d74:	d503201f 	nop
    fd8000000d78:	d503201f 	nop
    fd8000000d7c:	d503201f 	nop
    fd8000000d80:	d503201f 	nop
    fd8000000d84:	d503201f 	nop
    fd8000000d88:	d503201f 	nop
    fd8000000d8c:	d503201f 	nop
    fd8000000d90:	d503201f 	nop
    fd8000000d94:	d503201f 	nop
    fd8000000d98:	d503201f 	nop
    fd8000000d9c:	d503201f 	nop
    fd8000000da0:	d503201f 	nop
    fd8000000da4:	d503201f 	nop
    fd8000000da8:	d503201f 	nop
    fd8000000dac:	d503201f 	nop
    fd8000000db0:	d503201f 	nop
    fd8000000db4:	d503201f 	nop
    fd8000000db8:	d503201f 	nop
    fd8000000dbc:	d503201f 	nop
    fd8000000dc0:	d503201f 	nop
    fd8000000dc4:	d503201f 	nop
    fd8000000dc8:	d503201f 	nop
    fd8000000dcc:	d503201f 	nop
    fd8000000dd0:	d503201f 	nop
    fd8000000dd4:	d503201f 	nop
    fd8000000dd8:	d503201f 	nop
    fd8000000ddc:	d503201f 	nop
    fd8000000de0:	d503201f 	nop
    fd8000000de4:	d503201f 	nop
    fd8000000de8:	d503201f 	nop
    fd8000000dec:	d503201f 	nop
    fd8000000df0:	d503201f 	nop
    fd8000000df4:	d503201f 	nop
    fd8000000df8:	d503201f 	nop
    fd8000000dfc:	d503201f 	nop
    fd8000000e00:	d503201f 	nop
    fd8000000e04:	d503201f 	nop
    fd8000000e08:	d503201f 	nop
    fd8000000e0c:	d503201f 	nop
    fd8000000e10:	d503201f 	nop
    fd8000000e14:	d503201f 	nop
    fd8000000e18:	d503201f 	nop
    fd8000000e1c:	d503201f 	nop
    fd8000000e20:	d503201f 	nop
    fd8000000e24:	d503201f 	nop
    fd8000000e28:	d503201f 	nop
    fd8000000e2c:	d503201f 	nop
    fd8000000e30:	d503201f 	nop
    fd8000000e34:	d503201f 	nop
    fd8000000e38:	d503201f 	nop
    fd8000000e3c:	d503201f 	nop
    fd8000000e40:	d503201f 	nop
    fd8000000e44:	d503201f 	nop
    fd8000000e48:	d503201f 	nop
    fd8000000e4c:	d503201f 	nop
    fd8000000e50:	d503201f 	nop
    fd8000000e54:	d503201f 	nop
    fd8000000e58:	d503201f 	nop
    fd8000000e5c:	d503201f 	nop
    fd8000000e60:	d503201f 	nop
    fd8000000e64:	d503201f 	nop
    fd8000000e68:	d503201f 	nop
    fd8000000e6c:	d503201f 	nop
    fd8000000e70:	d503201f 	nop
    fd8000000e74:	d503201f 	nop
    fd8000000e78:	d503201f 	nop
    fd8000000e7c:	d503201f 	nop
    fd8000000e80:	d503201f 	nop
    fd8000000e84:	d503201f 	nop
    fd8000000e88:	d503201f 	nop
    fd8000000e8c:	d503201f 	nop
    fd8000000e90:	d503201f 	nop
    fd8000000e94:	d503201f 	nop
    fd8000000e98:	d503201f 	nop
    fd8000000e9c:	d503201f 	nop
    fd8000000ea0:	d503201f 	nop
    fd8000000ea4:	d503201f 	nop
    fd8000000ea8:	d503201f 	nop
    fd8000000eac:	d503201f 	nop
    fd8000000eb0:	d503201f 	nop
    fd8000000eb4:	d503201f 	nop
    fd8000000eb8:	d503201f 	nop
    fd8000000ebc:	d503201f 	nop
    fd8000000ec0:	d503201f 	nop
    fd8000000ec4:	d503201f 	nop
    fd8000000ec8:	d503201f 	nop
    fd8000000ecc:	d503201f 	nop
    fd8000000ed0:	d503201f 	nop
    fd8000000ed4:	d503201f 	nop
    fd8000000ed8:	d503201f 	nop
    fd8000000edc:	d503201f 	nop
    fd8000000ee0:	d503201f 	nop
    fd8000000ee4:	d503201f 	nop
    fd8000000ee8:	d503201f 	nop
    fd8000000eec:	d503201f 	nop
    fd8000000ef0:	d503201f 	nop
    fd8000000ef4:	d503201f 	nop
    fd8000000ef8:	d503201f 	nop
    fd8000000efc:	d503201f 	nop
    fd8000000f00:	d503201f 	nop
    fd8000000f04:	d503201f 	nop
    fd8000000f08:	d503201f 	nop
    fd8000000f0c:	d503201f 	nop
    fd8000000f10:	d503201f 	nop
    fd8000000f14:	d503201f 	nop
    fd8000000f18:	d503201f 	nop
    fd8000000f1c:	d503201f 	nop
    fd8000000f20:	d503201f 	nop
    fd8000000f24:	d503201f 	nop
    fd8000000f28:	d503201f 	nop
    fd8000000f2c:	d503201f 	nop
    fd8000000f30:	d503201f 	nop
    fd8000000f34:	d503201f 	nop
    fd8000000f38:	d503201f 	nop
    fd8000000f3c:	d503201f 	nop
    fd8000000f40:	d503201f 	nop
    fd8000000f44:	d503201f 	nop
    fd8000000f48:	d503201f 	nop
    fd8000000f4c:	d503201f 	nop
    fd8000000f50:	d503201f 	nop
    fd8000000f54:	d503201f 	nop
    fd8000000f58:	d503201f 	nop
    fd8000000f5c:	d503201f 	nop
    fd8000000f60:	d503201f 	nop
    fd8000000f64:	d503201f 	nop
    fd8000000f68:	d503201f 	nop
    fd8000000f6c:	d503201f 	nop
    fd8000000f70:	d503201f 	nop
    fd8000000f74:	d503201f 	nop
    fd8000000f78:	d503201f 	nop
    fd8000000f7c:	d503201f 	nop
    fd8000000f80:	d503201f 	nop
    fd8000000f84:	d503201f 	nop
    fd8000000f88:	d503201f 	nop
    fd8000000f8c:	d503201f 	nop
    fd8000000f90:	d503201f 	nop
    fd8000000f94:	d503201f 	nop
    fd8000000f98:	d503201f 	nop
    fd8000000f9c:	d503201f 	nop
    fd8000000fa0:	d503201f 	nop
    fd8000000fa4:	d503201f 	nop
    fd8000000fa8:	d503201f 	nop
    fd8000000fac:	d503201f 	nop
    fd8000000fb0:	d503201f 	nop
    fd8000000fb4:	d503201f 	nop
    fd8000000fb8:	d503201f 	nop
    fd8000000fbc:	d503201f 	nop
    fd8000000fc0:	d503201f 	nop
    fd8000000fc4:	d503201f 	nop
    fd8000000fc8:	d503201f 	nop
    fd8000000fcc:	d503201f 	nop
    fd8000000fd0:	d503201f 	nop
    fd8000000fd4:	d503201f 	nop
    fd8000000fd8:	d503201f 	nop
    fd8000000fdc:	d503201f 	nop
    fd8000000fe0:	d503201f 	nop
    fd8000000fe4:	d503201f 	nop
    fd8000000fe8:	d503201f 	nop
    fd8000000fec:	d503201f 	nop
    fd8000000ff0:	d503201f 	nop
    fd8000000ff4:	d503201f 	nop
    fd8000000ff8:	d503201f 	nop
    fd8000000ffc:	d503201f 	nop

0000fd8000001000 <_hyp_vector_table>:
/* 
 * EL2 with SP0
 */  
.balign ENTRY_SIZE
curr_el_sp0_sync:        
    b	.
    fd8000001000:	14000000 	b	fd8000001000 <_hyp_vector_table>
    fd8000001004:	d503201f 	nop
    fd8000001008:	d503201f 	nop
    fd800000100c:	d503201f 	nop
    fd8000001010:	d503201f 	nop
    fd8000001014:	d503201f 	nop
    fd8000001018:	d503201f 	nop
    fd800000101c:	d503201f 	nop
    fd8000001020:	d503201f 	nop
    fd8000001024:	d503201f 	nop
    fd8000001028:	d503201f 	nop
    fd800000102c:	d503201f 	nop
    fd8000001030:	d503201f 	nop
    fd8000001034:	d503201f 	nop
    fd8000001038:	d503201f 	nop
    fd800000103c:	d503201f 	nop
    fd8000001040:	d503201f 	nop
    fd8000001044:	d503201f 	nop
    fd8000001048:	d503201f 	nop
    fd800000104c:	d503201f 	nop
    fd8000001050:	d503201f 	nop
    fd8000001054:	d503201f 	nop
    fd8000001058:	d503201f 	nop
    fd800000105c:	d503201f 	nop
    fd8000001060:	d503201f 	nop
    fd8000001064:	d503201f 	nop
    fd8000001068:	d503201f 	nop
    fd800000106c:	d503201f 	nop
    fd8000001070:	d503201f 	nop
    fd8000001074:	d503201f 	nop
    fd8000001078:	d503201f 	nop
    fd800000107c:	d503201f 	nop

0000fd8000001080 <curr_el_sp0_irq>:
.balign ENTRY_SIZE
curr_el_sp0_irq:  
    b   .
    fd8000001080:	14000000 	b	fd8000001080 <curr_el_sp0_irq>
    fd8000001084:	d503201f 	nop
    fd8000001088:	d503201f 	nop
    fd800000108c:	d503201f 	nop
    fd8000001090:	d503201f 	nop
    fd8000001094:	d503201f 	nop
    fd8000001098:	d503201f 	nop
    fd800000109c:	d503201f 	nop
    fd80000010a0:	d503201f 	nop
    fd80000010a4:	d503201f 	nop
    fd80000010a8:	d503201f 	nop
    fd80000010ac:	d503201f 	nop
    fd80000010b0:	d503201f 	nop
    fd80000010b4:	d503201f 	nop
    fd80000010b8:	d503201f 	nop
    fd80000010bc:	d503201f 	nop
    fd80000010c0:	d503201f 	nop
    fd80000010c4:	d503201f 	nop
    fd80000010c8:	d503201f 	nop
    fd80000010cc:	d503201f 	nop
    fd80000010d0:	d503201f 	nop
    fd80000010d4:	d503201f 	nop
    fd80000010d8:	d503201f 	nop
    fd80000010dc:	d503201f 	nop
    fd80000010e0:	d503201f 	nop
    fd80000010e4:	d503201f 	nop
    fd80000010e8:	d503201f 	nop
    fd80000010ec:	d503201f 	nop
    fd80000010f0:	d503201f 	nop
    fd80000010f4:	d503201f 	nop
    fd80000010f8:	d503201f 	nop
    fd80000010fc:	d503201f 	nop

0000fd8000001100 <curr_el_sp0_fiq>:
.balign ENTRY_SIZE
curr_el_sp0_fiq:         
    b	.
    fd8000001100:	14000000 	b	fd8000001100 <curr_el_sp0_fiq>
    fd8000001104:	d503201f 	nop
    fd8000001108:	d503201f 	nop
    fd800000110c:	d503201f 	nop
    fd8000001110:	d503201f 	nop
    fd8000001114:	d503201f 	nop
    fd8000001118:	d503201f 	nop
    fd800000111c:	d503201f 	nop
    fd8000001120:	d503201f 	nop
    fd8000001124:	d503201f 	nop
    fd8000001128:	d503201f 	nop
    fd800000112c:	d503201f 	nop
    fd8000001130:	d503201f 	nop
    fd8000001134:	d503201f 	nop
    fd8000001138:	d503201f 	nop
    fd800000113c:	d503201f 	nop
    fd8000001140:	d503201f 	nop
    fd8000001144:	d503201f 	nop
    fd8000001148:	d503201f 	nop
    fd800000114c:	d503201f 	nop
    fd8000001150:	d503201f 	nop
    fd8000001154:	d503201f 	nop
    fd8000001158:	d503201f 	nop
    fd800000115c:	d503201f 	nop
    fd8000001160:	d503201f 	nop
    fd8000001164:	d503201f 	nop
    fd8000001168:	d503201f 	nop
    fd800000116c:	d503201f 	nop
    fd8000001170:	d503201f 	nop
    fd8000001174:	d503201f 	nop
    fd8000001178:	d503201f 	nop
    fd800000117c:	d503201f 	nop

0000fd8000001180 <curr_el_sp0_serror>:
.balign ENTRY_SIZE
curr_el_sp0_serror:      
    b	.
    fd8000001180:	14000000 	b	fd8000001180 <curr_el_sp0_serror>
    fd8000001184:	d503201f 	nop
    fd8000001188:	d503201f 	nop
    fd800000118c:	d503201f 	nop
    fd8000001190:	d503201f 	nop
    fd8000001194:	d503201f 	nop
    fd8000001198:	d503201f 	nop
    fd800000119c:	d503201f 	nop
    fd80000011a0:	d503201f 	nop
    fd80000011a4:	d503201f 	nop
    fd80000011a8:	d503201f 	nop
    fd80000011ac:	d503201f 	nop
    fd80000011b0:	d503201f 	nop
    fd80000011b4:	d503201f 	nop
    fd80000011b8:	d503201f 	nop
    fd80000011bc:	d503201f 	nop
    fd80000011c0:	d503201f 	nop
    fd80000011c4:	d503201f 	nop
    fd80000011c8:	d503201f 	nop
    fd80000011cc:	d503201f 	nop
    fd80000011d0:	d503201f 	nop
    fd80000011d4:	d503201f 	nop
    fd80000011d8:	d503201f 	nop
    fd80000011dc:	d503201f 	nop
    fd80000011e0:	d503201f 	nop
    fd80000011e4:	d503201f 	nop
    fd80000011e8:	d503201f 	nop
    fd80000011ec:	d503201f 	nop
    fd80000011f0:	d503201f 	nop
    fd80000011f4:	d503201f 	nop
    fd80000011f8:	d503201f 	nop
    fd80000011fc:	d503201f 	nop

0000fd8000001200 <curr_el_spx_sync>:
/* 
 * EL2 with SPx
 */  
.balign ENTRY_SIZE  
curr_el_spx_sync:
    SAVE_HYP_GPRS
    fd8000001200:	d10403ff 	sub	sp, sp, #0x100
    fd8000001204:	a90007e0 	stp	x0, x1, [sp]
    fd8000001208:	a9010fe2 	stp	x2, x3, [sp, #16]
    fd800000120c:	a90217e4 	stp	x4, x5, [sp, #32]
    fd8000001210:	a9031fe6 	stp	x6, x7, [sp, #48]
    fd8000001214:	a90427e8 	stp	x8, x9, [sp, #64]
    fd8000001218:	a9052fea 	stp	x10, x11, [sp, #80]
    fd800000121c:	a90637ec 	stp	x12, x13, [sp, #96]
    fd8000001220:	a9073fee 	stp	x14, x15, [sp, #112]
    fd8000001224:	a90847f0 	stp	x16, x17, [sp, #128]
    fd8000001228:	a9094ff2 	stp	x18, x19, [sp, #144]
    fd800000122c:	a90a57f4 	stp	x20, x21, [sp, #160]
    fd8000001230:	a90b5ff6 	stp	x22, x23, [sp, #176]
    fd8000001234:	a90c67f8 	stp	x24, x25, [sp, #192]
    fd8000001238:	a90d6ffa 	stp	x26, x27, [sp, #208]
    fd800000123c:	a90e77fc 	stp	x28, x29, [sp, #224]
    fd8000001240:	910003fd 	mov	x29, sp
    fd8000001244:	910403bd 	add	x29, x29, #0x100
    fd8000001248:	a90f77fe 	stp	x30, x29, [sp, #240]
    mov x0, sp
    fd800000124c:	910003e0 	mov	x0, sp
    bl	internal_abort_handler        
    fd8000001250:	9400018c 	bl	fd8000001880 <internal_abort_handler>
    b	.
    fd8000001254:	14000000 	b	fd8000001254 <curr_el_spx_sync+0x54>
    fd8000001258:	d503201f 	nop
    fd800000125c:	d503201f 	nop
    fd8000001260:	d503201f 	nop
    fd8000001264:	d503201f 	nop
    fd8000001268:	d503201f 	nop
    fd800000126c:	d503201f 	nop
    fd8000001270:	d503201f 	nop
    fd8000001274:	d503201f 	nop
    fd8000001278:	d503201f 	nop
    fd800000127c:	d503201f 	nop

0000fd8000001280 <curr_el_spx_irq>:
.balign ENTRY_SIZE
curr_el_spx_irq:         
    b	.
    fd8000001280:	14000000 	b	fd8000001280 <curr_el_spx_irq>
    fd8000001284:	d503201f 	nop
    fd8000001288:	d503201f 	nop
    fd800000128c:	d503201f 	nop
    fd8000001290:	d503201f 	nop
    fd8000001294:	d503201f 	nop
    fd8000001298:	d503201f 	nop
    fd800000129c:	d503201f 	nop
    fd80000012a0:	d503201f 	nop
    fd80000012a4:	d503201f 	nop
    fd80000012a8:	d503201f 	nop
    fd80000012ac:	d503201f 	nop
    fd80000012b0:	d503201f 	nop
    fd80000012b4:	d503201f 	nop
    fd80000012b8:	d503201f 	nop
    fd80000012bc:	d503201f 	nop
    fd80000012c0:	d503201f 	nop
    fd80000012c4:	d503201f 	nop
    fd80000012c8:	d503201f 	nop
    fd80000012cc:	d503201f 	nop
    fd80000012d0:	d503201f 	nop
    fd80000012d4:	d503201f 	nop
    fd80000012d8:	d503201f 	nop
    fd80000012dc:	d503201f 	nop
    fd80000012e0:	d503201f 	nop
    fd80000012e4:	d503201f 	nop
    fd80000012e8:	d503201f 	nop
    fd80000012ec:	d503201f 	nop
    fd80000012f0:	d503201f 	nop
    fd80000012f4:	d503201f 	nop
    fd80000012f8:	d503201f 	nop
    fd80000012fc:	d503201f 	nop

0000fd8000001300 <curr_el_spx_fiq>:
.balign ENTRY_SIZE
curr_el_spx_fiq:         
    b	.
    fd8000001300:	14000000 	b	fd8000001300 <curr_el_spx_fiq>
    fd8000001304:	d503201f 	nop
    fd8000001308:	d503201f 	nop
    fd800000130c:	d503201f 	nop
    fd8000001310:	d503201f 	nop
    fd8000001314:	d503201f 	nop
    fd8000001318:	d503201f 	nop
    fd800000131c:	d503201f 	nop
    fd8000001320:	d503201f 	nop
    fd8000001324:	d503201f 	nop
    fd8000001328:	d503201f 	nop
    fd800000132c:	d503201f 	nop
    fd8000001330:	d503201f 	nop
    fd8000001334:	d503201f 	nop
    fd8000001338:	d503201f 	nop
    fd800000133c:	d503201f 	nop
    fd8000001340:	d503201f 	nop
    fd8000001344:	d503201f 	nop
    fd8000001348:	d503201f 	nop
    fd800000134c:	d503201f 	nop
    fd8000001350:	d503201f 	nop
    fd8000001354:	d503201f 	nop
    fd8000001358:	d503201f 	nop
    fd800000135c:	d503201f 	nop
    fd8000001360:	d503201f 	nop
    fd8000001364:	d503201f 	nop
    fd8000001368:	d503201f 	nop
    fd800000136c:	d503201f 	nop
    fd8000001370:	d503201f 	nop
    fd8000001374:	d503201f 	nop
    fd8000001378:	d503201f 	nop
    fd800000137c:	d503201f 	nop

0000fd8000001380 <curr_el_spx_serror>:
.balign ENTRY_SIZE
curr_el_spx_serror:
    SAVE_HYP_GPRS
    fd8000001380:	d10403ff 	sub	sp, sp, #0x100
    fd8000001384:	a90007e0 	stp	x0, x1, [sp]
    fd8000001388:	a9010fe2 	stp	x2, x3, [sp, #16]
    fd800000138c:	a90217e4 	stp	x4, x5, [sp, #32]
    fd8000001390:	a9031fe6 	stp	x6, x7, [sp, #48]
    fd8000001394:	a90427e8 	stp	x8, x9, [sp, #64]
    fd8000001398:	a9052fea 	stp	x10, x11, [sp, #80]
    fd800000139c:	a90637ec 	stp	x12, x13, [sp, #96]
    fd80000013a0:	a9073fee 	stp	x14, x15, [sp, #112]
    fd80000013a4:	a90847f0 	stp	x16, x17, [sp, #128]
    fd80000013a8:	a9094ff2 	stp	x18, x19, [sp, #144]
    fd80000013ac:	a90a57f4 	stp	x20, x21, [sp, #160]
    fd80000013b0:	a90b5ff6 	stp	x22, x23, [sp, #176]
    fd80000013b4:	a90c67f8 	stp	x24, x25, [sp, #192]
    fd80000013b8:	a90d6ffa 	stp	x26, x27, [sp, #208]
    fd80000013bc:	a90e77fc 	stp	x28, x29, [sp, #224]
    fd80000013c0:	910003fd 	mov	x29, sp
    fd80000013c4:	910403bd 	add	x29, x29, #0x100
    fd80000013c8:	a90f77fe 	stp	x30, x29, [sp, #240]
    mov x0, sp
    fd80000013cc:	910003e0 	mov	x0, sp
    bl	internal_abort_handler       
    fd80000013d0:	9400012c 	bl	fd8000001880 <internal_abort_handler>
    b	.         
    fd80000013d4:	14000000 	b	fd80000013d4 <curr_el_spx_serror+0x54>
    fd80000013d8:	d503201f 	nop
    fd80000013dc:	d503201f 	nop
    fd80000013e0:	d503201f 	nop
    fd80000013e4:	d503201f 	nop
    fd80000013e8:	d503201f 	nop
    fd80000013ec:	d503201f 	nop
    fd80000013f0:	d503201f 	nop
    fd80000013f4:	d503201f 	nop
    fd80000013f8:	d503201f 	nop
    fd80000013fc:	d503201f 	nop

0000fd8000001400 <lower_el_aarch64_sync>:
 * Lower EL using AArch64
 */  

.balign ENTRY_SIZE
lower_el_aarch64_sync:
    VM_EXIT
    fd8000001400:	a90007e0 	stp	x0, x1, [sp]
    fd8000001404:	a9010fe2 	stp	x2, x3, [sp, #16]
    fd8000001408:	a90217e4 	stp	x4, x5, [sp, #32]
    fd800000140c:	a9031fe6 	stp	x6, x7, [sp, #48]
    fd8000001410:	a90427e8 	stp	x8, x9, [sp, #64]
    fd8000001414:	a9052fea 	stp	x10, x11, [sp, #80]
    fd8000001418:	a90637ec 	stp	x12, x13, [sp, #96]
    fd800000141c:	a9073fee 	stp	x14, x15, [sp, #112]
    fd8000001420:	a90847f0 	stp	x16, x17, [sp, #128]
    fd8000001424:	a9094ff2 	stp	x18, x19, [sp, #144]
    fd8000001428:	a90a57f4 	stp	x20, x21, [sp, #160]
    fd800000142c:	a90b5ff6 	stp	x22, x23, [sp, #176]
    fd8000001430:	a90c67f8 	stp	x24, x25, [sp, #192]
    fd8000001434:	a90d6ffa 	stp	x26, x27, [sp, #208]
    fd8000001438:	a90e77fc 	stp	x28, x29, [sp, #224]
    fd800000143c:	f9007bfe 	str	x30, [sp, #240]
    fd8000001440:	d53c4020 	mrs	x0, elr_el2
    fd8000001444:	d53c4001 	mrs	x1, spsr_el2
    fd8000001448:	a90f87e0 	stp	x0, x1, [sp, #248]
    fd800000144c:	d53cd040 	mrs	x0, tpidr_el2
    fd8000001450:	58001d81 	ldr	x1, fd8000001800 <lower_el_aarch32_serror+0x80>
    fd8000001454:	8b010000 	add	x0, x0, x1
    fd8000001458:	9100001f 	mov	sp, x0
    bl	aborts_sync_handler
    fd800000145c:	9400097d 	bl	fd8000003a50 <aborts_sync_handler>
    b   vcpu_arch_entry
    fd8000001460:	17fffce8 	b	fd8000000800 <vcpu_arch_entry>
    fd8000001464:	d503201f 	nop
    fd8000001468:	d503201f 	nop
    fd800000146c:	d503201f 	nop
    fd8000001470:	d503201f 	nop
    fd8000001474:	d503201f 	nop
    fd8000001478:	d503201f 	nop
    fd800000147c:	d503201f 	nop

0000fd8000001480 <lower_el_aarch64_irq>:
.balign ENTRY_SIZE
lower_el_aarch64_irq:    
    VM_EXIT
    fd8000001480:	a90007e0 	stp	x0, x1, [sp]
    fd8000001484:	a9010fe2 	stp	x2, x3, [sp, #16]
    fd8000001488:	a90217e4 	stp	x4, x5, [sp, #32]
    fd800000148c:	a9031fe6 	stp	x6, x7, [sp, #48]
    fd8000001490:	a90427e8 	stp	x8, x9, [sp, #64]
    fd8000001494:	a9052fea 	stp	x10, x11, [sp, #80]
    fd8000001498:	a90637ec 	stp	x12, x13, [sp, #96]
    fd800000149c:	a9073fee 	stp	x14, x15, [sp, #112]
    fd80000014a0:	a90847f0 	stp	x16, x17, [sp, #128]
    fd80000014a4:	a9094ff2 	stp	x18, x19, [sp, #144]
    fd80000014a8:	a90a57f4 	stp	x20, x21, [sp, #160]
    fd80000014ac:	a90b5ff6 	stp	x22, x23, [sp, #176]
    fd80000014b0:	a90c67f8 	stp	x24, x25, [sp, #192]
    fd80000014b4:	a90d6ffa 	stp	x26, x27, [sp, #208]
    fd80000014b8:	a90e77fc 	stp	x28, x29, [sp, #224]
    fd80000014bc:	f9007bfe 	str	x30, [sp, #240]
    fd80000014c0:	d53c4020 	mrs	x0, elr_el2
    fd80000014c4:	d53c4001 	mrs	x1, spsr_el2
    fd80000014c8:	a90f87e0 	stp	x0, x1, [sp, #248]
    fd80000014cc:	d53cd040 	mrs	x0, tpidr_el2
    fd80000014d0:	58001981 	ldr	x1, fd8000001800 <lower_el_aarch32_serror+0x80>
    fd80000014d4:	8b010000 	add	x0, x0, x1
    fd80000014d8:	9100001f 	mov	sp, x0
    bl  gic_handle
    fd80000014dc:	94000a69 	bl	fd8000003e80 <gic_handle>
    b   vcpu_arch_entry
    fd80000014e0:	17fffcc8 	b	fd8000000800 <vcpu_arch_entry>
    fd80000014e4:	d503201f 	nop
    fd80000014e8:	d503201f 	nop
    fd80000014ec:	d503201f 	nop
    fd80000014f0:	d503201f 	nop
    fd80000014f4:	d503201f 	nop
    fd80000014f8:	d503201f 	nop
    fd80000014fc:	d503201f 	nop

0000fd8000001500 <lower_el_aarch64_fiq>:
.balign ENTRY_SIZE
lower_el_aarch64_fiq:    
    b	.
    fd8000001500:	14000000 	b	fd8000001500 <lower_el_aarch64_fiq>
    fd8000001504:	d503201f 	nop
    fd8000001508:	d503201f 	nop
    fd800000150c:	d503201f 	nop
    fd8000001510:	d503201f 	nop
    fd8000001514:	d503201f 	nop
    fd8000001518:	d503201f 	nop
    fd800000151c:	d503201f 	nop
    fd8000001520:	d503201f 	nop
    fd8000001524:	d503201f 	nop
    fd8000001528:	d503201f 	nop
    fd800000152c:	d503201f 	nop
    fd8000001530:	d503201f 	nop
    fd8000001534:	d503201f 	nop
    fd8000001538:	d503201f 	nop
    fd800000153c:	d503201f 	nop
    fd8000001540:	d503201f 	nop
    fd8000001544:	d503201f 	nop
    fd8000001548:	d503201f 	nop
    fd800000154c:	d503201f 	nop
    fd8000001550:	d503201f 	nop
    fd8000001554:	d503201f 	nop
    fd8000001558:	d503201f 	nop
    fd800000155c:	d503201f 	nop
    fd8000001560:	d503201f 	nop
    fd8000001564:	d503201f 	nop
    fd8000001568:	d503201f 	nop
    fd800000156c:	d503201f 	nop
    fd8000001570:	d503201f 	nop
    fd8000001574:	d503201f 	nop
    fd8000001578:	d503201f 	nop
    fd800000157c:	d503201f 	nop

0000fd8000001580 <lower_el_aarch64_serror>:
.balign ENTRY_SIZE
lower_el_aarch64_serror: 
    b	.          
    fd8000001580:	14000000 	b	fd8000001580 <lower_el_aarch64_serror>
    fd8000001584:	d503201f 	nop
    fd8000001588:	d503201f 	nop
    fd800000158c:	d503201f 	nop
    fd8000001590:	d503201f 	nop
    fd8000001594:	d503201f 	nop
    fd8000001598:	d503201f 	nop
    fd800000159c:	d503201f 	nop
    fd80000015a0:	d503201f 	nop
    fd80000015a4:	d503201f 	nop
    fd80000015a8:	d503201f 	nop
    fd80000015ac:	d503201f 	nop
    fd80000015b0:	d503201f 	nop
    fd80000015b4:	d503201f 	nop
    fd80000015b8:	d503201f 	nop
    fd80000015bc:	d503201f 	nop
    fd80000015c0:	d503201f 	nop
    fd80000015c4:	d503201f 	nop
    fd80000015c8:	d503201f 	nop
    fd80000015cc:	d503201f 	nop
    fd80000015d0:	d503201f 	nop
    fd80000015d4:	d503201f 	nop
    fd80000015d8:	d503201f 	nop
    fd80000015dc:	d503201f 	nop
    fd80000015e0:	d503201f 	nop
    fd80000015e4:	d503201f 	nop
    fd80000015e8:	d503201f 	nop
    fd80000015ec:	d503201f 	nop
    fd80000015f0:	d503201f 	nop
    fd80000015f4:	d503201f 	nop
    fd80000015f8:	d503201f 	nop
    fd80000015fc:	d503201f 	nop

0000fd8000001600 <lower_el_aarch32_sync>:
/* 
 * Lower EL using AArch32
 */  
.balign ENTRY_SIZE   
lower_el_aarch32_sync:   
    b	.
    fd8000001600:	14000000 	b	fd8000001600 <lower_el_aarch32_sync>
    fd8000001604:	d503201f 	nop
    fd8000001608:	d503201f 	nop
    fd800000160c:	d503201f 	nop
    fd8000001610:	d503201f 	nop
    fd8000001614:	d503201f 	nop
    fd8000001618:	d503201f 	nop
    fd800000161c:	d503201f 	nop
    fd8000001620:	d503201f 	nop
    fd8000001624:	d503201f 	nop
    fd8000001628:	d503201f 	nop
    fd800000162c:	d503201f 	nop
    fd8000001630:	d503201f 	nop
    fd8000001634:	d503201f 	nop
    fd8000001638:	d503201f 	nop
    fd800000163c:	d503201f 	nop
    fd8000001640:	d503201f 	nop
    fd8000001644:	d503201f 	nop
    fd8000001648:	d503201f 	nop
    fd800000164c:	d503201f 	nop
    fd8000001650:	d503201f 	nop
    fd8000001654:	d503201f 	nop
    fd8000001658:	d503201f 	nop
    fd800000165c:	d503201f 	nop
    fd8000001660:	d503201f 	nop
    fd8000001664:	d503201f 	nop
    fd8000001668:	d503201f 	nop
    fd800000166c:	d503201f 	nop
    fd8000001670:	d503201f 	nop
    fd8000001674:	d503201f 	nop
    fd8000001678:	d503201f 	nop
    fd800000167c:	d503201f 	nop

0000fd8000001680 <lower_el_aarch32_irq>:
.balign ENTRY_SIZE
lower_el_aarch32_irq:    
    b	.
    fd8000001680:	14000000 	b	fd8000001680 <lower_el_aarch32_irq>
    fd8000001684:	d503201f 	nop
    fd8000001688:	d503201f 	nop
    fd800000168c:	d503201f 	nop
    fd8000001690:	d503201f 	nop
    fd8000001694:	d503201f 	nop
    fd8000001698:	d503201f 	nop
    fd800000169c:	d503201f 	nop
    fd80000016a0:	d503201f 	nop
    fd80000016a4:	d503201f 	nop
    fd80000016a8:	d503201f 	nop
    fd80000016ac:	d503201f 	nop
    fd80000016b0:	d503201f 	nop
    fd80000016b4:	d503201f 	nop
    fd80000016b8:	d503201f 	nop
    fd80000016bc:	d503201f 	nop
    fd80000016c0:	d503201f 	nop
    fd80000016c4:	d503201f 	nop
    fd80000016c8:	d503201f 	nop
    fd80000016cc:	d503201f 	nop
    fd80000016d0:	d503201f 	nop
    fd80000016d4:	d503201f 	nop
    fd80000016d8:	d503201f 	nop
    fd80000016dc:	d503201f 	nop
    fd80000016e0:	d503201f 	nop
    fd80000016e4:	d503201f 	nop
    fd80000016e8:	d503201f 	nop
    fd80000016ec:	d503201f 	nop
    fd80000016f0:	d503201f 	nop
    fd80000016f4:	d503201f 	nop
    fd80000016f8:	d503201f 	nop
    fd80000016fc:	d503201f 	nop

0000fd8000001700 <lower_el_aarch32_fiq>:
.balign ENTRY_SIZE
lower_el_aarch32_fiq:    
    b	.
    fd8000001700:	14000000 	b	fd8000001700 <lower_el_aarch32_fiq>
    fd8000001704:	d503201f 	nop
    fd8000001708:	d503201f 	nop
    fd800000170c:	d503201f 	nop
    fd8000001710:	d503201f 	nop
    fd8000001714:	d503201f 	nop
    fd8000001718:	d503201f 	nop
    fd800000171c:	d503201f 	nop
    fd8000001720:	d503201f 	nop
    fd8000001724:	d503201f 	nop
    fd8000001728:	d503201f 	nop
    fd800000172c:	d503201f 	nop
    fd8000001730:	d503201f 	nop
    fd8000001734:	d503201f 	nop
    fd8000001738:	d503201f 	nop
    fd800000173c:	d503201f 	nop
    fd8000001740:	d503201f 	nop
    fd8000001744:	d503201f 	nop
    fd8000001748:	d503201f 	nop
    fd800000174c:	d503201f 	nop
    fd8000001750:	d503201f 	nop
    fd8000001754:	d503201f 	nop
    fd8000001758:	d503201f 	nop
    fd800000175c:	d503201f 	nop
    fd8000001760:	d503201f 	nop
    fd8000001764:	d503201f 	nop
    fd8000001768:	d503201f 	nop
    fd800000176c:	d503201f 	nop
    fd8000001770:	d503201f 	nop
    fd8000001774:	d503201f 	nop
    fd8000001778:	d503201f 	nop
    fd800000177c:	d503201f 	nop

0000fd8000001780 <lower_el_aarch32_serror>:
.balign ENTRY_SIZE
lower_el_aarch32_serror: 
    b	.
    fd8000001780:	14000000 	b	fd8000001780 <lower_el_aarch32_serror>
    fd8000001784:	d503201f 	nop
    fd8000001788:	d503201f 	nop
    fd800000178c:	d503201f 	nop
    fd8000001790:	d503201f 	nop
    fd8000001794:	d503201f 	nop
    fd8000001798:	d503201f 	nop
    fd800000179c:	d503201f 	nop
    fd80000017a0:	d503201f 	nop
    fd80000017a4:	d503201f 	nop
    fd80000017a8:	d503201f 	nop
    fd80000017ac:	d503201f 	nop
    fd80000017b0:	d503201f 	nop
    fd80000017b4:	d503201f 	nop
    fd80000017b8:	d503201f 	nop
    fd80000017bc:	d503201f 	nop
    fd80000017c0:	d503201f 	nop
    fd80000017c4:	d503201f 	nop
    fd80000017c8:	d503201f 	nop
    fd80000017cc:	d503201f 	nop
    fd80000017d0:	d503201f 	nop
    fd80000017d4:	d503201f 	nop
    fd80000017d8:	d503201f 	nop
    fd80000017dc:	d503201f 	nop
    fd80000017e0:	d503201f 	nop
    fd80000017e4:	d503201f 	nop
    fd80000017e8:	d503201f 	nop
    fd80000017ec:	d503201f 	nop
    fd80000017f0:	d503201f 	nop
    fd80000017f4:	d503201f 	nop
    fd80000017f8:	d503201f 	nop
    fd80000017fc:	d503201f 	nop
    fd8000001800:	00002000 	.word	0x00002000
	...

0000fd8000001810 <vcpu_readreg>:
#include <vm.h>
#include <arch/sysregs.h>

unsigned long vcpu_readreg(struct vcpu* vcpu, unsigned long reg)
{
    if (reg > 30) {
    fd8000001810:	f100783f 	cmp	x1, #0x1e
    fd8000001814:	54000088 	b.hi	fd8000001824 <vcpu_readreg+0x14>  // b.pmore
        return 0;
    }
    return vcpu->regs.x[reg];
    fd8000001818:	91000821 	add	x1, x1, #0x2
    fd800000181c:	f8617800 	ldr	x0, [x0, x1, lsl #3]
}
    fd8000001820:	d65f03c0 	ret
        return 0;
    fd8000001824:	d2800000 	mov	x0, #0x0                   	// #0
}
    fd8000001828:	d65f03c0 	ret
    fd800000182c:	d503201f 	nop

0000fd8000001830 <vcpu_writereg>:

void vcpu_writereg(struct vcpu* vcpu, unsigned long reg, unsigned long val)
{
    if (reg > 30) {
    fd8000001830:	f100783f 	cmp	x1, #0x1e
    fd8000001834:	54000068 	b.hi	fd8000001840 <vcpu_writereg+0x10>  // b.pmore
        return;
    }
    vcpu->regs.x[reg] = val;
    fd8000001838:	91000821 	add	x1, x1, #0x2
    fd800000183c:	f8217802 	str	x2, [x0, x1, lsl #3]
}
    fd8000001840:	d65f03c0 	ret
    fd8000001844:	d503201f 	nop
    fd8000001848:	d503201f 	nop
    fd800000184c:	d503201f 	nop

0000fd8000001850 <vcpu_readpc>:

unsigned long vcpu_readpc(struct vcpu* vcpu)
{
    return vcpu->regs.elr_el2;
}
    fd8000001850:	f9408400 	ldr	x0, [x0, #264]
    fd8000001854:	d65f03c0 	ret
    fd8000001858:	d503201f 	nop
    fd800000185c:	d503201f 	nop

0000fd8000001860 <vcpu_writepc>:

void vcpu_writepc(struct vcpu* vcpu, unsigned long pc)
{
    vcpu->regs.elr_el2 = pc;
    fd8000001860:	f9008401 	str	x1, [x0, #264]
}
    fd8000001864:	d65f03c0 	ret
    fd8000001868:	d503201f 	nop
    fd800000186c:	d503201f 	nop

0000fd8000001870 <vcpu_subarch_reset>:

void vcpu_subarch_reset(struct vcpu* vcpu)
{
    vcpu->regs.spsr_el2 = SPSR_EL1h | SPSR_F | SPSR_I | SPSR_A | SPSR_D;
    fd8000001870:	d28078a1 	mov	x1, #0x3c5                 	// #965
    fd8000001874:	f9008801 	str	x1, [x0, #272]
}
    fd8000001878:	d65f03c0 	ret
    fd800000187c:	00000000 	udf	#0

0000fd8000001880 <internal_abort_handler>:
#include <bao.h>
#include <arch/sysregs.h>
#include <cpu.h>

void internal_abort_handler(unsigned long gprs[])
{
    fd8000001880:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    fd8000001884:	910003fd 	mov	x29, sp
    fd8000001888:	f90013f5 	str	x21, [sp, #32]
    fd800000188c:	90000001 	adrp	x1, fd8000001000 <_hyp_vector_table>
    fd8000001890:	f9448c35 	ldr	x21, [x1, #2328]
    fd8000001894:	a90153f3 	stp	x19, x20, [sp, #16]
    fd8000001898:	aa0003f4 	mov	x20, x0
    for (size_t i = 0; i < 31; i++) {
    fd800000189c:	d2800013 	mov	x19, #0x0                   	// #0
        console_printk("x%d:\t\t0x%0lx\n", i, gprs[i]);
    fd80000018a0:	f8737a82 	ldr	x2, [x20, x19, lsl #3]
    fd80000018a4:	aa1303e1 	mov	x1, x19
    fd80000018a8:	aa1503e0 	mov	x0, x21
    for (size_t i = 0; i < 31; i++) {
    fd80000018ac:	91000673 	add	x19, x19, #0x1
        console_printk("x%d:\t\t0x%0lx\n", i, gprs[i]);
    fd80000018b0:	940029dc 	bl	fd800000c020 <console_printk>
    for (size_t i = 0; i < 31; i++) {
    fd80000018b4:	f1007e7f 	cmp	x19, #0x1f
    fd80000018b8:	54ffff41 	b.ne	fd80000018a0 <internal_abort_handler+0x20>  // b.any
    }
    console_printk("SP:\t\t0x%0lx\n", gprs[31]);
    fd80000018bc:	f9407e81 	ldr	x1, [x20, #248]
    fd80000018c0:	90000000 	adrp	x0, fd8000001000 <_hyp_vector_table>
    fd80000018c4:	f9449000 	ldr	x0, [x0, #2336]
    fd80000018c8:	940029d6 	bl	fd800000c020 <console_printk>
        asm volatile("msr " XSTR(name) ", %0\n\r" ::"r"(val));    \
    }

#define SYSREG_GEN_ACCESSORS(reg) SYSREG_GEN_ACCESSORS_NAME(_##reg##_, reg)

SYSREG_GEN_ACCESSORS(esr_el2);
    fd80000018cc:	d53c5201 	mrs	x1, esr_el2
    console_printk("ESR:\t0x%0lx\n", sysreg_esr_el2_read());
    fd80000018d0:	90000000 	adrp	x0, fd8000001000 <_hyp_vector_table>
    fd80000018d4:	f9449400 	ldr	x0, [x0, #2344]
    fd80000018d8:	940029d2 	bl	fd800000c020 <console_printk>
SYSREG_GEN_ACCESSORS(elr_el2);
    fd80000018dc:	d53c4021 	mrs	x1, elr_el2
    console_printk("ELR:\t0x%0lx\n", sysreg_elr_el2_read());
    fd80000018e0:	90000000 	adrp	x0, fd8000001000 <_hyp_vector_table>
    fd80000018e4:	f9449800 	ldr	x0, [x0, #2352]
    fd80000018e8:	940029ce 	bl	fd800000c020 <console_printk>
SYSREG_GEN_ACCESSORS(far_el2);
    fd80000018ec:	d53c6001 	mrs	x1, far_el2
    console_printk("FAR:\t0x%0lx\n", sysreg_far_el2_read());
    fd80000018f0:	90000000 	adrp	x0, fd8000001000 <_hyp_vector_table>
    fd80000018f4:	f9449c00 	ldr	x0, [x0, #2360]
    fd80000018f8:	940029ca 	bl	fd800000c020 <console_printk>
    ERROR("cpu%d internal hypervisor abort - PANIC\n", cpu()->id);
    fd80000018fc:	d2dfc001 	mov	x1, #0xfe0000000000        	// #279275953455104
    fd8000001900:	90000000 	adrp	x0, fd8000001000 <_hyp_vector_table>
    fd8000001904:	f944a000 	ldr	x0, [x0, #2368]
    fd8000001908:	f9400021 	ldr	x1, [x1]
    fd800000190c:	940029c5 	bl	fd800000c020 <console_printk>
    fd8000001910:	14000000 	b	fd8000001910 <internal_abort_handler+0x90>
    fd8000001914:	d503201f 	nop
    fd8000001918:	00010000 	.word	0x00010000
    fd800000191c:	0000fd80 	.word	0x0000fd80
    fd8000001920:	00010010 	.word	0x00010010
    fd8000001924:	0000fd80 	.word	0x0000fd80
    fd8000001928:	00010020 	.word	0x00010020
    fd800000192c:	0000fd80 	.word	0x0000fd80
    fd8000001930:	00010030 	.word	0x00010030
    fd8000001934:	0000fd80 	.word	0x0000fd80
    fd8000001938:	00010040 	.word	0x00010040
    fd800000193c:	0000fd80 	.word	0x0000fd80
    fd8000001940:	00010050 	.word	0x00010050
    fd8000001944:	0000fd80 	.word	0x0000fd80
	...

0000fd8000001950 <pt_set_recursive>:
struct page_table_dscr* vm_pt_dscr = &armv8_pt_s2_dscr;

size_t parange __attribute__((section(".data")));

void pt_set_recursive(struct page_table* pt, size_t index)
{
    fd8000001950:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    fd8000001954:	910003fd 	mov	x29, sp
    fd8000001958:	a90153f3 	stp	x19, x20, [sp, #16]
    fd800000195c:	aa0003f3 	mov	x19, x0
    fd8000001960:	aa0103f4 	mov	x20, x1
    paddr_t pa;
    mem_translate(&cpu()->as, (vaddr_t)pt->root, &pa);
    fd8000001964:	d2800200 	mov	x0, #0x10                  	// #16
    fd8000001968:	9100a3e2 	add	x2, sp, #0x28
    fd800000196c:	f9400261 	ldr	x1, [x19]
    fd8000001970:	f2dfc000 	movk	x0, #0xfe00, lsl #32
    fd8000001974:	9400007f 	bl	fd8000001b70 <mem_translate>
    pte_t* pte = cpu()->as.pt.root + index;
    fd8000001978:	d2dfc001 	mov	x1, #0xfe0000000000        	// #279275953455104

void pt_set_recursive(struct page_table* pt, size_t index);

static inline void pte_set(pte_t* pte, paddr_t addr, pte_type_t type, pte_flags_t flags)
{
    *pte = (addr & PTE_ADDR_MSK) | ((type | flags) & PTE_FLAGS_MSK);
    fd800000197c:	d280e8e4 	mov	x4, #0x747                 	// #1863
    fd8000001980:	f94017e0 	ldr	x0, [sp, #40]
    fd8000001984:	f9400823 	ldr	x3, [x1, #16]
    fd8000001988:	92748c00 	and	x0, x0, #0xfffffffff000
    pte_set(pte, pa, PTE_TABLE, PTE_HYP_FLAGS);
    pt->arch.rec_ind = index;
    pt->arch.rec_mask = 0;
    size_t cpu_rec_ind = cpu()->as.pt.arch.rec_ind;
    for (size_t i = 0; i < pt->dscr->lvls; i++) {
    fd800000198c:	f9400662 	ldr	x2, [x19, #8]
    fd8000001990:	aa040000 	orr	x0, x0, x4
    fd8000001994:	f8347860 	str	x0, [x3, x20, lsl #3]
    fd8000001998:	f9400040 	ldr	x0, [x2]
    pt->arch.rec_ind = index;
    fd800000199c:	a901527f 	stp	xzr, x20, [x19, #16]
    size_t cpu_rec_ind = cpu()->as.pt.arch.rec_ind;
    fd80000019a0:	f9401424 	ldr	x4, [x1, #40]
    for (size_t i = 0; i < pt->dscr->lvls; i++) {
    fd80000019a4:	b4000160 	cbz	x0, fd80000019d0 <pt_set_recursive+0x80>
    fd80000019a8:	f9400442 	ldr	x2, [x2, #8]
        size_t lvl_off = pt->dscr->lvl_off[i];
    fd80000019ac:	d2800003 	mov	x3, #0x0                   	// #0
    fd80000019b0:	8b000c40 	add	x0, x2, x0, lsl #3
    fd80000019b4:	d503201f 	nop
        pt->arch.rec_mask |= cpu_rec_ind << lvl_off;
    fd80000019b8:	f8408441 	ldr	x1, [x2], #8
    for (size_t i = 0; i < pt->dscr->lvls; i++) {
    fd80000019bc:	eb00005f 	cmp	x2, x0
        pt->arch.rec_mask |= cpu_rec_ind << lvl_off;
    fd80000019c0:	9ac12081 	lsl	x1, x4, x1
    fd80000019c4:	aa010063 	orr	x3, x3, x1
    fd80000019c8:	f9000a63 	str	x3, [x19, #16]
    for (size_t i = 0; i < pt->dscr->lvls; i++) {
    fd80000019cc:	54ffff61 	b.ne	fd80000019b8 <pt_set_recursive+0x68>  // b.any
    }
}
    fd80000019d0:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd80000019d4:	a8c37bfd 	ldp	x29, x30, [sp], #48
    fd80000019d8:	d65f03c0 	ret
    fd80000019dc:	d503201f 	nop

0000fd80000019e0 <pt_get_pte>:

pte_t* pt_get_pte(struct page_table* pt, size_t lvl, vaddr_t va)
{
    struct page_table* cpu_pt = &cpu()->as.pt;

    size_t rec_ind_off = cpu_pt->dscr->lvl_off[cpu_pt->dscr->lvls - lvl - 1];
    fd80000019e0:	d2800206 	mov	x6, #0x10                  	// #16
    size_t rec_ind_len = cpu_pt->dscr->lvl_wdt[cpu_pt->dscr->lvls - lvl - 1];
    uintptr_t rec_ind_mask = PTE_MASK(rec_ind_off, rec_ind_len - rec_ind_off);
    uintptr_t addr = cpu_pt->arch.rec_mask & ~PTE_MASK(0, rec_ind_len);
    addr |= (pt->arch.rec_ind << rec_ind_off) & rec_ind_mask;
    addr |= (va >> pt->dscr->lvl_off[lvl]) * sizeof(pte_t) & PTE_MASK(0, rec_ind_off);
    fd80000019e4:	d2800023 	mov	x3, #0x1                   	// #1
    size_t rec_ind_off = cpu_pt->dscr->lvl_off[cpu_pt->dscr->lvls - lvl - 1];
    fd80000019e8:	f2dfc006 	movk	x6, #0xfe00, lsl #32
    addr |= (va >> pt->dscr->lvl_off[lvl]) * sizeof(pte_t) & PTE_MASK(0, rec_ind_off);
    fd80000019ec:	f9400407 	ldr	x7, [x0, #8]
    size_t rec_ind_off = cpu_pt->dscr->lvl_off[cpu_pt->dscr->lvls - lvl - 1];
    fd80000019f0:	f94004c4 	ldr	x4, [x6, #8]
    addr |= (va >> pt->dscr->lvl_off[lvl]) * sizeof(pte_t) & PTE_MASK(0, rec_ind_off);
    fd80000019f4:	f94004e7 	ldr	x7, [x7, #8]
    size_t rec_ind_off = cpu_pt->dscr->lvl_off[cpu_pt->dscr->lvls - lvl - 1];
    fd80000019f8:	a9402085 	ldp	x5, x8, [x4]
    size_t rec_ind_len = cpu_pt->dscr->lvl_wdt[cpu_pt->dscr->lvls - lvl - 1];
    fd80000019fc:	f9400889 	ldr	x9, [x4, #16]
    size_t rec_ind_off = cpu_pt->dscr->lvl_off[cpu_pt->dscr->lvls - lvl - 1];
    fd8000001a00:	cb0100a5 	sub	x5, x5, x1
    fd8000001a04:	d37df0a5 	lsl	x5, x5, #3
    fd8000001a08:	d10020a5 	sub	x5, x5, #0x8
    uintptr_t rec_ind_mask = PTE_MASK(rec_ind_off, rec_ind_len - rec_ind_off);
    fd8000001a0c:	f8656924 	ldr	x4, [x9, x5]
    fd8000001a10:	f8656905 	ldr	x5, [x8, x5]
    fd8000001a14:	51000484 	sub	w4, w4, #0x1
    addr |= (va >> pt->dscr->lvl_off[lvl]) * sizeof(pte_t) & PTE_MASK(0, rec_ind_off);
    fd8000001a18:	f86178e8 	ldr	x8, [x7, x1, lsl #3]
    uintptr_t rec_ind_mask = PTE_MASK(rec_ind_off, rec_ind_len - rec_ind_off);
    fd8000001a1c:	4b050089 	sub	w9, w4, w5
    addr |= (va >> pt->dscr->lvl_off[lvl]) * sizeof(pte_t) & PTE_MASK(0, rec_ind_off);
    fd8000001a20:	510004a1 	sub	w1, w5, #0x1
    uintptr_t addr = cpu_pt->arch.rec_mask & ~PTE_MASK(0, rec_ind_len);
    fd8000001a24:	9ac42064 	lsl	x4, x3, x4
    fd8000001a28:	f94008c7 	ldr	x7, [x6, #16]
    addr |= (va >> pt->dscr->lvl_off[lvl]) * sizeof(pte_t) & PTE_MASK(0, rec_ind_off);
    fd8000001a2c:	9ac12061 	lsl	x1, x3, x1
    addr |= (pt->arch.rec_ind << rec_ind_off) & rec_ind_mask;
    fd8000001a30:	f9400c06 	ldr	x6, [x0, #24]
    uintptr_t rec_ind_mask = PTE_MASK(rec_ind_off, rec_ind_len - rec_ind_off);
    fd8000001a34:	9ac92063 	lsl	x3, x3, x9
    addr |= (va >> pt->dscr->lvl_off[lvl]) * sizeof(pte_t) & PTE_MASK(0, rec_ind_off);
    fd8000001a38:	8b010021 	add	x1, x1, x1
    uintptr_t rec_ind_mask = PTE_MASK(rec_ind_off, rec_ind_len - rec_ind_off);
    fd8000001a3c:	8b030063 	add	x3, x3, x3
    addr |= (va >> pt->dscr->lvl_off[lvl]) * sizeof(pte_t) & PTE_MASK(0, rec_ind_off);
    fd8000001a40:	d1000421 	sub	x1, x1, #0x1
    fd8000001a44:	9ac82440 	lsr	x0, x2, x8
    uintptr_t addr = cpu_pt->arch.rec_mask & ~PTE_MASK(0, rec_ind_len);
    fd8000001a48:	cb0407e4 	neg	x4, x4, lsl #1
    uintptr_t rec_ind_mask = PTE_MASK(rec_ind_off, rec_ind_len - rec_ind_off);
    fd8000001a4c:	d1000463 	sub	x3, x3, #0x1
    uintptr_t addr = cpu_pt->arch.rec_mask & ~PTE_MASK(0, rec_ind_len);
    fd8000001a50:	8a070084 	and	x4, x4, x7
    addr |= (va >> pt->dscr->lvl_off[lvl]) * sizeof(pte_t) & PTE_MASK(0, rec_ind_off);
    fd8000001a54:	8a000c20 	and	x0, x1, x0, lsl #3
    addr |= (pt->arch.rec_ind << rec_ind_off) & rec_ind_mask;
    fd8000001a58:	8a060063 	and	x3, x3, x6
    fd8000001a5c:	aa040000 	orr	x0, x0, x4
    fd8000001a60:	9ac52063 	lsl	x3, x3, x5

    return (pte_t*)addr;
}
    fd8000001a64:	aa000060 	orr	x0, x3, x0
    fd8000001a68:	d65f03c0 	ret
    fd8000001a6c:	d503201f 	nop

0000fd8000001a70 <pt_get>:

pte_t* pt_get(struct page_table* pt, size_t lvl, vaddr_t va)
{
    fd8000001a70:	aa0003eb 	mov	x11, x0
    if (lvl == 0) {
    fd8000001a74:	b4000201 	cbz	x1, fd8000001ab4 <pt_get+0x44>
{
    fd8000001a78:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    fd8000001a7c:	aa0103ea 	mov	x10, x1
    fd8000001a80:	910003fd 	mov	x29, sp
        return pt->root;
    }

    uintptr_t pte = (uintptr_t)pt_get_pte(pt, lvl, va);
    fd8000001a84:	97ffffd7 	bl	fd80000019e0 <pt_get_pte>
    pte &= ~(pt_size(pt, lvl) - 1);
    fd8000001a88:	f9400562 	ldr	x2, [x11, #8]
extern struct page_table_dscr* hyp_pt_dscr;
extern struct page_table_dscr* vm_pt_dscr;

static inline size_t pt_nentries(struct page_table* pt, size_t lvl)
{
    return (1ULL << pt->dscr->lvl_wdt[lvl]) >> pt->dscr->lvl_off[lvl];
    fd8000001a8c:	d2800021 	mov	x1, #0x1                   	// #1
    return (pte_t*)pte;
}
    fd8000001a90:	a8c17bfd 	ldp	x29, x30, [sp], #16
    fd8000001a94:	a9408c42 	ldp	x2, x3, [x2, #8]
    fd8000001a98:	f86a7863 	ldr	x3, [x3, x10, lsl #3]
    fd8000001a9c:	f86a7842 	ldr	x2, [x2, x10, lsl #3]
    fd8000001aa0:	9ac32021 	lsl	x1, x1, x3
    fd8000001aa4:	9ac22421 	lsr	x1, x1, x2
    pte &= ~(pt_size(pt, lvl) - 1);
    fd8000001aa8:	cb010fe1 	neg	x1, x1, lsl #3
    fd8000001aac:	8a000020 	and	x0, x1, x0
}
    fd8000001ab0:	d65f03c0 	ret
        return pt->root;
    fd8000001ab4:	f9400000 	ldr	x0, [x0]
}
    fd8000001ab8:	d65f03c0 	ret
    fd8000001abc:	d503201f 	nop

0000fd8000001ac0 <pte_page>:
    return (va >> pt->dscr->lvl_off[lvl]) & (pt_nentries(pt, lvl) - 1);
}

static inline bool pt_lvl_terminal(struct page_table* pt, size_t lvl)
{
    return pt->dscr->lvl_term[lvl];
    fd8000001ac0:	f9400403 	ldr	x3, [x0, #8]
    fd8000001ac4:	f9400c60 	ldr	x0, [x3, #24]
    fd8000001ac8:	38626800 	ldrb	w0, [x0, x2]

bool pte_page(struct page_table* pt, pte_t* pte, size_t lvl)
{
    if (!pt_lvl_terminal(pt, lvl)) {
    fd8000001acc:	36000120 	tbz	w0, #0, fd8000001af0 <pte_page+0x30>
        return false;
    }

    if (lvl != pt->dscr->lvls - 1) {
    fd8000001ad0:	f9400063 	ldr	x3, [x3]
        return (*pte & PTE_TYPE_MSK) == PTE_SUPERPAGE;
    fd8000001ad4:	f9400020 	ldr	x0, [x1]
    if (lvl != pt->dscr->lvls - 1) {
    fd8000001ad8:	d1000461 	sub	x1, x3, #0x1
    fd8000001adc:	eb02003f 	cmp	x1, x2
        return (*pte & PTE_TYPE_MSK) == PTE_SUPERPAGE;
    fd8000001ae0:	92400400 	and	x0, x0, #0x3
    if (lvl != pt->dscr->lvls - 1) {
    fd8000001ae4:	54000080 	b.eq	fd8000001af4 <pte_page+0x34>  // b.none
        return (*pte & PTE_TYPE_MSK) == PTE_SUPERPAGE;
    fd8000001ae8:	f100041f 	cmp	x0, #0x1
    fd8000001aec:	1a9f17e0 	cset	w0, eq	// eq = none
    }

    return (*pte & PTE_TYPE_MSK) == PTE_PAGE;
}
    fd8000001af0:	d65f03c0 	ret
    return (*pte & PTE_TYPE_MSK) == PTE_PAGE;
    fd8000001af4:	f1000c1f 	cmp	x0, #0x3
    fd8000001af8:	1a9f17e0 	cset	w0, eq	// eq = none
}
    fd8000001afc:	d65f03c0 	ret

0000fd8000001b00 <pte_table>:

bool pte_table(struct page_table* pt, pte_t* pte, size_t lvl)
{
    if (lvl == pt->dscr->lvls - 1) {
    fd8000001b00:	f9400400 	ldr	x0, [x0, #8]
    fd8000001b04:	f9400000 	ldr	x0, [x0]
    fd8000001b08:	d1000400 	sub	x0, x0, #0x1
    fd8000001b0c:	eb02001f 	cmp	x0, x2
    fd8000001b10:	540000c0 	b.eq	fd8000001b28 <pte_table+0x28>  // b.none
        return false;
    }

    return (*pte & PTE_TYPE_MSK) == PTE_TABLE;
    fd8000001b14:	f9400020 	ldr	x0, [x1]
    fd8000001b18:	92400400 	and	x0, x0, #0x3
    fd8000001b1c:	f1000c1f 	cmp	x0, #0x3
    fd8000001b20:	1a9f17e0 	cset	w0, eq	// eq = none
}
    fd8000001b24:	d65f03c0 	ret
        return false;
    fd8000001b28:	52800000 	mov	w0, #0x0                   	// #0
}
    fd8000001b2c:	d65f03c0 	ret

0000fd8000001b30 <as_arch_init>:
    return (1ULL << pt->dscr->lvl_wdt[lvl]) >> pt->dscr->lvl_off[lvl];
    fd8000001b30:	d2800202 	mov	x2, #0x10                  	// #16
    fd8000001b34:	d2800021 	mov	x1, #0x1                   	// #1
    fd8000001b38:	f2dfc002 	movk	x2, #0xfe00, lsl #32
    fd8000001b3c:	f9400443 	ldr	x3, [x2, #8]

    /*
     * If the address space is a copy of an existing hypervisor space it's not possible to use the
     * PT_CPU_REC index to navigate it, so we have to use the PT_VM_REC_IND.
     */
    if (as->type == AS_HYP_CPY || as->type == AS_VM) {
    fd8000001b40:	b9402002 	ldr	w2, [x0, #32]
    fd8000001b44:	a9409464 	ldp	x4, x5, [x3, #8]
    fd8000001b48:	51000442 	sub	w2, w2, #0x1
        index = PT_VM_REC_IND;
    fd8000001b4c:	7100045f 	cmp	w2, #0x1
    fd8000001b50:	f94000a3 	ldr	x3, [x5]
    fd8000001b54:	f9400082 	ldr	x2, [x4]
    fd8000001b58:	9ac32021 	lsl	x1, x1, x3
    fd8000001b5c:	9ac22421 	lsr	x1, x1, x2
    fd8000001b60:	9a819421 	cinc	x1, x1, hi	// hi = pmore
    } else {
        index = PT_CPU_REC_IND;
    }
    pt_set_recursive(&as->pt, index);
    fd8000001b64:	d1000821 	sub	x1, x1, #0x2
    fd8000001b68:	17ffff7a 	b	fd8000001950 <pt_set_recursive>
    fd8000001b6c:	d503201f 	nop

0000fd8000001b70 <mem_translate>:
SYSREG_GEN_ACCESSORS(cntvoff_el2);
SYSREG_GEN_ACCESSORS(sctlr_el1);
SYSREG_GEN_ACCESSORS(cntkctl_el1);
SYSREG_GEN_ACCESSORS(cntfrq_el0);
SYSREG_GEN_ACCESSORS(pmcr_el0);
SYSREG_GEN_ACCESSORS(par_el1);
    fd8000001b70:	d5387404 	mrs	x4, par_el1
     * TODO: are barriers needed in this operation?
     */

    par_saved = sysreg_par_el1_read();

    if (as->type == AS_HYP || as->type == AS_HYP_CPY) {
    fd8000001b74:	b9402000 	ldr	w0, [x0, #32]
    fd8000001b78:	721e781f 	tst	w0, #0xfffffffd
    fd8000001b7c:	540001c1 	b.ne	fd8000001bb4 <mem_translate+0x44>  // b.any
    asm volatile("dc civac, %0\n\t" ::"r"(cache_addr));
}

static inline void arm_at_s1e2w(vaddr_t vaddr)
{
    asm volatile("at s1e2w, %0" ::"r"(vaddr));
    fd8000001b80:	d50c7821 	at	s1e2w, x1
        arm_at_s1e2w(va);
    } else {
        arm_at_s12e1w(va);
    }

    ISB();
    fd8000001b84:	d5033fdf 	isb
SYSREG_GEN_ACCESSORS(par_el1);
    fd8000001b88:	d5387403 	mrs	x3, par_el1
    fd8000001b8c:	d5187404 	msr	par_el1, x4
    par = sysreg_par_el1_read();
    sysreg_par_el1_write(par_saved);
    if (par & PAR_F) {
        return false;
    fd8000001b90:	52800000 	mov	w0, #0x0                   	// #0
    if (par & PAR_F) {
    fd8000001b94:	370000e3 	tbnz	w3, #0, fd8000001bb0 <mem_translate+0x40>
    } else {
        if (pa != NULL) {
    fd8000001b98:	b40000a2 	cbz	x2, fd8000001bac <mem_translate+0x3c>
            *pa = (par & PAR_PA_MSK) | (va & (PAGE_SIZE - 1));
    fd8000001b9c:	92746463 	and	x3, x3, #0x3ffffff000
    fd8000001ba0:	92402c21 	and	x1, x1, #0xfff
    fd8000001ba4:	aa010063 	orr	x3, x3, x1
    fd8000001ba8:	f9000043 	str	x3, [x2]
        }
        return true;
    fd8000001bac:	52800020 	mov	w0, #0x1                   	// #1
    }
}
    fd8000001bb0:	d65f03c0 	ret
}

static inline void arm_at_s12e1w(vaddr_t vaddr)
{
    asm volatile("at s12e1w, %0" ::"r"(vaddr));
    fd8000001bb4:	d50c78a1 	at	s12e1w, x1
}
    fd8000001bb8:	17fffff3 	b	fd8000001b84 <mem_translate+0x14>
    fd8000001bbc:	00000000 	udf	#0

0000fd8000001bc0 <vcpu_arch_profile_init>:
#include <arch/sysregs.h>
#include <arch/fences.h>
#include <tlb.h>

void vcpu_arch_profile_init(struct vcpu* vcpu, struct vm* vm)
{
    fd8000001bc0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    paddr_t root_pt_pa;
    mem_translate(&cpu()->as, (vaddr_t)vm->as.pt.root, &root_pt_pa);
    fd8000001bc4:	d2800200 	mov	x0, #0x10                  	// #16
    fd8000001bc8:	f2dfc000 	movk	x0, #0xfe00, lsl #32
{
    fd8000001bcc:	910003fd 	mov	x29, sp
    fd8000001bd0:	f9000bf3 	str	x19, [sp, #16]
    fd8000001bd4:	aa0103f3 	mov	x19, x1
    mem_translate(&cpu()->as, (vaddr_t)vm->as.pt.root, &root_pt_pa);
    fd8000001bd8:	f9402c21 	ldr	x1, [x1, #88]
    fd8000001bdc:	9100a3e2 	add	x2, sp, #0x28
    fd8000001be0:	97ffffe4 	bl	fd8000001b70 <mem_translate>
    sysreg_vttbr_el2_write((((uint64_t)vm->id << VTTBR_VMID_OFF) & VTTBR_VMID_MSK) |
    fd8000001be4:	f9400261 	ldr	x1, [x19]
        (root_pt_pa & ~VTTBR_VMID_MSK));
    fd8000001be8:	f94017e0 	ldr	x0, [sp, #40]
    sysreg_vttbr_el2_write((((uint64_t)vm->id << VTTBR_VMID_OFF) & VTTBR_VMID_MSK) |
    fd8000001bec:	b3501c20 	bfi	x0, x1, #48, #8
SYSREG_GEN_ACCESSORS(vttbr_el2);
    fd8000001bf0:	d51c2100 	msr	vttbr_el2, x0

    ISB(); // make sure vmid is commited befor tlbi
    fd8000001bf4:	d5033fdf 	isb
    tlb_vm_inv_all(vm->id);
    fd8000001bf8:	f9400260 	ldr	x0, [x19]
    fd8000001bfc:	d53c2101 	mrs	x1, vttbr_el2
        }                                                                        \
        return count;                                                            \
    }

BIT_OPS_GEN(bit32, uint32_t, UINT32_C(1), BIT32_MASK);
BIT_OPS_GEN(bit64, uint64_t, UINT64_C(1), BIT64_MASK);
    fd8000001c00:	d370dc21 	ubfx	x1, x1, #48, #8
{
    uint64_t vttbr = 0;
    vttbr = sysreg_vttbr_el2_read();
    bool switch_vmid = bit64_extract(vttbr, VTTBR_VMID_OFF, VTTBR_VMID_LEN) != vmid;

    if (switch_vmid) {
    fd8000001c04:	eb01001f 	cmp	x0, x1
    fd8000001c08:	54000160 	b.eq	fd8000001c34 <vcpu_arch_profile_init+0x74>  // b.none
        sysreg_vttbr_el2_write(((uint64_t)vmid << VTTBR_VMID_OFF) & VTTBR_VMID_MSK);
    fd8000001c0c:	d3501c00 	ubfiz	x0, x0, #48, #8
    fd8000001c10:	d51c2100 	msr	vttbr_el2, x0
        DSB(ish);
    fd8000001c14:	d5033b9f 	dsb	ish
        ISB();
    fd8000001c18:	d5033fdf 	isb
    asm volatile("tlbi alle2is");
}

static inline void arm_tlbi_vmalls12e1is()
{
    asm volatile("tlbi vmalls12e1is");
    fd8000001c1c:	d50c83df 	tlbi	vmalls12e1is
    }

    arm_tlbi_vmalls12e1is();

    if (switch_vmid) {
        DSB(ish);
    fd8000001c20:	d5033b9f 	dsb	ish
SYSREG_GEN_ACCESSORS(vttbr_el2);
    fd8000001c24:	d51c2100 	msr	vttbr_el2, x0
}
    fd8000001c28:	f9400bf3 	ldr	x19, [sp, #16]
    fd8000001c2c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    fd8000001c30:	d65f03c0 	ret
    asm volatile("tlbi vmalls12e1is");
    fd8000001c34:	d50c83df 	tlbi	vmalls12e1is
    fd8000001c38:	f9400bf3 	ldr	x19, [sp, #16]
    fd8000001c3c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    fd8000001c40:	d65f03c0 	ret
	...

0000fd8000001c50 <vmm_arch_profile_init>:

#include <vmm.h>

void vmm_arch_profile_init()
{
    vmm_arch_init_tcr();
    fd8000001c50:	14000438 	b	fd8000002d30 <vmm_arch_init_tcr>
	...

0000fd8000001c60 <psci_wake_from_idle>:
    vcpu_run(cpu()->vcpu);
}

void psci_wake_from_idle()
{
    cpu_idle_wakeup();
    fd8000001c60:	14002420 	b	fd800000ace0 <cpu_idle_wakeup>
    fd8000001c64:	d503201f 	nop
    fd8000001c68:	d503201f 	nop
    fd8000001c6c:	d503201f 	nop

0000fd8000001c70 <psci_wake_from_powerdown>:
{
    fd8000001c70:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    fd8000001c74:	910003fd 	mov	x29, sp
    fd8000001c78:	f9000bf3 	str	x19, [sp, #16]
    if (cpu()->vcpu == NULL) {
    fd8000001c7c:	d2dfc013 	mov	x19, #0xfe0000000000        	// #279275953455104
    fd8000001c80:	f9402a60 	ldr	x0, [x19, #80]
    fd8000001c84:	b4000160 	cbz	x0, fd8000001cb0 <psci_wake_from_powerdown+0x40>
    vcpu_arch_reset(cpu()->vcpu, cpu()->vcpu->arch.psci_ctx.entrypoint);
    fd8000001c88:	f944b001 	ldr	x1, [x0, #2400]
    fd8000001c8c:	9400061d 	bl	fd8000003500 <vcpu_arch_reset>
    vcpu_writereg(cpu()->vcpu, 0, cpu()->vcpu->arch.psci_ctx.context_id);
    fd8000001c90:	f9402a60 	ldr	x0, [x19, #80]
    fd8000001c94:	d2800001 	mov	x1, #0x0                   	// #0
    fd8000001c98:	f944b402 	ldr	x2, [x0, #2408]
    fd8000001c9c:	97fffee5 	bl	fd8000001830 <vcpu_writereg>
    vcpu_run(cpu()->vcpu);
    fd8000001ca0:	f9402a60 	ldr	x0, [x19, #80]
}
    fd8000001ca4:	f9400bf3 	ldr	x19, [sp, #16]
    fd8000001ca8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    vcpu_run(cpu()->vcpu);
    fd8000001cac:	14002885 	b	fd800000bec0 <vcpu_run>
        ERROR("cpu woke up but theres no vcpu to run");
    fd8000001cb0:	90000000 	adrp	x0, fd8000001000 <_hyp_vector_table>
    fd8000001cb4:	f9466000 	ldr	x0, [x0, #3264]
    fd8000001cb8:	940028da 	bl	fd800000c020 <console_printk>
    fd8000001cbc:	14000000 	b	fd8000001cbc <psci_wake_from_powerdown+0x4c>
    fd8000001cc0:	00010088 	.word	0x00010088
    fd8000001cc4:	0000fd80 	.word	0x0000fd80
    fd8000001cc8:	d503201f 	nop
    fd8000001ccc:	d503201f 	nop

0000fd8000001cd0 <psci_wake>:
    [PSCI_WAKEUP_POWERDOWN] = psci_wake_from_powerdown,
    [PSCI_WAKEUP_IDLE] = psci_wake_from_idle,
};

void psci_wake(uint32_t handler_id)
{
    fd8000001cd0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    fd8000001cd4:	910003fd 	mov	x29, sp
    fd8000001cd8:	f9000bf3 	str	x19, [sp, #16]
    fd8000001cdc:	2a0003f3 	mov	w19, w0
    gicc_restore_state(&cpu()->arch.profile.psci_off_state.gicc_state);
    fd8000001ce0:	d2801500 	mov	x0, #0xa8                  	// #168
    fd8000001ce4:	f2dfc000 	movk	x0, #0xfe00, lsl #32
    fd8000001ce8:	940018b2 	bl	fd8000007fb0 <gicc_restore_state>
    psci_restore_state();

    if (handler_id < PSCI_WAKEUP_NUM) {
    fd8000001cec:	71000a7f 	cmp	w19, #0x2
    fd8000001cf0:	54000108 	b.hi	fd8000001d10 <psci_wake+0x40>  // b.pmore
        psci_wake_handlers[handler_id]();
    fd8000001cf4:	90000000 	adrp	x0, fd8000001000 <_hyp_vector_table>
    fd8000001cf8:	f9469000 	ldr	x0, [x0, #3360]
    fd8000001cfc:	f8735800 	ldr	x0, [x0, w19, uxtw #3]
    } else {
        ERROR("unkown reason for cpu wake up");
    }
}
    fd8000001d00:	f9400bf3 	ldr	x19, [sp, #16]
        psci_wake_handlers[handler_id]();
    fd8000001d04:	aa0003f0 	mov	x16, x0
}
    fd8000001d08:	a8c27bfd 	ldp	x29, x30, [sp], #32
        psci_wake_handlers[handler_id]();
    fd8000001d0c:	d61f0200 	br	x16
        ERROR("unkown reason for cpu wake up");
    fd8000001d10:	90000000 	adrp	x0, fd8000001000 <_hyp_vector_table>
    fd8000001d14:	f9469400 	ldr	x0, [x0, #3368]
    fd8000001d18:	940028c2 	bl	fd800000c020 <console_printk>
    fd8000001d1c:	14000000 	b	fd8000001d1c <psci_wake+0x4c>
    fd8000001d20:	00012128 	.word	0x00012128
    fd8000001d24:	0000fd80 	.word	0x0000fd80
    fd8000001d28:	000100c0 	.word	0x000100c0
    fd8000001d2c:	0000fd80 	.word	0x0000fd80

0000fd8000001d30 <psci_standby>:

int32_t psci_standby()
{
    fd8000001d30:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    return psci_cpu_suspend(pwr_state_aux, psci_wakeup_addr, cntxt_paddr);
}

int32_t psci_cpu_suspend(uint32_t power_state, unsigned long entrypoint, unsigned long context_id)
{
    return smc_call(PSCI_CPU_SUSPEND, power_state, entrypoint, context_id, NULL);
    fd8000001d34:	d2800004 	mov	x4, #0x0                   	// #0
    fd8000001d38:	d2800003 	mov	x3, #0x0                   	// #0
{
    fd8000001d3c:	910003fd 	mov	x29, sp
    return smc_call(PSCI_CPU_SUSPEND, power_state, entrypoint, context_id, NULL);
    fd8000001d40:	d2800002 	mov	x2, #0x0                   	// #0
    fd8000001d44:	d2800001 	mov	x1, #0x0                   	// #0
    fd8000001d48:	d2800020 	mov	x0, #0x1                   	// #1
    fd8000001d4c:	f2b88000 	movk	x0, #0xc400, lsl #16
    fd8000001d50:	940003c8 	bl	fd8000002c70 <smc_call>
}
    fd8000001d54:	a8c17bfd 	ldp	x29, x30, [sp], #16
    fd8000001d58:	d65f03c0 	ret
    fd8000001d5c:	d503201f 	nop

0000fd8000001d60 <psci_power_down>:
{
    fd8000001d60:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    fd8000001d64:	910003fd 	mov	x29, sp
    fd8000001d68:	a90153f3 	stp	x19, x20, [sp, #16]
    fd8000001d6c:	2a0003f4 	mov	w20, w0
    fd8000001d70:	a9025bf5 	stp	x21, x22, [sp, #32]
SYSREG_GEN_ACCESSORS(tcr_el2);
    fd8000001d74:	d53c2040 	mrs	x0, tcr_el2
    cpu()->arch.profile.psci_off_state.tcr_el2 = sysreg_tcr_el2_read();
    fd8000001d78:	d2dfc013 	mov	x19, #0xfe0000000000        	// #279275953455104
    fd8000001d7c:	f9002e60 	str	x0, [x19, #88]
SYSREG_GEN_ACCESSORS(ttbr0_el2);
    fd8000001d80:	d53c2000 	mrs	x0, ttbr0_el2
    cpu()->arch.profile.psci_off_state.ttbr0_el2 = sysreg_ttbr0_el2_read();
    fd8000001d84:	f9003260 	str	x0, [x19, #96]
SYSREG_GEN_ACCESSORS(mair_el2);
    fd8000001d88:	d53ca200 	mrs	x0, mair_el2
    cpu()->arch.profile.psci_off_state.mair_el2 = sysreg_mair_el2_read();
    fd8000001d8c:	f9003660 	str	x0, [x19, #104]
SYSREG_GEN_ACCESSORS(cptr_el2);
    fd8000001d90:	d53c1140 	mrs	x0, cptr_el2
    cpu()->arch.profile.psci_off_state.cptr_el2 = sysreg_cptr_el2_read();
    fd8000001d94:	f9003a60 	str	x0, [x19, #112]
SYSREG_GEN_ACCESSORS(hcr_el2);
    fd8000001d98:	d53c1100 	mrs	x0, hcr_el2
    cpu()->arch.profile.psci_off_state.hcr_el2 = sysreg_hcr_el2_read();
    fd8000001d9c:	f9003e60 	str	x0, [x19, #120]
SYSREG_GEN_ACCESSORS(vmpidr_el2);
    fd8000001da0:	d53c00a0 	mrs	x0, vmpidr_el2
    cpu()->arch.profile.psci_off_state.vmpidr_el2 = sysreg_vmpidr_el2_read();
    fd8000001da4:	f9004260 	str	x0, [x19, #128]
SYSREG_GEN_ACCESSORS(vtcr_el2);
    fd8000001da8:	d53c2140 	mrs	x0, vtcr_el2
    cpu()->arch.profile.psci_off_state.vtcr_el2 = sysreg_vtcr_el2_read();
    fd8000001dac:	f9004660 	str	x0, [x19, #136]
SYSREG_GEN_ACCESSORS(vttbr_el2);
    fd8000001db0:	d53c2101 	mrs	x1, vttbr_el2
    mem_translate(&cpu()->as, (vaddr_t)&root_l1_flat_pt,
    fd8000001db4:	90000000 	adrp	x0, fd8000001000 <_hyp_vector_table>
    cpu()->arch.profile.psci_off_state.vttbr_el2 = sysreg_vttbr_el2_read();
    fd8000001db8:	f9004a61 	str	x1, [x19, #144]
    mem_translate(&cpu()->as, (vaddr_t)&root_l1_flat_pt,
    fd8000001dbc:	91028276 	add	x22, x19, #0xa0
    fd8000001dc0:	91004275 	add	x21, x19, #0x10
    fd8000001dc4:	f9472001 	ldr	x1, [x0, #3648]
    fd8000001dc8:	aa1603e2 	mov	x2, x22
    fd8000001dcc:	aa1503e0 	mov	x0, x21
    cache_flush_range((vaddr_t)&cpu()->arch.profile.psci_off_state,
    fd8000001dd0:	91016273 	add	x19, x19, #0x58
    mem_translate(&cpu()->as, (vaddr_t)&root_l1_flat_pt,
    fd8000001dd4:	97ffff67 	bl	fd8000001b70 <mem_translate>
    cpu()->arch.profile.psci_off_state.wakeup_reason = wakeup_reason;
    fd8000001dd8:	f9002274 	str	x20, [x19, #64]
    cache_flush_range((vaddr_t)&cpu()->arch.profile.psci_off_state,
    fd8000001ddc:	d2805301 	mov	x1, #0x298                 	// #664
    fd8000001de0:	aa1303e0 	mov	x0, x19
    fd8000001de4:	940004e7 	bl	fd8000003180 <cache_flush_range>
    gicc_save_state(&cpu()->arch.profile.psci_off_state.gicc_state);
    fd8000001de8:	910022c0 	add	x0, x22, #0x8
    fd8000001dec:	94001811 	bl	fd8000007e30 <gicc_save_state>
    mem_translate(&cpu()->as, (vaddr_t)&cpu()->arch.profile.psci_off_state, &cntxt_paddr);
    fd8000001df0:	aa1303e1 	mov	x1, x19
    fd8000001df4:	9100c3e2 	add	x2, sp, #0x30
    fd8000001df8:	aa1503e0 	mov	x0, x21
    fd8000001dfc:	97ffff5d 	bl	fd8000001b70 <mem_translate>
    mem_translate(&cpu()->as, (vaddr_t)&psci_boot_entry, &psci_wakeup_addr);
    fd8000001e00:	90000001 	adrp	x1, fd8000001000 <_hyp_vector_table>
    fd8000001e04:	9100e3e2 	add	x2, sp, #0x38
    fd8000001e08:	aa1503e0 	mov	x0, x21
    fd8000001e0c:	f9472421 	ldr	x1, [x1, #3656]
    fd8000001e10:	97ffff58 	bl	fd8000001b70 <mem_translate>
    return smc_call(PSCI_CPU_SUSPEND, power_state, entrypoint, context_id, NULL);
    fd8000001e14:	a9430be3 	ldp	x3, x2, [sp, #48]
    fd8000001e18:	d2800004 	mov	x4, #0x0                   	// #0
    fd8000001e1c:	d2800021 	mov	x1, #0x1                   	// #1
    fd8000001e20:	d2800020 	mov	x0, #0x1                   	// #1
    fd8000001e24:	f2b88000 	movk	x0, #0xc400, lsl #16
    fd8000001e28:	94000392 	bl	fd8000002c70 <smc_call>
}
    fd8000001e2c:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd8000001e30:	a9425bf5 	ldp	x21, x22, [sp, #32]
    fd8000001e34:	a8c47bfd 	ldp	x29, x30, [sp], #64
    fd8000001e38:	d65f03c0 	ret
    fd8000001e3c:	d503201f 	nop
    fd8000001e40:	0001f000 	.word	0x0001f000
    fd8000001e44:	0000fd80 	.word	0x0000fd80
    fd8000001e48:	000003ec 	.word	0x000003ec
    fd8000001e4c:	0000fd80 	.word	0x0000fd80

0000fd8000001e50 <psci_cpu_suspend>:
{
    fd8000001e50:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    fd8000001e54:	aa0103e4 	mov	x4, x1
    return smc_call(PSCI_CPU_SUSPEND, power_state, entrypoint, context_id, NULL);
    fd8000001e58:	aa0203e3 	mov	x3, x2
{
    fd8000001e5c:	910003fd 	mov	x29, sp
    return smc_call(PSCI_CPU_SUSPEND, power_state, entrypoint, context_id, NULL);
    fd8000001e60:	2a0003e1 	mov	w1, w0
    fd8000001e64:	aa0403e2 	mov	x2, x4
    fd8000001e68:	d2800004 	mov	x4, #0x0                   	// #0
    fd8000001e6c:	d2800020 	mov	x0, #0x1                   	// #1
    fd8000001e70:	f2b88000 	movk	x0, #0xc400, lsl #16
    fd8000001e74:	9400037f 	bl	fd8000002c70 <smc_call>
}
    fd8000001e78:	a8c17bfd 	ldp	x29, x30, [sp], #16
    fd8000001e7c:	d65f03c0 	ret

0000fd8000001e80 <psci_cpu_on>:

int32_t psci_cpu_on(unsigned long target_cpu, unsigned long entrypoint, unsigned long context_id)
{
    fd8000001e80:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    fd8000001e84:	aa0103e4 	mov	x4, x1
    return smc_call(PSCI_CPU_ON, target_cpu, entrypoint, context_id, NULL);
    fd8000001e88:	aa0203e3 	mov	x3, x2
{
    fd8000001e8c:	910003fd 	mov	x29, sp
    return smc_call(PSCI_CPU_ON, target_cpu, entrypoint, context_id, NULL);
    fd8000001e90:	aa0003e1 	mov	x1, x0
    fd8000001e94:	aa0403e2 	mov	x2, x4
    fd8000001e98:	d2800004 	mov	x4, #0x0                   	// #0
    fd8000001e9c:	d2800060 	mov	x0, #0x3                   	// #3
    fd8000001ea0:	f2b88000 	movk	x0, #0xc400, lsl #16
    fd8000001ea4:	94000373 	bl	fd8000002c70 <smc_call>
}
    fd8000001ea8:	a8c17bfd 	ldp	x29, x30, [sp], #16
    fd8000001eac:	d65f03c0 	ret

0000fd8000001eb0 <smmu_sme_is_group>:
    map[bit / BITMAP_GRANULE_LEN] &= ~(ONE << (bit % BITMAP_GRANULE_LEN));
}

static inline unsigned bitmap_get(bitmap_t* map, size_t bit)
{
    return (map[bit / BITMAP_GRANULE_LEN] & (ONE << (bit % BITMAP_GRANULE_LEN))) ? 1U : 0U;
    fd8000001eb0:	90000001 	adrp	x1, fd8000001000 <_hyp_vector_table>
    fd8000001eb4:	f9476c23 	ldr	x3, [x1, #3800]
    fd8000001eb8:	d345fc02 	lsr	x2, x0, #5
    fd8000001ebc:	52800021 	mov	w1, #0x1                   	// #1
    fd8000001ec0:	1ac02020 	lsl	w0, w1, w0
    fd8000001ec4:	8b020861 	add	x1, x3, x2, lsl #2
    fd8000001ec8:	b9403821 	ldr	w1, [x1, #56]
    fd8000001ecc:	6a01001f 	tst	w0, w1
 * Accessors inline functions.
 */
inline bool smmu_sme_is_group(size_t sme)
{
    return bitmap_get(smmu.grp_bitmap, sme);
}
    fd8000001ed0:	1a9f07e0 	cset	w0, ne	// ne = any
    fd8000001ed4:	d65f03c0 	ret
    fd8000001ed8:	00013000 	.word	0x00013000
    fd8000001edc:	0000fd80 	.word	0x0000fd80

0000fd8000001ee0 <smmu_sme_get_ctx>:

inline size_t smmu_sme_get_ctx(size_t sme)
{
    return S2CR_CBNDX(smmu.hw.glbl_rs0->S2CR[sme]);
    fd8000001ee0:	90000001 	adrp	x1, fd8000001000 <_hyp_vector_table>
    fd8000001ee4:	f9478021 	ldr	x1, [x1, #3840]
    fd8000001ee8:	f9400021 	ldr	x1, [x1]
    fd8000001eec:	8b000820 	add	x0, x1, x0, lsl #2
    fd8000001ef0:	b94c0000 	ldr	w0, [x0, #3072]
}
    fd8000001ef4:	92401c00 	and	x0, x0, #0xff
    fd8000001ef8:	d65f03c0 	ret
    fd8000001efc:	d503201f 	nop
    fd8000001f00:	00013000 	.word	0x00013000
    fd8000001f04:	0000fd80 	.word	0x0000fd80
    fd8000001f08:	d503201f 	nop
    fd8000001f0c:	d503201f 	nop

0000fd8000001f10 <smmu_sme_get_id>:

inline streamid_t smmu_sme_get_id(size_t sme)
{
    return SMMU_SMR_ID(smmu.hw.glbl_rs0->SMR[sme]);
    fd8000001f10:	90000001 	adrp	x1, fd8000001000 <_hyp_vector_table>
    fd8000001f14:	f9479821 	ldr	x1, [x1, #3888]
    fd8000001f18:	f9400021 	ldr	x1, [x1]
    fd8000001f1c:	8b000820 	add	x0, x1, x0, lsl #2
    fd8000001f20:	b9480000 	ldr	w0, [x0, #2048]
}
    fd8000001f24:	12003800 	and	w0, w0, #0x7fff
    fd8000001f28:	d65f03c0 	ret
    fd8000001f2c:	d503201f 	nop
    fd8000001f30:	00013000 	.word	0x00013000
    fd8000001f34:	0000fd80 	.word	0x0000fd80
    fd8000001f38:	d503201f 	nop
    fd8000001f3c:	d503201f 	nop

0000fd8000001f40 <smmu_sme_get_mask>:

inline streamid_t smmu_sme_get_mask(size_t sme)
{
    return SMMU_SMR_MASK(smmu.hw.glbl_rs0->SMR[sme]);
    fd8000001f40:	90000001 	adrp	x1, fd8000001000 <_hyp_vector_table>
    fd8000001f44:	f947b021 	ldr	x1, [x1, #3936]
    fd8000001f48:	f9400021 	ldr	x1, [x1]
    fd8000001f4c:	8b000820 	add	x0, x1, x0, lsl #2
    fd8000001f50:	b9480000 	ldr	w0, [x0, #2048]
}
    fd8000001f54:	d3507800 	ubfx	x0, x0, #16, #15
    fd8000001f58:	d65f03c0 	ret
    fd8000001f5c:	d503201f 	nop
    fd8000001f60:	00013000 	.word	0x00013000
    fd8000001f64:	0000fd80 	.word	0x0000fd80
    fd8000001f68:	d503201f 	nop
    fd8000001f6c:	d503201f 	nop

0000fd8000001f70 <smmu_init>:
        ERROR("smmuv2 does not support the full available ipa range");
    }
}

void smmu_init()
{
    fd8000001f70:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    /*
     * Alloc pages for global address space.
     *
     * Map the first 4k so we can read all the info we need to further allocate smmu registers.
     */
    vaddr_t smmu_glbl_rs0 = mem_alloc_map_dev(&cpu()->as, SEC_HYP_GLOBAL, INVALID_VA,
    fd8000001f74:	d2800024 	mov	x4, #0x1                   	// #1
    fd8000001f78:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
{
    fd8000001f7c:	910003fd 	mov	x29, sp
    fd8000001f80:	a90363f7 	stp	x23, x24, [sp, #48]
    vaddr_t smmu_glbl_rs0 = mem_alloc_map_dev(&cpu()->as, SEC_HYP_GLOBAL, INVALID_VA,
    fd8000001f84:	b0000000 	adrp	x0, fd8000002000 <smmu_init+0x90>
    fd8000001f88:	f9413018 	ldr	x24, [x0, #608]
    fd8000001f8c:	d2800200 	mov	x0, #0x10                  	// #16
    fd8000001f90:	52800001 	mov	w1, #0x0                   	// #0
    fd8000001f94:	f2dfc000 	movk	x0, #0xfe00, lsl #32
{
    fd8000001f98:	a90153f3 	stp	x19, x20, [sp, #16]
        platform.arch.smmu.base, NUM_PAGES(sizeof(struct smmu_glbl_rs0_hw)));

    smmu.hw.glbl_rs0 = (struct smmu_glbl_rs0_hw*)smmu_glbl_rs0;

    size_t pg_size = smmu.hw.glbl_rs0->IDR1 & SMMUV2_IDR1_PAGESIZE_BIT ? 0x10000 : 0x1000;
    fd8000001f9c:	d2820013 	mov	x19, #0x1000                	// #4096
    vaddr_t smmu_glbl_rs0 = mem_alloc_map_dev(&cpu()->as, SEC_HYP_GLOBAL, INVALID_VA,
    fd8000001fa0:	f9412b03 	ldr	x3, [x24, #592]
{
    fd8000001fa4:	a9025bf5 	stp	x21, x22, [sp, #32]
    vaddr_t smmu_glbl_rs0 = mem_alloc_map_dev(&cpu()->as, SEC_HYP_GLOBAL, INVALID_VA,
    fd8000001fa8:	940033b2 	bl	fd800000ee70 <mem_alloc_map_dev>
    fd8000001fac:	aa0003e5 	mov	x5, x0
    smmu.hw.glbl_rs0 = (struct smmu_glbl_rs0_hw*)smmu_glbl_rs0;
    fd8000001fb0:	b0000000 	adrp	x0, fd8000002000 <smmu_init+0x90>
    fd8000001fb4:	f9413415 	ldr	x21, [x0, #616]
    size_t pg_size = smmu.hw.glbl_rs0->IDR1 & SMMUV2_IDR1_PAGESIZE_BIT ? 0x10000 : 0x1000;
    fd8000001fb8:	d2a00020 	mov	x0, #0x10000               	// #65536
    fd8000001fbc:	b94024a1 	ldr	w1, [x5, #36]
                                   SMMUV2_IDR1_NUMPAGEDXB_LEN) +
                          1);
    size_t ctx_bank_num =
        bit32_extract(smmu.hw.glbl_rs0->IDR1, SMMUV2_IDR1_NUMCB_OFF, SMMUV2_IDR1_NUMCB_LEN);

    vaddr_t smmu_glbl_rs1 = mem_alloc_map_dev(&cpu()->as, SEC_HYP_GLOBAL, INVALID_VA,
    fd8000001fc0:	d2800024 	mov	x4, #0x1                   	// #1
    size_t num_page = 1ULL << (bit32_extract(smmu.hw.glbl_rs0->IDR1, SMMUV2_IDR1_NUMPAGEDXB_OFF,
    fd8000001fc4:	b94024b4 	ldr	w20, [x5, #36]
    vaddr_t smmu_glbl_rs1 = mem_alloc_map_dev(&cpu()->as, SEC_HYP_GLOBAL, INVALID_VA,
    fd8000001fc8:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
        bit32_extract(smmu.hw.glbl_rs0->IDR1, SMMUV2_IDR1_NUMCB_OFF, SMMUV2_IDR1_NUMCB_LEN);
    fd8000001fcc:	b94024b6 	ldr	w22, [x5, #36]
    size_t pg_size = smmu.hw.glbl_rs0->IDR1 & SMMUV2_IDR1_PAGESIZE_BIT ? 0x10000 : 0x1000;
    fd8000001fd0:	7100003f 	cmp	w1, #0x0
    vaddr_t smmu_glbl_rs1 = mem_alloc_map_dev(&cpu()->as, SEC_HYP_GLOBAL, INVALID_VA,
    fd8000001fd4:	f9412b03 	ldr	x3, [x24, #592]
    size_t pg_size = smmu.hw.glbl_rs0->IDR1 & SMMUV2_IDR1_PAGESIZE_BIT ? 0x10000 : 0x1000;
    fd8000001fd8:	9a80a273 	csel	x19, x19, x0, ge	// ge = tcont
BIT_OPS_GEN(bit32, uint32_t, UINT32_C(1), BIT32_MASK);
    fd8000001fdc:	12001ed7 	and	w23, w22, #0xff
    size_t ctx_bank_num =
    fd8000001fe0:	92401ed6 	and	x22, x22, #0xff
    vaddr_t smmu_glbl_rs1 = mem_alloc_map_dev(&cpu()->as, SEC_HYP_GLOBAL, INVALID_VA,
    fd8000001fe4:	d2800200 	mov	x0, #0x10                  	// #16
    fd8000001fe8:	8b030263 	add	x3, x19, x3
    fd8000001fec:	52800001 	mov	w1, #0x0                   	// #0
    fd8000001ff0:	f2dfc000 	movk	x0, #0xfe00, lsl #32
    smmu.hw.glbl_rs0 = (struct smmu_glbl_rs0_hw*)smmu_glbl_rs0;
    fd8000001ff4:	f90002a5 	str	x5, [x21]
    vaddr_t smmu_glbl_rs1 = mem_alloc_map_dev(&cpu()->as, SEC_HYP_GLOBAL, INVALID_VA,
    fd8000001ff8:	9400339e 	bl	fd800000ee70 <mem_alloc_map_dev>
        platform.arch.smmu.base + pg_size, NUM_PAGES(sizeof(struct smmu_glbl_rs1_hw)));

    vaddr_t smmu_cntxt = mem_alloc_map_dev(&cpu()->as, SEC_HYP_GLOBAL, INVALID_VA,
    fd8000001ffc:	f9412b03 	ldr	x3, [x24, #592]
        platform.arch.smmu.base + (num_page * pg_size), NUM_PAGES(pg_size * ctx_bank_num));
    fd8000002000:	9b167e64 	mul	x4, x19, x22
    fd8000002004:	d35c7a81 	ubfx	x1, x20, #28, #3
    vaddr_t smmu_glbl_rs1 = mem_alloc_map_dev(&cpu()->as, SEC_HYP_GLOBAL, INVALID_VA,
    fd8000002008:	aa0003e2 	mov	x2, x0
                                   SMMUV2_IDR1_NUMPAGEDXB_LEN) +
    fd800000200c:	11000421 	add	w1, w1, #0x1
    vaddr_t smmu_cntxt = mem_alloc_map_dev(&cpu()->as, SEC_HYP_GLOBAL, INVALID_VA,
    fd8000002010:	d2800200 	mov	x0, #0x10                  	// #16
    vaddr_t smmu_glbl_rs1 = mem_alloc_map_dev(&cpu()->as, SEC_HYP_GLOBAL, INVALID_VA,
    fd8000002014:	aa0203f4 	mov	x20, x2
    vaddr_t smmu_cntxt = mem_alloc_map_dev(&cpu()->as, SEC_HYP_GLOBAL, INVALID_VA,
    fd8000002018:	d34cfc84 	lsr	x4, x4, #12
        platform.arch.smmu.base + (num_page * pg_size), NUM_PAGES(pg_size * ctx_bank_num));
    fd800000201c:	9ac12273 	lsl	x19, x19, x1
    vaddr_t smmu_cntxt = mem_alloc_map_dev(&cpu()->as, SEC_HYP_GLOBAL, INVALID_VA,
    fd8000002020:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
    fd8000002024:	52800001 	mov	w1, #0x0                   	// #0
    fd8000002028:	8b030263 	add	x3, x19, x3
    fd800000202c:	f2dfc000 	movk	x0, #0xfe00, lsl #32
    fd8000002030:	94003390 	bl	fd800000ee70 <mem_alloc_map_dev>
        bit32_extract(smmu.hw.glbl_rs0->IDR7, SMMUV2_IDR7_MAJOR_OFF, SMMUV2_IDR7_MAJOR_LEN);
    fd8000002034:	f94002a2 	ldr	x2, [x21]

    smmu.hw.glbl_rs1 = (struct smmu_glbl_rs1_hw*)smmu_glbl_rs1;
    smmu.hw.cntxt = (struct smmu_cntxt_hw*)smmu_cntxt;
    fd8000002038:	a90082b4 	stp	x20, x0, [x21, #8]
        bit32_extract(smmu.hw.glbl_rs0->IDR7, SMMUV2_IDR7_MAJOR_OFF, SMMUV2_IDR7_MAJOR_LEN);
    fd800000203c:	b9403c41 	ldr	w1, [x2, #60]
    fd8000002040:	d3441c21 	ubfx	x1, x1, #4, #4
    if (version != 2) {
    fd8000002044:	7100083f 	cmp	w1, #0x2
    fd8000002048:	54000be1 	b.ne	fd80000021c4 <smmu_init+0x254>  // b.any
    if (!(smmu.hw.glbl_rs0->IDR0 & SMMUV2_IDR0_S2TS_BIT)) {
    fd800000204c:	b9402040 	ldr	w0, [x2, #32]
    fd8000002050:	36f00c20 	tbz	w0, #30, fd80000021d4 <smmu_init+0x264>
    if (!(smmu.hw.glbl_rs0->IDR0 & SMMUV2_IDR0_SMS_BIT)) {
    fd8000002054:	b9402040 	ldr	w0, [x2, #32]
    fd8000002058:	36d80d80 	tbz	w0, #27, fd8000002208 <smmu_init+0x298>
    if (!(smmu.hw.glbl_rs0->IDR0 & SMMUV2_IDR0_CTTW_BIT)) {
    fd800000205c:	b9402040 	ldr	w0, [x2, #32]
    fd8000002060:	36700ca0 	tbz	w0, #14, fd80000021f4 <smmu_init+0x284>
    if (!(smmu.hw.glbl_rs0->IDR0 & SMMUV2_IDR0_BTM_BIT)) {
    fd8000002064:	b9402040 	ldr	w0, [x2, #32]
    fd8000002068:	36680be0 	tbz	w0, #13, fd80000021e4 <smmu_init+0x274>
    if (!(smmu.hw.glbl_rs0->IDR2 & SMMUV2_IDR2_PTFSv8_4kB_BIT)) {
    fd800000206c:	b9402840 	ldr	w0, [x2, #40]
    fd8000002070:	36600d40 	tbz	w0, #12, fd8000002218 <smmu_init+0x2a8>
    if (pasize < parange) {
    fd8000002074:	90000000 	adrp	x0, fd8000002000 <smmu_init+0x90>
    fd8000002078:	f9415001 	ldr	x1, [x0, #672]
    size_t pasize = bit32_extract(smmu.hw.glbl_rs0->IDR2, SMMUV2_IDR2_OAS_OFF, SMMUV2_IDR2_OAS_LEN);
    fd800000207c:	b9402840 	ldr	w0, [x2, #40]
        bit32_extract(smmu.hw.glbl_rs0->IDR2, SMMUV2_IDR2_IAS_OFF, SMMUV2_IDR2_IAS_LEN);
    fd8000002080:	b9402843 	ldr	w3, [x2, #40]
    if (pasize < parange) {
    fd8000002084:	f9400021 	ldr	x1, [x1]
    size_t pasize = bit32_extract(smmu.hw.glbl_rs0->IDR2, SMMUV2_IDR2_OAS_OFF, SMMUV2_IDR2_OAS_LEN);
    fd8000002088:	d3441c00 	ubfx	x0, x0, #4, #4
    if (pasize < parange) {
    fd800000208c:	eb01001f 	cmp	x0, x1
    fd8000002090:	54000d43 	b.cc	fd8000002238 <smmu_init+0x2c8>  // b.lo, b.ul, b.last
    size_t ipasize =
    fd8000002094:	92400c63 	and	x3, x3, #0xf
    } else if (ipasize < parange) {
    fd8000002098:	eb01007f 	cmp	x3, x1
    fd800000209c:	54000c63 	b.cc	fd8000002228 <smmu_init+0x2b8>  // b.lo, b.ul, b.last
    /* Everything is mapped. Initialize book-keeping data. */

    smmu_check_features();

    smmu.ctx_lock = SPINLOCK_INITVAL;
    smmu.ctx_num = ctx_bank_num;
    fd80000020a0:	a904dabf 	stp	xzr, x22, [x21, #72]
    map[bit / BITMAP_GRANULE_LEN] &= ~(ONE << (bit % BITMAP_GRANULE_LEN));
    fd80000020a4:	910162a4 	add	x4, x21, #0x58

void bitmap_set_consecutive(bitmap_t* map, size_t start, size_t n);

static inline void bitmap_clear_consecutive(bitmap_t* map, size_t start, size_t n)
{
    for (size_t i = 0; i < n; i++) {
    fd80000020a8:	d2800000 	mov	x0, #0x0                   	// #0
    map[bit / BITMAP_GRANULE_LEN] &= ~(ONE << (bit % BITMAP_GRANULE_LEN));
    fd80000020ac:	52800026 	mov	w6, #0x1                   	// #1
    for (size_t i = 0; i < n; i++) {
    fd80000020b0:	34000137 	cbz	w23, fd80000020d4 <smmu_init+0x164>
    map[bit / BITMAP_GRANULE_LEN] &= ~(ONE << (bit % BITMAP_GRANULE_LEN));
    fd80000020b4:	d345fc03 	lsr	x3, x0, #5
    fd80000020b8:	1ac020c1 	lsl	w1, w6, w0
    for (size_t i = 0; i < n; i++) {
    fd80000020bc:	91000400 	add	x0, x0, #0x1
    fd80000020c0:	eb0002df 	cmp	x22, x0
    map[bit / BITMAP_GRANULE_LEN] &= ~(ONE << (bit % BITMAP_GRANULE_LEN));
    fd80000020c4:	b8637885 	ldr	w5, [x4, x3, lsl #2]
    fd80000020c8:	0a2100a1 	bic	w1, w5, w1
    fd80000020cc:	b8237881 	str	w1, [x4, x3, lsl #2]
    for (size_t i = 0; i < n; i++) {
    fd80000020d0:	54ffff21 	b.ne	fd80000020b4 <smmu_init+0x144>  // b.any
    bitmap_clear_consecutive(smmu.ctxbank_bitmap, 0, smmu.ctx_num);

    smmu.sme_lock = SPINLOCK_INITVAL;
    smmu.sme_num = smmu.hw.glbl_rs0->IDR0 & SMMUV2_IDR0_MASK;
    fd80000020d4:	b9402041 	ldr	w1, [x2, #32]
    map[bit / BITMAP_GRANULE_LEN] &= ~(ONE << (bit % BITMAP_GRANULE_LEN));
    fd80000020d8:	9100a2a5 	add	x5, x21, #0x28
    for (size_t i = 0; i < n; i++) {
    fd80000020dc:	d2800000 	mov	x0, #0x0                   	// #0
    map[bit / BITMAP_GRANULE_LEN] &= ~(ONE << (bit % BITMAP_GRANULE_LEN));
    fd80000020e0:	52800028 	mov	w8, #0x1                   	// #1
    fd80000020e4:	92401c27 	and	x7, x1, #0xff
    fd80000020e8:	a9019ebf 	stp	xzr, x7, [x21, #24]
    for (size_t i = 0; i < n; i++) {
    fd80000020ec:	72001c3f 	tst	w1, #0xff
    fd80000020f0:	54000ac0 	b.eq	fd8000002248 <smmu_init+0x2d8>  // b.none
    map[bit / BITMAP_GRANULE_LEN] &= ~(ONE << (bit % BITMAP_GRANULE_LEN));
    fd80000020f4:	d345fc04 	lsr	x4, x0, #5
    fd80000020f8:	1ac02101 	lsl	w1, w8, w0
    fd80000020fc:	aa0003e3 	mov	x3, x0
    for (size_t i = 0; i < n; i++) {
    fd8000002100:	91000400 	add	x0, x0, #0x1
    fd8000002104:	eb0000ff 	cmp	x7, x0
    map[bit / BITMAP_GRANULE_LEN] &= ~(ONE << (bit % BITMAP_GRANULE_LEN));
    fd8000002108:	b86478a6 	ldr	w6, [x5, x4, lsl #2]
    fd800000210c:	0a2100c1 	bic	w1, w6, w1
    fd8000002110:	b82478a1 	str	w1, [x5, x4, lsl #2]
    for (size_t i = 0; i < n; i++) {
    fd8000002114:	54ffff01 	b.ne	fd80000020f4 <smmu_init+0x184>  // b.any
    map[bit / BITMAP_GRANULE_LEN] &= ~(ONE << (bit % BITMAP_GRANULE_LEN));
    fd8000002118:	9100e2a6 	add	x6, x21, #0x38
    for (size_t i = 0; i < n; i++) {
    fd800000211c:	d2800001 	mov	x1, #0x0                   	// #0
    map[bit / BITMAP_GRANULE_LEN] &= ~(ONE << (bit % BITMAP_GRANULE_LEN));
    fd8000002120:	52800027 	mov	w7, #0x1                   	// #1
    fd8000002124:	d345fc25 	lsr	x5, x1, #5
    fd8000002128:	1ac120e0 	lsl	w0, w7, w1
    for (size_t i = 0; i < n; i++) {
    fd800000212c:	eb03003f 	cmp	x1, x3
    map[bit / BITMAP_GRANULE_LEN] &= ~(ONE << (bit % BITMAP_GRANULE_LEN));
    fd8000002130:	91000421 	add	x1, x1, #0x1
    fd8000002134:	b86578c4 	ldr	w4, [x6, x5, lsl #2]
    fd8000002138:	0a200080 	bic	w0, w4, w0
    fd800000213c:	b82578c0 	str	w0, [x6, x5, lsl #2]
    for (size_t i = 0; i < n; i++) {
    fd8000002140:	54ffff21 	b.ne	fd8000002124 <smmu_init+0x1b4>  // b.any
    bitmap_clear_consecutive(smmu.sme_bitmap, 0, smmu.sme_num);
    bitmap_clear_consecutive(smmu.grp_bitmap, 0, smmu.sme_num);

    /* Clear random reset state. */
    smmu.hw.glbl_rs0->GFSR = smmu.hw.glbl_rs0->GFSR;
    fd8000002144:	b9404841 	ldr	w1, [x2, #72]
    smmu.hw.glbl_rs0->NSGFSR = smmu.hw.glbl_rs0->NSGFSR;

    for (size_t i = 0; i < smmu.sme_num; i++) {
    fd8000002148:	d2800000 	mov	x0, #0x0                   	// #0
    smmu.hw.glbl_rs0->GFSR = smmu.hw.glbl_rs0->GFSR;
    fd800000214c:	b9004841 	str	w1, [x2, #72]
    smmu.hw.glbl_rs0->NSGFSR = smmu.hw.glbl_rs0->NSGFSR;
    fd8000002150:	b9444841 	ldr	w1, [x2, #1096]
    fd8000002154:	b9044841 	str	w1, [x2, #1096]
        smmu.hw.glbl_rs0->SMR[i] = 0;
    fd8000002158:	8b000841 	add	x1, x2, x0, lsl #2
    for (size_t i = 0; i < smmu.sme_num; i++) {
    fd800000215c:	eb03001f 	cmp	x0, x3
        smmu.hw.glbl_rs0->SMR[i] = 0;
    fd8000002160:	91000400 	add	x0, x0, #0x1
    fd8000002164:	b908003f 	str	wzr, [x1, #2048]
    for (size_t i = 0; i < smmu.sme_num; i++) {
    fd8000002168:	54ffff81 	b.ne	fd8000002158 <smmu_init+0x1e8>  // b.any
    }

    for (size_t i = 0; i < smmu.ctx_num; i++) {
    fd800000216c:	34000157 	cbz	w23, fd8000002194 <smmu_init+0x224>
        smmu.hw.cntxt[i].SCTLR = 0;
    fd8000002170:	f9400aa0 	ldr	x0, [x21, #16]
    fd8000002174:	52820001 	mov	w1, #0x1000                	// #4096
        smmu.hw.cntxt[i].FSR = -1;
    fd8000002178:	12800003 	mov	w3, #0xffffffff            	// #-1
    fd800000217c:	9ba102e1 	umaddl	x1, w23, w1, x0
        smmu.hw.cntxt[i].SCTLR = 0;
    fd8000002180:	b900001f 	str	wzr, [x0]
        smmu.hw.cntxt[i].FSR = -1;
    fd8000002184:	b9005803 	str	w3, [x0, #88]
    for (size_t i = 0; i < smmu.ctx_num; i++) {
    fd8000002188:	91400400 	add	x0, x0, #0x1, lsl #12
    fd800000218c:	eb00003f 	cmp	x1, x0
    fd8000002190:	54ffff81 	b.ne	fd8000002180 <smmu_init+0x210>  // b.any
    }

    /* Enable IOMMU. */
    uint32_t cr0 = smmu.hw.glbl_rs0->CR0;
    fd8000002194:	b9400040 	ldr	w0, [x2]
    cr0 = SMMUV2_CR0_CLEAR(cr0);
    cr0 |= SMMUV2_CR0_USFCFG | SMMUV2_CR0_SMCFCFG;
    fd8000002198:	52808001 	mov	w1, #0x400                 	// #1024
    fd800000219c:	72a00401 	movk	w1, #0x20, lsl #16
    cr0 = SMMUV2_CR0_CLEAR(cr0);
    fd80000021a0:	12155000 	and	w0, w0, #0xfffff800
    fd80000021a4:	12023400 	and	w0, w0, #0xc0000fff
    cr0 &= ~SMMUV2_CR0_CLIENTPD;
    smmu.hw.glbl_rs0->CR0 = cr0;
}
    fd80000021a8:	a94153f3 	ldp	x19, x20, [sp, #16]
    cr0 |= SMMUV2_CR0_USFCFG | SMMUV2_CR0_SMCFCFG;
    fd80000021ac:	2a010000 	orr	w0, w0, w1
}
    fd80000021b0:	a9425bf5 	ldp	x21, x22, [sp, #32]
    fd80000021b4:	a94363f7 	ldp	x23, x24, [sp, #48]
    smmu.hw.glbl_rs0->CR0 = cr0;
    fd80000021b8:	b9000040 	str	w0, [x2]
}
    fd80000021bc:	a8c47bfd 	ldp	x29, x30, [sp], #64
    fd80000021c0:	d65f03c0 	ret
        ERROR("smmu unsupported version: %d", version);
    fd80000021c4:	90000000 	adrp	x0, fd8000002000 <smmu_init+0x90>
    fd80000021c8:	f9413800 	ldr	x0, [x0, #624]
    fd80000021cc:	94002795 	bl	fd800000c020 <console_printk>
    fd80000021d0:	14000000 	b	fd80000021d0 <smmu_init+0x260>
        ERROR("smmuv2 does not support 2nd stage translation");
    fd80000021d4:	90000000 	adrp	x0, fd8000002000 <smmu_init+0x90>
    fd80000021d8:	f9413c00 	ldr	x0, [x0, #632]
    fd80000021dc:	94002791 	bl	fd800000c020 <console_printk>
    fd80000021e0:	14000000 	b	fd80000021e0 <smmu_init+0x270>
        ERROR("smmuv2 does not support tlb maintenance broadcast");
    fd80000021e4:	90000000 	adrp	x0, fd8000002000 <smmu_init+0x90>
    fd80000021e8:	f9414800 	ldr	x0, [x0, #656]
    fd80000021ec:	9400278d 	bl	fd800000c020 <console_printk>
    fd80000021f0:	14000000 	b	fd80000021f0 <smmu_init+0x280>
        WARNING("smmuv2 does not support coherent page table walks");
    fd80000021f4:	90000000 	adrp	x0, fd8000002000 <smmu_init+0x90>
    fd80000021f8:	f9414400 	ldr	x0, [x0, #648]
    fd80000021fc:	94002789 	bl	fd800000c020 <console_printk>
    if (!(smmu.hw.glbl_rs0->IDR0 & SMMUV2_IDR0_BTM_BIT)) {
    fd8000002200:	f94002a2 	ldr	x2, [x21]
    fd8000002204:	17ffff98 	b	fd8000002064 <smmu_init+0xf4>
        ERROR("smmuv2 does not support stream match");
    fd8000002208:	90000000 	adrp	x0, fd8000002000 <smmu_init+0x90>
    fd800000220c:	f9414000 	ldr	x0, [x0, #640]
    fd8000002210:	94002784 	bl	fd800000c020 <console_printk>
    fd8000002214:	14000000 	b	fd8000002214 <smmu_init+0x2a4>
        ERROR("smmuv2 does not support 4kb page granule");
    fd8000002218:	90000000 	adrp	x0, fd8000002000 <smmu_init+0x90>
    fd800000221c:	f9414c00 	ldr	x0, [x0, #664]
    fd8000002220:	94002780 	bl	fd800000c020 <console_printk>
    fd8000002224:	14000000 	b	fd8000002224 <smmu_init+0x2b4>
        ERROR("smmuv2 does not support the full available ipa range");
    fd8000002228:	90000000 	adrp	x0, fd8000002000 <smmu_init+0x90>
    fd800000222c:	f9415800 	ldr	x0, [x0, #688]
    fd8000002230:	9400277c 	bl	fd800000c020 <console_printk>
    fd8000002234:	14000000 	b	fd8000002234 <smmu_init+0x2c4>
        ERROR("smmuv2 does not support the full available pa range");
    fd8000002238:	90000000 	adrp	x0, fd8000002000 <smmu_init+0x90>
    fd800000223c:	f9415400 	ldr	x0, [x0, #680]
    fd8000002240:	94002778 	bl	fd800000c020 <console_printk>
    fd8000002244:	14000000 	b	fd8000002244 <smmu_init+0x2d4>
    smmu.hw.glbl_rs0->GFSR = smmu.hw.glbl_rs0->GFSR;
    fd8000002248:	b9404840 	ldr	w0, [x2, #72]
    fd800000224c:	b9004840 	str	w0, [x2, #72]
    smmu.hw.glbl_rs0->NSGFSR = smmu.hw.glbl_rs0->NSGFSR;
    fd8000002250:	b9444840 	ldr	w0, [x2, #1096]
    fd8000002254:	b9044840 	str	w0, [x2, #1096]
    for (size_t i = 0; i < smmu.sme_num; i++) {
    fd8000002258:	17ffffc5 	b	fd800000216c <smmu_init+0x1fc>
    fd800000225c:	d503201f 	nop
    fd8000002260:	00012930 	.word	0x00012930
    fd8000002264:	0000fd80 	.word	0x0000fd80
    fd8000002268:	00013000 	.word	0x00013000
    fd800000226c:	0000fd80 	.word	0x0000fd80
    fd8000002270:	000100f0 	.word	0x000100f0
    fd8000002274:	0000fd80 	.word	0x0000fd80
    fd8000002278:	00010120 	.word	0x00010120
    fd800000227c:	0000fd80 	.word	0x0000fd80
    fd8000002280:	00010160 	.word	0x00010160
    fd8000002284:	0000fd80 	.word	0x0000fd80
    fd8000002288:	00010198 	.word	0x00010198
    fd800000228c:	0000fd80 	.word	0x0000fd80
    fd8000002290:	000101d8 	.word	0x000101d8
    fd8000002294:	0000fd80 	.word	0x0000fd80
    fd8000002298:	00010218 	.word	0x00010218
    fd800000229c:	0000fd80 	.word	0x0000fd80
    fd80000022a0:	00012120 	.word	0x00012120
    fd80000022a4:	0000fd80 	.word	0x0000fd80
    fd80000022a8:	00010250 	.word	0x00010250
    fd80000022ac:	0000fd80 	.word	0x0000fd80
    fd80000022b0:	00010290 	.word	0x00010290
    fd80000022b4:	0000fd80 	.word	0x0000fd80
    fd80000022b8:	d503201f 	nop
    fd80000022bc:	d503201f 	nop

0000fd80000022c0 <smmu_alloc_ctxbnk>:

ssize_t smmu_alloc_ctxbnk()
{
    fd80000022c0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    fd80000022c4:	910003fd 	mov	x29, sp
    fd80000022c8:	a90153f3 	stp	x19, x20, [sp, #16]
    uint32_t ticket;
    uint32_t next;
    uint32_t temp;

    (void)lock;
    __asm__ volatile(
    fd80000022cc:	90000000 	adrp	x0, fd8000002000 <smmu_init+0x90>
    fd80000022d0:	f941b013 	ldr	x19, [x0, #864]
    fd80000022d4:	91012263 	add	x3, x19, #0x48
    fd80000022d8:	91013264 	add	x4, x19, #0x4c
    fd80000022dc:	885ffc60 	ldaxr	w0, [x3]
    fd80000022e0:	11000401 	add	w1, w0, #0x1
    fd80000022e4:	88027c61 	stxr	w2, w1, [x3]
    fd80000022e8:	35ffffa2 	cbnz	w2, fd80000022dc <smmu_alloc_ctxbnk+0x1c>
    fd80000022ec:	88dffc81 	ldar	w1, [x4]
    fd80000022f0:	6b01001f 	cmp	w0, w1
    fd80000022f4:	54000060 	b.eq	fd8000002300 <smmu_alloc_ctxbnk+0x40>  // b.none
    fd80000022f8:	d503205f 	wfe
    fd80000022fc:	17fffffc 	b	fd80000022ec <smmu_alloc_ctxbnk+0x2c>
    spin_lock(&smmu.ctx_lock);
    /* Find a free context bank. */
    ssize_t nth = bitmap_find_nth(smmu.ctxbank_bitmap, smmu.ctx_num, 1, 0, false);
    fd8000002300:	f9402a61 	ldr	x1, [x19, #80]
    fd8000002304:	91016274 	add	x20, x19, #0x58
    fd8000002308:	aa1403e0 	mov	x0, x20
    fd800000230c:	52800004 	mov	w4, #0x0                   	// #0
    fd8000002310:	d2800003 	mov	x3, #0x0                   	// #0
    fd8000002314:	d2800022 	mov	x2, #0x1                   	// #1
    fd8000002318:	94001b76 	bl	fd80000090f0 <bitmap_find_nth>
    if (nth >= 0) {
    fd800000231c:	b7f800e0 	tbnz	x0, #63, fd8000002338 <smmu_alloc_ctxbnk+0x78>
    map[bit / BITMAP_GRANULE_LEN] |= ONE << (bit % BITMAP_GRANULE_LEN);
    fd8000002320:	d345fc03 	lsr	x3, x0, #5
    fd8000002324:	52800022 	mov	w2, #0x1                   	// #1
    fd8000002328:	1ac02042 	lsl	w2, w2, w0
    fd800000232c:	b8637a81 	ldr	w1, [x20, x3, lsl #2]
    fd8000002330:	2a020021 	orr	w1, w1, w2
    fd8000002334:	b8237a81 	str	w1, [x20, x3, lsl #2]

static inline void spin_unlock(spinlock_t* lock)
{
    uint32_t temp;

    __asm__ volatile(
    fd8000002338:	91013262 	add	x2, x19, #0x4c
    fd800000233c:	b9400041 	ldr	w1, [x2]
    fd8000002340:	11000421 	add	w1, w1, #0x1
    fd8000002344:	889ffc41 	stlr	w1, [x2]
    fd8000002348:	d5033b9f 	dsb	ish
    fd800000234c:	d503209f 	sev
        bitmap_set(smmu.ctxbank_bitmap, nth);
    }
    spin_unlock(&smmu.ctx_lock);

    return nth;
}
    fd8000002350:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd8000002354:	a8c27bfd 	ldp	x29, x30, [sp], #32
    fd8000002358:	d65f03c0 	ret
    fd800000235c:	d503201f 	nop
    fd8000002360:	00013000 	.word	0x00013000
    fd8000002364:	0000fd80 	.word	0x0000fd80
    fd8000002368:	d503201f 	nop
    fd800000236c:	d503201f 	nop

0000fd8000002370 <smmu_write_ctxbnk>:
    __asm__ volatile(
    fd8000002370:	90000003 	adrp	x3, fd8000002000 <smmu_init+0x90>
    fd8000002374:	f9426c63 	ldr	x3, [x3, #1240]
    fd8000002378:	91012067 	add	x7, x3, #0x48
    fd800000237c:	91013068 	add	x8, x3, #0x4c
    fd8000002380:	885ffce4 	ldaxr	w4, [x7]
    fd8000002384:	11000485 	add	w5, w4, #0x1
    fd8000002388:	88067ce5 	stxr	w6, w5, [x7]
    fd800000238c:	35ffffa6 	cbnz	w6, fd8000002380 <smmu_write_ctxbnk+0x10>
    fd8000002390:	88dffd05 	ldar	w5, [x8]
    fd8000002394:	6b05009f 	cmp	w4, w5
    fd8000002398:	54000060 	b.eq	fd80000023a4 <smmu_write_ctxbnk+0x34>  // b.none
    fd800000239c:	d503205f 	wfe
    fd80000023a0:	17fffffc 	b	fd8000002390 <smmu_write_ctxbnk+0x20>
    return (map[bit / BITMAP_GRANULE_LEN] & (ONE << (bit % BITMAP_GRANULE_LEN))) ? 1U : 0U;
    fd80000023a4:	d345fc04 	lsr	x4, x0, #5
    fd80000023a8:	52800025 	mov	w5, #0x1                   	// #1
    fd80000023ac:	1ac020a6 	lsl	w6, w5, w0
    fd80000023b0:	8b040864 	add	x4, x3, x4, lsl #2
    fd80000023b4:	b9405884 	ldr	w4, [x4, #88]
    fd80000023b8:	6a0400df 	tst	w6, w4
    fd80000023bc:	540006a0 	b.eq	fd8000002490 <smmu_write_ctxbnk+0x120>  // b.none

        /**
         * This should closely match to the VTCR configuration set up in vmm_arch_init as we're
         * sharing page table between the VM and its smmu context.
         */
        uint32_t tcr = ((parange << SMMUV2_TCR_PS_OFF) & SMMUV2_TCR_PS_MSK);
    fd80000023c0:	90000004 	adrp	x4, fd8000002000 <smmu_init+0x90>
    fd80000023c4:	f9427086 	ldr	x6, [x4, #1248]
        size_t t0sz = 64 - parange_table[parange];
    fd80000023c8:	90000004 	adrp	x4, fd8000002000 <smmu_init+0x90>
    fd80000023cc:	f9427484 	ldr	x4, [x4, #1256]
        smmu.hw.glbl_rs1->CBAR[ctx_id] = SMMUV2_CBAR_VMID(vm_id);
    fd80000023d0:	12001c42 	and	w2, w2, #0xff
        uint32_t tcr = ((parange << SMMUV2_TCR_PS_OFF) & SMMUV2_TCR_PS_MSK);
    fd80000023d4:	f94000c7 	ldr	x7, [x6]
        tcr |= SMMUV2_TCR_ORGN0_WB_RA_WA;
        tcr |= SMMUV2_TCR_IRGN0_WB_RA_WA;
        tcr |= SMMUV2_TCR_T0SZ(t0sz);
        tcr |= SMMUV2_TCR_SH0_IS;
        tcr |= ((parange_table[parange] < 44) ? SMMUV2_TCR_SL0_1 : SMMUV2_TCR_SL0_0);
        smmu.hw.cntxt[ctx_id].TCR = tcr;
    fd80000023d8:	d374cc06 	lsl	x6, x0, #12
    fd80000023dc:	f9400468 	ldr	x8, [x3, #8]
        size_t t0sz = 64 - parange_table[parange];
    fd80000023e0:	f8677884 	ldr	x4, [x4, x7, lsl #3]
        uint32_t tcr = ((parange << SMMUV2_TCR_PS_OFF) & SMMUV2_TCR_PS_MSK);
    fd80000023e4:	531008e7 	ubfiz	w7, w7, #16, #3
    fd80000023e8:	8b000909 	add	x9, x8, x0, lsl #2
        smmu.hw.glbl_rs1->CBAR[ctx_id] = SMMUV2_CBAR_VMID(vm_id);
    fd80000023ec:	b8207902 	str	w2, [x8, x0, lsl #2]
        smmu.hw.cntxt[ctx_id].TCR = tcr;
    fd80000023f0:	f9400862 	ldr	x2, [x3, #16]
        size_t t0sz = 64 - parange_table[parange];
    fd80000023f4:	4b0403e0 	neg	w0, w4
        smmu.hw.glbl_rs1->CBA2R[ctx_id] = SMMUV2_CBAR_VA64;
    fd80000023f8:	b9080125 	str	w5, [x9, #2048]
        tcr |= SMMUV2_TCR_T0SZ(t0sz);
    fd80000023fc:	12001000 	and	w0, w0, #0x1f
        tcr |= ((parange_table[parange] < 44) ? SMMUV2_TCR_SL0_1 : SMMUV2_TCR_SL0_0);
    fd8000002400:	f100ac9f 	cmp	x4, #0x2b
    fd8000002404:	2a070000 	orr	w0, w0, w7
        smmu.hw.cntxt[ctx_id].TCR = tcr;
    fd8000002408:	8b060045 	add	x5, x2, x6
        tcr |= ((parange_table[parange] < 44) ? SMMUV2_TCR_SL0_1 : SMMUV2_TCR_SL0_0);
    fd800000240c:	54000508 	b.hi	fd80000024ac <smmu_write_ctxbnk+0x13c>  // b.pmore
    fd8000002410:	5286a807 	mov	w7, #0x3540                	// #13632
    fd8000002414:	2a070000 	orr	w0, w0, w7
        smmu.hw.cntxt[ctx_id].TCR = tcr;
    fd8000002418:	b90030a0 	str	w0, [x5, #48]
        if (t0sz >= 21 && t0sz <= 33) {
    fd800000241c:	d2800560 	mov	x0, #0x2b                  	// #43
    fd8000002420:	cb040000 	sub	x0, x0, x4
            offset = 37 - t0sz;
    fd8000002424:	d1006c84 	sub	x4, x4, #0x1b
        if (t0sz >= 21 && t0sz <= 33) {
    fd8000002428:	f100301f 	cmp	x0, #0xc
    fd800000242c:	54000508 	b.hi	fd80000024cc <smmu_write_ctxbnk+0x15c>  // b.pmore
        smmu.hw.cntxt[ctx_id].TTBR0 = root_pt & SMMUV2_CB_TTBA(smmu_cb_ttba_offset(t0sz));
    fd8000002430:	528005e7 	mov	w7, #0x2f                  	// #47
    fd8000002434:	4b0400e7 	sub	w7, w7, w4
    fd8000002438:	d2800040 	mov	x0, #0x2                   	// #2
    fd800000243c:	9ac72000 	lsl	x0, x0, x7
    fd8000002440:	d1000400 	sub	x0, x0, #0x1
    fd8000002444:	9ac42000 	lsl	x0, x0, x4
    fd8000002448:	8a000021 	and	x1, x1, x0
    fd800000244c:	f90010a1 	str	x1, [x5, #32]

        uint32_t sctlr = smmu.hw.cntxt[ctx_id].SCTLR;
        sctlr = SMMUV2_SCTLR_CLEAR(sctlr);
    fd8000002450:	5283c005 	mov	w5, #0x1e00                	// #7680
    fd8000002454:	72be0205 	movk	w5, #0xf010, lsl #16
        uint32_t sctlr = smmu.hw.cntxt[ctx_id].SCTLR;
    fd8000002458:	b8666840 	ldr	w0, [x2, x6]
        sctlr |= SMMUV2_SCTLR_DEFAULT;
        smmu.hw.cntxt[ctx_id].SCTLR |= sctlr;
    fd800000245c:	52801021 	mov	w1, #0x81                  	// #129
    fd8000002460:	b8666844 	ldr	w4, [x2, x6]
        sctlr = SMMUV2_SCTLR_CLEAR(sctlr);
    fd8000002464:	0a050000 	and	w0, w0, w5
        smmu.hw.cntxt[ctx_id].SCTLR |= sctlr;
    fd8000002468:	2a040000 	orr	w0, w0, w4
    fd800000246c:	2a010000 	orr	w0, w0, w1
    __asm__ volatile(
    fd8000002470:	91013061 	add	x1, x3, #0x4c
    fd8000002474:	b8266840 	str	w0, [x2, x6]
    fd8000002478:	b9400020 	ldr	w0, [x1]
    fd800000247c:	11000400 	add	w0, w0, #0x1
    fd8000002480:	889ffc20 	stlr	w0, [x1]
    fd8000002484:	d5033b9f 	dsb	ish
    fd8000002488:	d503209f 	sev
    fd800000248c:	d65f03c0 	ret
{
    fd8000002490:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
        ERROR("smmu ctx %d is already allocated", ctx_id);
    fd8000002494:	90000002 	adrp	x2, fd8000002000 <smmu_init+0x90>
    fd8000002498:	aa0003e1 	mov	x1, x0
{
    fd800000249c:	910003fd 	mov	x29, sp
        ERROR("smmu ctx %d is already allocated", ctx_id);
    fd80000024a0:	f9427840 	ldr	x0, [x2, #1264]
    fd80000024a4:	940026df 	bl	fd800000c020 <console_printk>
    fd80000024a8:	14000000 	b	fd80000024a8 <smmu_write_ctxbnk+0x138>
        tcr |= ((parange_table[parange] < 44) ? SMMUV2_TCR_SL0_1 : SMMUV2_TCR_SL0_0);
    fd80000024ac:	5286b007 	mov	w7, #0x3580                	// #13696
    fd80000024b0:	2a070000 	orr	w0, w0, w7
        smmu.hw.cntxt[ctx_id].TCR = tcr;
    fd80000024b4:	b90030a0 	str	w0, [x5, #48]
        if (t0sz >= 16 && t0sz <= 24) {
    fd80000024b8:	d2800600 	mov	x0, #0x30                  	// #48
    fd80000024bc:	cb040000 	sub	x0, x0, x4
            offset = 28 - t0sz;
    fd80000024c0:	d1009084 	sub	x4, x4, #0x24
        if (t0sz >= 16 && t0sz <= 24) {
    fd80000024c4:	f100201f 	cmp	x0, #0x8
    fd80000024c8:	54fffb49 	b.ls	fd8000002430 <smmu_write_ctxbnk+0xc0>  // b.plast
{
    fd80000024cc:	b2748fe0 	mov	x0, #0xfffffffff000        	// #281474976706560
    fd80000024d0:	17ffffde 	b	fd8000002448 <smmu_write_ctxbnk+0xd8>
    fd80000024d4:	d503201f 	nop
    fd80000024d8:	00013000 	.word	0x00013000
    fd80000024dc:	0000fd80 	.word	0x0000fd80
    fd80000024e0:	00012120 	.word	0x00012120
    fd80000024e4:	0000fd80 	.word	0x0000fd80
    fd80000024e8:	00012020 	.word	0x00012020
    fd80000024ec:	0000fd80 	.word	0x0000fd80
    fd80000024f0:	000102d8 	.word	0x000102d8
    fd80000024f4:	0000fd80 	.word	0x0000fd80
    fd80000024f8:	d503201f 	nop
    fd80000024fc:	d503201f 	nop

0000fd8000002500 <smmu_alloc_sme>:
    }
    spin_unlock(&smmu.ctx_lock);
}

ssize_t smmu_alloc_sme()
{
    fd8000002500:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    fd8000002504:	910003fd 	mov	x29, sp
    fd8000002508:	a90153f3 	stp	x19, x20, [sp, #16]
    __asm__ volatile(
    fd800000250c:	90000000 	adrp	x0, fd8000002000 <smmu_init+0x90>
    fd8000002510:	f942d013 	ldr	x19, [x0, #1440]
    fd8000002514:	91006263 	add	x3, x19, #0x18
    fd8000002518:	91007264 	add	x4, x19, #0x1c
    fd800000251c:	885ffc60 	ldaxr	w0, [x3]
    fd8000002520:	11000401 	add	w1, w0, #0x1
    fd8000002524:	88027c61 	stxr	w2, w1, [x3]
    fd8000002528:	35ffffa2 	cbnz	w2, fd800000251c <smmu_alloc_sme+0x1c>
    fd800000252c:	88dffc81 	ldar	w1, [x4]
    fd8000002530:	6b01001f 	cmp	w0, w1
    fd8000002534:	54000060 	b.eq	fd8000002540 <smmu_alloc_sme+0x40>  // b.none
    fd8000002538:	d503205f 	wfe
    fd800000253c:	17fffffc 	b	fd800000252c <smmu_alloc_sme+0x2c>
    spin_lock(&smmu.sme_lock);
    /* Find a free sme. */
    ssize_t nth = bitmap_find_nth(smmu.sme_bitmap, smmu.sme_num, 1, 0, false);
    fd8000002540:	f9401261 	ldr	x1, [x19, #32]
    fd8000002544:	9100a274 	add	x20, x19, #0x28
    fd8000002548:	aa1403e0 	mov	x0, x20
    fd800000254c:	52800004 	mov	w4, #0x0                   	// #0
    fd8000002550:	d2800003 	mov	x3, #0x0                   	// #0
    fd8000002554:	d2800022 	mov	x2, #0x1                   	// #1
    fd8000002558:	94001ae6 	bl	fd80000090f0 <bitmap_find_nth>
    if (nth >= 0) {
    fd800000255c:	b7f800e0 	tbnz	x0, #63, fd8000002578 <smmu_alloc_sme+0x78>
    map[bit / BITMAP_GRANULE_LEN] |= ONE << (bit % BITMAP_GRANULE_LEN);
    fd8000002560:	d345fc03 	lsr	x3, x0, #5
    fd8000002564:	52800022 	mov	w2, #0x1                   	// #1
    fd8000002568:	1ac02042 	lsl	w2, w2, w0
    fd800000256c:	b8637a81 	ldr	w1, [x20, x3, lsl #2]
    fd8000002570:	2a020021 	orr	w1, w1, w2
    fd8000002574:	b8237a81 	str	w1, [x20, x3, lsl #2]
    __asm__ volatile(
    fd8000002578:	91007262 	add	x2, x19, #0x1c
    fd800000257c:	b9400041 	ldr	w1, [x2]
    fd8000002580:	11000421 	add	w1, w1, #0x1
    fd8000002584:	889ffc41 	stlr	w1, [x2]
    fd8000002588:	d5033b9f 	dsb	ish
    fd800000258c:	d503209f 	sev
        bitmap_set(smmu.sme_bitmap, nth);
    }
    spin_unlock(&smmu.sme_lock);

    return nth;
}
    fd8000002590:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd8000002594:	a8c27bfd 	ldp	x29, x30, [sp], #32
    fd8000002598:	d65f03c0 	ret
    fd800000259c:	d503201f 	nop
    fd80000025a0:	00013000 	.word	0x00013000
    fd80000025a4:	0000fd80 	.word	0x0000fd80
    fd80000025a8:	d503201f 	nop
    fd80000025ac:	d503201f 	nop

0000fd80000025b0 <smmu_compatible_sme_exists>:
    __asm__ volatile(
    fd80000025b0:	90000004 	adrp	x4, fd8000002000 <smmu_init+0x90>
    fd80000025b4:	f9437c87 	ldr	x7, [x4, #1784]
    fd80000025b8:	910060e8 	add	x8, x7, #0x18
    fd80000025bc:	910070e9 	add	x9, x7, #0x1c
    fd80000025c0:	885ffd04 	ldaxr	w4, [x8]
    fd80000025c4:	11000485 	add	w5, w4, #0x1
    fd80000025c8:	88067d05 	stxr	w6, w5, [x8]
    fd80000025cc:	35ffffa6 	cbnz	w6, fd80000025c0 <smmu_compatible_sme_exists+0x10>
    fd80000025d0:	88dffd25 	ldar	w5, [x9]
    fd80000025d4:	6b05009f 	cmp	w4, w5
    fd80000025d8:	54000060 	b.eq	fd80000025e4 <smmu_compatible_sme_exists+0x34>  // b.none
    fd80000025dc:	d503205f 	wfe
    fd80000025e0:	17fffffc 	b	fd80000025d0 <smmu_compatible_sme_exists+0x20>
{
    bool included = false;
    size_t sme = 0;

    spin_lock(&smmu.sme_lock);
    smmu_for_each_sme(sme)
    fd80000025e4:	f94010ea 	ldr	x10, [x7, #32]
    return (map[bit / BITMAP_GRANULE_LEN] & (ONE << (bit % BITMAP_GRANULE_LEN))) ? 1U : 0U;
    fd80000025e8:	b94028e4 	ldr	w4, [x7, #40]
    fd80000025ec:	b400072a 	cbz	x10, fd80000026d0 <smmu_compatible_sme_exists+0x120>
    return SMMU_SMR_MASK(smmu.hw.glbl_rs0->SMR[sme]);
    fd80000025f0:	aa0703ec 	mov	x12, x7
    fd80000025f4:	12001c63 	and	w3, w3, #0xff
    fd80000025f8:	92400084 	and	x4, x4, #0x1
        streamid_t mask_r = mask & sme_mask;
        streamid_t diff_id = (smmu_sme_get_id(sme) ^ id) & ~(mask | sme_mask);

        if (!diff_id) {
            /* Only group-to-group or device-to-group can be merged */
            if (((group || smmu_sme_is_group(sme)) && (mask_r == mask || mask_r == sme_mask)) &&
    fd80000025fc:	1200006f 	and	w15, w3, #0x1
    map[bit / BITMAP_GRANULE_LEN] &= ~(ONE << (bit % BITMAP_GRANULE_LEN));
    fd8000002600:	52800028 	mov	w8, #0x1                   	// #1
    size_t sme = 0;
    fd8000002604:	d2800003 	mov	x3, #0x0                   	// #0
    return SMMU_SMR_MASK(smmu.hw.glbl_rs0->SMR[sme]);
    fd8000002608:	f842858b 	ldr	x11, [x12], #40
    fd800000260c:	d503201f 	nop
    fd8000002610:	8b030966 	add	x6, x11, x3, lsl #2
    smmu_for_each_sme(sme)
    fd8000002614:	b40004c4 	cbz	x4, fd80000026ac <smmu_compatible_sme_exists+0xfc>
    return SMMU_SMR_MASK(smmu.hw.glbl_rs0->SMR[sme]);
    fd8000002618:	b94800c5 	ldr	w5, [x6, #2048]
    return SMMU_SMR_ID(smmu.hw.glbl_rs0->SMR[sme]);
    fd800000261c:	b94800c4 	ldr	w4, [x6, #2048]
    fd8000002620:	d35078a5 	ubfx	x5, x5, #16, #15
    fd8000002624:	12003884 	and	w4, w4, #0x7fff
        streamid_t diff_id = (smmu_sme_get_id(sme) ^ id) & ~(mask | sme_mask);
    fd8000002628:	2a050009 	orr	w9, w0, w5
    fd800000262c:	4a010084 	eor	w4, w4, w1
        if (!diff_id) {
    fd8000002630:	6a29009f 	bics	wzr, w4, w9
    fd8000002634:	540003c1 	b.ne	fd80000026ac <smmu_compatible_sme_exists+0xfc>  // b.any
    return (map[bit / BITMAP_GRANULE_LEN] & (ONE << (bit % BITMAP_GRANULE_LEN))) ? 1U : 0U;
    fd8000002638:	d345fc64 	lsr	x4, x3, #5
    map[bit / BITMAP_GRANULE_LEN] &= ~(ONE << (bit % BITMAP_GRANULE_LEN));
    fd800000263c:	aa0403ed 	mov	x13, x4
            if (((group || smmu_sme_is_group(sme)) && (mask_r == mask || mask_r == sme_mask)) &&
    fd8000002640:	3500018f 	cbnz	w15, fd8000002670 <smmu_compatible_sme_exists+0xc0>
    return (map[bit / BITMAP_GRANULE_LEN] & (ONE << (bit % BITMAP_GRANULE_LEN))) ? 1U : 0U;
    fd8000002644:	8b0408e4 	add	x4, x7, x4, lsl #2
    fd8000002648:	1ac32109 	lsl	w9, w8, w3
    fd800000264c:	b940388e 	ldr	w14, [x4, #56]
    fd8000002650:	6a0e013f 	tst	w9, w14
    fd8000002654:	540000e1 	b.ne	fd8000002670 <smmu_compatible_sme_exists+0xc0>  // b.any
{
    fd8000002658:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    fd800000265c:	910003fd 	mov	x29, sp
                    included = true;
                    break;
                }

            } else {
                ERROR("SMMU sme conflict");
    fd8000002660:	90000000 	adrp	x0, fd8000002000 <smmu_init+0x90>
    fd8000002664:	f9438000 	ldr	x0, [x0, #1792]
    fd8000002668:	9400266e 	bl	fd800000c020 <console_printk>
    fd800000266c:	14000000 	b	fd800000266c <smmu_compatible_sme_exists+0xbc>
            if (((group || smmu_sme_is_group(sme)) && (mask_r == mask || mask_r == sme_mask)) &&
    fd8000002670:	6a25001f 	bics	wzr, w0, w5
    map[bit / BITMAP_GRANULE_LEN] &= ~(ONE << (bit % BITMAP_GRANULE_LEN));
    fd8000002674:	1ac32109 	lsl	w9, w8, w3
    fd8000002678:	1a9f17e4 	cset	w4, eq	// eq = none
    fd800000267c:	6a2000bf 	bics	wzr, w5, w0
    fd8000002680:	1a9f17ee 	cset	w14, eq	// eq = none
    fd8000002684:	2a0e0090 	orr	w16, w4, w14
    fd8000002688:	34fffe90 	cbz	w16, fd8000002658 <smmu_compatible_sme_exists+0xa8>
    return S2CR_CBNDX(smmu.hw.glbl_rs0->S2CR[sme]);
    fd800000268c:	b94c00c4 	ldr	w4, [x6, #3072]
            if (((group || smmu_sme_is_group(sme)) && (mask_r == mask || mask_r == sme_mask)) &&
    fd8000002690:	eb24005f 	cmp	x2, w4, uxtb
    fd8000002694:	54fffe21 	b.ne	fd8000002658 <smmu_compatible_sme_exists+0xa8>  // b.any
                if (mask > sme_mask) {
    fd8000002698:	6b05001f 	cmp	w0, w5
    fd800000269c:	540001c9 	b.ls	fd80000026d4 <smmu_compatible_sme_exists+0x124>  // b.plast
    fd80000026a0:	b86d7984 	ldr	w4, [x12, x13, lsl #2]
    fd80000026a4:	0a290089 	bic	w9, w4, w9
    fd80000026a8:	b82d7989 	str	w9, [x12, x13, lsl #2]
    smmu_for_each_sme(sme)
    fd80000026ac:	91000463 	add	x3, x3, #0x1
    return (map[bit / BITMAP_GRANULE_LEN] & (ONE << (bit % BITMAP_GRANULE_LEN))) ? 1U : 0U;
    fd80000026b0:	d345fc64 	lsr	x4, x3, #5
    fd80000026b4:	1ac32105 	lsl	w5, w8, w3
    fd80000026b8:	8b0408e4 	add	x4, x7, x4, lsl #2
    fd80000026bc:	b9402884 	ldr	w4, [x4, #40]
    fd80000026c0:	6a0400bf 	tst	w5, w4
    fd80000026c4:	9a9f07e4 	cset	x4, ne	// ne = any
    fd80000026c8:	eb0a007f 	cmp	x3, x10
    fd80000026cc:	54fffa21 	b.ne	fd8000002610 <smmu_compatible_sme_exists+0x60>  // b.any
    bool included = false;
    fd80000026d0:	52800010 	mov	w16, #0x0                   	// #0
    __asm__ volatile(
    fd80000026d4:	910070e1 	add	x1, x7, #0x1c
    fd80000026d8:	b9400020 	ldr	w0, [x1]
    fd80000026dc:	11000400 	add	w0, w0, #0x1
    fd80000026e0:	889ffc20 	stlr	w0, [x1]
    fd80000026e4:	d5033b9f 	dsb	ish
    fd80000026e8:	d503209f 	sev
        }
    }
    spin_unlock(&smmu.sme_lock);

    return included;
}
    fd80000026ec:	2a1003e0 	mov	w0, w16
    fd80000026f0:	d65f03c0 	ret
    fd80000026f4:	d503201f 	nop
    fd80000026f8:	00013000 	.word	0x00013000
    fd80000026fc:	0000fd80 	.word	0x0000fd80
    fd8000002700:	00010308 	.word	0x00010308
    fd8000002704:	0000fd80 	.word	0x0000fd80
    fd8000002708:	d503201f 	nop
    fd800000270c:	d503201f 	nop

0000fd8000002710 <smmu_write_sme>:
    __asm__ volatile(
    fd8000002710:	90000004 	adrp	x4, fd8000002000 <smmu_init+0x90>
    fd8000002714:	f943f084 	ldr	x4, [x4, #2016]
    fd8000002718:	91006088 	add	x8, x4, #0x18
    fd800000271c:	91007089 	add	x9, x4, #0x1c
    fd8000002720:	885ffd05 	ldaxr	w5, [x8]
    fd8000002724:	110004a6 	add	w6, w5, #0x1
    fd8000002728:	88077d06 	stxr	w7, w6, [x8]
    fd800000272c:	35ffffa7 	cbnz	w7, fd8000002720 <smmu_write_sme+0x10>
    fd8000002730:	88dffd26 	ldar	w6, [x9]
    fd8000002734:	6b0600bf 	cmp	w5, w6
    fd8000002738:	54000060 	b.eq	fd8000002744 <smmu_write_sme+0x34>  // b.none
    fd800000273c:	d503205f 	wfe
    fd8000002740:	17fffffc 	b	fd8000002730 <smmu_write_sme+0x20>
    fd8000002744:	d345fc06 	lsr	x6, x0, #5
    fd8000002748:	52800025 	mov	w5, #0x1                   	// #1
    fd800000274c:	1ac020a5 	lsl	w5, w5, w0
    fd8000002750:	8b060887 	add	x7, x4, x6, lsl #2
    fd8000002754:	b94028e7 	ldr	w7, [x7, #40]
    fd8000002758:	6a0700bf 	tst	w5, w7
    fd800000275c:	54000320 	b.eq	fd80000027c0 <smmu_write_sme+0xb0>  // b.none
{
    spin_lock(&smmu.sme_lock);
    if (!bitmap_get(smmu.sme_bitmap, sme)) {
        ERROR("smmu: trying to write unallocated sme %d", sme);
    } else {
        smmu.hw.glbl_rs0->SMR[sme] = mask << SMMU_SMR_MASK_OFF;
    fd8000002760:	f9400087 	ldr	x7, [x4]
    fd8000002764:	53103c21 	lsl	w1, w1, #16
        smmu.hw.glbl_rs0->SMR[sme] |= id & SMMU_ID_MSK;
    fd8000002768:	12003842 	and	w2, w2, #0x7fff
    fd800000276c:	12001c63 	and	w3, w3, #0xff
    fd8000002770:	8b0008e0 	add	x0, x7, x0, lsl #2
        smmu.hw.glbl_rs0->SMR[sme] = mask << SMMU_SMR_MASK_OFF;
    fd8000002774:	b9080001 	str	w1, [x0, #2048]
        smmu.hw.glbl_rs0->SMR[sme] |= id & SMMU_ID_MSK;
    fd8000002778:	b9480001 	ldr	w1, [x0, #2048]
    fd800000277c:	2a010042 	orr	w2, w2, w1
    fd8000002780:	b9080002 	str	w2, [x0, #2048]
        smmu.hw.glbl_rs0->SMR[sme] |= SMMUV2_SMR_VALID;
    fd8000002784:	b9480001 	ldr	w1, [x0, #2048]
    fd8000002788:	32010021 	orr	w1, w1, #0x80000000
    fd800000278c:	b9080001 	str	w1, [x0, #2048]

        if (group) {
    fd8000002790:	360000a3 	tbz	w3, #0, fd80000027a4 <smmu_write_sme+0x94>
    map[bit / BITMAP_GRANULE_LEN] |= ONE << (bit % BITMAP_GRANULE_LEN);
    fd8000002794:	9100e081 	add	x1, x4, #0x38
    fd8000002798:	b8667820 	ldr	w0, [x1, x6, lsl #2]
    fd800000279c:	2a050000 	orr	w0, w0, w5
    fd80000027a0:	b8267820 	str	w0, [x1, x6, lsl #2]
    __asm__ volatile(
    fd80000027a4:	91007081 	add	x1, x4, #0x1c
    fd80000027a8:	b9400020 	ldr	w0, [x1]
    fd80000027ac:	11000400 	add	w0, w0, #0x1
    fd80000027b0:	889ffc20 	stlr	w0, [x1]
    fd80000027b4:	d5033b9f 	dsb	ish
    fd80000027b8:	d503209f 	sev
    fd80000027bc:	d65f03c0 	ret
{
    fd80000027c0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
        ERROR("smmu: trying to write unallocated sme %d", sme);
    fd80000027c4:	90000002 	adrp	x2, fd8000002000 <smmu_init+0x90>
    fd80000027c8:	aa0003e1 	mov	x1, x0
{
    fd80000027cc:	910003fd 	mov	x29, sp
        ERROR("smmu: trying to write unallocated sme %d", sme);
    fd80000027d0:	f943f440 	ldr	x0, [x2, #2024]
    fd80000027d4:	94002613 	bl	fd800000c020 <console_printk>
    fd80000027d8:	14000000 	b	fd80000027d8 <smmu_write_sme+0xc8>
    fd80000027dc:	d503201f 	nop
    fd80000027e0:	00013000 	.word	0x00013000
    fd80000027e4:	0000fd80 	.word	0x0000fd80
    fd80000027e8:	00010328 	.word	0x00010328
    fd80000027ec:	0000fd80 	.word	0x0000fd80

0000fd80000027f0 <smmu_write_s2c>:
    }
    spin_unlock(&smmu.sme_lock);
}

void smmu_write_s2c(size_t sme, size_t ctx_id)
{
    fd80000027f0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    fd80000027f4:	910003fd 	mov	x29, sp
    __asm__ volatile(
    fd80000027f8:	90000002 	adrp	x2, fd8000002000 <smmu_init+0x90>
    fd80000027fc:	f9446442 	ldr	x2, [x2, #2248]
    fd8000002800:	91006047 	add	x7, x2, #0x18
    fd8000002804:	91007048 	add	x8, x2, #0x1c
    fd8000002808:	885ffce4 	ldaxr	w4, [x7]
    fd800000280c:	11000485 	add	w5, w4, #0x1
    fd8000002810:	88067ce5 	stxr	w6, w5, [x7]
    fd8000002814:	35ffffa6 	cbnz	w6, fd8000002808 <smmu_write_s2c+0x18>
    fd8000002818:	88dffd05 	ldar	w5, [x8]
    fd800000281c:	6b05009f 	cmp	w4, w5
    fd8000002820:	54000060 	b.eq	fd800000282c <smmu_write_s2c+0x3c>  // b.none
    fd8000002824:	d503205f 	wfe
    fd8000002828:	17fffffc 	b	fd8000002818 <smmu_write_s2c+0x28>
    return (map[bit / BITMAP_GRANULE_LEN] & (ONE << (bit % BITMAP_GRANULE_LEN))) ? 1U : 0U;
    fd800000282c:	d345fc24 	lsr	x4, x1, #5
    fd8000002830:	52800025 	mov	w5, #0x1                   	// #1
    fd8000002834:	1ac120a6 	lsl	w6, w5, w1
    fd8000002838:	8b040844 	add	x4, x2, x4, lsl #2
    fd800000283c:	b9405884 	ldr	w4, [x4, #88]
    fd8000002840:	6a0400df 	tst	w6, w4
    fd8000002844:	540002e0 	b.eq	fd80000028a0 <smmu_write_s2c+0xb0>  // b.none
    fd8000002848:	aa0103e3 	mov	x3, x1
    fd800000284c:	d345fc01 	lsr	x1, x0, #5
    fd8000002850:	1ac020a5 	lsl	w5, w5, w0
    fd8000002854:	8b010841 	add	x1, x2, x1, lsl #2
    fd8000002858:	b9402821 	ldr	w1, [x1, #40]
    fd800000285c:	6a0100bf 	tst	w5, w1
    fd8000002860:	54000280 	b.eq	fd80000028b0 <smmu_write_s2c+0xc0>  // b.none
        ERROR("smmu: trying to write unallocated s2c %d", ctx_id);
    } else if (!bitmap_get(smmu.sme_bitmap, sme)) {
        ERROR("smmu: trying to bind unallocated sme %d", sme);
    } else {
        /* Initial contex is a translation context. */
        uint32_t s2cr = smmu.hw.glbl_rs0->S2CR[sme];
    fd8000002864:	f9400041 	ldr	x1, [x2]

        s2cr = S2CR_CLEAR(s2cr);
        s2cr |= S2CR_DFLT;
        s2cr |= ctx_id & S2CR_CBNDX_MASK;
    fd8000002868:	12001c63 	and	w3, w3, #0xff
    fd800000286c:	8b000821 	add	x1, x1, x0, lsl #2
        uint32_t s2cr = smmu.hw.glbl_rs0->S2CR[sme];
    fd8000002870:	b94c0020 	ldr	w0, [x1, #3072]
        s2cr = S2CR_CLEAR(s2cr);
    fd8000002874:	12020400 	and	w0, w0, #0xc0000000
        s2cr |= ctx_id & S2CR_CBNDX_MASK;
    fd8000002878:	2a000060 	orr	w0, w3, w0

        smmu.hw.glbl_rs0->S2CR[sme] = s2cr;
    fd800000287c:	b90c0020 	str	w0, [x1, #3072]
    __asm__ volatile(
    fd8000002880:	91007041 	add	x1, x2, #0x1c
    fd8000002884:	b9400020 	ldr	w0, [x1]
    fd8000002888:	11000400 	add	w0, w0, #0x1
    fd800000288c:	889ffc20 	stlr	w0, [x1]
    fd8000002890:	d5033b9f 	dsb	ish
    fd8000002894:	d503209f 	sev
    }
    spin_unlock(&smmu.sme_lock);
}
    fd8000002898:	a8c17bfd 	ldp	x29, x30, [sp], #16
    fd800000289c:	d65f03c0 	ret
        ERROR("smmu: trying to write unallocated s2c %d", ctx_id);
    fd80000028a0:	90000000 	adrp	x0, fd8000002000 <smmu_init+0x90>
    fd80000028a4:	f9446800 	ldr	x0, [x0, #2256]
    fd80000028a8:	940025de 	bl	fd800000c020 <console_printk>
    fd80000028ac:	14000000 	b	fd80000028ac <smmu_write_s2c+0xbc>
        ERROR("smmu: trying to bind unallocated sme %d", sme);
    fd80000028b0:	90000002 	adrp	x2, fd8000002000 <smmu_init+0x90>
    fd80000028b4:	aa0003e1 	mov	x1, x0
    fd80000028b8:	f9446c40 	ldr	x0, [x2, #2264]
    fd80000028bc:	940025d9 	bl	fd800000c020 <console_printk>
    fd80000028c0:	14000000 	b	fd80000028c0 <smmu_write_s2c+0xd0>
    fd80000028c4:	d503201f 	nop
    fd80000028c8:	00013000 	.word	0x00013000
    fd80000028cc:	0000fd80 	.word	0x0000fd80
    fd80000028d0:	00010360 	.word	0x00010360
    fd80000028d4:	0000fd80 	.word	0x0000fd80
    fd80000028d8:	00010398 	.word	0x00010398
    fd80000028dc:	0000fd80 	.word	0x0000fd80

0000fd80000028e0 <iommu_vm_arch_add>:
    /* Ctx is valid when we get here. */
    return ctx_id;
}

static bool iommu_vm_arch_add(struct vm* vm, streamid_t mask, streamid_t id)
{
    fd80000028e0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    fd80000028e4:	910003fd 	mov	x29, sp
    fd80000028e8:	a9025bf5 	stp	x21, x22, [sp, #32]
    fd80000028ec:	aa0003f5 	mov	x21, x0
    ssize_t ctx_id = vm->io.prot.mmu.ctx_id;
    fd80000028f0:	f940c816 	ldr	x22, [x0, #400]
{
    fd80000028f4:	a90153f3 	stp	x19, x20, [sp, #16]
    fd80000028f8:	2a0103f3 	mov	w19, w1
    fd80000028fc:	f9001bf7 	str	x23, [sp, #48]
    fd8000002900:	2a0203f4 	mov	w20, w2
    if (ctx_id < 0) {
    fd8000002904:	b7f80276 	tbnz	x22, #63, fd8000002950 <iommu_vm_arch_add+0x70>
    ssize_t vm_ctx = iommu_vm_arch_init_ctx(vm);
    streamid_t glbl_mask = vm->io.prot.mmu.global_mask;
    streamid_t prep_mask = (mask & SMMU_ID_MSK) | glbl_mask;
    streamid_t prep_id = (id & SMMU_ID_MSK);
    bool group = (bool)mask;
    fd8000002908:	7100003f 	cmp	w1, #0x0
    streamid_t prep_mask = (mask & SMMU_ID_MSK) | glbl_mask;
    fd800000290c:	b9418800 	ldr	w0, [x0, #392]
    fd8000002910:	12003833 	and	w19, w1, #0x7fff
    streamid_t prep_id = (id & SMMU_ID_MSK);
    fd8000002914:	12003854 	and	w20, w2, #0x7fff
    bool group = (bool)mask;
    fd8000002918:	1a9f07f7 	cset	w23, ne	// ne = any
    streamid_t prep_mask = (mask & SMMU_ID_MSK) | glbl_mask;
    fd800000291c:	2a000273 	orr	w19, w19, w0

    if (vm_ctx < 0) {
        return false;
    }

    if (!smmu_compatible_sme_exists(prep_mask, prep_id, vm_ctx, group)) {
    fd8000002920:	2a1703e3 	mov	w3, w23
    fd8000002924:	aa1603e2 	mov	x2, x22
    fd8000002928:	2a1403e1 	mov	w1, w20
    fd800000292c:	2a1303e0 	mov	w0, w19
    fd8000002930:	97ffff20 	bl	fd80000025b0 <smmu_compatible_sme_exists>
    fd8000002934:	36000420 	tbz	w0, #0, fd80000029b8 <iommu_vm_arch_add+0xd8>
        }
        smmu_write_sme(sme, prep_mask, prep_id, group);
        smmu_write_s2c(sme, vm_ctx);
    }

    return true;
    fd8000002938:	52800020 	mov	w0, #0x1                   	// #1
}
    fd800000293c:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd8000002940:	a9425bf5 	ldp	x21, x22, [sp, #32]
    fd8000002944:	f9401bf7 	ldr	x23, [sp, #48]
    fd8000002948:	a8c57bfd 	ldp	x29, x30, [sp], #80
    fd800000294c:	d65f03c0 	ret
        ctx_id = smmu_alloc_ctxbnk();
    fd8000002950:	97fffe5c 	bl	fd80000022c0 <smmu_alloc_ctxbnk>
    fd8000002954:	aa0003f6 	mov	x22, x0
        if (ctx_id >= 0) {
    fd8000002958:	b7f80460 	tbnz	x0, #63, fd80000029e4 <iommu_vm_arch_add+0x104>
            mem_translate(&cpu()->as, (vaddr_t)vm->as.pt.root, &rootpt);
    fd800000295c:	f9402ea1 	ldr	x1, [x21, #88]
    fd8000002960:	d2800200 	mov	x0, #0x10                  	// #16
    fd8000002964:	910123e2 	add	x2, sp, #0x48
    fd8000002968:	f2dfc000 	movk	x0, #0xfe00, lsl #32
    streamid_t prep_id = (id & SMMU_ID_MSK);
    fd800000296c:	12003a94 	and	w20, w20, #0x7fff
            mem_translate(&cpu()->as, (vaddr_t)vm->as.pt.root, &rootpt);
    fd8000002970:	97fffc80 	bl	fd8000001b70 <mem_translate>
            smmu_write_ctxbnk(ctx_id, rootpt, vm->id);
    fd8000002974:	f94002a2 	ldr	x2, [x21]
    fd8000002978:	aa1603e0 	mov	x0, x22
    fd800000297c:	f94027e1 	ldr	x1, [sp, #72]
    fd8000002980:	97fffe7c 	bl	fd8000002370 <smmu_write_ctxbnk>
            vm->io.prot.mmu.ctx_id = ctx_id;
    fd8000002984:	f900cab6 	str	x22, [x21, #400]
    bool group = (bool)mask;
    fd8000002988:	7100027f 	cmp	w19, #0x0
    streamid_t prep_mask = (mask & SMMU_ID_MSK) | glbl_mask;
    fd800000298c:	b9418aa0 	ldr	w0, [x21, #392]
    fd8000002990:	12003a73 	and	w19, w19, #0x7fff
    bool group = (bool)mask;
    fd8000002994:	1a9f07f7 	cset	w23, ne	// ne = any
    streamid_t prep_mask = (mask & SMMU_ID_MSK) | glbl_mask;
    fd8000002998:	2a000273 	orr	w19, w19, w0
    if (!smmu_compatible_sme_exists(prep_mask, prep_id, vm_ctx, group)) {
    fd800000299c:	2a1703e3 	mov	w3, w23
    fd80000029a0:	aa1603e2 	mov	x2, x22
    fd80000029a4:	2a1403e1 	mov	w1, w20
    fd80000029a8:	2a1303e0 	mov	w0, w19
    fd80000029ac:	97ffff01 	bl	fd80000025b0 <smmu_compatible_sme_exists>
    fd80000029b0:	3707fc40 	tbnz	w0, #0, fd8000002938 <iommu_vm_arch_add+0x58>
    fd80000029b4:	d503201f 	nop
        ssize_t sme = smmu_alloc_sme();
    fd80000029b8:	97fffed2 	bl	fd8000002500 <smmu_alloc_sme>
    fd80000029bc:	aa0003f5 	mov	x21, x0
        if (sme < 0) {
    fd80000029c0:	b7f801e0 	tbnz	x0, #63, fd80000029fc <iommu_vm_arch_add+0x11c>
        smmu_write_sme(sme, prep_mask, prep_id, group);
    fd80000029c4:	2a1703e3 	mov	w3, w23
    fd80000029c8:	2a1403e2 	mov	w2, w20
    fd80000029cc:	2a1303e1 	mov	w1, w19
    fd80000029d0:	97ffff50 	bl	fd8000002710 <smmu_write_sme>
        smmu_write_s2c(sme, vm_ctx);
    fd80000029d4:	aa1603e1 	mov	x1, x22
    fd80000029d8:	aa1503e0 	mov	x0, x21
    fd80000029dc:	97ffff85 	bl	fd80000027f0 <smmu_write_s2c>
    fd80000029e0:	17ffffd6 	b	fd8000002938 <iommu_vm_arch_add+0x58>
            INFO("iommu: smmuv2 could not allocate ctx for vm: %d", vm->id);
    fd80000029e4:	f94002a1 	ldr	x1, [x21]
    fd80000029e8:	90000000 	adrp	x0, fd8000002000 <smmu_init+0x90>
    fd80000029ec:	f9450800 	ldr	x0, [x0, #2576]
    fd80000029f0:	9400258c 	bl	fd800000c020 <console_printk>
        return false;
    fd80000029f4:	52800000 	mov	w0, #0x0                   	// #0
    fd80000029f8:	17ffffd1 	b	fd800000293c <iommu_vm_arch_add+0x5c>
            INFO("iommu: smmuv2 no more free sme available.");
    fd80000029fc:	90000000 	adrp	x0, fd8000002000 <smmu_init+0x90>
    fd8000002a00:	f9450c00 	ldr	x0, [x0, #2584]
    fd8000002a04:	94002587 	bl	fd800000c020 <console_printk>
        return false;
    fd8000002a08:	52800000 	mov	w0, #0x0                   	// #0
    fd8000002a0c:	17ffffcc 	b	fd800000293c <iommu_vm_arch_add+0x5c>
    fd8000002a10:	000103d0 	.word	0x000103d0
    fd8000002a14:	0000fd80 	.word	0x0000fd80
    fd8000002a18:	00010410 	.word	0x00010410
    fd8000002a1c:	0000fd80 	.word	0x0000fd80

0000fd8000002a20 <iommu_arch_init>:
    if (cpu()->id == CPU_MASTER && platform.arch.smmu.base) {
    fd8000002a20:	90000000 	adrp	x0, fd8000002000 <smmu_init+0x90>
    fd8000002a24:	f9453801 	ldr	x1, [x0, #2672]
    fd8000002a28:	d2dfc002 	mov	x2, #0xfe0000000000        	// #279275953455104
    return false;
    fd8000002a2c:	52800000 	mov	w0, #0x0                   	// #0
    if (cpu()->id == CPU_MASTER && platform.arch.smmu.base) {
    fd8000002a30:	f9400042 	ldr	x2, [x2]
    fd8000002a34:	f9400021 	ldr	x1, [x1]
    fd8000002a38:	eb01005f 	cmp	x2, x1
    fd8000002a3c:	54000040 	b.eq	fd8000002a44 <iommu_arch_init+0x24>  // b.none
}
    fd8000002a40:	d65f03c0 	ret
    if (cpu()->id == CPU_MASTER && platform.arch.smmu.base) {
    fd8000002a44:	90000001 	adrp	x1, fd8000002000 <smmu_init+0x90>
    fd8000002a48:	f9453c21 	ldr	x1, [x1, #2680]
    fd8000002a4c:	f9412821 	ldr	x1, [x1, #592]
    fd8000002a50:	b4ffff81 	cbz	x1, fd8000002a40 <iommu_arch_init+0x20>
{
    fd8000002a54:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    fd8000002a58:	910003fd 	mov	x29, sp
        smmu_init();
    fd8000002a5c:	97fffd45 	bl	fd8000001f70 <smmu_init>
        return true;
    fd8000002a60:	52800020 	mov	w0, #0x1                   	// #1
}
    fd8000002a64:	a8c17bfd 	ldp	x29, x30, [sp], #16
    fd8000002a68:	d65f03c0 	ret
    fd8000002a6c:	d503201f 	nop
    fd8000002a70:	00012348 	.word	0x00012348
    fd8000002a74:	0000fd80 	.word	0x0000fd80
    fd8000002a78:	00012930 	.word	0x00012930
    fd8000002a7c:	0000fd80 	.word	0x0000fd80

0000fd8000002a80 <iommu_arch_vm_add_device>:

inline bool iommu_arch_vm_add_device(struct vm* vm, streamid_t id)
{
    fd8000002a80:	2a0103e2 	mov	w2, w1
    return iommu_vm_arch_add(vm, 0, id);
    fd8000002a84:	52800001 	mov	w1, #0x0                   	// #0
    fd8000002a88:	17ffff96 	b	fd80000028e0 <iommu_vm_arch_add>
    fd8000002a8c:	d503201f 	nop

0000fd8000002a90 <iommu_arch_vm_init>:
}

bool iommu_arch_vm_init(struct vm* vm, const struct vm_config* config)
{
    fd8000002a90:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    vm->io.prot.mmu.global_mask =
        config->platform.arch.smmu.global_mask | platform.arch.smmu.global_mask;
    vm->io.prot.mmu.ctx_id = -1;
    fd8000002a94:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
{
    fd8000002a98:	910003fd 	mov	x29, sp
        config->platform.arch.smmu.global_mask | platform.arch.smmu.global_mask;
    fd8000002a9c:	90000002 	adrp	x2, fd8000002000 <smmu_init+0x90>
    fd8000002aa0:	f945a042 	ldr	x2, [x2, #2880]
{
    fd8000002aa4:	a9025bf5 	stp	x21, x22, [sp, #32]
    fd8000002aa8:	aa0003f6 	mov	x22, x0
    fd8000002aac:	aa0103f5 	mov	x21, x1
        config->platform.arch.smmu.global_mask | platform.arch.smmu.global_mask;
    fd8000002ab0:	b9409820 	ldr	w0, [x1, #152]

    /* This section relates only to arm's iommu so we parse it here. */
    for (size_t i = 0; i < config->platform.arch.smmu.group_num; i++) {
    fd8000002ab4:	f9405021 	ldr	x1, [x1, #160]
        config->platform.arch.smmu.global_mask | platform.arch.smmu.global_mask;
    fd8000002ab8:	b9425c42 	ldr	w2, [x2, #604]
    vm->io.prot.mmu.ctx_id = -1;
    fd8000002abc:	f900cac3 	str	x3, [x22, #400]
        config->platform.arch.smmu.global_mask | platform.arch.smmu.global_mask;
    fd8000002ac0:	2a020000 	orr	w0, w0, w2
    vm->io.prot.mmu.global_mask =
    fd8000002ac4:	b9018ac0 	str	w0, [x22, #392]
    for (size_t i = 0; i < config->platform.arch.smmu.group_num; i++) {
    fd8000002ac8:	b4000301 	cbz	x1, fd8000002b28 <iommu_arch_vm_init+0x98>
    fd8000002acc:	a90153f3 	stp	x19, x20, [sp, #16]
    fd8000002ad0:	d2800013 	mov	x19, #0x0                   	// #0
    fd8000002ad4:	d2800014 	mov	x20, #0x0                   	// #0
    fd8000002ad8:	14000005 	b	fd8000002aec <iommu_arch_vm_init+0x5c>
    fd8000002adc:	f94052a1 	ldr	x1, [x21, #160]
    fd8000002ae0:	91002273 	add	x19, x19, #0x8
    fd8000002ae4:	eb14003f 	cmp	x1, x20
    fd8000002ae8:	540001e9 	b.ls	fd8000002b24 <iommu_arch_vm_init+0x94>  // b.plast
        /* Register each group. */
        const struct smmu_group* group = &config->platform.arch.smmu.groups[i];
    fd8000002aec:	f94056a2 	ldr	x2, [x21, #168]
        if (!iommu_vm_arch_add(vm, group->mask, group->id)) {
    fd8000002af0:	aa1603e0 	mov	x0, x22
    for (size_t i = 0; i < config->platform.arch.smmu.group_num; i++) {
    fd8000002af4:	91000694 	add	x20, x20, #0x1
        const struct smmu_group* group = &config->platform.arch.smmu.groups[i];
    fd8000002af8:	8b130043 	add	x3, x2, x19
        if (!iommu_vm_arch_add(vm, group->mask, group->id)) {
    fd8000002afc:	b8736841 	ldr	w1, [x2, x19]
    fd8000002b00:	b9400462 	ldr	w2, [x3, #4]
    fd8000002b04:	97ffff77 	bl	fd80000028e0 <iommu_vm_arch_add>
    fd8000002b08:	12001c01 	and	w1, w0, #0xff
    fd8000002b0c:	3707fe80 	tbnz	w0, #0, fd8000002adc <iommu_arch_vm_init+0x4c>
    fd8000002b10:	a94153f3 	ldp	x19, x20, [sp, #16]
            return false;
        }
    }

    return true;
}
    fd8000002b14:	2a0103e0 	mov	w0, w1
    fd8000002b18:	a9425bf5 	ldp	x21, x22, [sp, #32]
    fd8000002b1c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    fd8000002b20:	d65f03c0 	ret
    fd8000002b24:	a94153f3 	ldp	x19, x20, [sp, #16]
    return true;
    fd8000002b28:	52800021 	mov	w1, #0x1                   	// #1
}
    fd8000002b2c:	a9425bf5 	ldp	x21, x22, [sp, #32]
    fd8000002b30:	2a0103e0 	mov	w0, w1
    fd8000002b34:	a8c37bfd 	ldp	x29, x30, [sp], #48
    fd8000002b38:	d65f03c0 	ret
    fd8000002b3c:	d503201f 	nop
    fd8000002b40:	00012930 	.word	0x00012930
    fd8000002b44:	0000fd80 	.word	0x0000fd80
	...

0000fd8000002b50 <cpu_arch_profile_init>:
#include <platform.h>
#include <arch/psci.h>
#include <arch/sysregs.h>

void cpu_arch_profile_init(cpuid_t cpuid, paddr_t load_addr)
{
    fd8000002b50:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    fd8000002b54:	910003fd 	mov	x29, sp
    if (cpuid == CPU_MASTER) {
    fd8000002b58:	90000002 	adrp	x2, fd8000002000 <smmu_init+0x90>
    fd8000002b5c:	f9460042 	ldr	x2, [x2, #3072]
{
    fd8000002b60:	a90153f3 	stp	x19, x20, [sp, #16]
    fd8000002b64:	aa0003f4 	mov	x20, x0
    if (cpuid == CPU_MASTER) {
    fd8000002b68:	f9400040 	ldr	x0, [x2]
    fd8000002b6c:	eb14001f 	cmp	x0, x20
    fd8000002b70:	54000080 	b.eq	fd8000002b80 <cpu_arch_profile_init+0x30>  // b.none
            if (!(result == PSCI_E_SUCCESS || result == PSCI_E_ALREADY_ON)) {
                ERROR("cant wake up cpu %d", cpu_core_id);
            }
        }
    }
}
    fd8000002b74:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd8000002b78:	a8c37bfd 	ldp	x29, x30, [sp], #48
    fd8000002b7c:	d65f03c0 	ret
        for (size_t cpu_core_id = 0; cpu_core_id < platform.cpu_num; cpu_core_id++) {
    fd8000002b80:	a9025bf5 	stp	x21, x22, [sp, #32]
    fd8000002b84:	90000000 	adrp	x0, fd8000002000 <smmu_init+0x90>
    fd8000002b88:	f9460416 	ldr	x22, [x0, #3080]
    fd8000002b8c:	f94002c0 	ldr	x0, [x22]
    fd8000002b90:	b4000240 	cbz	x0, fd8000002bd8 <cpu_arch_profile_init+0x88>
    fd8000002b94:	aa0103f5 	mov	x21, x1
    fd8000002b98:	d2800013 	mov	x19, #0x0                   	// #0
    fd8000002b9c:	d503201f 	nop
            unsigned long mpidr = cpu_id_to_mpidr(cpu_core_id);
    fd8000002ba0:	aa1303e0 	mov	x0, x19
            if (cpu_core_id == cpuid) {
    fd8000002ba4:	eb13029f 	cmp	x20, x19
    fd8000002ba8:	54000100 	b.eq	fd8000002bc8 <cpu_arch_profile_init+0x78>  // b.none
            unsigned long mpidr = cpu_id_to_mpidr(cpu_core_id);
    fd8000002bac:	940003c9 	bl	fd8000003ad0 <cpu_id_to_mpidr>
            int32_t result = psci_cpu_on(mpidr, load_addr, 0);
    fd8000002bb0:	d2800002 	mov	x2, #0x0                   	// #0
    fd8000002bb4:	aa1503e1 	mov	x1, x21
    fd8000002bb8:	97fffcb2 	bl	fd8000001e80 <psci_cpu_on>
            if (!(result == PSCI_E_SUCCESS || result == PSCI_E_ALREADY_ON)) {
    fd8000002bbc:	11001002 	add	w2, w0, #0x4
    fd8000002bc0:	721d785f 	tst	w2, #0xfffffffb
    fd8000002bc4:	54000121 	b.ne	fd8000002be8 <cpu_arch_profile_init+0x98>  // b.any
        for (size_t cpu_core_id = 0; cpu_core_id < platform.cpu_num; cpu_core_id++) {
    fd8000002bc8:	f94002c0 	ldr	x0, [x22]
    fd8000002bcc:	91000673 	add	x19, x19, #0x1
    fd8000002bd0:	eb13001f 	cmp	x0, x19
    fd8000002bd4:	54fffe68 	b.hi	fd8000002ba0 <cpu_arch_profile_init+0x50>  // b.pmore
}
    fd8000002bd8:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd8000002bdc:	a9425bf5 	ldp	x21, x22, [sp, #32]
    fd8000002be0:	a8c37bfd 	ldp	x29, x30, [sp], #48
    fd8000002be4:	d65f03c0 	ret
                ERROR("cant wake up cpu %d", cpu_core_id);
    fd8000002be8:	90000000 	adrp	x0, fd8000002000 <smmu_init+0x90>
    fd8000002bec:	aa1303e1 	mov	x1, x19
    fd8000002bf0:	f9460800 	ldr	x0, [x0, #3088]
    fd8000002bf4:	9400250b 	bl	fd800000c020 <console_printk>
    fd8000002bf8:	14000000 	b	fd8000002bf8 <cpu_arch_profile_init+0xa8>
    fd8000002bfc:	d503201f 	nop
    fd8000002c00:	00012348 	.word	0x00012348
    fd8000002c04:	0000fd80 	.word	0x0000fd80
    fd8000002c08:	00012930 	.word	0x00012930
    fd8000002c0c:	0000fd80 	.word	0x0000fd80
    fd8000002c10:	00010448 	.word	0x00010448
    fd8000002c14:	0000fd80 	.word	0x0000fd80
    fd8000002c18:	d503201f 	nop
    fd8000002c1c:	d503201f 	nop

0000fd8000002c20 <cpu_arch_profile_idle>:

void cpu_arch_profile_idle()
{
    fd8000002c20:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    int64_t err = psci_power_down(PSCI_WAKEUP_IDLE);
    fd8000002c24:	52800040 	mov	w0, #0x2                   	// #2
{
    fd8000002c28:	910003fd 	mov	x29, sp
    int64_t err = psci_power_down(PSCI_WAKEUP_IDLE);
    fd8000002c2c:	97fffc4d 	bl	fd8000001d60 <psci_power_down>
    if (err) {
    fd8000002c30:	340000a0 	cbz	w0, fd8000002c44 <cpu_arch_profile_idle+0x24>
    fd8000002c34:	93407c02 	sxtw	x2, w0
        switch (err) {
    fd8000002c38:	b100045f 	cmn	x2, #0x1
    fd8000002c3c:	54000081 	b.ne	fd8000002c4c <cpu_arch_profile_idle+0x2c>  // b.any
            case PSCI_E_NOT_SUPPORTED:
                /**
                 * If power down is not supported let's just wait for an interrupt
                 */
                asm volatile("wfi");
    fd8000002c40:	d503207f 	wfi

    /**
     * Power down was sucessful but did not jump to requested entry point. Just return to the
     * architectural
     */
}
    fd8000002c44:	a8c17bfd 	ldp	x29, x30, [sp], #16
    fd8000002c48:	d65f03c0 	ret
                ERROR("PSCI cpu%d power down failed with error %ld", cpu()->id, err);
    fd8000002c4c:	d2dfc001 	mov	x1, #0xfe0000000000        	// #279275953455104
    fd8000002c50:	90000000 	adrp	x0, fd8000002000 <smmu_init+0x90>
    fd8000002c54:	f9463400 	ldr	x0, [x0, #3176]
    fd8000002c58:	f9400021 	ldr	x1, [x1]
    fd8000002c5c:	940024f1 	bl	fd800000c020 <console_printk>
    fd8000002c60:	14000000 	b	fd8000002c60 <cpu_arch_profile_idle+0x40>
    fd8000002c64:	d503201f 	nop
    fd8000002c68:	00010468 	.word	0x00010468
    fd8000002c6c:	0000fd80 	.word	0x0000fd80

0000fd8000002c70 <smc_call>:
    register unsigned long r0 asm(GPR(0)) = x0;
    register unsigned long r1 asm(GPR(1)) = x1;
    register unsigned long r2 asm(GPR(2)) = x2;
    register unsigned long r3 asm(GPR(3)) = x3;

    asm volatile("smc	#0\n" : "=r"(r0) : "r"(r0), "r"(r1), "r"(r2), "r"(r3));
    fd8000002c70:	d4000003 	smc	#0x0

    if (res != NULL) {
    fd8000002c74:	b4000064 	cbz	x4, fd8000002c80 <smc_call+0x10>
        res->x0 = r0;
        res->x1 = r1;
    fd8000002c78:	a9000480 	stp	x0, x1, [x4]
        res->x2 = r2;
        res->x3 = r3;
    fd8000002c7c:	a9010c82 	stp	x2, x3, [x4, #16]
    }

    return r0;
}
    fd8000002c80:	d65f03c0 	ret
    fd8000002c84:	00000000 	udf	#0

0000fd8000002c88 <memcpy>:
 *      x5: size
 *      x0: destination address
 *      x7: source address
 */
memcpy:
        mov x4, #0
    fd8000002c88:	d2800004 	mov	x4, #0x0                   	// #0
1:
        /* Copy two words */
        ldp x2, x3, [x7]
    fd8000002c8c:	a9400ce2 	ldp	x2, x3, [x7]
        stp x2, x3, [x0]
    fd8000002c90:	a9000c02 	stp	x2, x3, [x0]

        /* Increment addressess and count accordingly */
        add x7, x7, 8
    fd8000002c94:	910020e7 	add	x7, x7, #0x8
        add x0, x0, 8
    fd8000002c98:	91002000 	add	x0, x0, #0x8
        add x4, x4, 8
    fd8000002c9c:	91002084 	add	x4, x4, #0x8

        /* If count is less then size, repeat */
        cmp x4, x5
    fd8000002ca0:	eb05009f 	cmp	x4, x5
        b.le 1b
    fd8000002ca4:	54ffff4d 	b.le	fd8000002c8c <memcpy+0x4>

        /* Restore original addresses */
        sub x7, x7, x4
    fd8000002ca8:	cb0400e7 	sub	x7, x7, x4
        sub x0, x0, x4
    fd8000002cac:	cb040000 	sub	x0, x0, x4

        ret
    fd8000002cb0:	d65f03c0 	ret

0000fd8000002cb4 <switch_space>:
switch_space:
        
    /**
    * update flat maping page table entry  to feature new physical address space entry page
    */
    adr x3, _image_start
    fd8000002cb4:	10fe9a63 	adr	x3, fd8000000000 <_el2_entry>
    PTE_INDEX_ASM x4, x3, 1
    fd8000002cb8:	d35efc64 	lsr	x4, x3, #30
    fd8000002cbc:	92402084 	and	x4, x4, #0x1ff
    fd8000002cc0:	d37df084 	lsl	x4, x4, #3
    adr x5, root_l1_flat_pt
    fd8000002cc4:	100e19e5 	adr	x5, fd800001f000 <root_l1_flat_pt>
    add x3, x3, #(PTE_HYP_FLAGS | PTE_TABLE)
    fd8000002cc8:	911d1c63 	add	x3, x3, #0x747
    str x3, [x5, x4]
    fd8000002ccc:	f82468a3 	str	x3, [x5, x4]
    /**
     * Copy the stack
     */

    /* Get current CPU space stack start */
    ldr x7, =BAO_CPU_BASE
    fd8000002cd0:	580002c7 	ldr	x7, fd8000002d28 <switch_space+0x74>
    add x7, x7, #(CPU_STACK_OFF + CPU_STACK_SIZE)
    fd8000002cd4:	914008e7 	add	x7, x7, #0x2, lsl #12

    /* Calculate stack size */
    mov x8, sp
    fd8000002cd8:	910003e8 	mov	x8, sp
    sub x5, x7, x8
    fd8000002cdc:	cb0800e5 	sub	x5, x7, x8

    /* Get current CPU space current sp */
    mov x7, sp
    fd8000002ce0:	910003e7 	mov	x7, sp

    /* Get new CPU space current sp */
    add x0, x0, #(CPU_STACK_OFF + CPU_STACK_SIZE)
    fd8000002ce4:	91400800 	add	x0, x0, #0x2, lsl #12
    sub x0, x0, x5
    fd8000002ce8:	cb050000 	sub	x0, x0, x5

    /* Copy */
    mov x8, x30
    fd8000002cec:	aa1e03e8 	mov	x8, x30
    bl      memcpy
    fd8000002cf0:	97ffffe6 	bl	fd8000002c88 <memcpy>
    mov x30, x8
    fd8000002cf4:	aa0803fe 	mov	x30, x8

    /**
     * Invalidate TLB
     */
    dsb ishst
    fd8000002cf8:	d5033a9f 	dsb	ishst
    tlbi alle2
    fd8000002cfc:	d50c871f 	tlbi	alle2
    dsb ish
    fd8000002d00:	d5033b9f 	dsb	ish
    isb
    fd8000002d04:	d5033fdf 	isb
    /**
     * Update TTBR
     */

    /* Update value of TTBR0_EL2 */
	msr TTBR0_EL2, x1
    fd8000002d08:	d51c2001 	msr	ttbr0_el2, x1
    dsb ish
    fd8000002d0c:	d5033b9f 	dsb	ish
    isb
    fd8000002d10:	d5033fdf 	isb

    tlbi alle2
    fd8000002d14:	d50c871f 	tlbi	alle2
    dsb ish
    fd8000002d18:	d5033b9f 	dsb	ish
    isb
    fd8000002d1c:	d5033fdf 	isb

    ret
    fd8000002d20:	d65f03c0 	ret
	...
    fd8000002d2c:	0000fe00 	.word	0x0000fe00

0000fd8000002d30 <vmm_arch_init_tcr>:
SYSREG_GEN_ACCESSORS(id_aa64mmfr0_el1);
    fd8000002d30:	d5380701 	mrs	x1, id_aa64mmfr0_el1
    __asm__ volatile(
    fd8000002d34:	90000000 	adrp	x0, fd8000002000 <smmu_init+0x90>
    fd8000002d38:	f947cc00 	ldr	x0, [x0, #3992]
     */

    static size_t min_parange = 0b111;
    static spinlock_t lock = SPINLOCK_INITVAL;

    size_t temp_parange = sysreg_id_aa64mmfr0_el1_read() & ID_AA64MMFR0_PAR_MSK;
    fd8000002d3c:	92400c21 	and	x1, x1, #0xf
    fd8000002d40:	91001005 	add	x5, x0, #0x4
    fd8000002d44:	885ffc02 	ldaxr	w2, [x0]
    fd8000002d48:	11000443 	add	w3, w2, #0x1
    fd8000002d4c:	88047c03 	stxr	w4, w3, [x0]
    fd8000002d50:	35ffffa4 	cbnz	w4, fd8000002d44 <vmm_arch_init_tcr+0x14>
    fd8000002d54:	88dffca3 	ldar	w3, [x5]
    fd8000002d58:	6b03005f 	cmp	w2, w3
    fd8000002d5c:	54000060 	b.eq	fd8000002d68 <vmm_arch_init_tcr+0x38>  // b.none
    fd8000002d60:	d503205f 	wfe
    fd8000002d64:	17fffffc 	b	fd8000002d54 <vmm_arch_init_tcr+0x24>
    spin_lock(&lock);
    if (temp_parange < min_parange) {
    fd8000002d68:	90000002 	adrp	x2, fd8000002000 <smmu_init+0x90>
    fd8000002d6c:	f947d043 	ldr	x3, [x2, #4000]
    fd8000002d70:	f9400062 	ldr	x2, [x3]
    fd8000002d74:	eb01005f 	cmp	x2, x1
    fd8000002d78:	54000049 	b.ls	fd8000002d80 <vmm_arch_init_tcr+0x50>  // b.plast
        min_parange = temp_parange;
    fd8000002d7c:	f9000061 	str	x1, [x3]
    __asm__ volatile(
    fd8000002d80:	91001001 	add	x1, x0, #0x4
    fd8000002d84:	b9400020 	ldr	w0, [x1]
    fd8000002d88:	11000400 	add	w0, w0, #0x1
    fd8000002d8c:	889ffc20 	stlr	w0, [x1]
    fd8000002d90:	d5033b9f 	dsb	ish
    fd8000002d94:	d503209f 	sev
{
    // TODO: no fence/barrier needed in this function?

    size_t next_count = 0;

    while (!token->ready) { }
    fd8000002d98:	90000000 	adrp	x0, fd8000002000 <smmu_init+0x90>
    fd8000002d9c:	f947d400 	ldr	x0, [x0, #4008]
    fd8000002da0:	39404001 	ldrb	w1, [x0, #16]
    fd8000002da4:	3607ffe1 	tbz	w1, #0, fd8000002da0 <vmm_arch_init_tcr+0x70>
    __asm__ volatile(
    fd8000002da8:	91001005 	add	x5, x0, #0x4
    fd8000002dac:	885ffc01 	ldaxr	w1, [x0]
    fd8000002db0:	11000422 	add	w2, w1, #0x1
    fd8000002db4:	88047c02 	stxr	w4, w2, [x0]
    fd8000002db8:	35ffffa4 	cbnz	w4, fd8000002dac <vmm_arch_init_tcr+0x7c>
    fd8000002dbc:	88dffca2 	ldar	w2, [x5]
    fd8000002dc0:	6b02003f 	cmp	w1, w2
    fd8000002dc4:	54000060 	b.eq	fd8000002dd0 <vmm_arch_init_tcr+0xa0>  // b.none
    fd8000002dc8:	d503205f 	wfe
    fd8000002dcc:	17fffffc 	b	fd8000002dbc <vmm_arch_init_tcr+0x8c>

    spin_lock(&token->lock);
    token->count++;
    fd8000002dd0:	f9400c01 	ldr	x1, [x0, #24]
    fd8000002dd4:	91000421 	add	x1, x1, #0x1
    fd8000002dd8:	f9000c01 	str	x1, [x0, #24]
    next_count = ALIGN(token->count, token->n);
    fd8000002ddc:	f9400c02 	ldr	x2, [x0, #24]
    fd8000002de0:	f9400401 	ldr	x1, [x0, #8]
    fd8000002de4:	f9400404 	ldr	x4, [x0, #8]
    fd8000002de8:	8b010042 	add	x2, x2, x1
    fd8000002dec:	d1000442 	sub	x2, x2, #0x1
    fd8000002df0:	f9400401 	ldr	x1, [x0, #8]
    fd8000002df4:	9ac40842 	udiv	x2, x2, x4
    fd8000002df8:	9b017c42 	mul	x2, x2, x1
    __asm__ volatile(
    fd8000002dfc:	b94000a1 	ldr	w1, [x5]
    fd8000002e00:	11000421 	add	w1, w1, #0x1
    fd8000002e04:	889ffca1 	stlr	w1, [x5]
    fd8000002e08:	d5033b9f 	dsb	ish
    fd8000002e0c:	d503209f 	sev
    spin_unlock(&token->lock);

    while (token->count < next_count) { }
    fd8000002e10:	f9400c01 	ldr	x1, [x0, #24]
    fd8000002e14:	eb01005f 	cmp	x2, x1
    fd8000002e18:	54ffffc8 	b.hi	fd8000002e10 <vmm_arch_init_tcr+0xe0>  // b.pmore
    }
    spin_unlock(&lock);

    cpu_sync_barrier(&cpu_glb_sync);

    if (cpu()->id == CPU_MASTER) {
    fd8000002e1c:	90000001 	adrp	x1, fd8000002000 <smmu_init+0x90>
    fd8000002e20:	f947d821 	ldr	x1, [x1, #4016]
    fd8000002e24:	d2dfc002 	mov	x2, #0xfe0000000000        	// #279275953455104
    fd8000002e28:	f9400042 	ldr	x2, [x2]
    fd8000002e2c:	f9400021 	ldr	x1, [x1]
    fd8000002e30:	eb01005f 	cmp	x2, x1
        parange = min_parange;
    fd8000002e34:	90000001 	adrp	x1, fd8000002000 <smmu_init+0x90>
    fd8000002e38:	f947dc26 	ldr	x6, [x1, #4024]
        if (parange_table[parange] < 44) {
    fd8000002e3c:	90000001 	adrp	x1, fd8000002000 <smmu_init+0x90>
    fd8000002e40:	f947e025 	ldr	x5, [x1, #4032]
    if (cpu()->id == CPU_MASTER) {
    fd8000002e44:	54000600 	b.eq	fd8000002f04 <vmm_arch_init_tcr+0x1d4>  // b.none
    while (!token->ready) { }
    fd8000002e48:	39404001 	ldrb	w1, [x0, #16]
    fd8000002e4c:	3607ffe1 	tbz	w1, #0, fd8000002e48 <vmm_arch_init_tcr+0x118>
    __asm__ volatile(
    fd8000002e50:	91001004 	add	x4, x0, #0x4
    fd8000002e54:	885ffc01 	ldaxr	w1, [x0]
    fd8000002e58:	11000422 	add	w2, w1, #0x1
    fd8000002e5c:	88037c02 	stxr	w3, w2, [x0]
    fd8000002e60:	35ffffa3 	cbnz	w3, fd8000002e54 <vmm_arch_init_tcr+0x124>
    fd8000002e64:	88dffc82 	ldar	w2, [x4]
    fd8000002e68:	6b02003f 	cmp	w1, w2
    fd8000002e6c:	54000060 	b.eq	fd8000002e78 <vmm_arch_init_tcr+0x148>  // b.none
    fd8000002e70:	d503205f 	wfe
    fd8000002e74:	17fffffc 	b	fd8000002e64 <vmm_arch_init_tcr+0x134>
    token->count++;
    fd8000002e78:	f9400c01 	ldr	x1, [x0, #24]
    fd8000002e7c:	91000421 	add	x1, x1, #0x1
    fd8000002e80:	f9000c01 	str	x1, [x0, #24]
    next_count = ALIGN(token->count, token->n);
    fd8000002e84:	f9400c02 	ldr	x2, [x0, #24]
    fd8000002e88:	f9400401 	ldr	x1, [x0, #8]
    fd8000002e8c:	f9400403 	ldr	x3, [x0, #8]
    fd8000002e90:	8b010042 	add	x2, x2, x1
    fd8000002e94:	d1000442 	sub	x2, x2, #0x1
    fd8000002e98:	f9400401 	ldr	x1, [x0, #8]
    fd8000002e9c:	9ac30842 	udiv	x2, x2, x3
    fd8000002ea0:	9b017c42 	mul	x2, x2, x1
    __asm__ volatile(
    fd8000002ea4:	b9400081 	ldr	w1, [x4]
    fd8000002ea8:	11000421 	add	w1, w1, #0x1
    fd8000002eac:	889ffc81 	stlr	w1, [x4]
    fd8000002eb0:	d5033b9f 	dsb	ish
    fd8000002eb4:	d503209f 	sev
    while (token->count < next_count) { }
    fd8000002eb8:	f9400c01 	ldr	x1, [x0, #24]
    fd8000002ebc:	eb01005f 	cmp	x2, x1
    fd8000002ec0:	54ffffc8 	b.hi	fd8000002eb8 <vmm_arch_init_tcr+0x188>  // b.pmore
        }
    }

    cpu_sync_barrier(&cpu_glb_sync);

    uint64_t vtcr = VTCR_RES1 | ((parange << VTCR_PS_OFF) & VTCR_PS_MSK) | VTCR_TG0_4K |
    fd8000002ec4:	f94000c0 	ldr	x0, [x6]
        VTCR_ORGN0_WB_RA_WA | VTCR_IRGN0_WB_RA_WA | VTCR_T0SZ(64 - parange_table[parange]) |
        VTCR_SH0_IS | ((parange_table[parange] < 44) ? VTCR_SL0_12 : VTCR_SL0_01);
    fd8000002ec8:	d2800804 	mov	x4, #0x40                  	// #64
    fd8000002ecc:	d2801002 	mov	x2, #0x80                  	// #128
    fd8000002ed0:	d286a003 	mov	x3, #0x3500                	// #13568
    fd8000002ed4:	f2b00003 	movk	x3, #0x8000, lsl #16
        VTCR_ORGN0_WB_RA_WA | VTCR_IRGN0_WB_RA_WA | VTCR_T0SZ(64 - parange_table[parange]) |
    fd8000002ed8:	f86078a1 	ldr	x1, [x5, x0, lsl #3]
    uint64_t vtcr = VTCR_RES1 | ((parange << VTCR_PS_OFF) & VTCR_PS_MSK) | VTCR_TG0_4K |
    fd8000002edc:	d3700800 	ubfiz	x0, x0, #16, #3
        VTCR_SH0_IS | ((parange_table[parange] < 44) ? VTCR_SL0_12 : VTCR_SL0_01);
    fd8000002ee0:	f100ac3f 	cmp	x1, #0x2b
    fd8000002ee4:	cb0103e1 	neg	x1, x1
    fd8000002ee8:	9a848042 	csel	x2, x2, x4, hi	// hi = pmore
    fd8000002eec:	92401021 	and	x1, x1, #0x1f
    fd8000002ef0:	aa030021 	orr	x1, x1, x3
    uint64_t vtcr = VTCR_RES1 | ((parange << VTCR_PS_OFF) & VTCR_PS_MSK) | VTCR_TG0_4K |
    fd8000002ef4:	aa020000 	orr	x0, x0, x2
    fd8000002ef8:	aa010000 	orr	x0, x0, x1
SYSREG_GEN_ACCESSORS(vtcr_el2);
    fd8000002efc:	d51c2140 	msr	vtcr_el2, x0

    sysreg_vtcr_el2_write(vtcr);
}
    fd8000002f00:	d65f03c0 	ret
        parange = min_parange;
    fd8000002f04:	f9400061 	ldr	x1, [x3]
    fd8000002f08:	f90000c1 	str	x1, [x6]
        if (parange_table[parange] < 44) {
    fd8000002f0c:	f86178a1 	ldr	x1, [x5, x1, lsl #3]
    fd8000002f10:	f100ac3f 	cmp	x1, #0x2b
    fd8000002f14:	54fff9a8 	b.hi	fd8000002e48 <vmm_arch_init_tcr+0x118>  // b.pmore
            for (size_t i = 0; i < vm_pt_dscr->lvls - 1; i++) {
    fd8000002f18:	90000002 	adrp	x2, fd8000002000 <smmu_init+0x90>
    fd8000002f1c:	f947e442 	ldr	x2, [x2, #4040]
    fd8000002f20:	f9400044 	ldr	x4, [x2]
    fd8000002f24:	f9400082 	ldr	x2, [x4]
            vm_pt_dscr->lvl_wdt[0] = parange_table[parange];
    fd8000002f28:	f9400887 	ldr	x7, [x4, #16]
            for (size_t i = 0; i < vm_pt_dscr->lvls - 1; i++) {
    fd8000002f2c:	f100045f 	cmp	x2, #0x1
    fd8000002f30:	540002a0 	b.eq	fd8000002f84 <vmm_arch_init_tcr+0x254>  // b.none
                vm_pt_dscr->lvl_off[i] = vm_pt_dscr->lvl_off[i + 1];
    fd8000002f34:	f9400489 	ldr	x9, [x4, #8]
    fd8000002f38:	d10020ec 	sub	x12, x7, #0x8
                vm_pt_dscr->lvl_term[i] = vm_pt_dscr->lvl_term[i + 1];
    fd8000002f3c:	f9400c88 	ldr	x8, [x4, #24]
    fd8000002f40:	d100212b 	sub	x11, x9, #0x8
            for (size_t i = 0; i < vm_pt_dscr->lvls - 1; i++) {
    fd8000002f44:	d2800001 	mov	x1, #0x0                   	// #0
    fd8000002f48:	d100050a 	sub	x10, x8, #0x1
    fd8000002f4c:	d503201f 	nop
                vm_pt_dscr->lvl_wdt[i] = vm_pt_dscr->lvl_wdt[i + 1];
    fd8000002f50:	91000421 	add	x1, x1, #0x1
    fd8000002f54:	f86178e2 	ldr	x2, [x7, x1, lsl #3]
    fd8000002f58:	f8217982 	str	x2, [x12, x1, lsl #3]
                vm_pt_dscr->lvl_term[i] = vm_pt_dscr->lvl_term[i + 1];
    fd8000002f5c:	38616902 	ldrb	w2, [x8, x1]
                vm_pt_dscr->lvl_off[i] = vm_pt_dscr->lvl_off[i + 1];
    fd8000002f60:	f8617923 	ldr	x3, [x9, x1, lsl #3]
    fd8000002f64:	f8217963 	str	x3, [x11, x1, lsl #3]
                vm_pt_dscr->lvl_term[i] = vm_pt_dscr->lvl_term[i + 1];
    fd8000002f68:	38216942 	strb	w2, [x10, x1]
            for (size_t i = 0; i < vm_pt_dscr->lvls - 1; i++) {
    fd8000002f6c:	f9400082 	ldr	x2, [x4]
    fd8000002f70:	d1000442 	sub	x2, x2, #0x1
    fd8000002f74:	eb02003f 	cmp	x1, x2
    fd8000002f78:	54fffec3 	b.cc	fd8000002f50 <vmm_arch_init_tcr+0x220>  // b.lo, b.ul, b.last
            vm_pt_dscr->lvl_wdt[0] = parange_table[parange];
    fd8000002f7c:	f94000c1 	ldr	x1, [x6]
    fd8000002f80:	f86178a1 	ldr	x1, [x5, x1, lsl #3]
    fd8000002f84:	f90000e1 	str	x1, [x7]
            vm_pt_dscr->lvls = vm_pt_dscr->lvls - 1;
    fd8000002f88:	f9400081 	ldr	x1, [x4]
    fd8000002f8c:	d1000421 	sub	x1, x1, #0x1
    fd8000002f90:	f9000081 	str	x1, [x4]
    while (!token->ready) { }
    fd8000002f94:	17ffffad 	b	fd8000002e48 <vmm_arch_init_tcr+0x118>
    fd8000002f98:	00013068 	.word	0x00013068
    fd8000002f9c:	0000fd80 	.word	0x0000fd80
    fd8000002fa0:	00012140 	.word	0x00012140
    fd8000002fa4:	0000fd80 	.word	0x0000fd80
    fd8000002fa8:	00016000 	.word	0x00016000
    fd8000002fac:	0000fd80 	.word	0x0000fd80
    fd8000002fb0:	00012348 	.word	0x00012348
    fd8000002fb4:	0000fd80 	.word	0x0000fd80
    fd8000002fb8:	00012120 	.word	0x00012120
    fd8000002fbc:	0000fd80 	.word	0x0000fd80
    fd8000002fc0:	00012020 	.word	0x00012020
    fd8000002fc4:	0000fd80 	.word	0x0000fd80
    fd8000002fc8:	00012010 	.word	0x00012010
    fd8000002fcc:	0000fd80 	.word	0x0000fd80

0000fd8000002fd0 <cache_arch_enumerate>:
#include <fences.h>
#include <bit.h>
#include <platform.h>

void cache_arch_enumerate(struct cache* dscrp)
{
    fd8000002fd0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    fd8000002fd4:	910003fd 	mov	x29, sp
    if (platform.cache.lvls != 0) {
    fd8000002fd8:	b0000001 	adrp	x1, fd8000003000 <cache_arch_enumerate+0x30>
    fd8000002fdc:	f940bc21 	ldr	x1, [x1, #376]
    fd8000002fe0:	f9401822 	ldr	x2, [x1, #48]
{
    fd8000002fe4:	f9000bf3 	str	x19, [sp, #16]
    fd8000002fe8:	aa0003f3 	mov	x19, x0
    if (platform.cache.lvls != 0) {
    fd8000002fec:	b4000082 	cbz	x2, fd8000002ffc <cache_arch_enumerate+0x2c>
        /**
         * No need to probe cache registers, cache topology is described in the platform
         * descrption.
         */
        *dscrp = platform.cache;
    fd8000002ff0:	9100c021 	add	x1, x1, #0x30
    fd8000002ff4:	d2803e02 	mov	x2, #0x1f0                 	// #496
    fd8000002ff8:	940016a6 	bl	fd8000008a90 <memcpy>

    uint64_t clidr = 0;
    uint64_t temp = 0;
    bool first_unified = false;

    dscrp->lvls = 0;
    fd8000002ffc:	f900027f 	str	xzr, [x19]
SYSREG_GEN_ACCESSORS(clidr_el1);
    fd8000003000:	d5390022 	mrs	x2, clidr_el1

    clidr = sysreg_clidr_el1_read();
    for (size_t i = 0; i < CLIDR_CTYPE_NUM; i++) {
        if ((temp = bit64_extract(clidr, i * CLIDR_CTYPE_LEN, CLIDR_CTYPE_LEN)) != 0) {
    fd8000003004:	52800060 	mov	w0, #0x3                   	// #3
    fd8000003008:	f2400841 	ands	x1, x2, #0x7
    for (size_t i = 0; i < CLIDR_CTYPE_NUM; i++) {
    fd800000300c:	d2800003 	mov	x3, #0x0                   	// #0
        if ((temp = bit64_extract(clidr, i * CLIDR_CTYPE_LEN, CLIDR_CTYPE_LEN)) != 0) {
    fd8000003010:	54000780 	b.eq	fd8000003100 <cache_arch_enumerate+0x130>  // b.none
                    break;
                case CLIDR_CTYPE_DO:
                    dscrp->type[i] = DATA;
                    break;
                case CLIDR_CTYPE_SP:
                    dscrp->type[i] = SEPARATE;
    fd8000003014:	91003264 	add	x4, x19, #0xc
                    dscrp->type[i] = INSTRUCTION;
    fd8000003018:	2a0003e5 	mov	w5, w0
                    dscrp->type[i] = SEPARATE;
    fd800000301c:	52800027 	mov	w7, #0x1                   	// #1
                    dscrp->type[i] = DATA;
    fd8000003020:	52800046 	mov	w6, #0x2                   	// #2
    fd8000003024:	1400000a 	b	fd800000304c <cache_arch_enumerate+0x7c>
            switch (temp) {
    fd8000003028:	f100043f 	cmp	x1, #0x1
    fd800000302c:	54000740 	b.eq	fd8000003114 <cache_arch_enumerate+0x144>  // b.none
                    dscrp->type[i] = DATA;
    fd8000003030:	b8237886 	str	w6, [x4, x3, lsl #2]
    for (size_t i = 0; i < CLIDR_CTYPE_NUM; i++) {
    fd8000003034:	f1001c7f 	cmp	x3, #0x7
    fd8000003038:	540001e0 	b.eq	fd8000003074 <cache_arch_enumerate+0xa4>  // b.none
BIT_OPS_GEN(bit64, uint64_t, UINT64_C(1), BIT64_MASK);
    fd800000303c:	9ac02441 	lsr	x1, x2, x0
        if ((temp = bit64_extract(clidr, i * CLIDR_CTYPE_LEN, CLIDR_CTYPE_LEN)) != 0) {
    fd8000003040:	11000c00 	add	w0, w0, #0x3
    fd8000003044:	f2400821 	ands	x1, x1, #0x7
    fd8000003048:	54000180 	b.eq	fd8000003078 <cache_arch_enumerate+0xa8>  // b.none
            dscrp->lvls++;
    fd800000304c:	aa0303e8 	mov	x8, x3
            switch (temp) {
    fd8000003050:	f1000c3f 	cmp	x1, #0x3
            dscrp->lvls++;
    fd8000003054:	91000463 	add	x3, x3, #0x1
            switch (temp) {
    fd8000003058:	540005a0 	b.eq	fd800000310c <cache_arch_enumerate+0x13c>  // b.none
    fd800000305c:	54fffe69 	b.ls	fd8000003028 <cache_arch_enumerate+0x58>  // b.plast
    fd8000003060:	f100103f 	cmp	x1, #0x4
    fd8000003064:	54fffe81 	b.ne	fd8000003034 <cache_arch_enumerate+0x64>  // b.any
                    break;
                case CLIDR_CTYPE_UN:
                    dscrp->type[i] = UNIFIED;
    fd8000003068:	b823789f 	str	wzr, [x4, x3, lsl #2]
    for (size_t i = 0; i < CLIDR_CTYPE_NUM; i++) {
    fd800000306c:	f1001c7f 	cmp	x3, #0x7
    fd8000003070:	54fffe61 	b.ne	fd800000303c <cache_arch_enumerate+0x6c>  // b.any
    fd8000003074:	d28000c8 	mov	x8, #0x6                   	// #6
    fd8000003078:	aa1303e2 	mov	x2, x19
    fd800000307c:	9100c265 	add	x5, x19, #0x30
    fd8000003080:	9100426a 	add	x10, x19, #0x10
    fd8000003084:	d2800001 	mov	x1, #0x0                   	// #0
    fd8000003088:	5280000b 	mov	w11, #0x0                   	// #0
            csselr = bit64_set(csselr, CSSELR_IND_BIT);
            sysreg_csselr_el1_write(csselr);
            ccsidr = sysreg_ccsidr_el1_read();

            dscrp->line_size[lvl][1] = 1UL
                << (bit64_extract(ccsidr, CCSIDR_LINESIZE_OFF, CCSIDR_LINESIZE_LEN) + 4);
    fd800000308c:	d2800029 	mov	x9, #0x1                   	// #1
    fd8000003090:	f8070443 	str	x3, [x2], #112
    fd8000003094:	d503201f 	nop
        if (dscrp->type[lvl] == UNIFIED && first_unified == false) {
    fd8000003098:	b8617947 	ldr	w7, [x10, x1, lsl #2]
    fd800000309c:	8b010026 	add	x6, x1, x1
    fd80000030a0:	350003e7 	cbnz	w7, fd800000311c <cache_arch_enumerate+0x14c>
    fd80000030a4:	3500004b 	cbnz	w11, fd80000030ac <cache_arch_enumerate+0xdc>
            dscrp->min_shared_lvl = lvl;
    fd80000030a8:	f9000661 	str	x1, [x19, #8]
        if (dscrp->type[lvl] != INSTRUCTION) {
    fd80000030ac:	5280002b 	mov	w11, #0x1                   	// #1
SYSREG_GEN_ACCESSORS(csselr_el1);
    fd80000030b0:	d51a0006 	msr	csselr_el1, x6
SYSREG_GEN_ACCESSORS(ccsidr_el1);
    fd80000030b4:	d5390003 	mrs	x3, ccsidr_el1
    fd80000030b8:	92400864 	and	x4, x3, #0x7
    fd80000030bc:	d3433060 	ubfx	x0, x3, #3, #10
                << (bit64_extract(ccsidr, CCSIDR_LINESIZE_OFF, CCSIDR_LINESIZE_LEN) + 4);
    fd80000030c0:	11001084 	add	w4, w4, #0x4
    fd80000030c4:	d34d6c63 	ubfx	x3, x3, #13, #15
                bit64_extract(ccsidr, CCSIDR_ASSOCIATIVITY_OFF, CCSIDR_ASSOCIATIVITY_LEN) + 1;
    fd80000030c8:	91000400 	add	x0, x0, #0x1
                bit64_extract(ccsidr, CCSIDR_NUMSETS_OFF, CCSIDR_NUMSETS_LEN) + 1;
    fd80000030cc:	91000463 	add	x3, x3, #0x1
                << (bit64_extract(ccsidr, CCSIDR_LINESIZE_OFF, CCSIDR_LINESIZE_LEN) + 4);
    fd80000030d0:	9ac42124 	lsl	x4, x9, x4
            dscrp->line_size[lvl][0] = 1UL
    fd80000030d4:	f9000044 	str	x4, [x2]
            dscrp->assoc[lvl][0] =
    fd80000030d8:	f9004040 	str	x0, [x2, #128]
        if (dscrp->type[lvl] == SEPARATE || dscrp->type[lvl] == INSTRUCTION) {
    fd80000030dc:	710004ff 	cmp	w7, #0x1
            dscrp->numset[lvl][0] =
    fd80000030e0:	f9008043 	str	x3, [x2, #256]
            dscrp->indexed[lvl][0] = PIPT;
    fd80000030e4:	b90000bf 	str	wzr, [x5]
        if (dscrp->type[lvl] == SEPARATE || dscrp->type[lvl] == INSTRUCTION) {
    fd80000030e8:	540001e0 	b.eq	fd8000003124 <cache_arch_enumerate+0x154>  // b.none
    for (size_t lvl = 0; lvl < dscrp->lvls; lvl++) {
    fd80000030ec:	eb08003f 	cmp	x1, x8
    fd80000030f0:	91004042 	add	x2, x2, #0x10
    fd80000030f4:	910020a5 	add	x5, x5, #0x8
    fd80000030f8:	91000421 	add	x1, x1, #0x1
    fd80000030fc:	54fffce1 	b.ne	fd8000003098 <cache_arch_enumerate+0xc8>  // b.any
            } else {
                dscrp->indexed[lvl][1] = VIPT;
            }
        }
    }
}
    fd8000003100:	f9400bf3 	ldr	x19, [sp, #16]
    fd8000003104:	a8c27bfd 	ldp	x29, x30, [sp], #32
    fd8000003108:	d65f03c0 	ret
                    dscrp->type[i] = SEPARATE;
    fd800000310c:	b8237887 	str	w7, [x4, x3, lsl #2]
                    break;
    fd8000003110:	17ffffc9 	b	fd8000003034 <cache_arch_enumerate+0x64>
                    dscrp->type[i] = INSTRUCTION;
    fd8000003114:	b8237885 	str	w5, [x4, x3, lsl #2]
                    break;
    fd8000003118:	17ffffc7 	b	fd8000003034 <cache_arch_enumerate+0x64>
        if (dscrp->type[lvl] != INSTRUCTION) {
    fd800000311c:	71000cff 	cmp	w7, #0x3
    fd8000003120:	54fffc81 	b.ne	fd80000030b0 <cache_arch_enumerate+0xe0>  // b.any
    fd8000003124:	b24000c6 	orr	x6, x6, #0x1
SYSREG_GEN_ACCESSORS(csselr_el1);
    fd8000003128:	d51a0006 	msr	csselr_el1, x6
SYSREG_GEN_ACCESSORS(ccsidr_el1);
    fd800000312c:	d5390003 	mrs	x3, ccsidr_el1
    fd8000003130:	92400864 	and	x4, x3, #0x7
    fd8000003134:	d3433060 	ubfx	x0, x3, #3, #10
                << (bit64_extract(ccsidr, CCSIDR_LINESIZE_OFF, CCSIDR_LINESIZE_LEN) + 4);
    fd8000003138:	11001084 	add	w4, w4, #0x4
    fd800000313c:	d34d6c63 	ubfx	x3, x3, #13, #15
                bit64_extract(ccsidr, CCSIDR_ASSOCIATIVITY_OFF, CCSIDR_ASSOCIATIVITY_LEN) + 1;
    fd8000003140:	91000400 	add	x0, x0, #0x1
                bit64_extract(ccsidr, CCSIDR_NUMSETS_OFF, CCSIDR_NUMSETS_LEN) + 1;
    fd8000003144:	91000463 	add	x3, x3, #0x1
                << (bit64_extract(ccsidr, CCSIDR_LINESIZE_OFF, CCSIDR_LINESIZE_LEN) + 4);
    fd8000003148:	9ac42124 	lsl	x4, x9, x4
            dscrp->line_size[lvl][1] = 1UL
    fd800000314c:	f9000444 	str	x4, [x2, #8]
            dscrp->assoc[lvl][1] =
    fd8000003150:	f9004440 	str	x0, [x2, #136]
            dscrp->numset[lvl][1] =
    fd8000003154:	f9008443 	str	x3, [x2, #264]
SYSREG_GEN_ACCESSORS(ctr_el0);
    fd8000003158:	d53b0020 	mrs	x0, ctr_el0
            if ((ctr & BIT64_MASK(CTR_L1LP_OFF, CTR_L1LP_LEN)) == CTR_L1LP_PIPT) {
    fd800000315c:	92720400 	and	x0, x0, #0xc000
    fd8000003160:	f140301f 	cmp	x0, #0xc, lsl #12
    fd8000003164:	54000060 	b.eq	fd8000003170 <cache_arch_enumerate+0x1a0>  // b.none
                dscrp->indexed[lvl][1] = VIPT;
    fd8000003168:	b90004a9 	str	w9, [x5, #4]
    fd800000316c:	17ffffe0 	b	fd80000030ec <cache_arch_enumerate+0x11c>
                dscrp->indexed[lvl][1] = PIPT;
    fd8000003170:	b90004bf 	str	wzr, [x5, #4]
    fd8000003174:	17ffffde 	b	fd80000030ec <cache_arch_enumerate+0x11c>
    fd8000003178:	00012930 	.word	0x00012930
    fd800000317c:	0000fd80 	.word	0x0000fd80

0000fd8000003180 <cache_flush_range>:
    fd8000003180:	d53b0023 	mrs	x3, ctr_el0
    fd8000003184:	d3504c63 	ubfx	x3, x3, #16, #4
{
    vaddr_t cache_addr = base;
    uint64_t ctr = sysreg_ctr_el0_read();
    size_t min_line_size = 1UL << bit64_extract(ctr, CTR_DMINLINE_OFF, CTR_DMINLINE_LEN);

    while (cache_addr < (base + size)) {
    fd8000003188:	8b010001 	add	x1, x0, x1
    size_t min_line_size = 1UL << bit64_extract(ctr, CTR_DMINLINE_OFF, CTR_DMINLINE_LEN);
    fd800000318c:	d2800022 	mov	x2, #0x1                   	// #1
    while (cache_addr < (base + size)) {
    fd8000003190:	eb01001f 	cmp	x0, x1
    size_t min_line_size = 1UL << bit64_extract(ctr, CTR_DMINLINE_OFF, CTR_DMINLINE_LEN);
    fd8000003194:	9ac32042 	lsl	x2, x2, x3
    while (cache_addr < (base + size)) {
    fd8000003198:	540000c2 	b.cs	fd80000031b0 <cache_flush_range+0x30>  // b.hs, b.nlast
    fd800000319c:	d503201f 	nop
    asm volatile("dc civac, %0\n\t" ::"r"(cache_addr));
    fd80000031a0:	d50b7e20 	dc	civac, x0
        arm_dc_civac(cache_addr);
        cache_addr += min_line_size;
    fd80000031a4:	8b020000 	add	x0, x0, x2
    while (cache_addr < (base + size)) {
    fd80000031a8:	eb01001f 	cmp	x0, x1
    fd80000031ac:	54ffffa3 	b.cc	fd80000031a0 <cache_flush_range+0x20>  // b.lo, b.ul, b.last
    }

    DMB(ish);
    fd80000031b0:	d5033bbf 	dmb	ish
}
    fd80000031b4:	d65f03c0 	ret
	...

0000fd80000031c0 <interrupts_arch_init>:
#ifndef GIC_VERSION
#error "GIC_VERSION not defined for this platform"
#endif

void interrupts_arch_init()
{
    fd80000031c0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    fd80000031c4:	910003fd 	mov	x29, sp
    gic_init();
    fd80000031c8:	940002c2 	bl	fd8000003cd0 <gic_init>
    interrupts_cpu_enable(platform.arch.gic.maintenance_id, true);
    fd80000031cc:	90000000 	adrp	x0, fd8000003000 <cache_arch_enumerate+0x30>
    fd80000031d0:	f940f400 	ldr	x0, [x0, #488]
    fd80000031d4:	52800021 	mov	w1, #0x1                   	// #1
}
    fd80000031d8:	a8c17bfd 	ldp	x29, x30, [sp], #16
    interrupts_cpu_enable(platform.arch.gic.maintenance_id, true);
    fd80000031dc:	b9424800 	ldr	w0, [x0, #584]
    fd80000031e0:	14001cf0 	b	fd800000a5a0 <interrupts_cpu_enable>
    fd80000031e4:	d503201f 	nop
    fd80000031e8:	00012930 	.word	0x00012930
    fd80000031ec:	0000fd80 	.word	0x0000fd80

0000fd80000031f0 <interrupts_arch_ipi_send>:

void interrupts_arch_ipi_send(cpuid_t target_cpu, irqid_t ipi_id)
{
    if (ipi_id < GIC_MAX_SGIS) {
    fd80000031f0:	71003c3f 	cmp	w1, #0xf
    fd80000031f4:	54000049 	b.ls	fd80000031fc <interrupts_arch_ipi_send+0xc>  // b.plast
        gic_send_sgi(target_cpu, ipi_id);
    }
}
    fd80000031f8:	d65f03c0 	ret
        gic_send_sgi(target_cpu, ipi_id);
    fd80000031fc:	140015b9 	b	fd80000088e0 <gic_send_sgi>

0000fd8000003200 <interrupts_arch_enable>:

void interrupts_arch_enable(irqid_t int_id, bool en)
{
    fd8000003200:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    fd8000003204:	910003fd 	mov	x29, sp
    fd8000003208:	f9000bf3 	str	x19, [sp, #16]
    fd800000320c:	2a0003f3 	mov	w19, w0
    gic_set_enable(int_id, en);
    fd8000003210:	94001618 	bl	fd8000008a70 <gic_set_enable>
    gic_set_prio(int_id, 0x01);
    fd8000003214:	2a1303e0 	mov	w0, w19
    fd8000003218:	52800021 	mov	w1, #0x1                   	// #1
    fd800000321c:	940015c5 	bl	fd8000008930 <gic_set_prio>
    if (GIC_VERSION == GICV2) {
        gicd_set_trgt(int_id, 1 << cpu()->id);
    } else {
        gicd_set_route(int_id, cpu()->arch.mpidr);
    fd8000003220:	2a1303e0 	mov	w0, w19
    fd8000003224:	d2dfc001 	mov	x1, #0xfe0000000000        	// #279275953455104
    }
}
    fd8000003228:	f9400bf3 	ldr	x19, [sp, #16]
    fd800000322c:	a8c27bfd 	ldp	x29, x30, [sp], #32
        gicd_set_route(int_id, cpu()->arch.mpidr);
    fd8000003230:	f9417821 	ldr	x1, [x1, #752]
    fd8000003234:	14001587 	b	fd8000008850 <gicd_set_route>
    fd8000003238:	d503201f 	nop
    fd800000323c:	d503201f 	nop

0000fd8000003240 <interrupts_arch_check>:

bool interrupts_arch_check(irqid_t int_id)
{
    return gic_get_pend(int_id);
    fd8000003240:	140015dc 	b	fd80000089b0 <gic_get_pend>
    fd8000003244:	d503201f 	nop
    fd8000003248:	d503201f 	nop
    fd800000324c:	d503201f 	nop

0000fd8000003250 <interrupts_arch_conflict>:
    fd8000003250:	53057c23 	lsr	w3, w1, #5
    fd8000003254:	52800022 	mov	w2, #0x1                   	// #1
}

inline bool interrupts_arch_conflict(bitmap_t* interrupt_bitmap, irqid_t int_id)
{
    return (bitmap_get(interrupt_bitmap, int_id) && int_id > GIC_CPU_PRIV);
    fd8000003258:	7100803f 	cmp	w1, #0x20
    fd800000325c:	1ac12041 	lsl	w1, w2, w1
    fd8000003260:	b8637800 	ldr	w0, [x0, x3, lsl #2]
    fd8000003264:	0a000021 	and	w1, w1, w0
    fd8000003268:	7a408824 	ccmp	w1, #0x0, #0x4, hi	// hi = pmore
}
    fd800000326c:	1a9f07e0 	cset	w0, ne	// ne = any
    fd8000003270:	d65f03c0 	ret
    fd8000003274:	d503201f 	nop
    fd8000003278:	d503201f 	nop
    fd800000327c:	d503201f 	nop

0000fd8000003280 <interrupts_arch_clear>:

void interrupts_arch_clear(irqid_t int_id)
{
    fd8000003280:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    gic_set_act(int_id, false);
    fd8000003284:	52800001 	mov	w1, #0x0                   	// #0
{
    fd8000003288:	910003fd 	mov	x29, sp
    fd800000328c:	f9000bf3 	str	x19, [sp, #16]
    fd8000003290:	2a0003f3 	mov	w19, w0
    gic_set_act(int_id, false);
    fd8000003294:	940015db 	bl	fd8000008a00 <gic_set_act>
    gic_set_pend(int_id, false);
    fd8000003298:	2a1303e0 	mov	w0, w19
    fd800000329c:	52800001 	mov	w1, #0x0                   	// #0
}
    fd80000032a0:	f9400bf3 	ldr	x19, [sp, #16]
    fd80000032a4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    gic_set_pend(int_id, false);
    fd80000032a8:	140015ba 	b	fd8000008990 <gic_set_pend>
    fd80000032ac:	d503201f 	nop

0000fd80000032b0 <interrupts_arch_vm_assign>:

void interrupts_arch_vm_assign(struct vm* vm, irqid_t id)
{
    vgic_set_hw(vm, id);
    fd80000032b0:	14000e30 	b	fd8000006b70 <vgic_set_hw>
	...

0000fd80000032c0 <vm_arch_init>:
#include <fences.h>
#include <string.h>
#include <config.h>

void vm_arch_init(struct vm* vm, const struct vm_config* config)
{
    fd80000032c0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    if (vm->master == cpu()->id) {
    fd80000032c4:	d2dfc002 	mov	x2, #0xfe0000000000        	// #279275953455104
{
    fd80000032c8:	910003fd 	mov	x29, sp
    if (vm->master == cpu()->id) {
    fd80000032cc:	f9400042 	ldr	x2, [x2]
{
    fd80000032d0:	a90153f3 	stp	x19, x20, [sp, #16]
    fd80000032d4:	aa0003f3 	mov	x19, x0
    if (vm->master == cpu()->id) {
    fd80000032d8:	f9401c03 	ldr	x3, [x0, #56]
{
    fd80000032dc:	f90013f5 	str	x21, [sp, #32]
    if (vm->master == cpu()->id) {
    fd80000032e0:	eb02007f 	cmp	x3, x2
    fd80000032e4:	54000a00 	b.eq	fd8000003424 <vm_arch_init+0x164>  // b.none

static inline void cpu_sync_and_clear_msgs(struct cpu_synctoken* token)
{
    size_t next_count = 0;

    while (!token->ready) { }
    fd80000032e8:	91006273 	add	x19, x19, #0x18
    fd80000032ec:	d503201f 	nop
    fd80000032f0:	39404260 	ldrb	w0, [x19, #16]
    fd80000032f4:	3607ffe0 	tbz	w0, #0, fd80000032f0 <vm_arch_init+0x30>
    __asm__ volatile(
    fd80000032f8:	91001263 	add	x3, x19, #0x4
    fd80000032fc:	885ffe60 	ldaxr	w0, [x19]
    fd8000003300:	11000401 	add	w1, w0, #0x1
    fd8000003304:	88027e61 	stxr	w2, w1, [x19]
    fd8000003308:	35ffffa2 	cbnz	w2, fd80000032fc <vm_arch_init+0x3c>
    fd800000330c:	88dffc61 	ldar	w1, [x3]
    fd8000003310:	6b01001f 	cmp	w0, w1
    fd8000003314:	54000060 	b.eq	fd8000003320 <vm_arch_init+0x60>  // b.none
    fd8000003318:	d503205f 	wfe
    fd800000331c:	17fffffc 	b	fd800000330c <vm_arch_init+0x4c>

    spin_lock(&token->lock);
    token->count++;
    fd8000003320:	f9400e60 	ldr	x0, [x19, #24]
    fd8000003324:	91000400 	add	x0, x0, #0x1
    fd8000003328:	f9000e60 	str	x0, [x19, #24]
    next_count = ALIGN(token->count, token->n);
    fd800000332c:	f9400e74 	ldr	x20, [x19, #24]
    fd8000003330:	f9400660 	ldr	x0, [x19, #8]
    fd8000003334:	f9400661 	ldr	x1, [x19, #8]
    fd8000003338:	8b000294 	add	x20, x20, x0
    fd800000333c:	d1000694 	sub	x20, x20, #0x1
    fd8000003340:	f9400660 	ldr	x0, [x19, #8]
    fd8000003344:	9ac10a94 	udiv	x20, x20, x1
    fd8000003348:	9b007e94 	mul	x20, x20, x0
    __asm__ volatile(
    fd800000334c:	b9400060 	ldr	w0, [x3]
    fd8000003350:	11000400 	add	w0, w0, #0x1
    fd8000003354:	889ffc60 	stlr	w0, [x3]
    fd8000003358:	d5033b9f 	dsb	ish
    fd800000335c:	d503209f 	sev
    spin_unlock(&token->lock);

    while (token->count < next_count) {
        if (!cpu()->handling_msgs) {
    fd8000003360:	d2dfc015 	mov	x21, #0xfe0000000000        	// #279275953455104
    while (token->count < next_count) {
    fd8000003364:	f9400e61 	ldr	x1, [x19, #24]
        if (!cpu()->handling_msgs) {
    fd8000003368:	394022a0 	ldrb	w0, [x21, #8]
    while (token->count < next_count) {
    fd800000336c:	eb01029f 	cmp	x20, x1
        if (!cpu()->handling_msgs) {
    fd8000003370:	12000001 	and	w1, w0, #0x1
    while (token->count < next_count) {
    fd8000003374:	540000c9 	b.ls	fd800000338c <vm_arch_init+0xcc>  // b.plast
        if (!cpu()->handling_msgs) {
    fd8000003378:	36000520 	tbz	w0, #0, fd800000341c <vm_arch_init+0x15c>
    fd800000337c:	d503201f 	nop
    while (token->count < next_count) {
    fd8000003380:	f9400e60 	ldr	x0, [x19, #24]
    fd8000003384:	eb00029f 	cmp	x20, x0
    fd8000003388:	54ffffc8 	b.hi	fd8000003380 <vm_arch_init+0xc0>  // b.pmore
            cpu_msg_handler();
        }
    }

    if (!cpu()->handling_msgs) {
    fd800000338c:	34000521 	cbz	w1, fd8000003430 <vm_arch_init+0x170>
    while (!token->ready) { }
    fd8000003390:	39404260 	ldrb	w0, [x19, #16]
    fd8000003394:	3607ffe0 	tbz	w0, #0, fd8000003390 <vm_arch_init+0xd0>
    __asm__ volatile(
    fd8000003398:	91001263 	add	x3, x19, #0x4
    fd800000339c:	885ffe60 	ldaxr	w0, [x19]
    fd80000033a0:	11000401 	add	w1, w0, #0x1
    fd80000033a4:	88027e61 	stxr	w2, w1, [x19]
    fd80000033a8:	35ffffa2 	cbnz	w2, fd800000339c <vm_arch_init+0xdc>
    fd80000033ac:	88dffc61 	ldar	w1, [x3]
    fd80000033b0:	6b01001f 	cmp	w0, w1
    fd80000033b4:	54000060 	b.eq	fd80000033c0 <vm_arch_init+0x100>  // b.none
    fd80000033b8:	d503205f 	wfe
    fd80000033bc:	17fffffc 	b	fd80000033ac <vm_arch_init+0xec>
    token->count++;
    fd80000033c0:	f9400e60 	ldr	x0, [x19, #24]
    fd80000033c4:	91000400 	add	x0, x0, #0x1
    fd80000033c8:	f9000e60 	str	x0, [x19, #24]
    next_count = ALIGN(token->count, token->n);
    fd80000033cc:	f9400e61 	ldr	x1, [x19, #24]
    fd80000033d0:	f9400660 	ldr	x0, [x19, #8]
    fd80000033d4:	f9400662 	ldr	x2, [x19, #8]
    fd80000033d8:	8b000021 	add	x1, x1, x0
    fd80000033dc:	d1000421 	sub	x1, x1, #0x1
    fd80000033e0:	f9400660 	ldr	x0, [x19, #8]
    fd80000033e4:	9ac20821 	udiv	x1, x1, x2
    fd80000033e8:	9b007c21 	mul	x1, x1, x0
    __asm__ volatile(
    fd80000033ec:	b9400060 	ldr	w0, [x3]
    fd80000033f0:	11000400 	add	w0, w0, #0x1
    fd80000033f4:	889ffc60 	stlr	w0, [x3]
    fd80000033f8:	d5033b9f 	dsb	ish
    fd80000033fc:	d503209f 	sev
    while (token->count < next_count) { }
    fd8000003400:	f9400e60 	ldr	x0, [x19, #24]
    fd8000003404:	eb00003f 	cmp	x1, x0
    fd8000003408:	54ffffc8 	b.hi	fd8000003400 <vm_arch_init+0x140>  // b.pmore
        vgic_init(vm, &config->platform.arch.gic);
    }
    cpu_sync_and_clear_msgs(&vm->sync);
}
    fd800000340c:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd8000003410:	f94013f5 	ldr	x21, [sp, #32]
    fd8000003414:	a8c37bfd 	ldp	x29, x30, [sp], #48
    fd8000003418:	d65f03c0 	ret
            cpu_msg_handler();
    fd800000341c:	94001e01 	bl	fd800000ac20 <cpu_msg_handler>
    fd8000003420:	17ffffd1 	b	fd8000003364 <vm_arch_init+0xa4>
        vgic_init(vm, &config->platform.arch.gic);
    fd8000003424:	9101e021 	add	x1, x1, #0x78
    fd8000003428:	940011d2 	bl	fd8000007b70 <vgic_init>
    fd800000342c:	17ffffaf 	b	fd80000032e8 <vm_arch_init+0x28>
        cpu_msg_handler();
    fd8000003430:	94001dfc 	bl	fd800000ac20 <cpu_msg_handler>
    while (!token->ready) { }
    fd8000003434:	17ffffd7 	b	fd8000003390 <vm_arch_init+0xd0>
    fd8000003438:	d503201f 	nop
    fd800000343c:	d503201f 	nop

0000fd8000003440 <vm_get_vcpu_by_mpidr>:

struct vcpu* vm_get_vcpu_by_mpidr(struct vm* vm, unsigned long mpidr)
{
    for (cpuid_t vcpuid = 0; vcpuid < vm->cpu_num; vcpuid++) {
    fd8000003440:	f9402405 	ldr	x5, [x0, #72]
    fd8000003444:	b40001c5 	cbz	x5, fd800000347c <vm_get_vcpu_by_mpidr+0x3c>
    fd8000003448:	f9402003 	ldr	x3, [x0, #64]
    fd800000344c:	d2800004 	mov	x4, #0x0                   	// #0
    fd8000003450:	14000003 	b	fd800000345c <vm_get_vcpu_by_mpidr+0x1c>
    fd8000003454:	eb05009f 	cmp	x4, x5
    fd8000003458:	54000120 	b.eq	fd800000347c <vm_get_vcpu_by_mpidr+0x3c>  // b.none
        struct vcpu* vcpu = vm_get_vcpu(vm, vcpuid);
        if ((vcpu->arch.vmpidr & MPIDR_AFF_MSK) == (mpidr & MPIDR_AFF_MSK)) {
    fd800000345c:	f9409062 	ldr	x2, [x3, #288]
cpumap_t vm_translate_to_vcpu_mask(struct vm* vm, cpumap_t mask, size_t len);

static inline struct vcpu* vm_get_vcpu(struct vm* vm, vcpuid_t vcpuid)
{
    if (vcpuid < vm->cpu_num) {
        return &vm->vcpus[vcpuid];
    fd8000003460:	aa0303e0 	mov	x0, x3
    for (cpuid_t vcpuid = 0; vcpuid < vm->cpu_num; vcpuid++) {
    fd8000003464:	91000484 	add	x4, x4, #0x1
    fd8000003468:	91268063 	add	x3, x3, #0x9a0
        if ((vcpu->arch.vmpidr & MPIDR_AFF_MSK) == (mpidr & MPIDR_AFF_MSK)) {
    fd800000346c:	ca020022 	eor	x2, x1, x2
    fd8000003470:	72003c5f 	tst	w2, #0xffff
    fd8000003474:	54ffff01 	b.ne	fd8000003454 <vm_get_vcpu_by_mpidr+0x14>  // b.any
            return vcpu;
        }
    }

    return NULL;
}
    fd8000003478:	d65f03c0 	ret
    return NULL;
    fd800000347c:	d2800000 	mov	x0, #0x0                   	// #0
}
    fd8000003480:	d65f03c0 	ret
    fd8000003484:	d503201f 	nop
    fd8000003488:	d503201f 	nop
    fd800000348c:	d503201f 	nop

0000fd8000003490 <vcpu_arch_init>:

    return mpidr;
}

void vcpu_arch_init(struct vcpu* vcpu, struct vm* vm)
{
    fd8000003490:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    fd8000003494:	910003fd 	mov	x29, sp
    if (cpuid > vm->cpu_num) {
    fd8000003498:	f9402422 	ldr	x2, [x1, #72]
{
    fd800000349c:	f9000bf3 	str	x19, [sp, #16]
    fd80000034a0:	aa0003f3 	mov	x19, x0
    vcpu->arch.vmpidr = vm_cpuid_to_mpidr(vm, vcpu->id);
    fd80000034a4:	f944bc00 	ldr	x0, [x0, #2424]
    if (cpuid > vm->cpu_num) {
    fd80000034a8:	eb02001f 	cmp	x0, x2
    fd80000034ac:	54000208 	b.hi	fd80000034ec <vcpu_arch_init+0x5c>  // b.pmore
    unsigned long mpidr = cpuid | MPIDR_RES1;
    fd80000034b0:	f100045f 	cmp	x2, #0x1
    fd80000034b4:	b2610003 	orr	x3, x0, #0x80000000
    fd80000034b8:	b2620402 	orr	x2, x0, #0xc0000000
    fd80000034bc:	9a830042 	csel	x2, x2, x3, eq	// eq = none
    vcpu->arch.vmpidr = vm_cpuid_to_mpidr(vm, vcpu->id);
    fd80000034c0:	f9009262 	str	x2, [x19, #288]
SYSREG_GEN_ACCESSORS(vmpidr_el2);
    fd80000034c4:	d51c00a2 	msr	vmpidr_el2, x2
    sysreg_vmpidr_el2_write(vcpu->arch.vmpidr); //put the value of Virtualization multiprocessor ID

    vcpu->arch.psci_ctx.state = vcpu->id == 0 ? ON : OFF;
    fd80000034c8:	f100001f 	cmp	x0, #0x0
    fd80000034cc:	1a9f07e0 	cset	w0, ne	// ne = any
    fd80000034d0:	b9097260 	str	w0, [x19, #2416]

    vcpu_arch_profile_init(vcpu, vm);
    fd80000034d4:	aa1303e0 	mov	x0, x19
    fd80000034d8:	97fff9ba 	bl	fd8000001bc0 <vcpu_arch_profile_init>

    vgic_cpu_init(vcpu);
    fd80000034dc:	aa1303e0 	mov	x0, x19
}
    fd80000034e0:	f9400bf3 	ldr	x19, [sp, #16]
    fd80000034e4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    vgic_cpu_init(vcpu);
    fd80000034e8:	14001232 	b	fd8000007db0 <vgic_cpu_init>
        return ~(~MPIDR_RES1 & MPIDR_RES0_MSK); // return an invlid mpidr by
    fd80000034ec:	929fffe2 	mov	x2, #0xffffffffffff0000    	// #-65536
    fd80000034f0:	f2b7c002 	movk	x2, #0xbe00, lsl #16
    fd80000034f4:	17fffff3 	b	fd80000034c0 <vcpu_arch_init+0x30>
    fd80000034f8:	d503201f 	nop
    fd80000034fc:	d503201f 	nop

0000fd8000003500 <vcpu_arch_reset>:

void vcpu_arch_reset(struct vcpu* vcpu, vaddr_t entry)
{
    fd8000003500:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    memset(&vcpu->regs, 0, sizeof(struct arch_regs));
    fd8000003504:	d2802202 	mov	x2, #0x110                 	// #272
{
    fd8000003508:	910003fd 	mov	x29, sp
    fd800000350c:	a90153f3 	stp	x19, x20, [sp, #16]
    fd8000003510:	aa0103f4 	mov	x20, x1
    memset(&vcpu->regs, 0, sizeof(struct arch_regs));
    fd8000003514:	52800001 	mov	w1, #0x0                   	// #0
{
    fd8000003518:	aa0003f3 	mov	x19, x0
    memset(&vcpu->regs, 0, sizeof(struct arch_regs));
    fd800000351c:	91004000 	add	x0, x0, #0x10
    fd8000003520:	94001584 	bl	fd8000008b30 <memset>

    vcpu_subarch_reset(vcpu);
    fd8000003524:	aa1303e0 	mov	x0, x19
    fd8000003528:	97fff8d2 	bl	fd8000001870 <vcpu_subarch_reset>

    vcpu_writepc(vcpu, entry);
    fd800000352c:	aa1303e0 	mov	x0, x19
    fd8000003530:	aa1403e1 	mov	x1, x20
    fd8000003534:	97fff8cb 	bl	fd8000001860 <vcpu_writepc>
SYSREG_GEN_ACCESSORS(cntvoff_el2);
    fd8000003538:	d2800000 	mov	x0, #0x0                   	// #0
    fd800000353c:	d51ce060 	msr	cntvoff_el2, x0
SYSREG_GEN_ACCESSORS(sctlr_el1);
    fd8000003540:	d2810601 	mov	x1, #0x830                 	// #2096
    fd8000003544:	f2a618a1 	movk	x1, #0x30c5, lsl #16
    fd8000003548:	d5181001 	msr	sctlr_el1, x1
SYSREG_GEN_ACCESSORS(cntkctl_el1);
    fd800000354c:	d518e100 	msr	cntkctl_el1, x0
SYSREG_GEN_ACCESSORS(pmcr_el0);
    fd8000003550:	d51b9c00 	msr	pmcr_el0, x0

    /**
     *  TODO: ARMv8-A ARM mentions another implementation optional registers that reset to a known
     * value.
     */
}
    fd8000003554:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd8000003558:	a8c27bfd 	ldp	x29, x30, [sp], #32
    fd800000355c:	d65f03c0 	ret

0000fd8000003560 <vcpu_arch_run>:
    return vcpu->arch.psci_ctx.state == ON;
}

void vcpu_arch_run(struct vcpu* vcpu)
{
    if (vcpu_psci_state_on(vcpu)) {
    fd8000003560:	b9497000 	ldr	w0, [x0, #2416]
    fd8000003564:	35000040 	cbnz	w0, fd800000356c <vcpu_arch_run+0xc>
        vcpu_arch_entry();
    fd8000003568:	17fff4a6 	b	fd8000000800 <vcpu_arch_entry>
    } else {
        cpu_idle();
    fd800000356c:	14001dd1 	b	fd800000acb0 <cpu_idle>

0000fd8000003570 <sysreg_handler>:
        return (regaddr_t)UNDEFINED_REG_ADDR;
    }
}

void sysreg_handler(unsigned long iss, unsigned long far, unsigned long il, unsigned long ec)
{
    fd8000003570:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
    regaddr_t reg_addr = UNDEFINED_REG_ADDR;
    if (ec == ESR_EC_RG_64) {
    fd8000003574:	f100107f 	cmp	x3, #0x4
{
    fd8000003578:	910003fd 	mov	x29, sp
    fd800000357c:	a90153f3 	stp	x19, x20, [sp, #16]
    fd8000003580:	aa0003f3 	mov	x19, x0
    fd8000003584:	a9025bf5 	stp	x21, x22, [sp, #32]
    fd8000003588:	aa0303f5 	mov	x21, x3
    fd800000358c:	aa0203f6 	mov	x22, x2
    fd8000003590:	f9001bf7 	str	x23, [sp, #48]
    if (ec == ESR_EC_RG_64) {
    fd8000003594:	540005c0 	b.eq	fd800000364c <sysreg_handler+0xdc>  // b.none
        reg_addr = reg_addr_translate(iss);
    } else {
        reg_addr = (iss & ESR_ISS_SYSREG_ADDR_32) | OP0_MRS_CP15;
    }

    emul_handler_t handler = vm_emul_get_reg(cpu()->vcpu->vm, reg_addr);
    fd8000003598:	d2dfc017 	mov	x23, #0xfe0000000000        	// #279275953455104
        reg_addr = (iss & ESR_ISS_SYSREG_ADDR_32) | OP0_MRS_CP15;
    fd800000359c:	927f4814 	and	x20, x0, #0xffffe
    fd80000035a0:	9276ea94 	and	x20, x20, #0xfffffffffffffc1f
    emul_handler_t handler = vm_emul_get_reg(cpu()->vcpu->vm, reg_addr);
    fd80000035a4:	f9402ae0 	ldr	x0, [x23, #80]
        reg_addr = (iss & ESR_ISS_SYSREG_ADDR_32) | OP0_MRS_CP15;
    fd80000035a8:	b26c0694 	orr	x20, x20, #0x300000
    emul_handler_t handler = vm_emul_get_reg(cpu()->vcpu->vm, reg_addr);
    fd80000035ac:	aa1403e1 	mov	x1, x20
    fd80000035b0:	f944c800 	ldr	x0, [x0, #2448]
    fd80000035b4:	940021d3 	bl	fd800000bd00 <vm_emul_get_reg>
    fd80000035b8:	aa0003e1 	mov	x1, x0
    if (handler != NULL) {
    fd80000035bc:	b4000640 	cbz	x0, fd8000003684 <sysreg_handler+0x114>
        emul.width = 8;
        emul.write = iss & ESR_ISS_SYSREG_DIR ? false : true;
        emul.reg = bit64_extract(iss, ESR_ISS_SYSREG_REG_OFF, ESR_ISS_SYSREG_REG_LEN);
        emul.reg_high = bit64_extract(iss, ESR_ISS_SYSREG_REG2_OFF, ESR_ISS_SYSREG_REG2_LEN);
        emul.reg_width = 8;
        emul.multi_reg = (ec == ESR_EC_RG_64) ? true : false;
    fd80000035c0:	f10012bf 	cmp	x21, #0x4
        emul.write = iss & ESR_ISS_SYSREG_DIR ? false : true;
    fd80000035c4:	aa3303e0 	mvn	x0, x19
        emul.multi_reg = (ec == ESR_EC_RG_64) ? true : false;
    fd80000035c8:	1a9f17e3 	cset	w3, eq	// eq = none
    fd80000035cc:	d3452664 	ubfx	x4, x19, #5, #5
        emul.write = iss & ESR_ISS_SYSREG_DIR ? false : true;
    fd80000035d0:	12000000 	and	w0, w0, #0x1
        emul.width = 8;
    fd80000035d4:	d2800102 	mov	x2, #0x8                   	// #8
    fd80000035d8:	d34a3a73 	ubfx	x19, x19, #10, #5
        emul.addr = reg_addr;
    fd80000035dc:	f90027f4 	str	x20, [sp, #72]
        emul.write = iss & ESR_ISS_SYSREG_DIR ? false : true;
    fd80000035e0:	390143e0 	strb	w0, [sp, #80]
        emul.sign_ext = false;

        if (handler(&emul)) {
    fd80000035e4:	910123e0 	add	x0, sp, #0x48
        emul.sign_ext = false;
    fd80000035e8:	390147ff 	strb	wzr, [sp, #81]
        emul.reg = bit64_extract(iss, ESR_ISS_SYSREG_REG_OFF, ESR_ISS_SYSREG_REG_LEN);
    fd80000035ec:	a90593e2 	stp	x2, x4, [sp, #88]
        emul.reg_high = bit64_extract(iss, ESR_ISS_SYSREG_REG2_OFF, ESR_ISS_SYSREG_REG2_LEN);
    fd80000035f0:	f90037f3 	str	x19, [sp, #104]
        emul.multi_reg = (ec == ESR_EC_RG_64) ? true : false;
    fd80000035f4:	3901c3e3 	strb	w3, [sp, #112]
        emul.reg_width = 8;
    fd80000035f8:	f9003fe2 	str	x2, [sp, #120]
        if (handler(&emul)) {
    fd80000035fc:	d63f0020 	blr	x1
    fd8000003600:	360001c0 	tbz	w0, #0, fd8000003638 <sysreg_handler+0xc8>
            unsigned long pc_step = 2 + (2 * il);
            vcpu_writepc(cpu()->vcpu, vcpu_readpc(cpu()->vcpu) + pc_step);
    fd8000003604:	f9402af3 	ldr	x19, [x23, #80]
            unsigned long pc_step = 2 + (2 * il);
    fd8000003608:	910006d6 	add	x22, x22, #0x1
            vcpu_writepc(cpu()->vcpu, vcpu_readpc(cpu()->vcpu) + pc_step);
    fd800000360c:	aa1303e0 	mov	x0, x19
    fd8000003610:	97fff890 	bl	fd8000001850 <vcpu_readpc>
    fd8000003614:	aa0003e1 	mov	x1, x0
    fd8000003618:	aa1303e0 	mov	x0, x19
    fd800000361c:	8b160421 	add	x1, x1, x22, lsl #1
    fd8000003620:	97fff890 	bl	fd8000001860 <vcpu_writepc>
        }
    } else {
        ERROR("no emulation handler for register access (0x%x at 0x%x)", reg_addr,
            vcpu_readpc(cpu()->vcpu));
    }
}
    fd8000003624:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd8000003628:	a9425bf5 	ldp	x21, x22, [sp, #32]
    fd800000362c:	f9401bf7 	ldr	x23, [sp, #48]
    fd8000003630:	a8c87bfd 	ldp	x29, x30, [sp], #128
    fd8000003634:	d65f03c0 	ret
            ERROR("register access emulation failed (0x%x)", reg_addr);
    fd8000003638:	90000000 	adrp	x0, fd8000003000 <cache_arch_enumerate+0x30>
    fd800000363c:	aa1403e1 	mov	x1, x20
    fd8000003640:	f9435400 	ldr	x0, [x0, #1704]
    fd8000003644:	94002277 	bl	fd800000c020 <console_printk>
    fd8000003648:	14000000 	b	fd8000003648 <sysreg_handler+0xd8>
    iss &= ESR_ISS_SYSREG_ADDR_64;
    fd800000364c:	927f4800 	and	x0, x0, #0xffffe
    emul_handler_t handler = vm_emul_get_reg(cpu()->vcpu->vm, reg_addr);
    fd8000003650:	d2dfc017 	mov	x23, #0xfe0000000000        	// #279275953455104
    iss &= ESR_ISS_SYSREG_ADDR_64;
    fd8000003654:	9270d000 	and	x0, x0, #0xffffffffffff001f
        return (regaddr_t)ICC_SGI1R_ADDR;
    fd8000003658:	b2407ff4 	mov	x20, #0xffffffff            	// #4294967295
    fd800000365c:	f100601f 	cmp	x0, #0x18
    fd8000003660:	d28602c1 	mov	x1, #0x3016                	// #12310
    fd8000003664:	f2a00741 	movk	x1, #0x3a, lsl #16
    fd8000003668:	9a811294 	csel	x20, x20, x1, ne	// ne = any
    emul_handler_t handler = vm_emul_get_reg(cpu()->vcpu->vm, reg_addr);
    fd800000366c:	f9402ae0 	ldr	x0, [x23, #80]
    fd8000003670:	aa1403e1 	mov	x1, x20
    fd8000003674:	f944c800 	ldr	x0, [x0, #2448]
    fd8000003678:	940021a2 	bl	fd800000bd00 <vm_emul_get_reg>
    fd800000367c:	aa0003e1 	mov	x1, x0
    if (handler != NULL) {
    fd8000003680:	b5fffa00 	cbnz	x0, fd80000035c0 <sysreg_handler+0x50>
        ERROR("no emulation handler for register access (0x%x at 0x%x)", reg_addr,
    fd8000003684:	f9402ae0 	ldr	x0, [x23, #80]
    fd8000003688:	97fff872 	bl	fd8000001850 <vcpu_readpc>
    fd800000368c:	aa0003e2 	mov	x2, x0
    fd8000003690:	90000003 	adrp	x3, fd8000003000 <cache_arch_enumerate+0x30>
    fd8000003694:	aa1403e1 	mov	x1, x20
    fd8000003698:	f9435860 	ldr	x0, [x3, #1712]
    fd800000369c:	94002261 	bl	fd800000c020 <console_printk>
    fd80000036a0:	14000000 	b	fd80000036a0 <sysreg_handler+0x130>
    fd80000036a4:	d503201f 	nop
    fd80000036a8:	000104a0 	.word	0x000104a0
    fd80000036ac:	0000fd80 	.word	0x0000fd80
    fd80000036b0:	000104d8 	.word	0x000104d8
    fd80000036b4:	0000fd80 	.word	0x0000fd80
    fd80000036b8:	d503201f 	nop
    fd80000036bc:	d503201f 	nop

0000fd80000036c0 <aborts_data_lower>:
{
    fd80000036c0:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
    fd80000036c4:	910003fd 	mov	x29, sp
    fd80000036c8:	a90153f3 	stp	x19, x20, [sp, #16]
    fd80000036cc:	aa0003f3 	mov	x19, x0
    if (!(iss & ESR_ISS_DA_ISV_BIT) || (iss & ESR_ISS_DA_FnV_BIT)) {
    fd80000036d0:	d2808000 	mov	x0, #0x400                 	// #1024
    fd80000036d4:	f2a02000 	movk	x0, #0x100, lsl #16
{
    fd80000036d8:	a9025bf5 	stp	x21, x22, [sp, #32]
    if (!(iss & ESR_ISS_DA_ISV_BIT) || (iss & ESR_ISS_DA_FnV_BIT)) {
    fd80000036dc:	8a000263 	and	x3, x19, x0
    fd80000036e0:	d1100000 	sub	x0, x0, #0x400
    fd80000036e4:	eb00007f 	cmp	x3, x0
    fd80000036e8:	540005e1 	b.ne	fd80000037a4 <aborts_data_lower+0xe4>  // b.any
    if (DSFC != ESR_ISS_DA_DSFC_TRNSLT && DSFC != ESR_ISS_DA_DSFC_PERMIS) {
    fd80000036ec:	d2800680 	mov	x0, #0x34                  	// #52
    fd80000036f0:	8a000260 	and	x0, x19, x0
    fd80000036f4:	f100101f 	cmp	x0, #0x4
    fd80000036f8:	540004e1 	b.ne	fd8000003794 <aborts_data_lower+0xd4>  // b.any
    emul_handler_t handler = vm_emul_get_mem(cpu()->vcpu->vm, addr);
    fd80000036fc:	d2dfc016 	mov	x22, #0xfe0000000000        	// #279275953455104
    fd8000003700:	aa0103f4 	mov	x20, x1
    fd8000003704:	aa0203f5 	mov	x21, x2
    fd8000003708:	f9402ac0 	ldr	x0, [x22, #80]
    fd800000370c:	f944c800 	ldr	x0, [x0, #2448]
    fd8000003710:	9400216c 	bl	fd800000bcc0 <vm_emul_get_mem>
    fd8000003714:	aa0003e1 	mov	x1, x0
    if (handler != NULL) {
    fd8000003718:	b4000580 	cbz	x0, fd80000037c8 <aborts_data_lower+0x108>
    fd800000371c:	d3565e60 	ubfx	x0, x19, #22, #2
    fd8000003720:	d34f3e62 	ubfx	x2, x19, #15, #1
        emul.reg_width = 4 + (4 * bit64_extract(iss, ESR_ISS_DA_SF_OFF, ESR_ISS_DA_SF_LEN));
    fd8000003724:	91000442 	add	x2, x2, #0x1
        emul.width = (1 << bit64_extract(iss, ESR_ISS_DA_SAS_OFF, ESR_ISS_DA_SAS_LEN));
    fd8000003728:	52800023 	mov	w3, #0x1                   	// #1
    fd800000372c:	1ac02063 	lsl	w3, w3, w0
        emul.write = iss & ESR_ISS_DA_WnR_BIT ? true : false;
    fd8000003730:	53061a65 	ubfx	w5, w19, #6, #1
    fd8000003734:	d3505264 	ubfx	x4, x19, #16, #5
        emul.width = (1 << bit64_extract(iss, ESR_ISS_DA_SAS_OFF, ESR_ISS_DA_SAS_LEN));
    fd8000003738:	93407c63 	sxtw	x3, w3
        emul.reg_width = 4 + (4 * bit64_extract(iss, ESR_ISS_DA_SF_OFF, ESR_ISS_DA_SF_LEN));
    fd800000373c:	d37ef442 	lsl	x2, x2, #2
        emul.sign_ext = bit64_extract(iss, ESR_ISS_DA_SSE_OFF, ESR_ISS_DA_SSE_LEN);
    fd8000003740:	53155673 	ubfx	w19, w19, #21, #1
        emul.addr = addr;
    fd8000003744:	f9001ff4 	str	x20, [sp, #56]
        if (handler(&emul)) {
    fd8000003748:	9100e3e0 	add	x0, sp, #0x38
        emul.write = iss & ESR_ISS_DA_WnR_BIT ? true : false;
    fd800000374c:	390103e5 	strb	w5, [sp, #64]
        emul.sign_ext = bit64_extract(iss, ESR_ISS_DA_SSE_OFF, ESR_ISS_DA_SSE_LEN);
    fd8000003750:	390107f3 	strb	w19, [sp, #65]
        emul.reg = bit64_extract(iss, ESR_ISS_DA_SRT_OFF, ESR_ISS_DA_SRT_LEN);
    fd8000003754:	a90493e3 	stp	x3, x4, [sp, #72]
        emul.reg_width = 4 + (4 * bit64_extract(iss, ESR_ISS_DA_SF_OFF, ESR_ISS_DA_SF_LEN));
    fd8000003758:	f90037e2 	str	x2, [sp, #104]
        if (handler(&emul)) {
    fd800000375c:	d63f0020 	blr	x1
    fd8000003760:	360002a0 	tbz	w0, #0, fd80000037b4 <aborts_data_lower+0xf4>
            vcpu_writepc(cpu()->vcpu, vcpu_readpc(cpu()->vcpu) + pc_step);
    fd8000003764:	f9402ad3 	ldr	x19, [x22, #80]
            unsigned long pc_step = 2 + (2 * il);
    fd8000003768:	910006b5 	add	x21, x21, #0x1
            vcpu_writepc(cpu()->vcpu, vcpu_readpc(cpu()->vcpu) + pc_step);
    fd800000376c:	aa1303e0 	mov	x0, x19
    fd8000003770:	97fff838 	bl	fd8000001850 <vcpu_readpc>
    fd8000003774:	aa0003e1 	mov	x1, x0
    fd8000003778:	aa1303e0 	mov	x0, x19
    fd800000377c:	8b150421 	add	x1, x1, x21, lsl #1
    fd8000003780:	97fff838 	bl	fd8000001860 <vcpu_writepc>
}
    fd8000003784:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd8000003788:	a9425bf5 	ldp	x21, x22, [sp, #32]
    fd800000378c:	a8c77bfd 	ldp	x29, x30, [sp], #112
    fd8000003790:	d65f03c0 	ret
        ERROR("data abort is not translation fault - cant deal with it");
    fd8000003794:	90000000 	adrp	x0, fd8000003000 <cache_arch_enumerate+0x30>
    fd8000003798:	f943f800 	ldr	x0, [x0, #2032]
    fd800000379c:	94002221 	bl	fd800000c020 <console_printk>
    fd80000037a0:	14000000 	b	fd80000037a0 <aborts_data_lower+0xe0>
        ERROR("no information to handle data abort (0x%x)", far);
    fd80000037a4:	90000000 	adrp	x0, fd8000003000 <cache_arch_enumerate+0x30>
    fd80000037a8:	f943f400 	ldr	x0, [x0, #2024]
    fd80000037ac:	9400221d 	bl	fd800000c020 <console_printk>
    fd80000037b0:	14000000 	b	fd80000037b0 <aborts_data_lower+0xf0>
            ERROR("data abort emulation failed (0x%x)", far);
    fd80000037b4:	90000000 	adrp	x0, fd8000003000 <cache_arch_enumerate+0x30>
    fd80000037b8:	aa1403e1 	mov	x1, x20
    fd80000037bc:	f943fc00 	ldr	x0, [x0, #2040]
    fd80000037c0:	94002218 	bl	fd800000c020 <console_printk>
    fd80000037c4:	14000000 	b	fd80000037c4 <aborts_data_lower+0x104>
        ERROR("no emulation handler for abort(0x%lx at 0x%x)", far, vcpu_readpc(cpu()->vcpu));
    fd80000037c8:	f9402ac0 	ldr	x0, [x22, #80]
    fd80000037cc:	97fff821 	bl	fd8000001850 <vcpu_readpc>
    fd80000037d0:	aa0003e2 	mov	x2, x0
    fd80000037d4:	90000003 	adrp	x3, fd8000003000 <cache_arch_enumerate+0x30>
    fd80000037d8:	aa1403e1 	mov	x1, x20
    fd80000037dc:	f9440060 	ldr	x0, [x3, #2048]
    fd80000037e0:	94002210 	bl	fd800000c020 <console_printk>
    fd80000037e4:	14000000 	b	fd80000037e4 <aborts_data_lower+0x124>
    fd80000037e8:	00010520 	.word	0x00010520
    fd80000037ec:	0000fd80 	.word	0x0000fd80
    fd80000037f0:	00010558 	.word	0x00010558
    fd80000037f4:	0000fd80 	.word	0x0000fd80
    fd80000037f8:	000105a0 	.word	0x000105a0
    fd80000037fc:	0000fd80 	.word	0x0000fd80
    fd8000003800:	000105d0 	.word	0x000105d0
    fd8000003804:	0000fd80 	.word	0x0000fd80
    fd8000003808:	d503201f 	nop
    fd800000380c:	d503201f 	nop

0000fd8000003810 <standard_service_call>:
{
    fd8000003810:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    unsigned long smc_fid = vcpu_readreg(cpu()->vcpu, 0);
    fd8000003814:	d2800001 	mov	x1, #0x0                   	// #0
{
    fd8000003818:	910003fd 	mov	x29, sp
    fd800000381c:	a90153f3 	stp	x19, x20, [sp, #16]
    unsigned long smc_fid = vcpu_readreg(cpu()->vcpu, 0);
    fd8000003820:	d2dfc014 	mov	x20, #0xfe0000000000        	// #279275953455104
    fd8000003824:	f9402a80 	ldr	x0, [x20, #80]
{
    fd8000003828:	f90013f5 	str	x21, [sp, #32]
    unsigned long smc_fid = vcpu_readreg(cpu()->vcpu, 0);
    fd800000382c:	97fff7f9 	bl	fd8000001810 <vcpu_readreg>
    fd8000003830:	aa0003f3 	mov	x19, x0
    unsigned long x1 = vcpu_readreg(cpu()->vcpu, 1);
    fd8000003834:	f9402a80 	ldr	x0, [x20, #80]
    fd8000003838:	d2800021 	mov	x1, #0x1                   	// #1
    fd800000383c:	97fff7f5 	bl	fd8000001810 <vcpu_readreg>
    fd8000003840:	aa0003f5 	mov	x21, x0
    unsigned long x2 = vcpu_readreg(cpu()->vcpu, 2);
    fd8000003844:	f9402a80 	ldr	x0, [x20, #80]
    fd8000003848:	d2800041 	mov	x1, #0x2                   	// #2
    fd800000384c:	97fff7f1 	bl	fd8000001810 <vcpu_readreg>
    fd8000003850:	aa0003e2 	mov	x2, x0
    unsigned long x3 = vcpu_readreg(cpu()->vcpu, 3);
    fd8000003854:	f9402a80 	ldr	x0, [x20, #80]
    fd8000003858:	d2800061 	mov	x1, #0x3                   	// #3
    unsigned long x2 = vcpu_readreg(cpu()->vcpu, 2);
    fd800000385c:	aa0203f4 	mov	x20, x2
    unsigned long x3 = vcpu_readreg(cpu()->vcpu, 3);
    fd8000003860:	97fff7ec 	bl	fd8000001810 <vcpu_readreg>
    fd8000003864:	aa0003e3 	mov	x3, x0
    if (is_psci_fid(smc_fid)) {
    fd8000003868:	d2b7e004 	mov	x4, #0xbf000000            	// #3204448256
    fd800000386c:	8a040264 	and	x4, x19, x4
    fd8000003870:	d2b08000 	mov	x0, #0x84000000            	// #2214592512
    fd8000003874:	eb00009f 	cmp	x4, x0
    fd8000003878:	54000181 	b.ne	fd80000038a8 <standard_service_call+0x98>  // b.any
    fd800000387c:	f27b2a7f 	tst	x19, #0xffe0
    fd8000003880:	54000141 	b.ne	fd80000038a8 <standard_service_call+0x98>  // b.any
        ret = psci_smc_handler(smc_fid, x1, x2, x3);
    fd8000003884:	aa1403e2 	mov	x2, x20
    fd8000003888:	aa1503e1 	mov	x1, x21
    fd800000388c:	2a1303e0 	mov	w0, w19
    fd8000003890:	94000e0c 	bl	fd80000070c0 <psci_smc_handler>
    fd8000003894:	93407c00 	sxtw	x0, w0
}
    fd8000003898:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd800000389c:	f94013f5 	ldr	x21, [sp, #32]
    fd80000038a0:	a8c37bfd 	ldp	x29, x30, [sp], #48
    fd80000038a4:	d65f03c0 	ret
        INFO("unknown smc_fid 0x%lx", smc_fid);
    fd80000038a8:	90000000 	adrp	x0, fd8000003000 <cache_arch_enumerate+0x30>
    fd80000038ac:	aa1303e1 	mov	x1, x19
    fd80000038b0:	f9446000 	ldr	x0, [x0, #2240]
    fd80000038b4:	940021db 	bl	fd800000c020 <console_printk>
    int64_t ret = -1;
    fd80000038b8:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    return ret;
    fd80000038bc:	17fffff7 	b	fd8000003898 <standard_service_call+0x88>
    fd80000038c0:	00010610 	.word	0x00010610
    fd80000038c4:	0000fd80 	.word	0x0000fd80
    fd80000038c8:	d503201f 	nop
    fd80000038cc:	d503201f 	nop

0000fd80000038d0 <smc_handler>:
{
    fd80000038d0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    unsigned long fid = vcpu_readreg(cpu()->vcpu, 0);
    fd80000038d4:	d2dfc000 	mov	x0, #0xfe0000000000        	// #279275953455104
    fd80000038d8:	d2800001 	mov	x1, #0x0                   	// #0
{
    fd80000038dc:	910003fd 	mov	x29, sp
    unsigned long fid = vcpu_readreg(cpu()->vcpu, 0);
    fd80000038e0:	f9402800 	ldr	x0, [x0, #80]
{
    fd80000038e4:	f9000bf3 	str	x19, [sp, #16]
    unsigned long fid = vcpu_readreg(cpu()->vcpu, 0);
    fd80000038e8:	97fff7ca 	bl	fd8000001810 <vcpu_readreg>
    switch (fid & ~SMCC_FID_FN_NUM_MSK) {
    fd80000038ec:	9270bc01 	and	x1, x0, #0xffffffffffff0000
    fd80000038f0:	d2b88002 	mov	x2, #0xc4000000            	// #3288334336
    fd80000038f4:	eb02003f 	cmp	x1, x2
    fd80000038f8:	54000420 	b.eq	fd800000397c <smc_handler+0xac>  // b.none
    fd80000038fc:	540002e8 	b.hi	fd8000003958 <smc_handler+0x88>  // b.pmore
    fd8000003900:	d2b08002 	mov	x2, #0x84000000            	// #2214592512
    fd8000003904:	eb02003f 	cmp	x1, x2
    fd8000003908:	540003a0 	b.eq	fd800000397c <smc_handler+0xac>  // b.none
    fd800000390c:	d2b0c002 	mov	x2, #0x86000000            	// #2248146944
    fd8000003910:	eb02003f 	cmp	x1, x2
    fd8000003914:	54000281 	b.ne	fd8000003964 <smc_handler+0x94>  // b.any
            ret = hypercall(fid & SMCC_FID_FN_NUM_MSK);
    fd8000003918:	92403c00 	and	x0, x0, #0xffff
    fd800000391c:	940023b1 	bl	fd800000c7e0 <hypercall>
    fd8000003920:	aa0003e2 	mov	x2, x0
    vcpu_writereg(cpu()->vcpu, 0, ret);
    fd8000003924:	d2dfc013 	mov	x19, #0xfe0000000000        	// #279275953455104
    fd8000003928:	d2800001 	mov	x1, #0x0                   	// #0
    fd800000392c:	f9402a60 	ldr	x0, [x19, #80]
    fd8000003930:	97fff7c0 	bl	fd8000001830 <vcpu_writereg>
    vcpu_writepc(cpu()->vcpu, vcpu_readpc(cpu()->vcpu) + 4);
    fd8000003934:	f9402a73 	ldr	x19, [x19, #80]
    fd8000003938:	aa1303e0 	mov	x0, x19
    fd800000393c:	97fff7c5 	bl	fd8000001850 <vcpu_readpc>
    fd8000003940:	aa0003e1 	mov	x1, x0
    fd8000003944:	aa1303e0 	mov	x0, x19
}
    fd8000003948:	f9400bf3 	ldr	x19, [sp, #16]
    vcpu_writepc(cpu()->vcpu, vcpu_readpc(cpu()->vcpu) + 4);
    fd800000394c:	91001021 	add	x1, x1, #0x4
}
    fd8000003950:	a8c27bfd 	ldp	x29, x30, [sp], #32
    vcpu_writepc(cpu()->vcpu, vcpu_readpc(cpu()->vcpu) + 4);
    fd8000003954:	17fff7c3 	b	fd8000001860 <vcpu_writepc>
    switch (fid & ~SMCC_FID_FN_NUM_MSK) {
    fd8000003958:	d2b8c002 	mov	x2, #0xc6000000            	// #3321888768
    fd800000395c:	eb02003f 	cmp	x1, x2
    fd8000003960:	54fffdc0 	b.eq	fd8000003918 <smc_handler+0x48>  // b.none
            WARNING("Unknown system call fid 0x%x", fid);
    fd8000003964:	90000002 	adrp	x2, fd8000003000 <cache_arch_enumerate+0x30>
    fd8000003968:	aa0003e1 	mov	x1, x0
    fd800000396c:	f944c440 	ldr	x0, [x2, #2440]
    fd8000003970:	940021ac 	bl	fd800000c020 <console_printk>
    fd8000003974:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
    fd8000003978:	17ffffeb 	b	fd8000003924 <smc_handler+0x54>
            ret = standard_service_call(fid);
    fd800000397c:	97ffffa5 	bl	fd8000003810 <standard_service_call>
    fd8000003980:	aa0003e2 	mov	x2, x0
            break;
    fd8000003984:	17ffffe8 	b	fd8000003924 <smc_handler+0x54>
    fd8000003988:	00010638 	.word	0x00010638
    fd800000398c:	0000fd80 	.word	0x0000fd80

0000fd8000003990 <hvc_handler>:
{
    fd8000003990:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    unsigned long fid = vcpu_readreg(cpu()->vcpu, 0);
    fd8000003994:	d2dfc000 	mov	x0, #0xfe0000000000        	// #279275953455104
    fd8000003998:	d2800001 	mov	x1, #0x0                   	// #0
{
    fd800000399c:	910003fd 	mov	x29, sp
    unsigned long fid = vcpu_readreg(cpu()->vcpu, 0);
    fd80000039a0:	f9402800 	ldr	x0, [x0, #80]
    fd80000039a4:	97fff79b 	bl	fd8000001810 <vcpu_readreg>
    switch (fid & ~SMCC_FID_FN_NUM_MSK) {
    fd80000039a8:	9270bc01 	and	x1, x0, #0xffffffffffff0000
    fd80000039ac:	d2b88002 	mov	x2, #0xc4000000            	// #3288334336
    fd80000039b0:	eb02003f 	cmp	x1, x2
    fd80000039b4:	540003a0 	b.eq	fd8000003a28 <hvc_handler+0x98>  // b.none
    fd80000039b8:	540001e8 	b.hi	fd80000039f4 <hvc_handler+0x64>  // b.pmore
    fd80000039bc:	d2b08002 	mov	x2, #0x84000000            	// #2214592512
    fd80000039c0:	eb02003f 	cmp	x1, x2
    fd80000039c4:	54000320 	b.eq	fd8000003a28 <hvc_handler+0x98>  // b.none
    fd80000039c8:	d2b0c002 	mov	x2, #0x86000000            	// #2248146944
    fd80000039cc:	eb02003f 	cmp	x1, x2
    fd80000039d0:	54000181 	b.ne	fd8000003a00 <hvc_handler+0x70>  // b.any
            ret = hypercall(fid & SMCC_FID_FN_NUM_MSK);
    fd80000039d4:	92403c00 	and	x0, x0, #0xffff
    fd80000039d8:	94002382 	bl	fd800000c7e0 <hypercall>
}
    fd80000039dc:	a8c17bfd 	ldp	x29, x30, [sp], #16
            ret = hypercall(fid & SMCC_FID_FN_NUM_MSK);
    fd80000039e0:	aa0003e2 	mov	x2, x0
    vcpu_writereg(cpu()->vcpu, 0, ret);
    fd80000039e4:	d2dfc000 	mov	x0, #0xfe0000000000        	// #279275953455104
    fd80000039e8:	d2800001 	mov	x1, #0x0                   	// #0
    fd80000039ec:	f9402800 	ldr	x0, [x0, #80]
    fd80000039f0:	17fff790 	b	fd8000001830 <vcpu_writereg>
    switch (fid & ~SMCC_FID_FN_NUM_MSK) {
    fd80000039f4:	d2b8c002 	mov	x2, #0xc6000000            	// #3321888768
    fd80000039f8:	eb02003f 	cmp	x1, x2
    fd80000039fc:	54fffec0 	b.eq	fd80000039d4 <hvc_handler+0x44>  // b.none
            WARNING("Unknown system call fid 0x%x", fid);
    fd8000003a00:	90000002 	adrp	x2, fd8000003000 <cache_arch_enumerate+0x30>
    fd8000003a04:	aa0003e1 	mov	x1, x0
    fd8000003a08:	f9452440 	ldr	x0, [x2, #2632]
    fd8000003a0c:	94002185 	bl	fd800000c020 <console_printk>
}
    fd8000003a10:	a8c17bfd 	ldp	x29, x30, [sp], #16
    vcpu_writereg(cpu()->vcpu, 0, ret);
    fd8000003a14:	d2dfc000 	mov	x0, #0xfe0000000000        	// #279275953455104
            WARNING("Unknown system call fid 0x%x", fid);
    fd8000003a18:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
    vcpu_writereg(cpu()->vcpu, 0, ret);
    fd8000003a1c:	d2800001 	mov	x1, #0x0                   	// #0
    fd8000003a20:	f9402800 	ldr	x0, [x0, #80]
    fd8000003a24:	17fff783 	b	fd8000001830 <vcpu_writereg>
            ret = standard_service_call(fid);
    fd8000003a28:	97ffff7a 	bl	fd8000003810 <standard_service_call>
    fd8000003a2c:	aa0003e2 	mov	x2, x0
}
    fd8000003a30:	a8c17bfd 	ldp	x29, x30, [sp], #16
    vcpu_writereg(cpu()->vcpu, 0, ret);
    fd8000003a34:	d2dfc000 	mov	x0, #0xfe0000000000        	// #279275953455104
    fd8000003a38:	d2800001 	mov	x1, #0x0                   	// #0
    fd8000003a3c:	f9402800 	ldr	x0, [x0, #80]
    fd8000003a40:	17fff77c 	b	fd8000001830 <vcpu_writereg>
    fd8000003a44:	d503201f 	nop
    fd8000003a48:	00010638 	.word	0x00010638
    fd8000003a4c:	0000fd80 	.word	0x0000fd80

0000fd8000003a50 <aborts_sync_handler>:
SYSREG_GEN_ACCESSORS(esr_el2);
    fd8000003a50:	d53c5200 	mrs	x0, esr_el2
SYSREG_GEN_ACCESSORS(far_el2);
    fd8000003a54:	d53c6004 	mrs	x4, far_el2
SYSREG_GEN_ACCESSORS(hpfar_el2);
    fd8000003a58:	d53c6085 	mrs	x5, hpfar_el2

    unsigned long ec = bit64_extract(esr, ESR_EC_OFF, ESR_EC_LEN);
    unsigned long il = bit64_extract(esr, ESR_IL_OFF, ESR_IL_LEN);
    unsigned long iss = bit64_extract(esr, ESR_ISS_OFF, ESR_ISS_LEN);

    abort_handler_t handler = abort_handlers[ec];
    fd8000003a5c:	90000001 	adrp	x1, fd8000003000 <cache_arch_enumerate+0x30>
    fd8000003a60:	f9455426 	ldr	x6, [x1, #2728]
    fd8000003a64:	531a7c03 	lsr	w3, w0, #26
        ipa_fault_addr = (far & 0xFFF) | (hpfar << 8);
    fd8000003a68:	92402c84 	and	x4, x4, #0xfff
    fd8000003a6c:	d3596402 	ubfx	x2, x0, #25, #1
    fd8000003a70:	aa052081 	orr	x1, x4, x5, lsl #8
    abort_handler_t handler = abort_handlers[ec];
    fd8000003a74:	f86378c4 	ldr	x4, [x6, x3, lsl #3]
    if (handler) {
    fd8000003a78:	b4000084 	cbz	x4, fd8000003a88 <aborts_sync_handler+0x38>
    fd8000003a7c:	92406000 	and	x0, x0, #0x1ffffff
        handler(iss, ipa_fault_addr, il, ec);
    fd8000003a80:	aa0403f0 	mov	x16, x4
    fd8000003a84:	d61f0200 	br	x16
{
    fd8000003a88:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    } else {
        ERROR("no handler for abort ec = 0x%x", ec); // unknown guest exception
    fd8000003a8c:	90000000 	adrp	x0, fd8000003000 <cache_arch_enumerate+0x30>
    fd8000003a90:	aa0303e1 	mov	x1, x3
{
    fd8000003a94:	910003fd 	mov	x29, sp
        ERROR("no handler for abort ec = 0x%x", ec); // unknown guest exception
    fd8000003a98:	f9455800 	ldr	x0, [x0, #2736]
    fd8000003a9c:	94002161 	bl	fd800000c020 <console_printk>
    fd8000003aa0:	14000000 	b	fd8000003aa0 <aborts_sync_handler+0x50>
    fd8000003aa4:	d503201f 	nop
    fd8000003aa8:	00012148 	.word	0x00012148
    fd8000003aac:	0000fd80 	.word	0x0000fd80
    fd8000003ab0:	00010668 	.word	0x00010668
    fd8000003ab4:	0000fd80 	.word	0x0000fd80
	...

0000fd8000003ac0 <cpu_arch_init>:
SYSREG_GEN_ACCESSORS(mpidr_el1);
    fd8000003ac0:	d53800a3 	mrs	x3, mpidr_el1
cpuid_t CPU_MASTER __attribute__((section(".data")));

/* Perform architecture dependent cpu cores initializations */
void cpu_arch_init(cpuid_t cpuid, paddr_t load_addr)
{
    cpu()->arch.mpidr = sysreg_mpidr_el1_read(); //provides an aditional PE identification
    fd8000003ac4:	d2dfc002 	mov	x2, #0xfe0000000000        	// #279275953455104
    fd8000003ac8:	f9017843 	str	x3, [x2, #752]
    cpu_arch_profile_init(cpuid, load_addr);
    fd8000003acc:	17fffc21 	b	fd8000002b50 <cpu_arch_profile_init>

0000fd8000003ad0 <cpu_id_to_mpidr>:
}

unsigned long cpu_id_to_mpidr(cpuid_t id)
{
    return platform_arch_cpuid_to_mpidr(&platform, id);
    fd8000003ad0:	90000002 	adrp	x2, fd8000003000 <cache_arch_enumerate+0x30>
    fd8000003ad4:	aa0003e1 	mov	x1, x0
    fd8000003ad8:	f9457040 	ldr	x0, [x2, #2784]
    fd8000003adc:	14000015 	b	fd8000003b30 <platform_arch_cpuid_to_mpidr>
    fd8000003ae0:	00012930 	.word	0x00012930
    fd8000003ae4:	0000fd80 	.word	0x0000fd80
    fd8000003ae8:	d503201f 	nop
    fd8000003aec:	d503201f 	nop

0000fd8000003af0 <cpu_arch_idle>:
}

void cpu_arch_idle()
{
    fd8000003af0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    fd8000003af4:	910003fd 	mov	x29, sp
    cpu_arch_profile_idle();
    fd8000003af8:	97fffc4a 	bl	fd8000002c20 <cpu_arch_profile_idle>
    /*
     * In case the profile implementation does not jump to a predefined wake-up point and just
     * returns from the profile, manually rewind stack and jump to idle wake up. Therefore, we
     * should not return after this point.
     */
    asm volatile("mov sp, %0\n\r"
    fd8000003afc:	d2840000 	mov	x0, #0x2000                	// #8192
    fd8000003b00:	f2dfc000 	movk	x0, #0xfe00, lsl #32
    fd8000003b04:	9100001f 	mov	sp, x0
    fd8000003b08:	14001c76 	b	fd800000ace0 <cpu_idle_wakeup>
                 "b cpu_idle_wakeup\n\r" ::"r"(&cpu()->stack[STACK_SIZE]));

    ERROR("returned from idle wake up");
    fd8000003b0c:	90000000 	adrp	x0, fd8000003000 <cache_arch_enumerate+0x30>
    fd8000003b10:	f9459000 	ldr	x0, [x0, #2848]
    fd8000003b14:	94002143 	bl	fd800000c020 <console_printk>
    fd8000003b18:	14000000 	b	fd8000003b18 <cpu_arch_idle+0x28>
    fd8000003b1c:	d503201f 	nop
    fd8000003b20:	00010698 	.word	0x00010698
    fd8000003b24:	0000fd80 	.word	0x0000fd80
	...

0000fd8000003b30 <platform_arch_cpuid_to_mpidr>:
#include <platform.h>
#include <arch/sysregs.h>

unsigned long platform_arch_cpuid_to_mpidr(const struct platform* plat, cpuid_t cpuid)
{
    if (cpuid > plat->cpu_num) {
    fd8000003b30:	f9400006 	ldr	x6, [x0]
    fd8000003b34:	eb0100df 	cmp	x6, x1
    fd8000003b38:	54000403 	b.cc	fd8000003bb8 <platform_arch_cpuid_to_mpidr+0x88>  // b.lo, b.ul, b.last
        return ~(~MPIDR_RES1 & MPIDR_RES0_MSK); // return an invlid mpidr by inverting res bits
    }

    unsigned long mpidr = 0;
    bool found = false;
    if (plat->arch.clusters.num > 0) {
    fd8000003b3c:	f9413404 	ldr	x4, [x0, #616]
    fd8000003b40:	b4000324 	cbz	x4, fd8000003ba4 <platform_arch_cpuid_to_mpidr+0x74>
        for (size_t i = 0, j = 0; i < plat->arch.clusters.num; i++) {
            if (cpuid < (j + plat->arch.clusters.core_num[i])) {
    fd8000003b44:	f9413805 	ldr	x5, [x0, #624]
    fd8000003b48:	d2800002 	mov	x2, #0x0                   	// #0
    fd8000003b4c:	f94000a3 	ldr	x3, [x5]
    fd8000003b50:	eb03003f 	cmp	x1, x3
    fd8000003b54:	540000e2 	b.cs	fd8000003b70 <platform_arch_cpuid_to_mpidr+0x40>  // b.hs, b.nlast
    fd8000003b58:	14000011 	b	fd8000003b9c <platform_arch_cpuid_to_mpidr+0x6c>
    fd8000003b5c:	f86278a0 	ldr	x0, [x5, x2, lsl #3]
    fd8000003b60:	8b000060 	add	x0, x3, x0
    fd8000003b64:	eb01001f 	cmp	x0, x1
    fd8000003b68:	54000168 	b.hi	fd8000003b94 <platform_arch_cpuid_to_mpidr+0x64>  // b.pmore
    fd8000003b6c:	aa0003e3 	mov	x3, x0
        for (size_t i = 0, j = 0; i < plat->arch.clusters.num; i++) {
    fd8000003b70:	91000442 	add	x2, x2, #0x1
    fd8000003b74:	eb02009f 	cmp	x4, x2
    fd8000003b78:	54ffff21 	b.ne	fd8000003b5c <platform_arch_cpuid_to_mpidr+0x2c>  // b.any
{
    fd8000003b7c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    fd8000003b80:	910003fd 	mov	x29, sp

            j += plat->arch.clusters.core_num[i];
        }

        if (!found) {
            ERROR("failed cpuid to mpidr translation");
    fd8000003b84:	90000000 	adrp	x0, fd8000003000 <cache_arch_enumerate+0x30>
    fd8000003b88:	f945e400 	ldr	x0, [x0, #3016]
    fd8000003b8c:	94002125 	bl	fd800000c020 <console_printk>
    fd8000003b90:	14000000 	b	fd8000003b90 <platform_arch_cpuid_to_mpidr+0x60>
                mpidr = (i << 8) | ((cpuid - j) & 0xff);
    fd8000003b94:	d378dc42 	lsl	x2, x2, #8
    fd8000003b98:	cb030021 	sub	x1, x1, x3
    fd8000003b9c:	92401c21 	and	x1, x1, #0xff
    fd8000003ba0:	aa020021 	orr	x1, x1, x2
         * No cluster information in configuration. Assume a singl cluster.
         */
        mpidr = cpuid;
    }

    mpidr |= MPIDR_RES1;
    fd8000003ba4:	f10004df 	cmp	x6, #0x1
    fd8000003ba8:	b2610020 	orr	x0, x1, #0x80000000
    fd8000003bac:	b2620421 	orr	x1, x1, #0xc0000000
    fd8000003bb0:	9a800020 	csel	x0, x1, x0, eq	// eq = none
    fd8000003bb4:	d65f03c0 	ret
        return ~(~MPIDR_RES1 & MPIDR_RES0_MSK); // return an invlid mpidr by inverting res bits
    fd8000003bb8:	929fffe0 	mov	x0, #0xffffffffffff0000    	// #-65536
    fd8000003bbc:	f2b7c000 	movk	x0, #0xbe00, lsl #16
    if (plat->cpu_num == 1) {
        mpidr |= MPIDR_U_BIT;
    }

    return mpidr;
}
    fd8000003bc0:	d65f03c0 	ret
    fd8000003bc4:	d503201f 	nop
    fd8000003bc8:	000106c0 	.word	0x000106c0
    fd8000003bcc:	0000fd80 	.word	0x0000fd80

0000fd8000003bd0 <gicd_init>:

volatile struct gicd_hw* gicd;
spinlock_t gicd_lock;

void gicd_init()
{
    fd8000003bd0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
size_t gich_num_lrs();

static inline size_t gic_num_irqs()
{
    size_t itlinenumber = bit32_extract(gicd->TYPER, GICD_TYPER_ITLN_OFF, GICD_TYPER_ITLN_LEN);
    return 32 * itlinenumber + 1;
    fd8000003bd4:	d2800021 	mov	x1, #0x1                   	// #1
    fd8000003bd8:	910003fd 	mov	x29, sp
    size_t itlinenumber = bit32_extract(gicd->TYPER, GICD_TYPER_ITLN_OFF, GICD_TYPER_ITLN_LEN);
    fd8000003bdc:	90000000 	adrp	x0, fd8000003000 <cache_arch_enumerate+0x30>
    fd8000003be0:	f9465800 	ldr	x0, [x0, #3248]
    fd8000003be4:	f9400002 	ldr	x2, [x0]
    fd8000003be8:	b9400444 	ldr	w4, [x2, #4]
    return 32 * itlinenumber + 1;
    fd8000003bec:	d37b1084 	ubfiz	x4, x4, #5, #5
    size_t int_num = gic_num_irqs();

    /* Bring distributor to known state */
    for (size_t i = GIC_NUM_PRIVINT_REGS; i < GIC_NUM_INT_REGS(int_num); i++) {
    fd8000003bf0:	f100809f 	cmp	x4, #0x20
    fd8000003bf4:	8b010085 	add	x5, x4, x1
    fd8000003bf8:	540002a9 	b.ls	fd8000003c4c <gicd_init+0x7c>  // b.plast
    fd8000003bfc:	d345fc84 	lsr	x4, x4, #5
        /**
         * Make sure all interrupts are not enabled, non pending, non active.
         */
        gicd->IGROUPR[i] = -1;
    fd8000003c00:	12800003 	mov	w3, #0xffffffff            	// #-1
    fd8000003c04:	d503201f 	nop
    fd8000003c08:	8b010840 	add	x0, x2, x1, lsl #2
    for (size_t i = GIC_NUM_PRIVINT_REGS; i < GIC_NUM_INT_REGS(int_num); i++) {
    fd8000003c0c:	91000421 	add	x1, x1, #0x1
    fd8000003c10:	eb04003f 	cmp	x1, x4
        gicd->IGROUPR[i] = -1;
    fd8000003c14:	b9008003 	str	w3, [x0, #128]
        gicd->ICENABLER[i] = -1;
    fd8000003c18:	b9018003 	str	w3, [x0, #384]
        gicd->ICPENDR[i] = -1;
    fd8000003c1c:	b9028003 	str	w3, [x0, #640]
        gicd->ICACTIVER[i] = -1;
    fd8000003c20:	b9038003 	str	w3, [x0, #896]
    for (size_t i = GIC_NUM_PRIVINT_REGS; i < GIC_NUM_INT_REGS(int_num); i++) {
    fd8000003c24:	54ffff21 	b.ne	fd8000003c08 <gicd_init+0x38>  // b.any
    }

    /* All interrupts have lowest priority possible by default */
    for (size_t i = GIC_NUM_PRIO_REGS(GIC_CPU_PRIV); i < GIC_NUM_PRIO_REGS(int_num); i++) {
    fd8000003c28:	d342fca3 	lsr	x3, x5, #2
    fd8000003c2c:	d2800100 	mov	x0, #0x8                   	// #8
        gicd->IPRIORITYR[i] = -1;
    fd8000003c30:	12800004 	mov	w4, #0xffffffff            	// #-1
    fd8000003c34:	d503201f 	nop
    fd8000003c38:	8b000841 	add	x1, x2, x0, lsl #2
    for (size_t i = GIC_NUM_PRIO_REGS(GIC_CPU_PRIV); i < GIC_NUM_PRIO_REGS(int_num); i++) {
    fd8000003c3c:	91000400 	add	x0, x0, #0x1
    fd8000003c40:	eb03001f 	cmp	x0, x3
        gicd->IPRIORITYR[i] = -1;
    fd8000003c44:	b9040024 	str	w4, [x1, #1024]
    for (size_t i = GIC_NUM_PRIO_REGS(GIC_CPU_PRIV); i < GIC_NUM_PRIO_REGS(int_num); i++) {
    fd8000003c48:	54ffff81 	b.ne	fd8000003c38 <gicd_init+0x68>  // b.any

        /* Enable distributor */
        gicd->CTLR |= GICD_CTLR_EN_BIT;

    } else {
        for (size_t i = GIC_CPU_PRIV; i < GIC_MAX_INTERUPTS; i++) {
    fd8000003c4c:	d2800400 	mov	x0, #0x20                  	// #32
            gicd->IROUTER[i] = GICD_IROUTER_INV;
    fd8000003c50:	929fffe3 	mov	x3, #0xffffffffffff0000    	// #-65536
    fd8000003c54:	d503201f 	nop
    fd8000003c58:	8b000c41 	add	x1, x2, x0, lsl #3
        for (size_t i = GIC_CPU_PRIV; i < GIC_MAX_INTERUPTS; i++) {
    fd8000003c5c:	91000400 	add	x0, x0, #0x1
    fd8000003c60:	f110001f 	cmp	x0, #0x400
            gicd->IROUTER[i] = GICD_IROUTER_INV;
    fd8000003c64:	f9300023 	str	x3, [x1, #24576]
        for (size_t i = GIC_CPU_PRIV; i < GIC_MAX_INTERUPTS; i++) {
    fd8000003c68:	54ffff81 	b.ne	fd8000003c58 <gicd_init+0x88>  // b.any

    /* ICFGR are platform dependent, lets leave them as is */

    /* No need to setup gicd->NSACR as all interrupts are  setup to group 1 */

    if (!interrupts_reserve(platform.arch.gic.maintenance_id, gic_maintenance_handler)) {
    fd8000003c6c:	90000000 	adrp	x0, fd8000003000 <cache_arch_enumerate+0x30>
    fd8000003c70:	f9466000 	ldr	x0, [x0, #3264]
    fd8000003c74:	90000001 	adrp	x1, fd8000003000 <cache_arch_enumerate+0x30>
        gicd->CTLR |= GICD_CTLR_ARE_NS_BIT | GICD_CTLR_ENA_BIT;
    fd8000003c78:	b9400043 	ldr	w3, [x2]
    fd8000003c7c:	52800244 	mov	w4, #0x12                  	// #18
    if (!interrupts_reserve(platform.arch.gic.maintenance_id, gic_maintenance_handler)) {
    fd8000003c80:	f9465c21 	ldr	x1, [x1, #3256]
        gicd->CTLR |= GICD_CTLR_ARE_NS_BIT | GICD_CTLR_ENA_BIT;
    fd8000003c84:	2a040063 	orr	w3, w3, w4
    if (!interrupts_reserve(platform.arch.gic.maintenance_id, gic_maintenance_handler)) {
    fd8000003c88:	b9424800 	ldr	w0, [x0, #584]
        gicd->CTLR |= GICD_CTLR_ARE_NS_BIT | GICD_CTLR_ENA_BIT;
    fd8000003c8c:	b9000043 	str	w3, [x2]
    if (!interrupts_reserve(platform.arch.gic.maintenance_id, gic_maintenance_handler)) {
    fd8000003c90:	94001ab4 	bl	fd800000a760 <interrupts_reserve>
    fd8000003c94:	36000060 	tbz	w0, #0, fd8000003ca0 <gicd_init+0xd0>
        ERROR("Failed to reserve GIC maintenance interrupt");
    }
}
    fd8000003c98:	a8c17bfd 	ldp	x29, x30, [sp], #16
    fd8000003c9c:	d65f03c0 	ret
        ERROR("Failed to reserve GIC maintenance interrupt");
    fd8000003ca0:	90000000 	adrp	x0, fd8000003000 <cache_arch_enumerate+0x30>
    fd8000003ca4:	f9466400 	ldr	x0, [x0, #3272]
    fd8000003ca8:	940020de 	bl	fd800000c020 <console_printk>
    fd8000003cac:	14000000 	b	fd8000003cac <gicd_init+0xdc>
    fd8000003cb0:	00013070 	.word	0x00013070
    fd8000003cb4:	0000fd80 	.word	0x0000fd80
    fd8000003cb8:	00006370 	.word	0x00006370
    fd8000003cbc:	0000fd80 	.word	0x0000fd80
    fd8000003cc0:	00012930 	.word	0x00012930
    fd8000003cc4:	0000fd80 	.word	0x0000fd80
    fd8000003cc8:	000106f0 	.word	0x000106f0
    fd8000003ccc:	0000fd80 	.word	0x0000fd80

0000fd8000003cd0 <gic_init>:

void gic_map_mmio();

void gic_init()
{
    fd8000003cd0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
SYSREG_GEN_ACCESSORS(icc_sre_el2);
    fd8000003cd4:	d2800120 	mov	x0, #0x9                   	// #9
    fd8000003cd8:	910003fd 	mov	x29, sp
    fd8000003cdc:	a90153f3 	stp	x19, x20, [sp, #16]
    fd8000003ce0:	f90013f5 	str	x21, [sp, #32]
    fd8000003ce4:	d51cc9a0 	msr	icc_sre_el2, x0
    if (GIC_VERSION == GICV3) {
        sysreg_icc_sre_el2_write(ICC_SRE_SRE_BIT | ICC_SRE_ENB_BIT);    //Enable the system register interface and enable el1 access to icc_sre_el1
        ISB();
    fd8000003ce8:	d5033fdf 	isb
    }

    if (cpu()->id == CPU_MASTER) {
    fd8000003cec:	90000000 	adrp	x0, fd8000003000 <cache_arch_enumerate+0x30>
    fd8000003cf0:	f9473400 	ldr	x0, [x0, #3688]
    fd8000003cf4:	d2dfc001 	mov	x1, #0xfe0000000000        	// #279275953455104
    fd8000003cf8:	f9400021 	ldr	x1, [x1]
    fd8000003cfc:	f9400000 	ldr	x0, [x0]
    fd8000003d00:	eb00003f 	cmp	x1, x0
    fd8000003d04:	54000a40 	b.eq	fd8000003e4c <gic_init+0x17c>  // b.none
    while (!token->ready) { }
    fd8000003d08:	90000000 	adrp	x0, fd8000003000 <cache_arch_enumerate+0x30>
    fd8000003d0c:	f9473c13 	ldr	x19, [x0, #3704]
    fd8000003d10:	39404260 	ldrb	w0, [x19, #16]
    fd8000003d14:	3607ffe0 	tbz	w0, #0, fd8000003d10 <gic_init+0x40>
    __asm__ volatile(
    fd8000003d18:	91001263 	add	x3, x19, #0x4
    fd8000003d1c:	885ffe60 	ldaxr	w0, [x19]
    fd8000003d20:	11000401 	add	w1, w0, #0x1
    fd8000003d24:	88027e61 	stxr	w2, w1, [x19]
    fd8000003d28:	35ffffa2 	cbnz	w2, fd8000003d1c <gic_init+0x4c>
    fd8000003d2c:	88dffc61 	ldar	w1, [x3]
    fd8000003d30:	6b01001f 	cmp	w0, w1
    fd8000003d34:	54000060 	b.eq	fd8000003d40 <gic_init+0x70>  // b.none
    fd8000003d38:	d503205f 	wfe
    fd8000003d3c:	17fffffc 	b	fd8000003d2c <gic_init+0x5c>
    token->count++;
    fd8000003d40:	f9400e60 	ldr	x0, [x19, #24]
    fd8000003d44:	91000400 	add	x0, x0, #0x1
    fd8000003d48:	f9000e60 	str	x0, [x19, #24]
    next_count = ALIGN(token->count, token->n);
    fd8000003d4c:	f9400e74 	ldr	x20, [x19, #24]
    fd8000003d50:	f9400660 	ldr	x0, [x19, #8]
    fd8000003d54:	f9400661 	ldr	x1, [x19, #8]
    fd8000003d58:	8b000294 	add	x20, x20, x0
    fd8000003d5c:	d1000694 	sub	x20, x20, #0x1
    fd8000003d60:	f9400660 	ldr	x0, [x19, #8]
    fd8000003d64:	9ac10a94 	udiv	x20, x20, x1
    fd8000003d68:	9b007e94 	mul	x20, x20, x0
    __asm__ volatile(
    fd8000003d6c:	b9400060 	ldr	w0, [x3]
    fd8000003d70:	11000400 	add	w0, w0, #0x1
    fd8000003d74:	889ffc60 	stlr	w0, [x3]
    fd8000003d78:	d5033b9f 	dsb	ish
    fd8000003d7c:	d503209f 	sev
        if (!cpu()->handling_msgs) {
    fd8000003d80:	d2dfc015 	mov	x21, #0xfe0000000000        	// #279275953455104
    while (token->count < next_count) {
    fd8000003d84:	f9400e61 	ldr	x1, [x19, #24]
        if (!cpu()->handling_msgs) {
    fd8000003d88:	394022a0 	ldrb	w0, [x21, #8]
    while (token->count < next_count) {
    fd8000003d8c:	eb01029f 	cmp	x20, x1
        if (!cpu()->handling_msgs) {
    fd8000003d90:	12000001 	and	w1, w0, #0x1
    while (token->count < next_count) {
    fd8000003d94:	540000c9 	b.ls	fd8000003dac <gic_init+0xdc>  // b.plast
        if (!cpu()->handling_msgs) {
    fd8000003d98:	36000520 	tbz	w0, #0, fd8000003e3c <gic_init+0x16c>
    fd8000003d9c:	d503201f 	nop
    while (token->count < next_count) {
    fd8000003da0:	f9400e60 	ldr	x0, [x19, #24]
    fd8000003da4:	eb00029f 	cmp	x20, x0
    fd8000003da8:	54ffffc8 	b.hi	fd8000003da0 <gic_init+0xd0>  // b.pmore
    if (!cpu()->handling_msgs) {
    fd8000003dac:	340004c1 	cbz	w1, fd8000003e44 <gic_init+0x174>
    while (!token->ready) { }
    fd8000003db0:	39404260 	ldrb	w0, [x19, #16]
    fd8000003db4:	3607ffe0 	tbz	w0, #0, fd8000003db0 <gic_init+0xe0>
    __asm__ volatile(
    fd8000003db8:	91001263 	add	x3, x19, #0x4
    fd8000003dbc:	885ffe60 	ldaxr	w0, [x19]
    fd8000003dc0:	11000401 	add	w1, w0, #0x1
    fd8000003dc4:	88027e61 	stxr	w2, w1, [x19]
    fd8000003dc8:	35ffffa2 	cbnz	w2, fd8000003dbc <gic_init+0xec>
    fd8000003dcc:	88dffc61 	ldar	w1, [x3]
    fd8000003dd0:	6b01001f 	cmp	w0, w1
    fd8000003dd4:	54000060 	b.eq	fd8000003de0 <gic_init+0x110>  // b.none
    fd8000003dd8:	d503205f 	wfe
    fd8000003ddc:	17fffffc 	b	fd8000003dcc <gic_init+0xfc>
    token->count++;
    fd8000003de0:	f9400e60 	ldr	x0, [x19, #24]
    fd8000003de4:	91000400 	add	x0, x0, #0x1
    fd8000003de8:	f9000e60 	str	x0, [x19, #24]
    next_count = ALIGN(token->count, token->n);
    fd8000003dec:	f9400e61 	ldr	x1, [x19, #24]
    fd8000003df0:	f9400660 	ldr	x0, [x19, #8]
    fd8000003df4:	f9400662 	ldr	x2, [x19, #8]
    fd8000003df8:	8b000021 	add	x1, x1, x0
    fd8000003dfc:	d1000421 	sub	x1, x1, #0x1
    fd8000003e00:	f9400660 	ldr	x0, [x19, #8]
    fd8000003e04:	9ac20821 	udiv	x1, x1, x2
    fd8000003e08:	9b007c21 	mul	x1, x1, x0
    __asm__ volatile(
    fd8000003e0c:	b9400060 	ldr	w0, [x3]
    fd8000003e10:	11000400 	add	w0, w0, #0x1
    fd8000003e14:	889ffc60 	stlr	w0, [x3]
    fd8000003e18:	d5033b9f 	dsb	ish
    fd8000003e1c:	d503209f 	sev
    while (token->count < next_count) { }
    fd8000003e20:	f9400e60 	ldr	x0, [x19, #24]
    fd8000003e24:	eb00003f 	cmp	x1, x0
    fd8000003e28:	54ffffc8 	b.hi	fd8000003e20 <gic_init+0x150>  // b.pmore
    }

    cpu_sync_and_clear_msgs(&cpu_glb_sync);

    gic_cpu_init();
}
    fd8000003e2c:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd8000003e30:	f94013f5 	ldr	x21, [sp, #32]
    fd8000003e34:	a8c37bfd 	ldp	x29, x30, [sp], #48
    gic_cpu_init();
    fd8000003e38:	140010c2 	b	fd8000008140 <gic_cpu_init>
            cpu_msg_handler();
    fd8000003e3c:	94001b79 	bl	fd800000ac20 <cpu_msg_handler>
    fd8000003e40:	17ffffd1 	b	fd8000003d84 <gic_init+0xb4>
        cpu_msg_handler();
    fd8000003e44:	94001b77 	bl	fd800000ac20 <cpu_msg_handler>
    while (!token->ready) { }
    fd8000003e48:	17ffffda 	b	fd8000003db0 <gic_init+0xe0>
        gic_map_mmio();
    fd8000003e4c:	94001135 	bl	fd8000008320 <gic_map_mmio>
        gicd_init();
    fd8000003e50:	97ffff60 	bl	fd8000003bd0 <gicd_init>
        NUM_LRS = gich_num_lrs();
    fd8000003e54:	94000ff3 	bl	fd8000007e20 <gich_num_lrs>
    fd8000003e58:	90000001 	adrp	x1, fd8000003000 <cache_arch_enumerate+0x30>
    fd8000003e5c:	f9473821 	ldr	x1, [x1, #3696]
    fd8000003e60:	f9000020 	str	x0, [x1]
    fd8000003e64:	17ffffa9 	b	fd8000003d08 <gic_init+0x38>
    fd8000003e68:	00012348 	.word	0x00012348
    fd8000003e6c:	0000fd80 	.word	0x0000fd80
    fd8000003e70:	00013088 	.word	0x00013088
    fd8000003e74:	0000fd80 	.word	0x0000fd80
    fd8000003e78:	00016000 	.word	0x00016000
    fd8000003e7c:	0000fd80 	.word	0x0000fd80

0000fd8000003e80 <gic_handle>:

void gic_handle()
{
    fd8000003e80:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    fd8000003e84:	910003fd 	mov	x29, sp
    fd8000003e88:	a90153f3 	stp	x19, x20, [sp, #16]
SYSREG_GEN_ACCESSORS(icc_iar1_el1);
    fd8000003e8c:	d538cc14 	mrs	x20, icc_iar1_el1
BIT_OPS_GEN(bit32, uint32_t, UINT32_C(1), BIT32_MASK);
    fd8000003e90:	12005e93 	and	w19, w20, #0xffffff
    uint32_t ack = gicc_iar();
    irqid_t id = bit32_extract(ack, GICC_IAR_ID_OFF, GICC_IAR_ID_LEN);

    if (id < GIC_FIRST_SPECIAL_INTID) {
    fd8000003e94:	710fee7f 	cmp	w19, #0x3fb
    fd8000003e98:	54000208 	b.hi	fd8000003ed8 <gic_handle+0x58>  // b.pmore
        if(id != 27 && id != 78 && id != 1 && id != 79)
    fd8000003e9c:	51013a60 	sub	w0, w19, #0x4e
    fd8000003ea0:	7100041f 	cmp	w0, #0x1
    fd8000003ea4:	7a5b8a64 	ccmp	w19, #0x1b, #0x4, hi	// hi = pmore
    fd8000003ea8:	54000060 	b.eq	fd8000003eb4 <gic_handle+0x34>  // b.none
    fd8000003eac:	7100067f 	cmp	w19, #0x1
    fd8000003eb0:	54000201 	b.ne	fd8000003ef0 <gic_handle+0x70>  // b.any
            console_printk("BAO: Interrupt received wiht ID - %d\n",id);
        enum irq_res res = interrupts_handle(id);
    fd8000003eb4:	2a1303e0 	mov	w0, w19
    fd8000003eb8:	92407e94 	and	x20, x20, #0xffffffff
    fd8000003ebc:	940019c5 	bl	fd800000a5d0 <interrupts_handle>
SYSREG_GEN_ACCESSORS(icc_eoir1_el1);
    fd8000003ec0:	d518cc34 	msr	icc_eoir1_el1, x20
        gicc_eoir(ack);
        if (res == HANDLED_BY_HYP) {
    fd8000003ec4:	35000040 	cbnz	w0, fd8000003ecc <gic_handle+0x4c>
SYSREG_GEN_ACCESSORS(icc_dir_el1);
    fd8000003ec8:	d518cb34 	msr	icc_dir_el1, x20
            gicc_dir(ack);
        }
    }else {
        console_printk("BAO: Interrupt received wiht ID out of range - %d\n",id);
    }
}
    fd8000003ecc:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd8000003ed0:	a8c27bfd 	ldp	x29, x30, [sp], #32
    fd8000003ed4:	d65f03c0 	ret
        console_printk("BAO: Interrupt received wiht ID out of range - %d\n",id);
    fd8000003ed8:	2a1303e1 	mov	w1, w19
    fd8000003edc:	90000000 	adrp	x0, fd8000003000 <cache_arch_enumerate+0x30>
}
    fd8000003ee0:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd8000003ee4:	a8c27bfd 	ldp	x29, x30, [sp], #32
        console_printk("BAO: Interrupt received wiht ID out of range - %d\n",id);
    fd8000003ee8:	f9479000 	ldr	x0, [x0, #3872]
    fd8000003eec:	1400204d 	b	fd800000c020 <console_printk>
            console_printk("BAO: Interrupt received wiht ID - %d\n",id);
    fd8000003ef0:	90000000 	adrp	x0, fd8000003000 <cache_arch_enumerate+0x30>
    fd8000003ef4:	2a1303e1 	mov	w1, w19
    fd8000003ef8:	92407e94 	and	x20, x20, #0xffffffff
    fd8000003efc:	f9478c00 	ldr	x0, [x0, #3864]
    fd8000003f00:	94002048 	bl	fd800000c020 <console_printk>
        enum irq_res res = interrupts_handle(id);
    fd8000003f04:	2a1303e0 	mov	w0, w19
    fd8000003f08:	940019b2 	bl	fd800000a5d0 <interrupts_handle>
SYSREG_GEN_ACCESSORS(icc_eoir1_el1);
    fd8000003f0c:	d518cc34 	msr	icc_eoir1_el1, x20
        if (res == HANDLED_BY_HYP) {
    fd8000003f10:	35fffde0 	cbnz	w0, fd8000003ecc <gic_handle+0x4c>
    fd8000003f14:	17ffffed 	b	fd8000003ec8 <gic_handle+0x48>
    fd8000003f18:	00010728 	.word	0x00010728
    fd8000003f1c:	0000fd80 	.word	0x0000fd80
    fd8000003f20:	00010750 	.word	0x00010750
    fd8000003f24:	0000fd80 	.word	0x0000fd80
    fd8000003f28:	d503201f 	nop
    fd8000003f2c:	d503201f 	nop

0000fd8000003f30 <gicd_get_prio>:
uint8_t gicd_get_prio(irqid_t int_id)
{
    size_t reg_ind = GIC_PRIO_REG(int_id);
    size_t off = GIC_PRIO_OFF(int_id);

    uint8_t prio = gicd->IPRIORITYR[reg_ind] >> off & BIT32_MASK(off, GIC_PRIO_BITS);
    fd8000003f30:	90000001 	adrp	x1, fd8000003000 <cache_arch_enumerate+0x30>
    fd8000003f34:	f947b024 	ldr	x4, [x1, #3936]
    fd8000003f38:	927e6803 	and	x3, x0, #0x1ffffffc
    fd8000003f3c:	531d0401 	ubfiz	w1, w0, #3, #2
    fd8000003f40:	52801fe2 	mov	w2, #0xff                  	// #255
    fd8000003f44:	f9400080 	ldr	x0, [x4]
    fd8000003f48:	1ac12042 	lsl	w2, w2, w1
    fd8000003f4c:	8b030000 	add	x0, x0, x3
    fd8000003f50:	b9440000 	ldr	w0, [x0, #1024]
    fd8000003f54:	1ac12400 	lsr	w0, w0, w1

    return prio;
}
    fd8000003f58:	0a020000 	and	w0, w0, w2
    fd8000003f5c:	d65f03c0 	ret
    fd8000003f60:	00013070 	.word	0x00013070
    fd8000003f64:	0000fd80 	.word	0x0000fd80
    fd8000003f68:	d503201f 	nop
    fd8000003f6c:	d503201f 	nop

0000fd8000003f70 <gicd_set_icfgr>:
    __asm__ volatile(
    fd8000003f70:	90000002 	adrp	x2, fd8000003000 <cache_arch_enumerate+0x30>
    fd8000003f74:	f947fc43 	ldr	x3, [x2, #4088]

void gicd_set_icfgr(irqid_t int_id, uint8_t cfg)
{
    size_t reg_ind = (int_id * GIC_CONFIG_BITS) / (sizeof(uint32_t) * 8);
    fd8000003f78:	531f7800 	lsl	w0, w0, #1
{
    fd8000003f7c:	12001c21 	and	w1, w1, #0xff
    fd8000003f80:	121f0c04 	and	w4, w0, #0x1e
    fd8000003f84:	91002062 	add	x2, x3, #0x8
    fd8000003f88:	91003068 	add	x8, x3, #0xc
    fd8000003f8c:	885ffc45 	ldaxr	w5, [x2]
    fd8000003f90:	110004a6 	add	w6, w5, #0x1
    fd8000003f94:	88077c46 	stxr	w7, w6, [x2]
    fd8000003f98:	35ffffa7 	cbnz	w7, fd8000003f8c <gicd_set_icfgr+0x1c>
    fd8000003f9c:	88dffd06 	ldar	w6, [x8]
    fd8000003fa0:	6b0600bf 	cmp	w5, w6
    fd8000003fa4:	54000060 	b.eq	fd8000003fb0 <gicd_set_icfgr+0x40>  // b.none
    fd8000003fa8:	d503205f 	wfe
    fd8000003fac:	17fffffc 	b	fd8000003f9c <gicd_set_icfgr+0x2c>
    size_t off = (int_id * GIC_CONFIG_BITS) % (sizeof(uint32_t) * 8);
    uint32_t mask = ((1U << GIC_CONFIG_BITS) - 1) << off;

    spin_lock(&gicd_lock);

    gicd->ICFGR[reg_ind] = (gicd->ICFGR[reg_ind] & ~mask) | ((cfg << off) & mask);
    fd8000003fb0:	f9400065 	ldr	x5, [x3]
    fd8000003fb4:	53057c00 	lsr	w0, w0, #5
    uint32_t mask = ((1U << GIC_CONFIG_BITS) - 1) << off;
    fd8000003fb8:	52800063 	mov	w3, #0x3                   	// #3
    gicd->ICFGR[reg_ind] = (gicd->ICFGR[reg_ind] & ~mask) | ((cfg << off) & mask);
    fd8000003fbc:	1ac42021 	lsl	w1, w1, w4
    uint32_t mask = ((1U << GIC_CONFIG_BITS) - 1) << off;
    fd8000003fc0:	1ac42063 	lsl	w3, w3, w4
    fd8000003fc4:	8b0008a0 	add	x0, x5, x0, lsl #2
    gicd->ICFGR[reg_ind] = (gicd->ICFGR[reg_ind] & ~mask) | ((cfg << off) & mask);
    fd8000003fc8:	b94c0004 	ldr	w4, [x0, #3072]
    fd8000003fcc:	4a040021 	eor	w1, w1, w4
    fd8000003fd0:	0a030021 	and	w1, w1, w3
    fd8000003fd4:	4a040021 	eor	w1, w1, w4
    fd8000003fd8:	b90c0001 	str	w1, [x0, #3072]
    __asm__ volatile(
    fd8000003fdc:	b9400100 	ldr	w0, [x8]
    fd8000003fe0:	11000400 	add	w0, w0, #0x1
    fd8000003fe4:	889ffd00 	stlr	w0, [x8]
    fd8000003fe8:	d5033b9f 	dsb	ish
    fd8000003fec:	d503209f 	sev

    spin_unlock(&gicd_lock);
}
    fd8000003ff0:	d65f03c0 	ret
    fd8000003ff4:	d503201f 	nop
    fd8000003ff8:	00013070 	.word	0x00013070
    fd8000003ffc:	0000fd80 	.word	0x0000fd80

0000fd8000004000 <gicd_set_prio>:
    __asm__ volatile(
    fd8000004000:	90000002 	adrp	x2, fd8000004000 <gicd_set_prio>
    fd8000004004:	f9404443 	ldr	x3, [x2, #136]

void gicd_set_prio(irqid_t int_id, uint8_t prio)
{
    size_t reg_ind = GIC_PRIO_REG(int_id);
    fd8000004008:	531d7000 	lsl	w0, w0, #3
{
    fd800000400c:	12001c21 	and	w1, w1, #0xff
    fd8000004010:	121d0404 	and	w4, w0, #0x18
    fd8000004014:	91002062 	add	x2, x3, #0x8
    fd8000004018:	91003068 	add	x8, x3, #0xc
    fd800000401c:	885ffc45 	ldaxr	w5, [x2]
    fd8000004020:	110004a6 	add	w6, w5, #0x1
    fd8000004024:	88077c46 	stxr	w7, w6, [x2]
    fd8000004028:	35ffffa7 	cbnz	w7, fd800000401c <gicd_set_prio+0x1c>
    fd800000402c:	88dffd06 	ldar	w6, [x8]
    fd8000004030:	6b0600bf 	cmp	w5, w6
    fd8000004034:	54000060 	b.eq	fd8000004040 <gicd_set_prio+0x40>  // b.none
    fd8000004038:	d503205f 	wfe
    fd800000403c:	17fffffc 	b	fd800000402c <gicd_set_prio+0x2c>
    size_t off = GIC_PRIO_OFF(int_id);
    uint32_t mask = BIT32_MASK(off, GIC_PRIO_BITS);

    spin_lock(&gicd_lock);

    gicd->IPRIORITYR[reg_ind] = (gicd->IPRIORITYR[reg_ind] & ~mask) | ((prio << off) & mask);
    fd8000004040:	f9400065 	ldr	x5, [x3]
    fd8000004044:	53057c00 	lsr	w0, w0, #5
    uint32_t mask = BIT32_MASK(off, GIC_PRIO_BITS);
    fd8000004048:	52801fe3 	mov	w3, #0xff                  	// #255
    gicd->IPRIORITYR[reg_ind] = (gicd->IPRIORITYR[reg_ind] & ~mask) | ((prio << off) & mask);
    fd800000404c:	1ac42021 	lsl	w1, w1, w4
    uint32_t mask = BIT32_MASK(off, GIC_PRIO_BITS);
    fd8000004050:	1ac42063 	lsl	w3, w3, w4
    fd8000004054:	8b0008a0 	add	x0, x5, x0, lsl #2
    gicd->IPRIORITYR[reg_ind] = (gicd->IPRIORITYR[reg_ind] & ~mask) | ((prio << off) & mask);
    fd8000004058:	b9440004 	ldr	w4, [x0, #1024]
    fd800000405c:	4a040021 	eor	w1, w1, w4
    fd8000004060:	0a030021 	and	w1, w1, w3
    fd8000004064:	4a040021 	eor	w1, w1, w4
    fd8000004068:	b9040001 	str	w1, [x0, #1024]
    __asm__ volatile(
    fd800000406c:	b9400100 	ldr	w0, [x8]
    fd8000004070:	11000400 	add	w0, w0, #0x1
    fd8000004074:	889ffd00 	stlr	w0, [x8]
    fd8000004078:	d5033b9f 	dsb	ish
    fd800000407c:	d503209f 	sev

    spin_unlock(&gicd_lock);
}
    fd8000004080:	d65f03c0 	ret
    fd8000004084:	d503201f 	nop
    fd8000004088:	00013070 	.word	0x00013070
    fd800000408c:	0000fd80 	.word	0x0000fd80

0000fd8000004090 <gicd_set_pend>:

void gicd_set_pend(irqid_t int_id, bool pend)
{
    size_t reg_ind = GIC_INT_REG(int_id);
    if (pend) {
        gicd->ISPENDR[reg_ind] = GIC_INT_MASK(int_id);
    fd8000004090:	90000002 	adrp	x2, fd8000004000 <gicd_set_prio>
    fd8000004094:	f9406042 	ldr	x2, [x2, #192]
    fd8000004098:	52800023 	mov	w3, #0x1                   	// #1
    fd800000409c:	f9400044 	ldr	x4, [x2]
    size_t reg_ind = GIC_INT_REG(int_id);
    fd80000040a0:	53057c02 	lsr	w2, w0, #5
        gicd->ISPENDR[reg_ind] = GIC_INT_MASK(int_id);
    fd80000040a4:	1ac02060 	lsl	w0, w3, w0
    fd80000040a8:	8b020882 	add	x2, x4, x2, lsl #2
    if (pend) {
    fd80000040ac:	36000061 	tbz	w1, #0, fd80000040b8 <gicd_set_pend+0x28>
        gicd->ISPENDR[reg_ind] = GIC_INT_MASK(int_id);
    fd80000040b0:	b9020040 	str	w0, [x2, #512]
    } else {
        gicd->ICPENDR[reg_ind] = GIC_INT_MASK(int_id);
    }
}
    fd80000040b4:	d65f03c0 	ret
        gicd->ICPENDR[reg_ind] = GIC_INT_MASK(int_id);
    fd80000040b8:	b9028040 	str	w0, [x2, #640]
}
    fd80000040bc:	d65f03c0 	ret
    fd80000040c0:	00013070 	.word	0x00013070
    fd80000040c4:	0000fd80 	.word	0x0000fd80
    fd80000040c8:	d503201f 	nop
    fd80000040cc:	d503201f 	nop

0000fd80000040d0 <gicd_get_pend>:

bool gicd_get_pend(irqid_t int_id)
{
    return (gicd->ISPENDR[GIC_INT_REG(int_id)] & GIC_INT_MASK(int_id)) != 0;
    fd80000040d0:	90000001 	adrp	x1, fd8000004000 <gicd_set_prio>
    fd80000040d4:	f9408022 	ldr	x2, [x1, #256]
    fd80000040d8:	52800021 	mov	w1, #0x1                   	// #1
    fd80000040dc:	f9400043 	ldr	x3, [x2]
    fd80000040e0:	53057c02 	lsr	w2, w0, #5
    fd80000040e4:	1ac02020 	lsl	w0, w1, w0
    fd80000040e8:	8b020861 	add	x1, x3, x2, lsl #2
    fd80000040ec:	b9420021 	ldr	w1, [x1, #512]
    fd80000040f0:	6a01001f 	tst	w0, w1
}
    fd80000040f4:	1a9f07e0 	cset	w0, ne	// ne = any
    fd80000040f8:	d65f03c0 	ret
    fd80000040fc:	d503201f 	nop
    fd8000004100:	00013070 	.word	0x00013070
    fd8000004104:	0000fd80 	.word	0x0000fd80
    fd8000004108:	d503201f 	nop
    fd800000410c:	d503201f 	nop

0000fd8000004110 <gicd_set_act>:
void gicd_set_act(irqid_t int_id, bool act)
{
    size_t reg_ind = GIC_INT_REG(int_id);

    if (act) {
        gicd->ISACTIVER[reg_ind] = GIC_INT_MASK(int_id);
    fd8000004110:	90000002 	adrp	x2, fd8000004000 <gicd_set_prio>
    fd8000004114:	f940a042 	ldr	x2, [x2, #320]
    fd8000004118:	52800023 	mov	w3, #0x1                   	// #1
    fd800000411c:	f9400044 	ldr	x4, [x2]
    size_t reg_ind = GIC_INT_REG(int_id);
    fd8000004120:	53057c02 	lsr	w2, w0, #5
        gicd->ISACTIVER[reg_ind] = GIC_INT_MASK(int_id);
    fd8000004124:	1ac02060 	lsl	w0, w3, w0
    fd8000004128:	8b020882 	add	x2, x4, x2, lsl #2
    if (act) {
    fd800000412c:	36000061 	tbz	w1, #0, fd8000004138 <gicd_set_act+0x28>
        gicd->ISACTIVER[reg_ind] = GIC_INT_MASK(int_id);
    fd8000004130:	b9030040 	str	w0, [x2, #768]
    } else {
        gicd->ICACTIVER[reg_ind] = GIC_INT_MASK(int_id);
    }
}
    fd8000004134:	d65f03c0 	ret
        gicd->ICACTIVER[reg_ind] = GIC_INT_MASK(int_id);
    fd8000004138:	b9038040 	str	w0, [x2, #896]
}
    fd800000413c:	d65f03c0 	ret
    fd8000004140:	00013070 	.word	0x00013070
    fd8000004144:	0000fd80 	.word	0x0000fd80
    fd8000004148:	d503201f 	nop
    fd800000414c:	d503201f 	nop

0000fd8000004150 <gicd_get_act>:

bool gicd_get_act(irqid_t int_id)
{
    return (gicd->ISACTIVER[GIC_INT_REG(int_id)] & GIC_INT_MASK(int_id)) != 0;
    fd8000004150:	90000001 	adrp	x1, fd8000004000 <gicd_set_prio>
    fd8000004154:	f940c022 	ldr	x2, [x1, #384]
    fd8000004158:	52800021 	mov	w1, #0x1                   	// #1
    fd800000415c:	f9400043 	ldr	x3, [x2]
    fd8000004160:	53057c02 	lsr	w2, w0, #5
    fd8000004164:	1ac02020 	lsl	w0, w1, w0
    fd8000004168:	8b020861 	add	x1, x3, x2, lsl #2
    fd800000416c:	b9430021 	ldr	w1, [x1, #768]
    fd8000004170:	6a01001f 	tst	w0, w1
}
    fd8000004174:	1a9f07e0 	cset	w0, ne	// ne = any
    fd8000004178:	d65f03c0 	ret
    fd800000417c:	d503201f 	nop
    fd8000004180:	00013070 	.word	0x00013070
    fd8000004184:	0000fd80 	.word	0x0000fd80
    fd8000004188:	d503201f 	nop
    fd800000418c:	d503201f 	nop

0000fd8000004190 <gicd_set_enable>:
{
    size_t reg_ind = GIC_INT_REG(int_id);
    uint32_t bit = GIC_INT_MASK(int_id);

    if (en) {
        gicd->ISENABLER[reg_ind] = bit;
    fd8000004190:	90000002 	adrp	x2, fd8000004000 <gicd_set_prio>
    fd8000004194:	f940e042 	ldr	x2, [x2, #448]
    uint32_t bit = GIC_INT_MASK(int_id);
    fd8000004198:	52800023 	mov	w3, #0x1                   	// #1
        gicd->ISENABLER[reg_ind] = bit;
    fd800000419c:	f9400044 	ldr	x4, [x2]
    size_t reg_ind = GIC_INT_REG(int_id);
    fd80000041a0:	53057c02 	lsr	w2, w0, #5
    uint32_t bit = GIC_INT_MASK(int_id);
    fd80000041a4:	1ac02060 	lsl	w0, w3, w0
        gicd->ISENABLER[reg_ind] = bit;
    fd80000041a8:	8b020882 	add	x2, x4, x2, lsl #2
    if (en) {
    fd80000041ac:	36000061 	tbz	w1, #0, fd80000041b8 <gicd_set_enable+0x28>
        gicd->ISENABLER[reg_ind] = bit;
    fd80000041b0:	b9010040 	str	w0, [x2, #256]
    } else {
        gicd->ICENABLER[reg_ind] = bit;
    }
}
    fd80000041b4:	d65f03c0 	ret
        gicd->ICENABLER[reg_ind] = bit;
    fd80000041b8:	b9018040 	str	w0, [x2, #384]
}
    fd80000041bc:	d65f03c0 	ret
    fd80000041c0:	00013070 	.word	0x00013070
    fd80000041c4:	0000fd80 	.word	0x0000fd80
	...

0000fd80000041d0 <vgic_int_get_enable>:
}

unsigned long vgic_int_get_enable(struct vcpu* vcpu, struct vgic_int* interrupt)
{
    return (unsigned long)interrupt->enabled;
}
    fd80000041d0:	3940c820 	ldrb	w0, [x1, #50]
    fd80000041d4:	d65f03c0 	ret
    fd80000041d8:	d503201f 	nop
    fd80000041dc:	d503201f 	nop

0000fd80000041e0 <vgic_int_get_pend>:
    }
}

unsigned long vgic_int_get_pend(struct vcpu* vcpu, struct vgic_int* interrupt)
{
    return (interrupt->state & PEND) ? 1 : 0;
    fd80000041e0:	3940b020 	ldrb	w0, [x1, #44]
}
    fd80000041e4:	92400000 	and	x0, x0, #0x1
    fd80000041e8:	d65f03c0 	ret
    fd80000041ec:	d503201f 	nop

0000fd80000041f0 <vgic_int_get_act>:
    }
}

unsigned long vgic_int_get_act(struct vcpu* vcpu, struct vgic_int* interrupt)
{
    return (interrupt->state & ACT) ? 1 : 0;
    fd80000041f0:	3940b020 	ldrb	w0, [x1, #44]
}
    fd80000041f4:	d3410400 	ubfx	x0, x0, #1, #1
    fd80000041f8:	d65f03c0 	ret
    fd80000041fc:	d503201f 	nop

0000fd8000004200 <vgic_int_set_cfg>:

bool vgic_int_set_cfg(struct vcpu* vcpu, struct vgic_int* interrupt, unsigned long cfg)
{
    uint8_t prev_cfg = interrupt->cfg;
    fd8000004200:	3940b820 	ldrb	w0, [x1, #46]
    interrupt->cfg = (uint8_t)cfg;
    fd8000004204:	3900b822 	strb	w2, [x1, #46]
    return prev_cfg != cfg;
    fd8000004208:	eb20005f 	cmp	x2, w0, uxtb
}
    fd800000420c:	1a9f07e0 	cset	w0, ne	// ne = any
    fd8000004210:	d65f03c0 	ret
    fd8000004214:	d503201f 	nop
    fd8000004218:	d503201f 	nop
    fd800000421c:	d503201f 	nop

0000fd8000004220 <vgic_int_get_cfg>:

unsigned long vgic_int_get_cfg(struct vcpu* vcpu, struct vgic_int* interrupt)
{
    return (unsigned long)interrupt->cfg;
}
    fd8000004220:	3940b820 	ldrb	w0, [x1, #46]
    fd8000004224:	d65f03c0 	ret
    fd8000004228:	d503201f 	nop
    fd800000422c:	d503201f 	nop

0000fd8000004230 <vgic_int_set_prio>:
#endif
}

bool vgic_int_set_prio(struct vcpu* vcpu, struct vgic_int* interrupt, unsigned long prio)
{
    uint8_t prev_prio = interrupt->prio;
    fd8000004230:	3940b420 	ldrb	w0, [x1, #45]
    interrupt->prio = (uint8_t)prio & BIT_MASK(8 - GICH_LR_PRIO_LEN, GICH_LR_PRIO_LEN);
    fd8000004234:	3900b422 	strb	w2, [x1, #45]
    return prev_prio != prio;
    fd8000004238:	eb20005f 	cmp	x2, w0, uxtb
}
    fd800000423c:	1a9f07e0 	cset	w0, ne	// ne = any
    fd8000004240:	d65f03c0 	ret
    fd8000004244:	d503201f 	nop
    fd8000004248:	d503201f 	nop
    fd800000424c:	d503201f 	nop

0000fd8000004250 <vgic_int_get_prio>:

unsigned long vgic_int_get_prio(struct vcpu* vcpu, struct vgic_int* interrupt)
{
    return (unsigned long)interrupt->prio;
}
    fd8000004250:	3940b420 	ldrb	w0, [x1, #45]
    fd8000004254:	d65f03c0 	ret
    fd8000004258:	d503201f 	nop
    fd800000425c:	d503201f 	nop

0000fd8000004260 <vgic_int_enable_hw>:
{
    fd8000004260:	aa0103e2 	mov	x2, x1
        gicr_set_enable(interrupt->id, interrupt->enabled, interrupt->phys.redist);
    fd8000004264:	3940c821 	ldrb	w1, [x1, #50]
    if (gic_is_priv(interrupt->id)) {
    fd8000004268:	b9402840 	ldr	w0, [x2, #40]
    fd800000426c:	71007c1f 	cmp	w0, #0x1f
    fd8000004270:	54000068 	b.hi	fd800000427c <vgic_int_enable_hw+0x1c>  // b.pmore
        gicr_set_enable(interrupt->id, interrupt->enabled, interrupt->phys.redist);
    fd8000004274:	f9400c42 	ldr	x2, [x2, #24]
    fd8000004278:	1400114a 	b	fd80000087a0 <gicr_set_enable>
        gicd_set_enable(interrupt->id, interrupt->enabled);
    fd800000427c:	17ffffc5 	b	fd8000004190 <gicd_set_enable>

0000fd8000004280 <vgic_int_state_hw>:
{
    fd8000004280:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    fd8000004284:	910003fd 	mov	x29, sp
    fd8000004288:	a90153f3 	stp	x19, x20, [sp, #16]
    fd800000428c:	aa0103f3 	mov	x19, x1
    fd8000004290:	52800014 	mov	w20, #0x0                   	// #0
    uint8_t state = interrupt->state == PEND ? ACT : interrupt->state;
    fd8000004294:	3940b021 	ldrb	w1, [x1, #44]
    fd8000004298:	7100043f 	cmp	w1, #0x1
    fd800000429c:	54000060 	b.eq	fd80000042a8 <vgic_int_state_hw+0x28>  // b.none
    bool pend = (state & PEND) != 0;
    fd80000042a0:	12000034 	and	w20, w1, #0x1
    bool act = (state & ACT) != 0;
    fd80000042a4:	d3410421 	ubfx	x1, x1, #1, #1
    if (gic_is_priv(interrupt->id)) {
    fd80000042a8:	b9402a60 	ldr	w0, [x19, #40]
    fd80000042ac:	71007c1f 	cmp	w0, #0x1f
    fd80000042b0:	54000128 	b.hi	fd80000042d4 <vgic_int_state_hw+0x54>  // b.pmore
        gicr_set_act(interrupt->id, act, interrupt->phys.redist);
    fd80000042b4:	f9400e62 	ldr	x2, [x19, #24]
    fd80000042b8:	940010fa 	bl	fd80000086a0 <gicr_set_act>
        gicr_set_pend(interrupt->id, pend, interrupt->phys.redist);
    fd80000042bc:	f9400e62 	ldr	x2, [x19, #24]
    fd80000042c0:	2a1403e1 	mov	w1, w20
    fd80000042c4:	b9402a60 	ldr	w0, [x19, #40]
}
    fd80000042c8:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd80000042cc:	a8c27bfd 	ldp	x29, x30, [sp], #32
        gicr_set_pend(interrupt->id, pend, interrupt->phys.redist);
    fd80000042d0:	140010b4 	b	fd80000085a0 <gicr_set_pend>
        gicd_set_act(interrupt->id, act);
    fd80000042d4:	97ffff8f 	bl	fd8000004110 <gicd_set_act>
        gicd_set_pend(interrupt->id, pend);
    fd80000042d8:	b9402a60 	ldr	w0, [x19, #40]
    fd80000042dc:	2a1403e1 	mov	w1, w20
}
    fd80000042e0:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd80000042e4:	a8c27bfd 	ldp	x29, x30, [sp], #32
        gicd_set_pend(interrupt->id, pend);
    fd80000042e8:	17ffff6a 	b	fd8000004090 <gicd_set_pend>
    fd80000042ec:	d503201f 	nop

0000fd80000042f0 <vgic_int_set_cfg_hw>:
{
    fd80000042f0:	aa0103e2 	mov	x2, x1
        gicr_set_icfgr(interrupt->id, interrupt->cfg, interrupt->phys.redist);
    fd80000042f4:	3940b821 	ldrb	w1, [x1, #46]
    if (gic_is_priv(interrupt->id)) {
    fd80000042f8:	b9402840 	ldr	w0, [x2, #40]
    fd80000042fc:	71007c1f 	cmp	w0, #0x1f
    fd8000004300:	54000068 	b.hi	fd800000430c <vgic_int_set_cfg_hw+0x1c>  // b.pmore
        gicr_set_icfgr(interrupt->id, interrupt->cfg, interrupt->phys.redist);
    fd8000004304:	f9400c42 	ldr	x2, [x2, #24]
    fd8000004308:	14001072 	b	fd80000084d0 <gicr_set_icfgr>
        gicd_set_icfgr(interrupt->id, interrupt->cfg);
    fd800000430c:	17ffff19 	b	fd8000003f70 <gicd_set_icfgr>

0000fd8000004310 <vgic_int_set_prio_hw>:

void vgic_int_set_prio_hw(struct vcpu* vcpu, struct vgic_int* interrupt)
{
    fd8000004310:	aa0103e2 	mov	x2, x1
#if (GIC_VERSION != GICV2)
    if (gic_is_priv(interrupt->id)) {
        gicr_set_prio(interrupt->id, interrupt->prio, interrupt->phys.redist);
    fd8000004314:	3940b421 	ldrb	w1, [x1, #45]
    if (gic_is_priv(interrupt->id)) {
    fd8000004318:	b9402840 	ldr	w0, [x2, #40]
    fd800000431c:	71007c1f 	cmp	w0, #0x1f
    fd8000004320:	54000068 	b.hi	fd800000432c <vgic_int_set_prio_hw+0x1c>  // b.pmore
        gicr_set_prio(interrupt->id, interrupt->prio, interrupt->phys.redist);
    fd8000004324:	f9400c42 	ldr	x2, [x2, #24]
    fd8000004328:	14001022 	b	fd80000083b0 <gicr_set_prio>
    } else {
        gicd_set_prio(interrupt->id, interrupt->prio);
    fd800000432c:	17ffff35 	b	fd8000004000 <gicd_set_prio>

0000fd8000004330 <vgic_int_clear_enable>:
        return false;
    fd8000004330:	52800000 	mov	w0, #0x0                   	// #0
    if (!data) {
    fd8000004334:	b4000082 	cbz	x2, fd8000004344 <vgic_int_clear_enable+0x14>
    if (enable != interrupt->enabled) {
    fd8000004338:	3940c820 	ldrb	w0, [x1, #50]
    fd800000433c:	36000040 	tbz	w0, #0, fd8000004344 <vgic_int_clear_enable+0x14>
        interrupt->enabled = enable;
    fd8000004340:	3900c83f 	strb	wzr, [x1, #50]
}
    fd8000004344:	d65f03c0 	ret
    fd8000004348:	d503201f 	nop
    fd800000434c:	d503201f 	nop

0000fd8000004350 <vgic_int_set_enable>:
        return false;
    fd8000004350:	52800000 	mov	w0, #0x0                   	// #0
    if (!data) {
    fd8000004354:	b40000c2 	cbz	x2, fd800000436c <vgic_int_set_enable+0x1c>
    if (enable != interrupt->enabled) {
    fd8000004358:	3940c822 	ldrb	w2, [x1, #50]
    fd800000435c:	37000082 	tbnz	w2, #0, fd800000436c <vgic_int_set_enable+0x1c>
        interrupt->enabled = enable;
    fd8000004360:	52800022 	mov	w2, #0x1                   	// #1
        return true;
    fd8000004364:	52800020 	mov	w0, #0x1                   	// #1
        interrupt->enabled = enable;
    fd8000004368:	3900c822 	strb	w2, [x1, #50]
}
    fd800000436c:	d65f03c0 	ret

0000fd8000004370 <vgic_int_clear_pend>:
        return false;
    fd8000004370:	52800000 	mov	w0, #0x0                   	// #0
    if (!data) {
    fd8000004374:	b40000c2 	cbz	x2, fd800000438c <vgic_int_clear_pend+0x1c>
    if (pend ^ !!(interrupt->state & PEND)) {
    fd8000004378:	3940b022 	ldrb	w2, [x1, #44]
    fd800000437c:	12000040 	and	w0, w2, #0x1
    fd8000004380:	36000062 	tbz	w2, #0, fd800000438c <vgic_int_clear_pend+0x1c>
            interrupt->state &= ~PEND;
    fd8000004384:	121f7842 	and	w2, w2, #0xfffffffe
    fd8000004388:	3900b022 	strb	w2, [x1, #44]
}
    fd800000438c:	d65f03c0 	ret

0000fd8000004390 <vgic_int_set_pend>:
        return false;
    fd8000004390:	52800000 	mov	w0, #0x0                   	// #0
    if (!data) {
    fd8000004394:	b40000c2 	cbz	x2, fd80000043ac <vgic_int_set_pend+0x1c>
    if (pend ^ !!(interrupt->state & PEND)) {
    fd8000004398:	3940b022 	ldrb	w2, [x1, #44]
    fd800000439c:	37000082 	tbnz	w2, #0, fd80000043ac <vgic_int_set_pend+0x1c>
            interrupt->state |= PEND;
    fd80000043a0:	32000042 	orr	w2, w2, #0x1
        return true;
    fd80000043a4:	52800020 	mov	w0, #0x1                   	// #1
            interrupt->state |= PEND;
    fd80000043a8:	3900b022 	strb	w2, [x1, #44]
}
    fd80000043ac:	d65f03c0 	ret

0000fd80000043b0 <vgic_int_clear_act>:
        return false;
    fd80000043b0:	52800000 	mov	w0, #0x0                   	// #0
    if (!data) {
    fd80000043b4:	b40000c2 	cbz	x2, fd80000043cc <vgic_int_clear_act+0x1c>
    if (act ^ !!(interrupt->state & ACT)) {
    fd80000043b8:	3940b022 	ldrb	w2, [x1, #44]
    fd80000043bc:	36080082 	tbz	w2, #1, fd80000043cc <vgic_int_clear_act+0x1c>
            interrupt->state &= ~ACT;
    fd80000043c0:	121e7842 	and	w2, w2, #0xfffffffd
        return true;
    fd80000043c4:	52800020 	mov	w0, #0x1                   	// #1
            interrupt->state &= ~ACT;
    fd80000043c8:	3900b022 	strb	w2, [x1, #44]
}
    fd80000043cc:	d65f03c0 	ret

0000fd80000043d0 <vgic_int_set_act>:
        return false;
    fd80000043d0:	52800000 	mov	w0, #0x0                   	// #0
    if (!data) {
    fd80000043d4:	b40000c2 	cbz	x2, fd80000043ec <vgic_int_set_act+0x1c>
    if (act ^ !!(interrupt->state & ACT)) {
    fd80000043d8:	3940b022 	ldrb	w2, [x1, #44]
    fd80000043dc:	37080082 	tbnz	w2, #1, fd80000043ec <vgic_int_set_act+0x1c>
            interrupt->state |= ACT;
    fd80000043e0:	321f0042 	orr	w2, w2, #0x2
        return true;
    fd80000043e4:	52800020 	mov	w0, #0x1                   	// #1
            interrupt->state |= ACT;
    fd80000043e8:	3900b022 	strb	w2, [x1, #44]
}
    fd80000043ec:	d65f03c0 	ret

0000fd80000043f0 <vgic_emul_razwi>:
}

void vgic_emul_razwi(struct emul_access* acc, struct vgic_reg_handler_info* handlers,
    bool gicr_access, cpuid_t vgicr_id)
{
    if (!acc->write) {
    fd80000043f0:	39402001 	ldrb	w1, [x0, #8]
    fd80000043f4:	36000041 	tbz	w1, #0, fd80000043fc <vgic_emul_razwi+0xc>
        vcpu_writereg(cpu()->vcpu, acc->reg, 0);
    }
}
    fd80000043f8:	d65f03c0 	ret
        vcpu_writereg(cpu()->vcpu, acc->reg, 0);
    fd80000043fc:	d2dfc003 	mov	x3, #0xfe0000000000        	// #279275953455104
    fd8000004400:	d2800002 	mov	x2, #0x0                   	// #0
    fd8000004404:	f9400c01 	ldr	x1, [x0, #24]
    fd8000004408:	f9402860 	ldr	x0, [x3, #80]
    fd800000440c:	17fff509 	b	fd8000001830 <vcpu_writereg>

0000fd8000004410 <vgicd_emul_pidr_access>:
    if (!acc->write) {
    fd8000004410:	39402001 	ldrb	w1, [x0, #8]
    fd8000004414:	36000041 	tbz	w1, #0, fd800000441c <vgicd_emul_pidr_access+0xc>
}
    fd8000004418:	d65f03c0 	ret
        vcpu_writereg(cpu()->vcpu, acc->reg, gicd->ID[((acc->addr & 0xff) - 0xd0) / 4]);
    fd800000441c:	90000001 	adrp	x1, fd8000004000 <gicd_set_prio>
    fd8000004420:	f9422c22 	ldr	x2, [x1, #1112]
    fd8000004424:	d2dfc004 	mov	x4, #0xfe0000000000        	// #279275953455104
    fd8000004428:	39400003 	ldrb	w3, [x0]
    fd800000442c:	f9400c01 	ldr	x1, [x0, #24]
    fd8000004430:	d1034063 	sub	x3, x3, #0xd0
    fd8000004434:	f9400042 	ldr	x2, [x2]
    fd8000004438:	927ef463 	and	x3, x3, #0xfffffffffffffffc
    fd800000443c:	f9402880 	ldr	x0, [x4, #80]
    fd8000004440:	91403042 	add	x2, x2, #0xc, lsl #12
    fd8000004444:	8b030042 	add	x2, x2, x3
    fd8000004448:	b97fd042 	ldr	w2, [x2, #16336]
    fd800000444c:	2a0203e2 	mov	w2, w2
    fd8000004450:	17fff4f8 	b	fd8000001830 <vcpu_writereg>
    fd8000004454:	d503201f 	nop
    fd8000004458:	00013070 	.word	0x00013070
    fd800000445c:	0000fd80 	.word	0x0000fd80

0000fd8000004460 <vgicd_emul_misc_access>:
{
    fd8000004460:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    fd8000004464:	910003fd 	mov	x29, sp
    unsigned reg = acc->addr & 0x7F;
    fd8000004468:	f9400001 	ldr	x1, [x0]
{
    fd800000446c:	f90013f5 	str	x21, [sp, #32]
    struct vgicd* vgicd = &cpu()->vcpu->vm->arch.vgicd;
    fd8000004470:	d2dfc015 	mov	x21, #0xfe0000000000        	// #279275953455104
{
    fd8000004474:	a90153f3 	stp	x19, x20, [sp, #16]
    fd8000004478:	aa0003f3 	mov	x19, x0
    struct vgicd* vgicd = &cpu()->vcpu->vm->arch.vgicd;
    fd800000447c:	f9402aa0 	ldr	x0, [x21, #80]
    unsigned reg = acc->addr & 0x7F;
    fd8000004480:	12001821 	and	w1, w1, #0x7f
    switch (reg) {
    fd8000004484:	7100103f 	cmp	w1, #0x4
    struct vgicd* vgicd = &cpu()->vcpu->vm->arch.vgicd;
    fd8000004488:	f944c802 	ldr	x2, [x0, #2448]
    switch (reg) {
    fd800000448c:	540004e0 	b.eq	fd8000004528 <vgicd_emul_misc_access+0xc8>  // b.none
    fd8000004490:	7100203f 	cmp	w1, #0x8
    fd8000004494:	54000400 	b.eq	fd8000004514 <vgicd_emul_misc_access+0xb4>  // b.none
    fd8000004498:	35000361 	cbnz	w1, fd8000004504 <vgicd_emul_misc_access+0xa4>
            if (acc->write) {
    fd800000449c:	39402263 	ldrb	w3, [x19, #8]
                uint32_t prev_ctrl = vgicd->CTLR;
    fd80000044a0:	91026054 	add	x20, x2, #0x98
                vgicd->CTLR = vcpu_readreg(cpu()->vcpu, acc->reg) & VGIC_ENABLE_MASK;
    fd80000044a4:	f9400e61 	ldr	x1, [x19, #24]
                uint32_t prev_ctrl = vgicd->CTLR;
    fd80000044a8:	b940b053 	ldr	w19, [x2, #176]
            if (acc->write) {
    fd80000044ac:	36000663 	tbz	w3, #0, fd8000004578 <vgicd_emul_misc_access+0x118>
                vgicd->CTLR = vcpu_readreg(cpu()->vcpu, acc->reg) & VGIC_ENABLE_MASK;
    fd80000044b0:	97fff4d8 	bl	fd8000001810 <vcpu_readreg>
    fd80000044b4:	121f0000 	and	w0, w0, #0x2
    fd80000044b8:	b9001a80 	str	w0, [x20, #24]
                if (prev_ctrl ^ vgicd->CTLR) {
    fd80000044bc:	6b13001f 	cmp	w0, w19
    fd80000044c0:	54000220 	b.eq	fd8000004504 <vgicd_emul_misc_access+0xa4>  // b.none
    if (cpu()->vcpu->vm->arch.vgicd.CTLR & VGIC_ENABLE_MASK) {
    fd80000044c4:	f9402aa0 	ldr	x0, [x21, #80]
    fd80000044c8:	f944c800 	ldr	x0, [x0, #2448]
    fd80000044cc:	b940b001 	ldr	w1, [x0, #176]
    fd80000044d0:	370805e1 	tbnz	w1, #1, fd800000458c <vgicd_emul_misc_access+0x12c>
SYSREG_GEN_ACCESSORS(ich_hcr_el2);
    fd80000044d4:	d53ccb01 	mrs	x1, ich_hcr_el2
    return sysreg_ich_hcr_el2_read();
}

static inline void gich_set_hcr(uint32_t hcr)
{
    sysreg_ich_hcr_el2_write(hcr);
    fd80000044d8:	927f7821 	and	x1, x1, #0xfffffffe
    fd80000044dc:	d51ccb01 	msr	ich_hcr_el2, x1
                    struct cpu_msg msg = {
    fd80000044e0:	90000001 	adrp	x1, fd8000004000 <gicd_set_prio>
    fd80000044e4:	f942d023 	ldr	x3, [x1, #1440]
                    vm_msg_broadcast(cpu()->vcpu->vm, &msg);
    fd80000044e8:	9100c3e1 	add	x1, sp, #0x30
                        VGIC_MSG_DATA(cpu()->vcpu->vm->id, 0, 0, 0, 0),
    fd80000044ec:	f9400002 	ldr	x2, [x0]
                    struct cpu_msg msg = {
    fd80000044f0:	f9400063 	ldr	x3, [x3]
    fd80000044f4:	29067fe3 	stp	w3, wzr, [sp, #48]
                        VGIC_MSG_DATA(cpu()->vcpu->vm->id, 0, 0, 0, 0),
    fd80000044f8:	d3503c42 	lsl	x2, x2, #48
                    struct cpu_msg msg = {
    fd80000044fc:	f9001fe2 	str	x2, [sp, #56]
                    vm_msg_broadcast(cpu()->vcpu->vm, &msg);
    fd8000004500:	94001e0c 	bl	fd800000bd30 <vm_msg_broadcast>
}
    fd8000004504:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd8000004508:	f94013f5 	ldr	x21, [sp, #32]
    fd800000450c:	a8c47bfd 	ldp	x29, x30, [sp], #64
    fd8000004510:	d65f03c0 	ret
            if (!acc->write) {
    fd8000004514:	39402261 	ldrb	w1, [x19, #8]
    fd8000004518:	3707ff61 	tbnz	w1, #0, fd8000004504 <vgicd_emul_misc_access+0xa4>
                vcpu_writereg(cpu()->vcpu, acc->reg, vgicd->IIDR);
    fd800000451c:	f9400e61 	ldr	x1, [x19, #24]
    fd8000004520:	b940b842 	ldr	w2, [x2, #184]
    fd8000004524:	1400000b 	b	fd8000004550 <vgicd_emul_misc_access+0xf0>
            if (!acc->write) {
    fd8000004528:	39402260 	ldrb	w0, [x19, #8]
                console_printk("BAO-vgic: Inside read of dTYPER:%d\n",vgicd->TYPER);
    fd800000452c:	91026054 	add	x20, x2, #0x98
    fd8000004530:	b940b441 	ldr	w1, [x2, #180]
            if (!acc->write) {
    fd8000004534:	37000160 	tbnz	w0, #0, fd8000004560 <vgicd_emul_misc_access+0x100>
                console_printk("BAO-vgic: Inside read of dTYPER:%d\n",vgicd->TYPER);
    fd8000004538:	90000000 	adrp	x0, fd8000004000 <gicd_set_prio>
    fd800000453c:	f942d400 	ldr	x0, [x0, #1448]
    fd8000004540:	94001eb8 	bl	fd800000c020 <console_printk>
                vcpu_writereg(cpu()->vcpu, acc->reg, vgicd->TYPER);
    fd8000004544:	f9400e61 	ldr	x1, [x19, #24]
    fd8000004548:	f9402aa0 	ldr	x0, [x21, #80]
    fd800000454c:	b9401e82 	ldr	w2, [x20, #28]
}
    fd8000004550:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd8000004554:	f94013f5 	ldr	x21, [sp, #32]
    fd8000004558:	a8c47bfd 	ldp	x29, x30, [sp], #64
                vcpu_writereg(cpu()->vcpu, acc->reg, vgicd->IIDR);
    fd800000455c:	17fff4b5 	b	fd8000001830 <vcpu_writereg>
}
    fd8000004560:	a94153f3 	ldp	x19, x20, [sp, #16]
                console_printk("BAO-vgic: Inside write of dTYPER:%d\n",vgicd->TYPER);
    fd8000004564:	90000000 	adrp	x0, fd8000004000 <gicd_set_prio>
    fd8000004568:	f942d800 	ldr	x0, [x0, #1456]
}
    fd800000456c:	f94013f5 	ldr	x21, [sp, #32]
    fd8000004570:	a8c47bfd 	ldp	x29, x30, [sp], #64
                console_printk("BAO-vgic: Inside write of dTYPER:%d\n",vgicd->TYPER);
    fd8000004574:	14001eab 	b	fd800000c020 <console_printk>
}
    fd8000004578:	f94013f5 	ldr	x21, [sp, #32]
                vcpu_writereg(cpu()->vcpu, acc->reg, vgicd->CTLR | GICD_CTLR_ARE_NS_BIT);
    fd800000457c:	321c0262 	orr	w2, w19, #0x10
}
    fd8000004580:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd8000004584:	a8c47bfd 	ldp	x29, x30, [sp], #64
                vcpu_writereg(cpu()->vcpu, acc->reg, vgicd->IIDR);
    fd8000004588:	17fff4aa 	b	fd8000001830 <vcpu_writereg>
    fd800000458c:	d53ccb01 	mrs	x1, ich_hcr_el2
    fd8000004590:	32000021 	orr	w1, w1, #0x1
    fd8000004594:	d51ccb01 	msr	ich_hcr_el2, x1
}
    fd8000004598:	17ffffd2 	b	fd80000044e0 <vgicd_emul_misc_access+0x80>
    fd800000459c:	d503201f 	nop
    fd80000045a0:	00012e78 	.word	0x00012e78
    fd80000045a4:	0000fd80 	.word	0x0000fd80
    fd80000045a8:	00010788 	.word	0x00010788
    fd80000045ac:	0000fd80 	.word	0x0000fd80
    fd80000045b0:	000107b0 	.word	0x000107b0
    fd80000045b4:	0000fd80 	.word	0x0000fd80
    fd80000045b8:	d503201f 	nop
    fd80000045bc:	d503201f 	nop

0000fd80000045c0 <vgic_highest_prio_spilled.constprop.0>:
}

/**
 * Must be called holding the vgic_spilled_lock
 */
static inline struct vgic_int* vgic_highest_prio_spilled(struct vcpu* vcpu, unsigned flags,
    fd80000045c0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    struct list** outlist)
{
    struct vgic_int* irq = NULL;
    struct list* spilled_lists[] = {
        &vcpu->arch.vgic_spilled,
    fd80000045c4:	91250003 	add	x3, x0, #0x940
static inline struct vgic_int* vgic_highest_prio_spilled(struct vcpu* vcpu, unsigned flags,
    fd80000045c8:	910003fd 	mov	x29, sp
        &vcpu->vm->arch.vgic_spilled,
    fd80000045cc:	f944c804 	ldr	x4, [x0, #2448]
    fd80000045d0:	910043e8 	add	x8, sp, #0x10
    fd80000045d4:	910083eb 	add	x11, sp, #0x20
    struct vgic_int* irq = NULL;
    fd80000045d8:	d2800000 	mov	x0, #0x0                   	// #0
    struct list* spilled_lists[] = {
    fd80000045dc:	f9000be3 	str	x3, [sp, #16]
        &vcpu->vm->arch.vgic_spilled,
    fd80000045e0:	91032083 	add	x3, x4, #0xc8
    struct list* spilled_lists[] = {
    fd80000045e4:	f9000fe3 	str	x3, [sp, #24]
    };
    size_t spilled_list_size = sizeof(spilled_lists) / sizeof(struct list*);
    for (size_t i = 0; i < spilled_list_size; i++) {
        struct list* list = spilled_lists[i];
    fd80000045e8:	f9400109 	ldr	x9, [x8]
        list_foreach ((*list), struct vgic_int, temp_irq) {
    fd80000045ec:	f9400123 	ldr	x3, [x9]
    fd80000045f0:	b40003e3 	cbz	x3, fd800000466c <vgic_highest_prio_spilled.constprop.0+0xac>
    if (i >= NUM_LRS) {
    fd80000045f4:	90000004 	adrp	x4, fd8000004000 <gicd_set_prio>
    fd80000045f8:	f943b084 	ldr	x4, [x4, #1888]
    if (!interrupt->in_lr || interrupt->owner->phys_id != cpu()->id) {
    fd80000045fc:	d2dfc006 	mov	x6, #0xfe0000000000        	// #279275953455104
    fd8000004600:	f9400087 	ldr	x7, [x4]
    fd8000004604:	3940c464 	ldrb	w4, [x3, #49]
    fd8000004608:	36000164 	tbz	w4, #0, fd8000004634 <vgic_highest_prio_spilled.constprop.0+0x74>
    fd800000460c:	f9400465 	ldr	x5, [x3, #8]
    fd8000004610:	f94000c4 	ldr	x4, [x6]
    fd8000004614:	f944c0a5 	ldr	x5, [x5, #2432]
    fd8000004618:	eb0400bf 	cmp	x5, x4
    fd800000461c:	540000c1 	b.ne	fd8000004634 <vgic_highest_prio_spilled.constprop.0+0x74>  // b.any
    unsigned long lr_val = gich_read_lr(interrupt->lr);
    fd8000004620:	3940bc64 	ldrb	w4, [x3, #47]
    fd8000004624:	eb2400ff 	cmp	x7, w4, uxtb
    fd8000004628:	54000389 	b.ls	fd8000004698 <vgic_highest_prio_spilled.constprop.0+0xd8>  // b.plast
    switch (i) {
    fd800000462c:	71003c9f 	cmp	w4, #0xf
    fd8000004630:	54000289 	b.ls	fd8000004680 <vgic_highest_prio_spilled.constprop.0+0xc0>  // b.plast
        state = interrupt->state;
    fd8000004634:	3940b064 	ldrb	w4, [x3, #44]
            if (!(vgic_get_state(temp_irq) & flags)) {
    fd8000004638:	6a01009f 	tst	w4, w1
    fd800000463c:	54000140 	b.eq	fd8000004664 <vgic_highest_prio_spilled.constprop.0+0xa4>  // b.none
                continue;
            }
            bool irq_is_null = irq == NULL;
            uint8_t irq_prio = irq_is_null ? GIC_LOWEST_PRIO : irq->prio;
    fd8000004640:	b40003a0 	cbz	x0, fd80000046b4 <vgic_highest_prio_spilled.constprop.0+0xf4>
    fd8000004644:	3940b404 	ldrb	w4, [x0, #45]
            irqid_t irq_id = irq_is_null ? GIC_MAX_VALID_INTERRUPTS : irq->id;
    fd8000004648:	b940280a 	ldr	w10, [x0, #40]
            bool is_higher_prio = (temp_irq->prio < irq_prio);
    fd800000464c:	3940b465 	ldrb	w5, [x3, #45]
            bool is_same_prio = temp_irq->prio == irq_prio;
            bool is_lower_id = temp_irq->id < irq_id;
    fd8000004650:	b940286c 	ldr	w12, [x3, #40]
            if (is_higher_prio || (is_same_prio && is_lower_id)) {
    fd8000004654:	6b0400bf 	cmp	w5, w4
    fd8000004658:	54000282 	b.cs	fd80000046a8 <vgic_highest_prio_spilled.constprop.0+0xe8>  // b.hs, b.nlast
                irq = temp_irq;
    fd800000465c:	aa0303e0 	mov	x0, x3
                *outlist = list;
    fd8000004660:	f9000049 	str	x9, [x2]
        list_foreach ((*list), struct vgic_int, temp_irq) {
    fd8000004664:	f9400063 	ldr	x3, [x3]
    fd8000004668:	b5fffce3 	cbnz	x3, fd8000004604 <vgic_highest_prio_spilled.constprop.0+0x44>
    for (size_t i = 0; i < spilled_list_size; i++) {
    fd800000466c:	91002108 	add	x8, x8, #0x8
    fd8000004670:	eb0b011f 	cmp	x8, x11
    fd8000004674:	54fffba1 	b.ne	fd80000045e8 <vgic_highest_prio_spilled.constprop.0+0x28>  // b.any
            }
        }
    }
    return irq;
}
    fd8000004678:	a8c27bfd 	ldp	x29, x30, [sp], #32
    fd800000467c:	d65f03c0 	ret
    fd8000004680:	90000005 	adrp	x5, fd8000004000 <gicd_set_prio>
    fd8000004684:	f943b8a5 	ldr	x5, [x5, #1904]
    fd8000004688:	386448a5 	ldrb	w5, [x5, w4, uxtw]
    fd800000468c:	10000064 	adr	x4, fd8000004698 <vgic_highest_prio_spilled.constprop.0+0xd8>
    fd8000004690:	8b258885 	add	x5, x4, w5, sxtb #2
    fd8000004694:	d61f00a0 	br	x5
        ERROR("gic: trying to read inexistent list register");
    fd8000004698:	90000000 	adrp	x0, fd8000004000 <gicd_set_prio>
    fd800000469c:	f943b400 	ldr	x0, [x0, #1896]
    fd80000046a0:	94001e60 	bl	fd800000c020 <console_printk>
    fd80000046a4:	14000000 	b	fd80000046a4 <vgic_highest_prio_spilled.constprop.0+0xe4>
            if (is_higher_prio || (is_same_prio && is_lower_id)) {
    fd80000046a8:	7a4a0182 	ccmp	w12, w10, #0x2, eq	// eq = none
    fd80000046ac:	54fffdc2 	b.cs	fd8000004664 <vgic_highest_prio_spilled.constprop.0+0xa4>  // b.hs, b.nlast
    fd80000046b0:	17ffffeb 	b	fd800000465c <vgic_highest_prio_spilled.constprop.0+0x9c>
            uint8_t irq_prio = irq_is_null ? GIC_LOWEST_PRIO : irq->prio;
    fd80000046b4:	52801fe4 	mov	w4, #0xff                  	// #255
            irqid_t irq_id = irq_is_null ? GIC_MAX_VALID_INTERRUPTS : irq->id;
    fd80000046b8:	52807f8a 	mov	w10, #0x3fc                 	// #1020
    fd80000046bc:	17ffffe4 	b	fd800000464c <vgic_highest_prio_spilled.constprop.0+0x8c>
SYSREG_GEN_ACCESSORS(ich_lr15_el2);
    fd80000046c0:	d53ccde4 	mrs	x4, ich_lr15_el2
    fd80000046c4:	d503201f 	nop
    if ((GICH_LR_VID(lr_val) == interrupt->id) && (GICH_LR_STATE(lr_val) != INV)) {
    fd80000046c8:	b9402865 	ldr	w5, [x3, #40]
    fd80000046cc:	eb2440bf 	cmp	x5, w4, uxtw
    fd80000046d0:	54fffb21 	b.ne	fd8000004634 <vgic_highest_prio_spilled.constprop.0+0x74>  // b.any
BIT_OPS_GEN(bit64, uint64_t, UINT64_C(1), BIT64_MASK);
    fd80000046d4:	d37efc84 	lsr	x4, x4, #62
    fd80000046d8:	b4fffae4 	cbz	x4, fd8000004634 <vgic_highest_prio_spilled.constprop.0+0x74>
        state = GICH_LR_STATE(lr_val);
    fd80000046dc:	12001c84 	and	w4, w4, #0xff
    fd80000046e0:	17ffffd6 	b	fd8000004638 <vgic_highest_prio_spilled.constprop.0+0x78>
SYSREG_GEN_ACCESSORS(ich_lr6_el2);
    fd80000046e4:	d53cccc4 	mrs	x4, ich_lr6_el2
            return sysreg_ich_lr6_el2_read();
    fd80000046e8:	17fffff8 	b	fd80000046c8 <vgic_highest_prio_spilled.constprop.0+0x108>
SYSREG_GEN_ACCESSORS(ich_lr7_el2);
    fd80000046ec:	d53ccce4 	mrs	x4, ich_lr7_el2
            return sysreg_ich_lr7_el2_read();
    fd80000046f0:	17fffff6 	b	fd80000046c8 <vgic_highest_prio_spilled.constprop.0+0x108>
SYSREG_GEN_ACCESSORS(ich_lr8_el2);
    fd80000046f4:	d53ccd04 	mrs	x4, ich_lr8_el2
            return sysreg_ich_lr8_el2_read();
    fd80000046f8:	17fffff4 	b	fd80000046c8 <vgic_highest_prio_spilled.constprop.0+0x108>
SYSREG_GEN_ACCESSORS(ich_lr9_el2);
    fd80000046fc:	d53ccd24 	mrs	x4, ich_lr9_el2
            return sysreg_ich_lr9_el2_read();
    fd8000004700:	17fffff2 	b	fd80000046c8 <vgic_highest_prio_spilled.constprop.0+0x108>
SYSREG_GEN_ACCESSORS(ich_lr10_el2);
    fd8000004704:	d53ccd44 	mrs	x4, ich_lr10_el2
            return sysreg_ich_lr10_el2_read();
    fd8000004708:	17fffff0 	b	fd80000046c8 <vgic_highest_prio_spilled.constprop.0+0x108>
SYSREG_GEN_ACCESSORS(ich_lr11_el2);
    fd800000470c:	d53ccd64 	mrs	x4, ich_lr11_el2
            return sysreg_ich_lr11_el2_read();
    fd8000004710:	17ffffee 	b	fd80000046c8 <vgic_highest_prio_spilled.constprop.0+0x108>
SYSREG_GEN_ACCESSORS(ich_lr12_el2);
    fd8000004714:	d53ccd84 	mrs	x4, ich_lr12_el2
            return sysreg_ich_lr12_el2_read();
    fd8000004718:	17ffffec 	b	fd80000046c8 <vgic_highest_prio_spilled.constprop.0+0x108>
SYSREG_GEN_ACCESSORS(ich_lr13_el2);
    fd800000471c:	d53ccda4 	mrs	x4, ich_lr13_el2
            return sysreg_ich_lr13_el2_read();
    fd8000004720:	17ffffea 	b	fd80000046c8 <vgic_highest_prio_spilled.constprop.0+0x108>
SYSREG_GEN_ACCESSORS(ich_lr2_el2);
    fd8000004724:	d53ccc44 	mrs	x4, ich_lr2_el2
            return sysreg_ich_lr2_el2_read();
    fd8000004728:	17ffffe8 	b	fd80000046c8 <vgic_highest_prio_spilled.constprop.0+0x108>
SYSREG_GEN_ACCESSORS(ich_lr3_el2);
    fd800000472c:	d53ccc64 	mrs	x4, ich_lr3_el2
            return sysreg_ich_lr3_el2_read();
    fd8000004730:	17ffffe6 	b	fd80000046c8 <vgic_highest_prio_spilled.constprop.0+0x108>
SYSREG_GEN_ACCESSORS(ich_lr4_el2);
    fd8000004734:	d53ccc84 	mrs	x4, ich_lr4_el2
            return sysreg_ich_lr4_el2_read();
    fd8000004738:	17ffffe4 	b	fd80000046c8 <vgic_highest_prio_spilled.constprop.0+0x108>
SYSREG_GEN_ACCESSORS(ich_lr5_el2);
    fd800000473c:	d53ccca4 	mrs	x4, ich_lr5_el2
            return sysreg_ich_lr5_el2_read();
    fd8000004740:	17ffffe2 	b	fd80000046c8 <vgic_highest_prio_spilled.constprop.0+0x108>
SYSREG_GEN_ACCESSORS(ich_lr0_el2);
    fd8000004744:	d53ccc04 	mrs	x4, ich_lr0_el2
            return sysreg_ich_lr0_el2_read();
    fd8000004748:	17ffffe0 	b	fd80000046c8 <vgic_highest_prio_spilled.constprop.0+0x108>
SYSREG_GEN_ACCESSORS(ich_lr1_el2);
    fd800000474c:	d53ccc24 	mrs	x4, ich_lr1_el2
            return sysreg_ich_lr1_el2_read();
    fd8000004750:	17ffffde 	b	fd80000046c8 <vgic_highest_prio_spilled.constprop.0+0x108>
SYSREG_GEN_ACCESSORS(ich_lr14_el2);
    fd8000004754:	d53ccdc4 	mrs	x4, ich_lr14_el2
            return sysreg_ich_lr14_el2_read();
    fd8000004758:	17ffffdc 	b	fd80000046c8 <vgic_highest_prio_spilled.constprop.0+0x108>
    fd800000475c:	d503201f 	nop
    fd8000004760:	00013088 	.word	0x00013088
    fd8000004764:	0000fd80 	.word	0x0000fd80
    fd8000004768:	000107d8 	.word	0x000107d8
    fd800000476c:	0000fd80 	.word	0x0000fd80
    fd8000004770:	00011120 	.word	0x00011120
    fd8000004774:	0000fd80 	.word	0x0000fd80
    fd8000004778:	d503201f 	nop
    fd800000477c:	d503201f 	nop

0000fd8000004780 <vgic_get_state>:
    if (!interrupt->in_lr || interrupt->owner->phys_id != cpu()->id) {
    fd8000004780:	3940c401 	ldrb	w1, [x0, #49]
    fd8000004784:	360001e1 	tbz	w1, #0, fd80000047c0 <vgic_get_state+0x40>
    fd8000004788:	f9400402 	ldr	x2, [x0, #8]
    fd800000478c:	d2dfc001 	mov	x1, #0xfe0000000000        	// #279275953455104
    fd8000004790:	f9400021 	ldr	x1, [x1]
    fd8000004794:	f944c042 	ldr	x2, [x2, #2432]
    fd8000004798:	eb01005f 	cmp	x2, x1
    fd800000479c:	54000121 	b.ne	fd80000047c0 <vgic_get_state+0x40>  // b.any
    if (i >= NUM_LRS) {
    fd80000047a0:	90000001 	adrp	x1, fd8000004000 <gicd_set_prio>
    fd80000047a4:	f9444c22 	ldr	x2, [x1, #2200]
    unsigned long lr_val = gich_read_lr(interrupt->lr);
    fd80000047a8:	3940bc01 	ldrb	w1, [x0, #47]
    fd80000047ac:	f9400042 	ldr	x2, [x2]
    fd80000047b0:	eb21005f 	cmp	x2, w1, uxtb
    fd80000047b4:	54000169 	b.ls	fd80000047e0 <vgic_get_state+0x60>  // b.plast
    switch (i) {
    fd80000047b8:	71003c3f 	cmp	w1, #0xf
    fd80000047bc:	54000069 	b.ls	fd80000047c8 <vgic_get_state+0x48>  // b.plast
        state = interrupt->state;
    fd80000047c0:	3940b000 	ldrb	w0, [x0, #44]
}
    fd80000047c4:	d65f03c0 	ret
    fd80000047c8:	90000002 	adrp	x2, fd8000004000 <gicd_set_prio>
    fd80000047cc:	f9445442 	ldr	x2, [x2, #2216]
    fd80000047d0:	38614842 	ldrb	w2, [x2, w1, uxtw]
    fd80000047d4:	10000061 	adr	x1, fd80000047e0 <vgic_get_state+0x60>
    fd80000047d8:	8b228822 	add	x2, x1, w2, sxtb #2
    fd80000047dc:	d61f0040 	br	x2
{
    fd80000047e0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    fd80000047e4:	910003fd 	mov	x29, sp
        ERROR("gic: trying to read inexistent list register");
    fd80000047e8:	90000000 	adrp	x0, fd8000004000 <gicd_set_prio>
    fd80000047ec:	f9445000 	ldr	x0, [x0, #2208]
    fd80000047f0:	94001e0c 	bl	fd800000c020 <console_printk>
    fd80000047f4:	14000000 	b	fd80000047f4 <vgic_get_state+0x74>
    fd80000047f8:	d53ccdc1 	mrs	x1, ich_lr14_el2
    fd80000047fc:	d503201f 	nop
    if ((GICH_LR_VID(lr_val) == interrupt->id) && (GICH_LR_STATE(lr_val) != INV)) {
    fd8000004800:	b9402802 	ldr	w2, [x0, #40]
    fd8000004804:	eb21405f 	cmp	x2, w1, uxtw
    fd8000004808:	54fffdc1 	b.ne	fd80000047c0 <vgic_get_state+0x40>  // b.any
    fd800000480c:	d37efc21 	lsr	x1, x1, #62
    fd8000004810:	b4fffd81 	cbz	x1, fd80000047c0 <vgic_get_state+0x40>
        state = GICH_LR_STATE(lr_val);
    fd8000004814:	12001c20 	and	w0, w1, #0xff
    fd8000004818:	d65f03c0 	ret
SYSREG_GEN_ACCESSORS(ich_lr15_el2);
    fd800000481c:	d53ccde1 	mrs	x1, ich_lr15_el2
            return sysreg_ich_lr15_el2_read();
    fd8000004820:	17fffff8 	b	fd8000004800 <vgic_get_state+0x80>
SYSREG_GEN_ACCESSORS(ich_lr0_el2);
    fd8000004824:	d53ccc01 	mrs	x1, ich_lr0_el2
            return sysreg_ich_lr0_el2_read();
    fd8000004828:	17fffff6 	b	fd8000004800 <vgic_get_state+0x80>
SYSREG_GEN_ACCESSORS(ich_lr1_el2);
    fd800000482c:	d53ccc21 	mrs	x1, ich_lr1_el2
            return sysreg_ich_lr1_el2_read();
    fd8000004830:	17fffff4 	b	fd8000004800 <vgic_get_state+0x80>
SYSREG_GEN_ACCESSORS(ich_lr2_el2);
    fd8000004834:	d53ccc41 	mrs	x1, ich_lr2_el2
            return sysreg_ich_lr2_el2_read();
    fd8000004838:	17fffff2 	b	fd8000004800 <vgic_get_state+0x80>
SYSREG_GEN_ACCESSORS(ich_lr3_el2);
    fd800000483c:	d53ccc61 	mrs	x1, ich_lr3_el2
            return sysreg_ich_lr3_el2_read();
    fd8000004840:	17fffff0 	b	fd8000004800 <vgic_get_state+0x80>
SYSREG_GEN_ACCESSORS(ich_lr4_el2);
    fd8000004844:	d53ccc81 	mrs	x1, ich_lr4_el2
            return sysreg_ich_lr4_el2_read();
    fd8000004848:	17ffffee 	b	fd8000004800 <vgic_get_state+0x80>
SYSREG_GEN_ACCESSORS(ich_lr5_el2);
    fd800000484c:	d53ccca1 	mrs	x1, ich_lr5_el2
            return sysreg_ich_lr5_el2_read();
    fd8000004850:	17ffffec 	b	fd8000004800 <vgic_get_state+0x80>
SYSREG_GEN_ACCESSORS(ich_lr6_el2);
    fd8000004854:	d53cccc1 	mrs	x1, ich_lr6_el2
            return sysreg_ich_lr6_el2_read();
    fd8000004858:	17ffffea 	b	fd8000004800 <vgic_get_state+0x80>
SYSREG_GEN_ACCESSORS(ich_lr7_el2);
    fd800000485c:	d53ccce1 	mrs	x1, ich_lr7_el2
            return sysreg_ich_lr7_el2_read();
    fd8000004860:	17ffffe8 	b	fd8000004800 <vgic_get_state+0x80>
SYSREG_GEN_ACCESSORS(ich_lr8_el2);
    fd8000004864:	d53ccd01 	mrs	x1, ich_lr8_el2
            return sysreg_ich_lr8_el2_read();
    fd8000004868:	17ffffe6 	b	fd8000004800 <vgic_get_state+0x80>
SYSREG_GEN_ACCESSORS(ich_lr9_el2);
    fd800000486c:	d53ccd21 	mrs	x1, ich_lr9_el2
            return sysreg_ich_lr9_el2_read();
    fd8000004870:	17ffffe4 	b	fd8000004800 <vgic_get_state+0x80>
SYSREG_GEN_ACCESSORS(ich_lr10_el2);
    fd8000004874:	d53ccd41 	mrs	x1, ich_lr10_el2
            return sysreg_ich_lr10_el2_read();
    fd8000004878:	17ffffe2 	b	fd8000004800 <vgic_get_state+0x80>
SYSREG_GEN_ACCESSORS(ich_lr11_el2);
    fd800000487c:	d53ccd61 	mrs	x1, ich_lr11_el2
            return sysreg_ich_lr11_el2_read();
    fd8000004880:	17ffffe0 	b	fd8000004800 <vgic_get_state+0x80>
SYSREG_GEN_ACCESSORS(ich_lr12_el2);
    fd8000004884:	d53ccd81 	mrs	x1, ich_lr12_el2
            return sysreg_ich_lr12_el2_read();
    fd8000004888:	17ffffde 	b	fd8000004800 <vgic_get_state+0x80>
SYSREG_GEN_ACCESSORS(ich_lr13_el2);
    fd800000488c:	d53ccda1 	mrs	x1, ich_lr13_el2
            return sysreg_ich_lr13_el2_read();
    fd8000004890:	17ffffdc 	b	fd8000004800 <vgic_get_state+0x80>
    fd8000004894:	d503201f 	nop
    fd8000004898:	00013088 	.word	0x00013088
    fd800000489c:	0000fd80 	.word	0x0000fd80
    fd80000048a0:	000107d8 	.word	0x000107d8
    fd80000048a4:	0000fd80 	.word	0x0000fd80
    fd80000048a8:	00011130 	.word	0x00011130
    fd80000048ac:	0000fd80 	.word	0x0000fd80

0000fd80000048b0 <vgic_get_int>:
    if (int_id < GIC_CPU_PRIV) {
    fd80000048b0:	71007c3f 	cmp	w1, #0x1f
    fd80000048b4:	2a0103e3 	mov	w3, w1
    fd80000048b8:	54000169 	b.ls	fd80000048e4 <vgic_get_int+0x34>  // b.plast
    } else if (int_id < vcpu->vm->arch.vgicd.int_num) {
    fd80000048bc:	f944c802 	ldr	x2, [x0, #2448]
    return NULL;
    fd80000048c0:	d2800000 	mov	x0, #0x0                   	// #0
    } else if (int_id < vcpu->vm->arch.vgicd.int_num) {
    fd80000048c4:	f9405444 	ldr	x4, [x2, #168]
    fd80000048c8:	eb03009f 	cmp	x4, x3
    fd80000048cc:	540000a9 	b.ls	fd80000048e0 <vgic_get_int+0x30>  // b.plast
        return &vcpu->vm->arch.vgicd.interrupts[int_id - GIC_CPU_PRIV];
    fd80000048d0:	f9404c42 	ldr	x2, [x2, #152]
    fd80000048d4:	51008021 	sub	w1, w1, #0x20
    fd80000048d8:	52800700 	mov	w0, #0x38                  	// #56
    fd80000048dc:	9ba00820 	umaddl	x0, w1, w0, x2
}
    fd80000048e0:	d65f03c0 	ret
        struct vcpu* target_vcpu = vgicr_id == vcpu->id ? vcpu : vm_get_vcpu(vcpu->vm, vgicr_id);
    fd80000048e4:	f944bc03 	ldr	x3, [x0, #2424]
    fd80000048e8:	eb03005f 	cmp	x2, x3
    fd80000048ec:	54000120 	b.eq	fd8000004910 <vgic_get_int+0x60>  // b.none
    fd80000048f0:	f944c803 	ldr	x3, [x0, #2448]
    }
    return NULL;
    fd80000048f4:	d2800000 	mov	x0, #0x0                   	// #0
    if (vcpuid < vm->cpu_num) {
    fd80000048f8:	f9402464 	ldr	x4, [x3, #72]
    fd80000048fc:	eb04005f 	cmp	x2, x4
    fd8000004900:	54000082 	b.cs	fd8000004910 <vgic_get_int+0x60>  // b.hs, b.nlast
        return &vm->vcpus[vcpuid];
    fd8000004904:	f9402063 	ldr	x3, [x3, #64]
    fd8000004908:	d2813400 	mov	x0, #0x9a0                 	// #2464
    fd800000490c:	9b000c40 	madd	x0, x2, x0, x3
        return &target_vcpu->arch.vgic_priv.interrupts[int_id];
    fd8000004910:	52800702 	mov	w2, #0x38                  	// #56
    fd8000004914:	9ba20021 	umaddl	x1, w1, w2, x0
    fd8000004918:	91090020 	add	x0, x1, #0x240
}
    fd800000491c:	d65f03c0 	ret

0000fd8000004920 <vgic_get_ownership>:
    if (interrupt->owner == vcpu) {
    fd8000004920:	f9400423 	ldr	x3, [x1, #8]
{
    fd8000004924:	aa0003e2 	mov	x2, x0
    if (interrupt->owner == vcpu) {
    fd8000004928:	eb00007f 	cmp	x3, x0
    fd800000492c:	540000a0 	b.eq	fd8000004940 <vgic_get_ownership+0x20>  // b.none
    bool ret = false;
    fd8000004930:	52800000 	mov	w0, #0x0                   	// #0
    } else if (interrupt->owner == NULL) {
    fd8000004934:	b4000043 	cbz	x3, fd800000493c <vgic_get_ownership+0x1c>
}
    fd8000004938:	d65f03c0 	ret
        interrupt->owner = vcpu;
    fd800000493c:	f9000422 	str	x2, [x1, #8]
        ret = true;
    fd8000004940:	52800020 	mov	w0, #0x1                   	// #1
}
    fd8000004944:	d65f03c0 	ret
    fd8000004948:	d503201f 	nop
    fd800000494c:	d503201f 	nop

0000fd8000004950 <vgic_owns>:
    return interrupt->owner == vcpu;
    fd8000004950:	f9400421 	ldr	x1, [x1, #8]
    fd8000004954:	eb00003f 	cmp	x1, x0
}
    fd8000004958:	1a9f17e0 	cset	w0, eq	// eq = none
    fd800000495c:	d65f03c0 	ret

0000fd8000004960 <vgic_yield_ownership>:
{
    fd8000004960:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    fd8000004964:	910003fd 	mov	x29, sp
    fd8000004968:	f9000bf3 	str	x19, [sp, #16]
    fd800000496c:	aa0103f3 	mov	x19, x1
    if ((GIC_VERSION == GICV2 && gic_is_priv(interrupt->id)) || !vgic_owns(vcpu, interrupt) ||
    fd8000004970:	f9400421 	ldr	x1, [x1, #8]
    fd8000004974:	eb00003f 	cmp	x1, x0
    fd8000004978:	54000080 	b.eq	fd8000004988 <vgic_yield_ownership+0x28>  // b.none
}
    fd800000497c:	f9400bf3 	ldr	x19, [sp, #16]
    fd8000004980:	a8c27bfd 	ldp	x29, x30, [sp], #32
    fd8000004984:	d65f03c0 	ret
    if ((GIC_VERSION == GICV2 && gic_is_priv(interrupt->id)) || !vgic_owns(vcpu, interrupt) ||
    fd8000004988:	3940c660 	ldrb	w0, [x19, #49]
    fd800000498c:	3707ff80 	tbnz	w0, #0, fd800000497c <vgic_yield_ownership+0x1c>
        interrupt->in_lr || (vgic_get_state(interrupt) & ACT)) {
    fd8000004990:	aa1303e0 	mov	x0, x19
    fd8000004994:	97ffff7b 	bl	fd8000004780 <vgic_get_state>
    fd8000004998:	370fff20 	tbnz	w0, #1, fd800000497c <vgic_yield_ownership+0x1c>
    interrupt->owner = NULL;
    fd800000499c:	f900067f 	str	xzr, [x19, #8]
}
    fd80000049a0:	f9400bf3 	ldr	x19, [sp, #16]
    fd80000049a4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    fd80000049a8:	d65f03c0 	ret
    fd80000049ac:	d503201f 	nop

0000fd80000049b0 <vgic_send_sgi_msg>:
{
    fd80000049b0:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
        VGIC_MSG_DATA(cpu()->vcpu->vm->id, 0, int_id, 0, cpu()->vcpu->id),
    fd80000049b4:	d2dfc000 	mov	x0, #0xfe0000000000        	// #279275953455104
    struct cpu_msg msg = {
    fd80000049b8:	52800046 	mov	w6, #0x2                   	// #2
{
    fd80000049bc:	910003fd 	mov	x29, sp
        VGIC_MSG_DATA(cpu()->vcpu->vm->id, 0, int_id, 0, cpu()->vcpu->id),
    fd80000049c0:	f9402800 	ldr	x0, [x0, #80]
    struct cpu_msg msg = {
    fd80000049c4:	90000003 	adrp	x3, fd8000004000 <gicd_set_prio>
    fd80000049c8:	f9452c63 	ldr	x3, [x3, #2648]
        VGIC_MSG_DATA(cpu()->vcpu->vm->id, 0, int_id, 0, cpu()->vcpu->id),
    fd80000049cc:	d3703842 	ubfiz	x2, x2, #16, #15
    fd80000049d0:	f944c805 	ldr	x5, [x0, #2448]
    struct cpu_msg msg = {
    fd80000049d4:	f9400063 	ldr	x3, [x3]
{
    fd80000049d8:	f90013f5 	str	x21, [sp, #32]
    for (size_t i = 0; i < platform.cpu_num; i++) {
    fd80000049dc:	90000004 	adrp	x4, fd8000004000 <gicd_set_prio>
    fd80000049e0:	f9453095 	ldr	x21, [x4, #2656]
    struct cpu_msg msg = {
    fd80000049e4:	29061be3 	stp	w3, w6, [sp, #48]
        VGIC_MSG_DATA(cpu()->vcpu->vm->id, 0, int_id, 0, cpu()->vcpu->id),
    fd80000049e8:	3965e004 	ldrb	w4, [x0, #2424]
    fd80000049ec:	f94000a0 	ldr	x0, [x5]
    for (size_t i = 0; i < platform.cpu_num; i++) {
    fd80000049f0:	f94002a3 	ldr	x3, [x21]
        VGIC_MSG_DATA(cpu()->vcpu->vm->id, 0, int_id, 0, cpu()->vcpu->id),
    fd80000049f4:	aa00c080 	orr	x0, x4, x0, lsl #48
    fd80000049f8:	aa020000 	orr	x0, x0, x2
    struct cpu_msg msg = {
    fd80000049fc:	f9001fe0 	str	x0, [sp, #56]
    for (size_t i = 0; i < platform.cpu_num; i++) {
    fd8000004a00:	b4000263 	cbz	x3, fd8000004a4c <vgic_send_sgi_msg+0x9c>
    fd8000004a04:	a90153f3 	stp	x19, x20, [sp, #16]
    fd8000004a08:	aa0103f4 	mov	x20, x1
    fd8000004a0c:	d2800013 	mov	x19, #0x0                   	// #0
    fd8000004a10:	14000005 	b	fd8000004a24 <vgic_send_sgi_msg+0x74>
    fd8000004a14:	f94002a0 	ldr	x0, [x21]
    fd8000004a18:	91000673 	add	x19, x19, #0x1
    fd8000004a1c:	eb13001f 	cmp	x0, x19
    fd8000004a20:	54000149 	b.ls	fd8000004a48 <vgic_send_sgi_msg+0x98>  // b.plast
        if (pcpu_mask & (1ull << i)) {
    fd8000004a24:	9ad32680 	lsr	x0, x20, x19
    fd8000004a28:	3607ff60 	tbz	w0, #0, fd8000004a14 <vgic_send_sgi_msg+0x64>
            cpu_send_msg(i, &msg);
    fd8000004a2c:	aa1303e0 	mov	x0, x19
    fd8000004a30:	9100c3e1 	add	x1, sp, #0x30
    fd8000004a34:	94001807 	bl	fd800000aa50 <cpu_send_msg>
    for (size_t i = 0; i < platform.cpu_num; i++) {
    fd8000004a38:	91000673 	add	x19, x19, #0x1
    fd8000004a3c:	f94002a0 	ldr	x0, [x21]
    fd8000004a40:	eb13001f 	cmp	x0, x19
    fd8000004a44:	54ffff08 	b.hi	fd8000004a24 <vgic_send_sgi_msg+0x74>  // b.pmore
    fd8000004a48:	a94153f3 	ldp	x19, x20, [sp, #16]
}
    fd8000004a4c:	f94013f5 	ldr	x21, [sp, #32]
    fd8000004a50:	a8c47bfd 	ldp	x29, x30, [sp], #64
    fd8000004a54:	d65f03c0 	ret
    fd8000004a58:	00012e78 	.word	0x00012e78
    fd8000004a5c:	0000fd80 	.word	0x0000fd80
    fd8000004a60:	00012930 	.word	0x00012930
    fd8000004a64:	0000fd80 	.word	0x0000fd80
    fd8000004a68:	d503201f 	nop
    fd8000004a6c:	d503201f 	nop

0000fd8000004a70 <vgic_remove_lr>:
{
    fd8000004a70:	aa0003e2 	mov	x2, x0
    return interrupt->owner == vcpu;
    fd8000004a74:	f9400420 	ldr	x0, [x1, #8]
    if (!vgic_owns(vcpu, interrupt) || !interrupt->in_lr) {
    fd8000004a78:	eb00005f 	cmp	x2, x0
    fd8000004a7c:	54000060 	b.eq	fd8000004a88 <vgic_remove_lr+0x18>  // b.none
        return ret;
    fd8000004a80:	52800000 	mov	w0, #0x0                   	// #0
    fd8000004a84:	d65f03c0 	ret
    if (!vgic_owns(vcpu, interrupt) || !interrupt->in_lr) {
    fd8000004a88:	3940c420 	ldrb	w0, [x1, #49]
    fd8000004a8c:	3607ffa0 	tbz	w0, #0, fd8000004a80 <vgic_remove_lr+0x10>
    if (!interrupt->in_lr || interrupt->owner->phys_id != cpu()->id) {
    fd8000004a90:	d2dfc004 	mov	x4, #0xfe0000000000        	// #279275953455104
    fd8000004a94:	f944c043 	ldr	x3, [x2, #2432]
    fd8000004a98:	f9400082 	ldr	x2, [x4]
    fd8000004a9c:	eb02007f 	cmp	x3, x2
    fd8000004aa0:	54000121 	b.ne	fd8000004ac4 <vgic_remove_lr+0x54>  // b.any
    if (i >= NUM_LRS) {
    fd8000004aa4:	90000002 	adrp	x2, fd8000004000 <gicd_set_prio>
    fd8000004aa8:	f9465043 	ldr	x3, [x2, #3232]
    unsigned long lr_val = gich_read_lr(interrupt->lr);
    fd8000004aac:	3940bc22 	ldrb	w2, [x1, #47]
    fd8000004ab0:	f9400063 	ldr	x3, [x3]
    fd8000004ab4:	eb22007f 	cmp	x3, w2, uxtb
    fd8000004ab8:	54000169 	b.ls	fd8000004ae4 <vgic_remove_lr+0x74>  // b.plast
    switch (i) {
    fd8000004abc:	71003c5f 	cmp	w2, #0xf
    fd8000004ac0:	54000069 	b.ls	fd8000004acc <vgic_remove_lr+0x5c>  // b.plast
    interrupt->in_lr = false;
    fd8000004ac4:	3900c43f 	strb	wzr, [x1, #49]
    if (GICH_LR_STATE(lr_val) != INV) {
    fd8000004ac8:	17ffffee 	b	fd8000004a80 <vgic_remove_lr+0x10>
    fd8000004acc:	90000003 	adrp	x3, fd8000004000 <gicd_set_prio>
    fd8000004ad0:	f9465863 	ldr	x3, [x3, #3248]
    fd8000004ad4:	38624863 	ldrb	w3, [x3, w2, uxtw]
    fd8000004ad8:	10000064 	adr	x4, fd8000004ae4 <vgic_remove_lr+0x74>
    fd8000004adc:	8b238883 	add	x3, x4, w3, sxtb #2
    fd8000004ae0:	d61f0060 	br	x3
{
    fd8000004ae4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    fd8000004ae8:	910003fd 	mov	x29, sp
        ERROR("gic: trying to read inexistent list register");
    fd8000004aec:	90000000 	adrp	x0, fd8000004000 <gicd_set_prio>
    fd8000004af0:	f9465400 	ldr	x0, [x0, #3240]
    fd8000004af4:	94001d4b 	bl	fd800000c020 <console_printk>
    fd8000004af8:	14000000 	b	fd8000004af8 <vgic_remove_lr+0x88>
SYSREG_GEN_ACCESSORS(ich_lr14_el2);
    fd8000004afc:	d53ccdc3 	mrs	x3, ich_lr14_el2
    if ((GICH_LR_VID(lr_val) == interrupt->id) && (GICH_LR_STATE(lr_val) != INV)) {
    fd8000004b00:	b9402824 	ldr	w4, [x1, #40]
    fd8000004b04:	eb23409f 	cmp	x4, w3, uxtw
    fd8000004b08:	54fffde1 	b.ne	fd8000004ac4 <vgic_remove_lr+0x54>  // b.any
    fd8000004b0c:	d37efc63 	lsr	x3, x3, #62
    fd8000004b10:	b4fffda3 	cbz	x3, fd8000004ac4 <vgic_remove_lr+0x54>
    switch (i) {
    fd8000004b14:	51000442 	sub	w2, w2, #0x1
    fd8000004b18:	7100385f 	cmp	w2, #0xe
    fd8000004b1c:	540005c9 	b.ls	fd8000004bd4 <vgic_remove_lr+0x164>  // b.plast
SYSREG_GEN_ACCESSORS(ich_lr0_el2);
    fd8000004b20:	d2800002 	mov	x2, #0x0                   	// #0
    fd8000004b24:	d51ccc02 	msr	ich_lr0_el2, x2
        interrupt->state = GICH_LR_STATE(lr_val);
    fd8000004b28:	12001c63 	and	w3, w3, #0xff
    fd8000004b2c:	3900b023 	strb	w3, [x1, #44]
    interrupt->in_lr = false;
    fd8000004b30:	3900c43f 	strb	wzr, [x1, #49]
SYSREG_GEN_ACCESSORS(ich_hcr_el2);
    fd8000004b34:	d53ccb04 	mrs	x4, ich_hcr_el2
    return sysreg_ich_hcr_el2_read();
    fd8000004b38:	2a0403e2 	mov	w2, w4
        if ((interrupt->state & PEND) && interrupt->enabled) {
    fd8000004b3c:	360000a3 	tbz	w3, #0, fd8000004b50 <vgic_remove_lr+0xe0>
    fd8000004b40:	3940c822 	ldrb	w2, [x1, #50]
    fd8000004b44:	4b0203e2 	neg	w2, w2
    fd8000004b48:	121d0042 	and	w2, w2, #0x8
    fd8000004b4c:	2a040042 	orr	w2, w2, w4
    sysreg_ich_hcr_el2_write(hcr);
    fd8000004b50:	321f0042 	orr	w2, w2, #0x2
    fd8000004b54:	d51ccb02 	msr	ich_hcr_el2, x2
}
    fd8000004b58:	d65f03c0 	ret
SYSREG_GEN_ACCESSORS(ich_lr13_el2);
    fd8000004b5c:	d53ccda3 	mrs	x3, ich_lr13_el2
            return sysreg_ich_lr13_el2_read();
    fd8000004b60:	17ffffe8 	b	fd8000004b00 <vgic_remove_lr+0x90>
SYSREG_GEN_ACCESSORS(ich_lr12_el2);
    fd8000004b64:	d53ccd83 	mrs	x3, ich_lr12_el2
            return sysreg_ich_lr12_el2_read();
    fd8000004b68:	17ffffe6 	b	fd8000004b00 <vgic_remove_lr+0x90>
SYSREG_GEN_ACCESSORS(ich_lr11_el2);
    fd8000004b6c:	d53ccd63 	mrs	x3, ich_lr11_el2
            return sysreg_ich_lr11_el2_read();
    fd8000004b70:	17ffffe4 	b	fd8000004b00 <vgic_remove_lr+0x90>
SYSREG_GEN_ACCESSORS(ich_lr10_el2);
    fd8000004b74:	d53ccd43 	mrs	x3, ich_lr10_el2
            return sysreg_ich_lr10_el2_read();
    fd8000004b78:	17ffffe2 	b	fd8000004b00 <vgic_remove_lr+0x90>
SYSREG_GEN_ACCESSORS(ich_lr9_el2);
    fd8000004b7c:	d53ccd23 	mrs	x3, ich_lr9_el2
            return sysreg_ich_lr9_el2_read();
    fd8000004b80:	17ffffe0 	b	fd8000004b00 <vgic_remove_lr+0x90>
SYSREG_GEN_ACCESSORS(ich_lr8_el2);
    fd8000004b84:	d53ccd03 	mrs	x3, ich_lr8_el2
            return sysreg_ich_lr8_el2_read();
    fd8000004b88:	17ffffde 	b	fd8000004b00 <vgic_remove_lr+0x90>
SYSREG_GEN_ACCESSORS(ich_lr7_el2);
    fd8000004b8c:	d53ccce3 	mrs	x3, ich_lr7_el2
            return sysreg_ich_lr7_el2_read();
    fd8000004b90:	17ffffdc 	b	fd8000004b00 <vgic_remove_lr+0x90>
SYSREG_GEN_ACCESSORS(ich_lr6_el2);
    fd8000004b94:	d53cccc3 	mrs	x3, ich_lr6_el2
            return sysreg_ich_lr6_el2_read();
    fd8000004b98:	17ffffda 	b	fd8000004b00 <vgic_remove_lr+0x90>
SYSREG_GEN_ACCESSORS(ich_lr5_el2);
    fd8000004b9c:	d53ccca3 	mrs	x3, ich_lr5_el2
            return sysreg_ich_lr5_el2_read();
    fd8000004ba0:	17ffffd8 	b	fd8000004b00 <vgic_remove_lr+0x90>
SYSREG_GEN_ACCESSORS(ich_lr4_el2);
    fd8000004ba4:	d53ccc83 	mrs	x3, ich_lr4_el2
            return sysreg_ich_lr4_el2_read();
    fd8000004ba8:	17ffffd6 	b	fd8000004b00 <vgic_remove_lr+0x90>
SYSREG_GEN_ACCESSORS(ich_lr3_el2);
    fd8000004bac:	d53ccc63 	mrs	x3, ich_lr3_el2
            return sysreg_ich_lr3_el2_read();
    fd8000004bb0:	17ffffd4 	b	fd8000004b00 <vgic_remove_lr+0x90>
SYSREG_GEN_ACCESSORS(ich_lr2_el2);
    fd8000004bb4:	d53ccc43 	mrs	x3, ich_lr2_el2
            return sysreg_ich_lr2_el2_read();
    fd8000004bb8:	17ffffd2 	b	fd8000004b00 <vgic_remove_lr+0x90>
SYSREG_GEN_ACCESSORS(ich_lr1_el2);
    fd8000004bbc:	d53ccc23 	mrs	x3, ich_lr1_el2
            return sysreg_ich_lr1_el2_read();
    fd8000004bc0:	17ffffd0 	b	fd8000004b00 <vgic_remove_lr+0x90>
SYSREG_GEN_ACCESSORS(ich_lr0_el2);
    fd8000004bc4:	d53ccc03 	mrs	x3, ich_lr0_el2
            return sysreg_ich_lr0_el2_read();
    fd8000004bc8:	17ffffce 	b	fd8000004b00 <vgic_remove_lr+0x90>
SYSREG_GEN_ACCESSORS(ich_lr15_el2);
    fd8000004bcc:	d53ccde3 	mrs	x3, ich_lr15_el2
            return sysreg_ich_lr15_el2_read();
    fd8000004bd0:	17ffffcc 	b	fd8000004b00 <vgic_remove_lr+0x90>
    switch (i) {
    fd8000004bd4:	90000004 	adrp	x4, fd8000004000 <gicd_set_prio>
    fd8000004bd8:	f9465c84 	ldr	x4, [x4, #3256]
    fd8000004bdc:	38624884 	ldrb	w4, [x4, w2, uxtw]
    fd8000004be0:	10000062 	adr	x2, fd8000004bec <vgic_remove_lr+0x17c>
    fd8000004be4:	8b248844 	add	x4, x2, w4, sxtb #2
    fd8000004be8:	d61f0080 	br	x4
SYSREG_GEN_ACCESSORS(ich_lr14_el2);
    fd8000004bec:	d2800002 	mov	x2, #0x0                   	// #0
    fd8000004bf0:	d51ccdc2 	msr	ich_lr14_el2, x2
    fd8000004bf4:	17ffffcd 	b	fd8000004b28 <vgic_remove_lr+0xb8>
SYSREG_GEN_ACCESSORS(ich_lr13_el2);
    fd8000004bf8:	d2800002 	mov	x2, #0x0                   	// #0
    fd8000004bfc:	d51ccda2 	msr	ich_lr13_el2, x2
    fd8000004c00:	17ffffca 	b	fd8000004b28 <vgic_remove_lr+0xb8>
SYSREG_GEN_ACCESSORS(ich_lr12_el2);
    fd8000004c04:	d2800002 	mov	x2, #0x0                   	// #0
    fd8000004c08:	d51ccd82 	msr	ich_lr12_el2, x2
    fd8000004c0c:	17ffffc7 	b	fd8000004b28 <vgic_remove_lr+0xb8>
SYSREG_GEN_ACCESSORS(ich_lr11_el2);
    fd8000004c10:	d2800002 	mov	x2, #0x0                   	// #0
    fd8000004c14:	d51ccd62 	msr	ich_lr11_el2, x2
    fd8000004c18:	17ffffc4 	b	fd8000004b28 <vgic_remove_lr+0xb8>
SYSREG_GEN_ACCESSORS(ich_lr10_el2);
    fd8000004c1c:	d2800002 	mov	x2, #0x0                   	// #0
    fd8000004c20:	d51ccd42 	msr	ich_lr10_el2, x2
    fd8000004c24:	17ffffc1 	b	fd8000004b28 <vgic_remove_lr+0xb8>
SYSREG_GEN_ACCESSORS(ich_lr9_el2);
    fd8000004c28:	d2800002 	mov	x2, #0x0                   	// #0
    fd8000004c2c:	d51ccd22 	msr	ich_lr9_el2, x2
    fd8000004c30:	17ffffbe 	b	fd8000004b28 <vgic_remove_lr+0xb8>
SYSREG_GEN_ACCESSORS(ich_lr8_el2);
    fd8000004c34:	d2800002 	mov	x2, #0x0                   	// #0
    fd8000004c38:	d51ccd02 	msr	ich_lr8_el2, x2
    fd8000004c3c:	17ffffbb 	b	fd8000004b28 <vgic_remove_lr+0xb8>
SYSREG_GEN_ACCESSORS(ich_lr7_el2);
    fd8000004c40:	d2800002 	mov	x2, #0x0                   	// #0
    fd8000004c44:	d51ccce2 	msr	ich_lr7_el2, x2
    fd8000004c48:	17ffffb8 	b	fd8000004b28 <vgic_remove_lr+0xb8>
SYSREG_GEN_ACCESSORS(ich_lr6_el2);
    fd8000004c4c:	d2800002 	mov	x2, #0x0                   	// #0
    fd8000004c50:	d51cccc2 	msr	ich_lr6_el2, x2
    fd8000004c54:	17ffffb5 	b	fd8000004b28 <vgic_remove_lr+0xb8>
SYSREG_GEN_ACCESSORS(ich_lr5_el2);
    fd8000004c58:	d2800002 	mov	x2, #0x0                   	// #0
    fd8000004c5c:	d51ccca2 	msr	ich_lr5_el2, x2
    fd8000004c60:	17ffffb2 	b	fd8000004b28 <vgic_remove_lr+0xb8>
SYSREG_GEN_ACCESSORS(ich_lr4_el2);
    fd8000004c64:	d2800002 	mov	x2, #0x0                   	// #0
    fd8000004c68:	d51ccc82 	msr	ich_lr4_el2, x2
    fd8000004c6c:	17ffffaf 	b	fd8000004b28 <vgic_remove_lr+0xb8>
SYSREG_GEN_ACCESSORS(ich_lr3_el2);
    fd8000004c70:	d2800002 	mov	x2, #0x0                   	// #0
    fd8000004c74:	d51ccc62 	msr	ich_lr3_el2, x2
    fd8000004c78:	17ffffac 	b	fd8000004b28 <vgic_remove_lr+0xb8>
SYSREG_GEN_ACCESSORS(ich_lr2_el2);
    fd8000004c7c:	d2800002 	mov	x2, #0x0                   	// #0
    fd8000004c80:	d51ccc42 	msr	ich_lr2_el2, x2
    fd8000004c84:	17ffffa9 	b	fd8000004b28 <vgic_remove_lr+0xb8>
SYSREG_GEN_ACCESSORS(ich_lr1_el2);
    fd8000004c88:	d2800002 	mov	x2, #0x0                   	// #0
    fd8000004c8c:	d51ccc22 	msr	ich_lr1_el2, x2
    fd8000004c90:	17ffffa6 	b	fd8000004b28 <vgic_remove_lr+0xb8>
SYSREG_GEN_ACCESSORS(ich_lr15_el2);
    fd8000004c94:	d2800002 	mov	x2, #0x0                   	// #0
    fd8000004c98:	d51ccde2 	msr	ich_lr15_el2, x2
    fd8000004c9c:	17ffffa3 	b	fd8000004b28 <vgic_remove_lr+0xb8>
    fd8000004ca0:	00013088 	.word	0x00013088
    fd8000004ca4:	0000fd80 	.word	0x0000fd80
    fd8000004ca8:	000107d8 	.word	0x000107d8
    fd8000004cac:	0000fd80 	.word	0x0000fd80
    fd8000004cb0:	00011140 	.word	0x00011140
    fd8000004cb4:	0000fd80 	.word	0x0000fd80
    fd8000004cb8:	00011150 	.word	0x00011150
    fd8000004cbc:	0000fd80 	.word	0x0000fd80

0000fd8000004cc0 <vgic_add_spilled>:
    spin_lock(&vcpu->vm->arch.vgic_spilled_lock);
    fd8000004cc0:	f944c802 	ldr	x2, [x0, #2448]
    __asm__ volatile(
    fd8000004cc4:	91038045 	add	x5, x2, #0xe0
    fd8000004cc8:	91039046 	add	x6, x2, #0xe4
    fd8000004ccc:	885ffca2 	ldaxr	w2, [x5]
    fd8000004cd0:	11000443 	add	w3, w2, #0x1
    fd8000004cd4:	88047ca3 	stxr	w4, w3, [x5]
    fd8000004cd8:	35ffffa4 	cbnz	w4, fd8000004ccc <vgic_add_spilled+0xc>
    fd8000004cdc:	88dffcc3 	ldar	w3, [x6]
    fd8000004ce0:	6b03005f 	cmp	w2, w3
    fd8000004ce4:	54000060 	b.eq	fd8000004cf0 <vgic_add_spilled+0x30>  // b.none
    fd8000004ce8:	d503205f 	wfe
    fd8000004cec:	17fffffc 	b	fd8000004cdc <vgic_add_spilled+0x1c>
    if (gic_is_priv(interrupt->id)) {
    fd8000004cf0:	b9402822 	ldr	w2, [x1, #40]
    fd8000004cf4:	71007c5f 	cmp	w2, #0x1f
    fd8000004cf8:	540004a8 	b.hi	fd8000004d8c <vgic_add_spilled+0xcc>  // b.pmore
        spilled_list = &vcpu->arch.vgic_spilled;
    fd8000004cfc:	91250002 	add	x2, x0, #0x940

static inline void list_push(struct list* list, node_t* node)
{
    if (list != NULL && node != NULL) {
        *node = NULL;
        spin_lock(&list->lock);
    fd8000004d00:	91004043 	add	x3, x2, #0x10
        *node = NULL;
    fd8000004d04:	f900003f 	str	xzr, [x1]
    fd8000004d08:	91001067 	add	x7, x3, #0x4
    fd8000004d0c:	885ffc64 	ldaxr	w4, [x3]
    fd8000004d10:	11000485 	add	w5, w4, #0x1
    fd8000004d14:	88067c65 	stxr	w6, w5, [x3]
    fd8000004d18:	35ffffa6 	cbnz	w6, fd8000004d0c <vgic_add_spilled+0x4c>
    fd8000004d1c:	88dffce5 	ldar	w5, [x7]
    fd8000004d20:	6b05009f 	cmp	w4, w5
    fd8000004d24:	54000060 	b.eq	fd8000004d30 <vgic_add_spilled+0x70>  // b.none
    fd8000004d28:	d503205f 	wfe
    fd8000004d2c:	17fffffc 	b	fd8000004d1c <vgic_add_spilled+0x5c>

        if (list->tail != NULL) {
    fd8000004d30:	f9400444 	ldr	x4, [x2, #8]
    fd8000004d34:	b4000044 	cbz	x4, fd8000004d3c <vgic_add_spilled+0x7c>
            *list->tail = node;
    fd8000004d38:	f9000081 	str	x1, [x4]
        }

        list->tail = node;

        if (list->head == NULL) {
    fd8000004d3c:	f9400044 	ldr	x4, [x2]
        list->tail = node;
    fd8000004d40:	f9000441 	str	x1, [x2, #8]
        if (list->head == NULL) {
    fd8000004d44:	b40002a4 	cbz	x4, fd8000004d98 <vgic_add_spilled+0xd8>
    __asm__ volatile(
    fd8000004d48:	91001062 	add	x2, x3, #0x4
    fd8000004d4c:	b9400041 	ldr	w1, [x2]
    fd8000004d50:	11000421 	add	w1, w1, #0x1
    fd8000004d54:	889ffc41 	stlr	w1, [x2]
    fd8000004d58:	d5033b9f 	dsb	ish
    fd8000004d5c:	d503209f 	sev
    fd8000004d60:	f944c800 	ldr	x0, [x0, #2448]
    fd8000004d64:	91039001 	add	x1, x0, #0xe4
    fd8000004d68:	b9400020 	ldr	w0, [x1]
    fd8000004d6c:	11000400 	add	w0, w0, #0x1
    fd8000004d70:	889ffc20 	stlr	w0, [x1]
    fd8000004d74:	d5033b9f 	dsb	ish
    fd8000004d78:	d503209f 	sev
SYSREG_GEN_ACCESSORS(ich_hcr_el2);
    fd8000004d7c:	d53ccb00 	mrs	x0, ich_hcr_el2
    sysreg_ich_hcr_el2_write(hcr);
    fd8000004d80:	321d0000 	orr	w0, w0, #0x8
    fd8000004d84:	d51ccb00 	msr	ich_hcr_el2, x0
}
    fd8000004d88:	d65f03c0 	ret
        spilled_list = &vcpu->vm->arch.vgic_spilled;
    fd8000004d8c:	f944c802 	ldr	x2, [x0, #2448]
    fd8000004d90:	91032042 	add	x2, x2, #0xc8
    if (list != NULL && node != NULL) {
    fd8000004d94:	17ffffdb 	b	fd8000004d00 <vgic_add_spilled+0x40>
            list->head = node;
    fd8000004d98:	f9000041 	str	x1, [x2]
    fd8000004d9c:	17ffffeb 	b	fd8000004d48 <vgic_add_spilled+0x88>

0000fd8000004da0 <vgic_spill_lr>:
{
    fd8000004da0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    fd8000004da4:	910003fd 	mov	x29, sp
    if (i >= NUM_LRS) {
    fd8000004da8:	90000002 	adrp	x2, fd8000004000 <gicd_set_prio>
    fd8000004dac:	f947b042 	ldr	x2, [x2, #3936]
    fd8000004db0:	a90153f3 	stp	x19, x20, [sp, #16]
    fd8000004db4:	aa0003f3 	mov	x19, x0
    fd8000004db8:	f9400040 	ldr	x0, [x2]
    fd8000004dbc:	eb21401f 	cmp	x0, w1, uxtw
    fd8000004dc0:	540001a9 	b.ls	fd8000004df4 <vgic_spill_lr+0x54>  // b.plast
    switch (i) {
    fd8000004dc4:	71003c3f 	cmp	w1, #0xf
    fd8000004dc8:	540000a9 	b.ls	fd8000004ddc <vgic_spill_lr+0x3c>  // b.plast
    fd8000004dcc:	d2804814 	mov	x20, #0x240                 	// #576
        return &target_vcpu->arch.vgic_priv.interrupts[int_id];
    fd8000004dd0:	8b140274 	add	x20, x19, x20
    fd8000004dd4:	f90013f5 	str	x21, [sp, #32]
    if (spilled_int != NULL) {
    fd8000004dd8:	14000018 	b	fd8000004e38 <vgic_spill_lr+0x98>
    fd8000004ddc:	90000000 	adrp	x0, fd8000004000 <gicd_set_prio>
    fd8000004de0:	f947b800 	ldr	x0, [x0, #3952]
    fd8000004de4:	38614800 	ldrb	w0, [x0, w1, uxtw]
    fd8000004de8:	10000061 	adr	x1, fd8000004df4 <vgic_spill_lr+0x54>
    fd8000004dec:	8b208820 	add	x0, x1, w0, sxtb #2
    fd8000004df0:	d61f0000 	br	x0
        ERROR("gic: trying to read inexistent list register");
    fd8000004df4:	90000000 	adrp	x0, fd8000004000 <gicd_set_prio>
    fd8000004df8:	f947b400 	ldr	x0, [x0, #3944]
    fd8000004dfc:	94001c89 	bl	fd800000c020 <console_printk>
    fd8000004e00:	14000000 	b	fd8000004e00 <vgic_spill_lr+0x60>
SYSREG_GEN_ACCESSORS(ich_lr14_el2);
    fd8000004e04:	d53ccdc1 	mrs	x1, ich_lr14_el2
    if (int_id < GIC_CPU_PRIV) {
    fd8000004e08:	71007c3f 	cmp	w1, #0x1f
    fd8000004e0c:	540008e9 	b.ls	fd8000004f28 <vgic_spill_lr+0x188>  // b.plast
    } else if (int_id < vcpu->vm->arch.vgicd.int_num) {
    fd8000004e10:	f944ca62 	ldr	x2, [x19, #2448]
    fd8000004e14:	f9405443 	ldr	x3, [x2, #168]
    fd8000004e18:	eb21407f 	cmp	x3, w1, uxtw
    fd8000004e1c:	54000449 	b.ls	fd8000004ea4 <vgic_spill_lr+0x104>  // b.plast
        return &vcpu->vm->arch.vgicd.interrupts[int_id - GIC_CPU_PRIV];
    fd8000004e20:	51008020 	sub	w0, w1, #0x20
    fd8000004e24:	f9404c41 	ldr	x1, [x2, #152]
    fd8000004e28:	52800702 	mov	w2, #0x38                  	// #56
    fd8000004e2c:	9ba20414 	umaddl	x20, w0, w2, x1
    if (spilled_int != NULL) {
    fd8000004e30:	b40003b4 	cbz	x20, fd8000004ea4 <vgic_spill_lr+0x104>
    fd8000004e34:	f90013f5 	str	x21, [sp, #32]
        spin_lock(&spilled_int->lock);
    fd8000004e38:	91008295 	add	x21, x20, #0x20
    __asm__ volatile(
    fd8000004e3c:	910012a3 	add	x3, x21, #0x4
    fd8000004e40:	885ffea0 	ldaxr	w0, [x21]
    fd8000004e44:	11000401 	add	w1, w0, #0x1
    fd8000004e48:	88027ea1 	stxr	w2, w1, [x21]
    fd8000004e4c:	35ffffa2 	cbnz	w2, fd8000004e40 <vgic_spill_lr+0xa0>
    fd8000004e50:	88dffc61 	ldar	w1, [x3]
    fd8000004e54:	6b01001f 	cmp	w0, w1
    fd8000004e58:	54000060 	b.eq	fd8000004e64 <vgic_spill_lr+0xc4>  // b.none
    fd8000004e5c:	d503205f 	wfe
    fd8000004e60:	17fffffc 	b	fd8000004e50 <vgic_spill_lr+0xb0>
        vgic_remove_lr(vcpu, spilled_int);
    fd8000004e64:	aa1403e1 	mov	x1, x20
    fd8000004e68:	aa1303e0 	mov	x0, x19
    fd8000004e6c:	97ffff01 	bl	fd8000004a70 <vgic_remove_lr>
        vgic_add_spilled(vcpu, spilled_int);
    fd8000004e70:	aa1303e0 	mov	x0, x19
    fd8000004e74:	aa1403e1 	mov	x1, x20
    fd8000004e78:	97ffff92 	bl	fd8000004cc0 <vgic_add_spilled>
    if ((GIC_VERSION == GICV2 && gic_is_priv(interrupt->id)) || !vgic_owns(vcpu, interrupt) ||
    fd8000004e7c:	f9400680 	ldr	x0, [x20, #8]
    fd8000004e80:	eb00027f 	cmp	x19, x0
    fd8000004e84:	54000600 	b.eq	fd8000004f44 <vgic_spill_lr+0x1a4>  // b.none
    __asm__ volatile(
    fd8000004e88:	910012a1 	add	x1, x21, #0x4
    fd8000004e8c:	b9400020 	ldr	w0, [x1]
    fd8000004e90:	11000400 	add	w0, w0, #0x1
    fd8000004e94:	889ffc20 	stlr	w0, [x1]
    fd8000004e98:	d5033b9f 	dsb	ish
    fd8000004e9c:	d503209f 	sev
    fd8000004ea0:	f94013f5 	ldr	x21, [sp, #32]
}
    fd8000004ea4:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd8000004ea8:	a8c37bfd 	ldp	x29, x30, [sp], #48
    fd8000004eac:	d65f03c0 	ret
SYSREG_GEN_ACCESSORS(ich_lr15_el2);
    fd8000004eb0:	d53ccde1 	mrs	x1, ich_lr15_el2
            return sysreg_ich_lr15_el2_read();
    fd8000004eb4:	17ffffd5 	b	fd8000004e08 <vgic_spill_lr+0x68>
SYSREG_GEN_ACCESSORS(ich_lr0_el2);
    fd8000004eb8:	d53ccc01 	mrs	x1, ich_lr0_el2
            return sysreg_ich_lr0_el2_read();
    fd8000004ebc:	17ffffd3 	b	fd8000004e08 <vgic_spill_lr+0x68>
SYSREG_GEN_ACCESSORS(ich_lr1_el2);
    fd8000004ec0:	d53ccc21 	mrs	x1, ich_lr1_el2
            return sysreg_ich_lr1_el2_read();
    fd8000004ec4:	17ffffd1 	b	fd8000004e08 <vgic_spill_lr+0x68>
SYSREG_GEN_ACCESSORS(ich_lr2_el2);
    fd8000004ec8:	d53ccc41 	mrs	x1, ich_lr2_el2
            return sysreg_ich_lr2_el2_read();
    fd8000004ecc:	17ffffcf 	b	fd8000004e08 <vgic_spill_lr+0x68>
SYSREG_GEN_ACCESSORS(ich_lr3_el2);
    fd8000004ed0:	d53ccc61 	mrs	x1, ich_lr3_el2
            return sysreg_ich_lr3_el2_read();
    fd8000004ed4:	17ffffcd 	b	fd8000004e08 <vgic_spill_lr+0x68>
SYSREG_GEN_ACCESSORS(ich_lr4_el2);
    fd8000004ed8:	d53ccc81 	mrs	x1, ich_lr4_el2
            return sysreg_ich_lr4_el2_read();
    fd8000004edc:	17ffffcb 	b	fd8000004e08 <vgic_spill_lr+0x68>
SYSREG_GEN_ACCESSORS(ich_lr5_el2);
    fd8000004ee0:	d53ccca1 	mrs	x1, ich_lr5_el2
            return sysreg_ich_lr5_el2_read();
    fd8000004ee4:	17ffffc9 	b	fd8000004e08 <vgic_spill_lr+0x68>
SYSREG_GEN_ACCESSORS(ich_lr6_el2);
    fd8000004ee8:	d53cccc1 	mrs	x1, ich_lr6_el2
            return sysreg_ich_lr6_el2_read();
    fd8000004eec:	17ffffc7 	b	fd8000004e08 <vgic_spill_lr+0x68>
SYSREG_GEN_ACCESSORS(ich_lr7_el2);
    fd8000004ef0:	d53ccce1 	mrs	x1, ich_lr7_el2
            return sysreg_ich_lr7_el2_read();
    fd8000004ef4:	17ffffc5 	b	fd8000004e08 <vgic_spill_lr+0x68>
SYSREG_GEN_ACCESSORS(ich_lr8_el2);
    fd8000004ef8:	d53ccd01 	mrs	x1, ich_lr8_el2
            return sysreg_ich_lr8_el2_read();
    fd8000004efc:	17ffffc3 	b	fd8000004e08 <vgic_spill_lr+0x68>
SYSREG_GEN_ACCESSORS(ich_lr9_el2);
    fd8000004f00:	d53ccd21 	mrs	x1, ich_lr9_el2
            return sysreg_ich_lr9_el2_read();
    fd8000004f04:	17ffffc1 	b	fd8000004e08 <vgic_spill_lr+0x68>
SYSREG_GEN_ACCESSORS(ich_lr10_el2);
    fd8000004f08:	d53ccd41 	mrs	x1, ich_lr10_el2
            return sysreg_ich_lr10_el2_read();
    fd8000004f0c:	17ffffbf 	b	fd8000004e08 <vgic_spill_lr+0x68>
SYSREG_GEN_ACCESSORS(ich_lr11_el2);
    fd8000004f10:	d53ccd61 	mrs	x1, ich_lr11_el2
            return sysreg_ich_lr11_el2_read();
    fd8000004f14:	17ffffbd 	b	fd8000004e08 <vgic_spill_lr+0x68>
SYSREG_GEN_ACCESSORS(ich_lr12_el2);
    fd8000004f18:	d53ccd81 	mrs	x1, ich_lr12_el2
            return sysreg_ich_lr12_el2_read();
    fd8000004f1c:	17ffffbb 	b	fd8000004e08 <vgic_spill_lr+0x68>
SYSREG_GEN_ACCESSORS(ich_lr13_el2);
    fd8000004f20:	d53ccda1 	mrs	x1, ich_lr13_el2
            return sysreg_ich_lr13_el2_read();
    fd8000004f24:	17ffffb9 	b	fd8000004e08 <vgic_spill_lr+0x68>
    fd8000004f28:	92407c20 	and	x0, x1, #0xffffffff
    fd8000004f2c:	d2800701 	mov	x1, #0x38                  	// #56
    fd8000004f30:	f90013f5 	str	x21, [sp, #32]
        return &target_vcpu->arch.vgic_priv.interrupts[int_id];
    fd8000004f34:	9b017c00 	mul	x0, x0, x1
    fd8000004f38:	91090014 	add	x20, x0, #0x240
    fd8000004f3c:	8b140274 	add	x20, x19, x20
    if (spilled_int != NULL) {
    fd8000004f40:	17ffffbe 	b	fd8000004e38 <vgic_spill_lr+0x98>
    if ((GIC_VERSION == GICV2 && gic_is_priv(interrupt->id)) || !vgic_owns(vcpu, interrupt) ||
    fd8000004f44:	3940c680 	ldrb	w0, [x20, #49]
    fd8000004f48:	3707fa00 	tbnz	w0, #0, fd8000004e88 <vgic_spill_lr+0xe8>
        interrupt->in_lr || (vgic_get_state(interrupt) & ACT)) {
    fd8000004f4c:	aa1403e0 	mov	x0, x20
    fd8000004f50:	97fffe0c 	bl	fd8000004780 <vgic_get_state>
    fd8000004f54:	370ff9a0 	tbnz	w0, #1, fd8000004e88 <vgic_spill_lr+0xe8>
    interrupt->owner = NULL;
    fd8000004f58:	f900069f 	str	xzr, [x20, #8]
    fd8000004f5c:	17ffffcb 	b	fd8000004e88 <vgic_spill_lr+0xe8>
    fd8000004f60:	00013088 	.word	0x00013088
    fd8000004f64:	0000fd80 	.word	0x0000fd80
    fd8000004f68:	000107d8 	.word	0x000107d8
    fd8000004f6c:	0000fd80 	.word	0x0000fd80
    fd8000004f70:	00011160 	.word	0x00011160
    fd8000004f74:	0000fd80 	.word	0x0000fd80
    fd8000004f78:	d503201f 	nop
    fd8000004f7c:	d503201f 	nop

0000fd8000004f80 <vgic_add_lr>:
{
    fd8000004f80:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    fd8000004f84:	910003fd 	mov	x29, sp
    fd8000004f88:	a9025bf5 	stp	x21, x22, [sp, #32]
    if (!interrupt->enabled || interrupt->in_lr) {
    fd8000004f8c:	3940c835 	ldrb	w21, [x1, #50]
    fd8000004f90:	36000415 	tbz	w21, #0, fd8000005010 <vgic_add_lr+0x90>
    fd8000004f94:	a90153f3 	stp	x19, x20, [sp, #16]
    fd8000004f98:	aa0103f4 	mov	x20, x1
    fd8000004f9c:	3940c421 	ldrb	w1, [x1, #49]
    fd8000004fa0:	37000421 	tbnz	w1, #0, fd8000005024 <vgic_add_lr+0xa4>
SYSREG_GEN_ACCESSORS(ich_elrsr_el2);
    fd8000004fa4:	d53ccba3 	mrs	x3, ich_elrsr_el2
    for (size_t i = 0; i < NUM_LRS; i++) {
    fd8000004fa8:	b0000001 	adrp	x1, fd8000005000 <vgic_add_lr+0x80>
    fd8000004fac:	f941e436 	ldr	x22, [x1, #968]
    fd8000004fb0:	f94002c1 	ldr	x1, [x22]
    fd8000004fb4:	b4000261 	cbz	x1, fd8000005000 <vgic_add_lr+0x80>
        if (bit64_get(elrsr, i)) {  //contains a valid interrupt
    fd8000004fb8:	92400065 	and	x5, x3, #0x1
    fd8000004fbc:	37001e43 	tbnz	w3, #0, fd8000005384 <vgic_add_lr+0x404>
    for (size_t i = 0; i < NUM_LRS; i++) {
    fd8000004fc0:	d2800013 	mov	x19, #0x0                   	// #0
    fd8000004fc4:	d2800024 	mov	x4, #0x1                   	// #1
    fd8000004fc8:	14000004 	b	fd8000004fd8 <vgic_add_lr+0x58>
    fd8000004fcc:	9ad32082 	lsl	x2, x4, x19
        if (bit64_get(elrsr, i)) {  //contains a valid interrupt
    fd8000004fd0:	ea03005f 	tst	x2, x3
    fd8000004fd4:	54000381 	b.ne	fd8000005044 <vgic_add_lr+0xc4>  // b.any
    for (size_t i = 0; i < NUM_LRS; i++) {
    fd8000004fd8:	91000673 	add	x19, x19, #0x1
    fd8000004fdc:	eb01027f 	cmp	x19, x1
    fd8000004fe0:	54ffff61 	b.ne	fd8000004fcc <vgic_add_lr+0x4c>  // b.any
    switch (i) {
    fd8000004fe4:	f1003cbf 	cmp	x5, #0xf
    fd8000004fe8:	54000068 	b.hi	fd8000004ff4 <vgic_add_lr+0x74>  // b.pmore
    fd8000004fec:	71003cbf 	cmp	w5, #0xf
    fd8000004ff0:	540001e9 	b.ls	fd800000502c <vgic_add_lr+0xac>  // b.plast
        for (size_t i = 0; i < NUM_LRS; i++) {
    fd8000004ff4:	910004a5 	add	x5, x5, #0x1
    fd8000004ff8:	eb0100bf 	cmp	x5, x1
    fd8000004ffc:	54ffff41 	b.ne	fd8000004fe4 <vgic_add_lr+0x64>  // b.any
        vgic_add_spilled(vcpu, interrupt);
    fd8000005000:	aa1403e1 	mov	x1, x20
    fd8000005004:	97ffff2f 	bl	fd8000004cc0 <vgic_add_spilled>
    fd8000005008:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd800000500c:	d503201f 	nop
        return ret;
    fd8000005010:	52800015 	mov	w21, #0x0                   	// #0
}
    fd8000005014:	2a1503e0 	mov	w0, w21
    fd8000005018:	a9425bf5 	ldp	x21, x22, [sp, #32]
    fd800000501c:	a8c57bfd 	ldp	x29, x30, [sp], #80
    fd8000005020:	d65f03c0 	ret
    fd8000005024:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd8000005028:	17fffffa 	b	fd8000005010 <vgic_add_lr+0x90>
    fd800000502c:	90000002 	adrp	x2, fd8000005000 <vgic_add_lr+0x80>
    fd8000005030:	f941f042 	ldr	x2, [x2, #992]
    fd8000005034:	78655842 	ldrh	w2, [x2, w5, uxtw #1]
    fd8000005038:	10000063 	adr	x3, fd8000005044 <vgic_add_lr+0xc4>
    fd800000503c:	8b22a862 	add	x2, x3, w2, sxth #2
    fd8000005040:	d61f0040 	br	x2
            lr_ind = i;
    fd8000005044:	a90363f7 	stp	x23, x24, [sp, #48]
    fd8000005048:	aa1303f8 	mov	x24, x19
    if (lr_ind < 0) {   //if all of the list registers doesnt have a valid interrupt
    fd800000504c:	b7f81993 	tbnz	x19, #63, fd800000537c <vgic_add_lr+0x3fc>
    interrupt->lr = lr_ind;
    fd8000005050:	12001e77 	and	w23, w19, #0xff
    fd8000005054:	f90023f9 	str	x25, [sp, #64]
    irqid_t prev_int_id = vcpu->arch.vgic_priv.curr_lrs[lr_ind];
    fd8000005058:	8b130819 	add	x25, x0, x19, lsl #2
    if ((prev_int_id != interrupt->id) && !gic_is_priv(prev_int_id)) {
    fd800000505c:	b9402a82 	ldr	w2, [x20, #40]
    irqid_t prev_int_id = vcpu->arch.vgic_priv.curr_lrs[lr_ind];
    fd8000005060:	b9414321 	ldr	w1, [x25, #320]
    if ((prev_int_id != interrupt->id) && !gic_is_priv(prev_int_id)) {
    fd8000005064:	6b01005f 	cmp	w2, w1
    fd8000005068:	7a5f1820 	ccmp	w1, #0x1f, #0x0, ne	// ne = any
    fd800000506c:	540005c8 	b.hi	fd8000005124 <vgic_add_lr+0x1a4>  // b.pmore
    unsigned state = vgic_get_state(interrupt);
    fd8000005070:	aa1403e0 	mov	x0, x20
    fd8000005074:	97fffdc3 	bl	fd8000004780 <vgic_get_state>
    gic_lr_t lr = ((interrupt->id << GICH_LR_VID_OFF) & GICH_LR_VID_MSK);
    fd8000005078:	b9402a82 	ldr	w2, [x20, #40]
    unsigned state = vgic_get_state(interrupt);
    fd800000507c:	12001c00 	and	w0, w0, #0xff
    lr |= (((gic_lr_t)interrupt->prio << GICH_LR_PRIO_OFF) & GICH_LR_PRIO_MSK) | GICH_LR_GRP_BIT;
    fd8000005080:	3940b681 	ldrb	w1, [x20, #45]
    gic_lr_t lr = ((interrupt->id << GICH_LR_VID_OFF) & GICH_LR_VID_MSK);
    fd8000005084:	2a0203e3 	mov	w3, w2
    return !(interrupt->id < GIC_MAX_SGIS) && interrupt->hw;
    fd8000005088:	71003c5f 	cmp	w2, #0xf
    lr |= (((gic_lr_t)interrupt->prio << GICH_LR_PRIO_OFF) & GICH_LR_PRIO_MSK) | GICH_LR_GRP_BIT;
    fd800000508c:	aa01c061 	orr	x1, x3, x1, lsl #48
    fd8000005090:	b2440024 	orr	x4, x1, #0x1000000000000000
    return !(interrupt->id < GIC_MAX_SGIS) && interrupt->hw;
    fd8000005094:	54000229 	b.ls	fd80000050d8 <vgic_add_lr+0x158>  // b.plast
    fd8000005098:	3940c285 	ldrb	w5, [x20, #48]
    fd800000509c:	36000145 	tbz	w5, #0, fd80000050c4 <vgic_add_lr+0x144>
        lr |= ((gic_lr_t)interrupt->id << GICH_LR_PID_OFF) & GICH_LR_PID_MSK;
    fd80000050a0:	d3602463 	ubfiz	x3, x3, #32, #10
            lr |= ((gic_lr_t)state << GICH_LR_STATE_OFF) & GICH_LR_STATE_MSK;
    fd80000050a4:	71000c1f 	cmp	w0, #0x3
    fd80000050a8:	aa010061 	orr	x1, x3, x1
    fd80000050ac:	d2f60003 	mov	x3, #0xb000000000000000    	// #-5764607523034234880
    fd80000050b0:	aa00f820 	orr	x0, x1, x0, lsl #62
    fd80000050b4:	aa030021 	orr	x1, x1, x3
    fd80000050b8:	b2440400 	orr	x0, x0, #0x3000000000000000
    fd80000050bc:	9a800020 	csel	x0, x1, x0, eq	// eq = none
    fd80000050c0:	14000007 	b	fd80000050dc <vgic_add_lr+0x15c>
            lr |= GICH_LR_EOI_BIT;
    fd80000050c4:	d2c04003 	mov	x3, #0x20000000000         	// #2199023255552
    fd80000050c8:	71007c5f 	cmp	w2, #0x1f
    fd80000050cc:	f2e20003 	movk	x3, #0x1000, lsl #48
    fd80000050d0:	aa030021 	orr	x1, x1, x3
    fd80000050d4:	9a848024 	csel	x4, x1, x4, hi	// hi = pmore
        lr |= ((gic_lr_t)state << GICH_LR_STATE_OFF) & GICH_LR_STATE_MSK;
    fd80000050d8:	aa00f880 	orr	x0, x4, x0, lsl #62
    if (i >= NUM_LRS) {
    fd80000050dc:	f94002c3 	ldr	x3, [x22]
    interrupt->in_lr = true;
    fd80000050e0:	52800021 	mov	w1, #0x1                   	// #1
    interrupt->state = 0;
    fd80000050e4:	3900b29f 	strb	wzr, [x20, #44]
    interrupt->lr = lr_ind;
    fd80000050e8:	3900be97 	strb	w23, [x20, #47]
    fd80000050ec:	eb03027f 	cmp	x19, x3
    interrupt->in_lr = true;
    fd80000050f0:	3900c681 	strb	w1, [x20, #49]
    vcpu->arch.vgic_priv.curr_lrs[lr_ind] = interrupt->id;
    fd80000050f4:	b9014322 	str	w2, [x25, #320]
    fd80000050f8:	540005a2 	b.cs	fd80000051ac <vgic_add_lr+0x22c>  // b.hs, b.nlast
    switch (i) {
    fd80000050fc:	f1003f1f 	cmp	x24, #0xf
    fd8000005100:	540004e8 	b.hi	fd800000519c <vgic_add_lr+0x21c>  // b.pmore
    fd8000005104:	71003f1f 	cmp	w24, #0xf
    fd8000005108:	540004a8 	b.hi	fd800000519c <vgic_add_lr+0x21c>  // b.pmore
    fd800000510c:	90000001 	adrp	x1, fd8000005000 <vgic_add_lr+0x80>
    fd8000005110:	f941ec21 	ldr	x1, [x1, #984]
    fd8000005114:	78785821 	ldrh	w1, [x1, w24, uxtw #1]
    fd8000005118:	10000078 	adr	x24, fd8000005124 <vgic_add_lr+0x1a4>
    fd800000511c:	8b21ab01 	add	x1, x24, w1, sxth #2
    fd8000005120:	d61f0020 	br	x1
    } else if (int_id < vcpu->vm->arch.vgicd.int_num) {
    fd8000005124:	f944c802 	ldr	x2, [x0, #2448]
    fd8000005128:	f9405443 	ldr	x3, [x2, #168]
    fd800000512c:	eb21407f 	cmp	x3, w1, uxtw
    fd8000005130:	54fffa09 	b.ls	fd8000005070 <vgic_add_lr+0xf0>  // b.plast
        return &vcpu->vm->arch.vgicd.interrupts[int_id - GIC_CPU_PRIV];
    fd8000005134:	f9404c42 	ldr	x2, [x2, #152]
    fd8000005138:	51008021 	sub	w1, w1, #0x20
    fd800000513c:	52800703 	mov	w3, #0x38                  	// #56
    fd8000005140:	9ba30821 	umaddl	x1, w1, w3, x2
        if (prev_interrupt != NULL) {
    fd8000005144:	b4fff961 	cbz	x1, fd8000005070 <vgic_add_lr+0xf0>
            spin_lock(&prev_interrupt->lock);
    fd8000005148:	91008022 	add	x2, x1, #0x20
    __asm__ volatile(
    fd800000514c:	91001046 	add	x6, x2, #0x4
    fd8000005150:	885ffc43 	ldaxr	w3, [x2]
    fd8000005154:	11000464 	add	w4, w3, #0x1
    fd8000005158:	88057c44 	stxr	w5, w4, [x2]
    fd800000515c:	35ffffa5 	cbnz	w5, fd8000005150 <vgic_add_lr+0x1d0>
    fd8000005160:	88dffcc4 	ldar	w4, [x6]
    fd8000005164:	6b04007f 	cmp	w3, w4
    fd8000005168:	54000060 	b.eq	fd8000005174 <vgic_add_lr+0x1f4>  // b.none
    fd800000516c:	d503205f 	wfe
    fd8000005170:	17fffffc 	b	fd8000005160 <vgic_add_lr+0x1e0>
            if (vgic_owns(vcpu, prev_interrupt) && prev_interrupt->in_lr &&
    fd8000005174:	f9400423 	ldr	x3, [x1, #8]
    fd8000005178:	eb03001f 	cmp	x0, x3
    fd800000517c:	54001100 	b.eq	fd800000539c <vgic_add_lr+0x41c>  // b.none
    __asm__ volatile(
    fd8000005180:	91001041 	add	x1, x2, #0x4
    fd8000005184:	b9400020 	ldr	w0, [x1]
    fd8000005188:	11000400 	add	w0, w0, #0x1
    fd800000518c:	889ffc20 	stlr	w0, [x1]
    fd8000005190:	d5033b9f 	dsb	ish
    fd8000005194:	d503209f 	sev
        "ldr    %w0, %1\n\t"
        "add    %w0, %w0, 1\n\t"
        "stlr   %w0, %1\n\t"
        "dsb ish\n\t"
        "sev\n\t" : "=&r"(temp) : "Q"(lock->next) : "memory");
}
    fd8000005198:	17ffffb6 	b	fd8000005070 <vgic_add_lr+0xf0>
    fd800000519c:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd80000051a0:	a94363f7 	ldp	x23, x24, [sp, #48]
    fd80000051a4:	f94023f9 	ldr	x25, [sp, #64]
    fd80000051a8:	17ffff9b 	b	fd8000005014 <vgic_add_lr+0x94>
        ERROR("gic: trying to write inexistent list register");
    fd80000051ac:	90000000 	adrp	x0, fd8000005000 <vgic_add_lr+0x80>
    fd80000051b0:	f941e800 	ldr	x0, [x0, #976]
    fd80000051b4:	94001b9b 	bl	fd800000c020 <console_printk>
    fd80000051b8:	14000000 	b	fd80000051b8 <vgic_add_lr+0x238>
SYSREG_GEN_ACCESSORS(ich_lr14_el2);
    fd80000051bc:	d53ccdc2 	mrs	x2, ich_lr14_el2
            return sysreg_ich_lr14_el2_read();
    fd80000051c0:	17ffff8d 	b	fd8000004ff4 <vgic_add_lr+0x74>
SYSREG_GEN_ACCESSORS(ich_lr13_el2);
    fd80000051c4:	d53ccda2 	mrs	x2, ich_lr13_el2
            return sysreg_ich_lr13_el2_read();
    fd80000051c8:	17ffff8b 	b	fd8000004ff4 <vgic_add_lr+0x74>
SYSREG_GEN_ACCESSORS(ich_lr0_el2);
    fd80000051cc:	d53ccc02 	mrs	x2, ich_lr0_el2
            return sysreg_ich_lr0_el2_read();
    fd80000051d0:	17ffff89 	b	fd8000004ff4 <vgic_add_lr+0x74>
SYSREG_GEN_ACCESSORS(ich_lr15_el2);
    fd80000051d4:	d53ccde2 	mrs	x2, ich_lr15_el2
            return sysreg_ich_lr15_el2_read();
    fd80000051d8:	17ffff87 	b	fd8000004ff4 <vgic_add_lr+0x74>
SYSREG_GEN_ACCESSORS(ich_lr4_el2);
    fd80000051dc:	d53ccc82 	mrs	x2, ich_lr4_el2
            return sysreg_ich_lr4_el2_read();
    fd80000051e0:	17ffff85 	b	fd8000004ff4 <vgic_add_lr+0x74>
SYSREG_GEN_ACCESSORS(ich_lr3_el2);
    fd80000051e4:	d53ccc62 	mrs	x2, ich_lr3_el2
            return sysreg_ich_lr3_el2_read();
    fd80000051e8:	17ffff83 	b	fd8000004ff4 <vgic_add_lr+0x74>
SYSREG_GEN_ACCESSORS(ich_lr2_el2);
    fd80000051ec:	d53ccc42 	mrs	x2, ich_lr2_el2
            return sysreg_ich_lr2_el2_read();
    fd80000051f0:	17ffff81 	b	fd8000004ff4 <vgic_add_lr+0x74>
SYSREG_GEN_ACCESSORS(ich_lr1_el2);
    fd80000051f4:	d53ccc22 	mrs	x2, ich_lr1_el2
            return sysreg_ich_lr1_el2_read();
    fd80000051f8:	17ffff7f 	b	fd8000004ff4 <vgic_add_lr+0x74>
SYSREG_GEN_ACCESSORS(ich_lr12_el2);
    fd80000051fc:	d53ccd82 	mrs	x2, ich_lr12_el2
            return sysreg_ich_lr12_el2_read();
    fd8000005200:	17ffff7d 	b	fd8000004ff4 <vgic_add_lr+0x74>
SYSREG_GEN_ACCESSORS(ich_lr11_el2);
    fd8000005204:	d53ccd62 	mrs	x2, ich_lr11_el2
            return sysreg_ich_lr11_el2_read();
    fd8000005208:	17ffff7b 	b	fd8000004ff4 <vgic_add_lr+0x74>
SYSREG_GEN_ACCESSORS(ich_lr10_el2);
    fd800000520c:	d53ccd42 	mrs	x2, ich_lr10_el2
            return sysreg_ich_lr10_el2_read();
    fd8000005210:	17ffff79 	b	fd8000004ff4 <vgic_add_lr+0x74>
SYSREG_GEN_ACCESSORS(ich_lr9_el2);
    fd8000005214:	d53ccd22 	mrs	x2, ich_lr9_el2
            return sysreg_ich_lr9_el2_read();
    fd8000005218:	17ffff77 	b	fd8000004ff4 <vgic_add_lr+0x74>
SYSREG_GEN_ACCESSORS(ich_lr8_el2);
    fd800000521c:	d53ccd02 	mrs	x2, ich_lr8_el2
            return sysreg_ich_lr8_el2_read();
    fd8000005220:	17ffff75 	b	fd8000004ff4 <vgic_add_lr+0x74>
SYSREG_GEN_ACCESSORS(ich_lr7_el2);
    fd8000005224:	d53ccce2 	mrs	x2, ich_lr7_el2
            return sysreg_ich_lr7_el2_read();
    fd8000005228:	17ffff73 	b	fd8000004ff4 <vgic_add_lr+0x74>
SYSREG_GEN_ACCESSORS(ich_lr6_el2);
    fd800000522c:	d53cccc2 	mrs	x2, ich_lr6_el2
            return sysreg_ich_lr6_el2_read();
    fd8000005230:	17ffff71 	b	fd8000004ff4 <vgic_add_lr+0x74>
SYSREG_GEN_ACCESSORS(ich_lr5_el2);
    fd8000005234:	d53ccca2 	mrs	x2, ich_lr5_el2
            return sysreg_ich_lr5_el2_read();
    fd8000005238:	17ffff6f 	b	fd8000004ff4 <vgic_add_lr+0x74>
SYSREG_GEN_ACCESSORS(ich_lr14_el2);
    fd800000523c:	d51ccdc0 	msr	ich_lr14_el2, x0
    fd8000005240:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd8000005244:	a94363f7 	ldp	x23, x24, [sp, #48]
    fd8000005248:	f94023f9 	ldr	x25, [sp, #64]
    fd800000524c:	17ffff72 	b	fd8000005014 <vgic_add_lr+0x94>
SYSREG_GEN_ACCESSORS(ich_lr13_el2);
    fd8000005250:	d51ccda0 	msr	ich_lr13_el2, x0
    fd8000005254:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd8000005258:	a94363f7 	ldp	x23, x24, [sp, #48]
    fd800000525c:	f94023f9 	ldr	x25, [sp, #64]
    fd8000005260:	17ffff6d 	b	fd8000005014 <vgic_add_lr+0x94>
SYSREG_GEN_ACCESSORS(ich_lr12_el2);
    fd8000005264:	d51ccd80 	msr	ich_lr12_el2, x0
    fd8000005268:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd800000526c:	a94363f7 	ldp	x23, x24, [sp, #48]
    fd8000005270:	f94023f9 	ldr	x25, [sp, #64]
    fd8000005274:	17ffff68 	b	fd8000005014 <vgic_add_lr+0x94>
SYSREG_GEN_ACCESSORS(ich_lr11_el2);
    fd8000005278:	d51ccd60 	msr	ich_lr11_el2, x0
    fd800000527c:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd8000005280:	a94363f7 	ldp	x23, x24, [sp, #48]
    fd8000005284:	f94023f9 	ldr	x25, [sp, #64]
    fd8000005288:	17ffff63 	b	fd8000005014 <vgic_add_lr+0x94>
SYSREG_GEN_ACCESSORS(ich_lr10_el2);
    fd800000528c:	d51ccd40 	msr	ich_lr10_el2, x0
    fd8000005290:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd8000005294:	a94363f7 	ldp	x23, x24, [sp, #48]
    fd8000005298:	f94023f9 	ldr	x25, [sp, #64]
    fd800000529c:	17ffff5e 	b	fd8000005014 <vgic_add_lr+0x94>
SYSREG_GEN_ACCESSORS(ich_lr9_el2);
    fd80000052a0:	d51ccd20 	msr	ich_lr9_el2, x0
    fd80000052a4:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd80000052a8:	a94363f7 	ldp	x23, x24, [sp, #48]
    fd80000052ac:	f94023f9 	ldr	x25, [sp, #64]
    fd80000052b0:	17ffff59 	b	fd8000005014 <vgic_add_lr+0x94>
SYSREG_GEN_ACCESSORS(ich_lr8_el2);
    fd80000052b4:	d51ccd00 	msr	ich_lr8_el2, x0
    fd80000052b8:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd80000052bc:	a94363f7 	ldp	x23, x24, [sp, #48]
    fd80000052c0:	f94023f9 	ldr	x25, [sp, #64]
    fd80000052c4:	17ffff54 	b	fd8000005014 <vgic_add_lr+0x94>
SYSREG_GEN_ACCESSORS(ich_lr7_el2);
    fd80000052c8:	d51ccce0 	msr	ich_lr7_el2, x0
    fd80000052cc:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd80000052d0:	a94363f7 	ldp	x23, x24, [sp, #48]
    fd80000052d4:	f94023f9 	ldr	x25, [sp, #64]
    fd80000052d8:	17ffff4f 	b	fd8000005014 <vgic_add_lr+0x94>
SYSREG_GEN_ACCESSORS(ich_lr6_el2);
    fd80000052dc:	d51cccc0 	msr	ich_lr6_el2, x0
    fd80000052e0:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd80000052e4:	a94363f7 	ldp	x23, x24, [sp, #48]
    fd80000052e8:	f94023f9 	ldr	x25, [sp, #64]
    fd80000052ec:	17ffff4a 	b	fd8000005014 <vgic_add_lr+0x94>
SYSREG_GEN_ACCESSORS(ich_lr5_el2);
    fd80000052f0:	d51ccca0 	msr	ich_lr5_el2, x0
    fd80000052f4:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd80000052f8:	a94363f7 	ldp	x23, x24, [sp, #48]
    fd80000052fc:	f94023f9 	ldr	x25, [sp, #64]
    fd8000005300:	17ffff45 	b	fd8000005014 <vgic_add_lr+0x94>
SYSREG_GEN_ACCESSORS(ich_lr4_el2);
    fd8000005304:	d51ccc80 	msr	ich_lr4_el2, x0
    fd8000005308:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd800000530c:	a94363f7 	ldp	x23, x24, [sp, #48]
    fd8000005310:	f94023f9 	ldr	x25, [sp, #64]
    fd8000005314:	17ffff40 	b	fd8000005014 <vgic_add_lr+0x94>
SYSREG_GEN_ACCESSORS(ich_lr3_el2);
    fd8000005318:	d51ccc60 	msr	ich_lr3_el2, x0
    fd800000531c:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd8000005320:	a94363f7 	ldp	x23, x24, [sp, #48]
    fd8000005324:	f94023f9 	ldr	x25, [sp, #64]
    fd8000005328:	17ffff3b 	b	fd8000005014 <vgic_add_lr+0x94>
SYSREG_GEN_ACCESSORS(ich_lr2_el2);
    fd800000532c:	d51ccc40 	msr	ich_lr2_el2, x0
    fd8000005330:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd8000005334:	a94363f7 	ldp	x23, x24, [sp, #48]
    fd8000005338:	f94023f9 	ldr	x25, [sp, #64]
    fd800000533c:	17ffff36 	b	fd8000005014 <vgic_add_lr+0x94>
SYSREG_GEN_ACCESSORS(ich_lr1_el2);
    fd8000005340:	d51ccc20 	msr	ich_lr1_el2, x0
    fd8000005344:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd8000005348:	a94363f7 	ldp	x23, x24, [sp, #48]
    fd800000534c:	f94023f9 	ldr	x25, [sp, #64]
    fd8000005350:	17ffff31 	b	fd8000005014 <vgic_add_lr+0x94>
SYSREG_GEN_ACCESSORS(ich_lr0_el2);
    fd8000005354:	d51ccc00 	msr	ich_lr0_el2, x0
    fd8000005358:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd800000535c:	a94363f7 	ldp	x23, x24, [sp, #48]
    fd8000005360:	f94023f9 	ldr	x25, [sp, #64]
    fd8000005364:	17ffff2c 	b	fd8000005014 <vgic_add_lr+0x94>
SYSREG_GEN_ACCESSORS(ich_lr15_el2);
    fd8000005368:	d51ccde0 	msr	ich_lr15_el2, x0
    fd800000536c:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd8000005370:	a94363f7 	ldp	x23, x24, [sp, #48]
    fd8000005374:	f94023f9 	ldr	x25, [sp, #64]
    fd8000005378:	17ffff27 	b	fd8000005014 <vgic_add_lr+0x94>
    fd800000537c:	a94363f7 	ldp	x23, x24, [sp, #48]
    fd8000005380:	17ffff19 	b	fd8000004fe4 <vgic_add_lr+0x64>
        if (bit64_get(elrsr, i)) {  //contains a valid interrupt
    fd8000005384:	d2800013 	mov	x19, #0x0                   	// #0
    fd8000005388:	a90363f7 	stp	x23, x24, [sp, #48]
    fd800000538c:	52800017 	mov	w23, #0x0                   	// #0
            lr_ind = i;
    fd8000005390:	d2800018 	mov	x24, #0x0                   	// #0
    fd8000005394:	f90023f9 	str	x25, [sp, #64]
    fd8000005398:	17ffff30 	b	fd8000005058 <vgic_add_lr+0xd8>
            if (vgic_owns(vcpu, prev_interrupt) && prev_interrupt->in_lr &&
    fd800000539c:	3940c420 	ldrb	w0, [x1, #49]
    fd80000053a0:	3607ef00 	tbz	w0, #0, fd8000005180 <vgic_add_lr+0x200>
                (prev_interrupt->lr == lr_ind)) {
    fd80000053a4:	3940bc20 	ldrb	w0, [x1, #47]
            if (vgic_owns(vcpu, prev_interrupt) && prev_interrupt->in_lr &&
    fd80000053a8:	eb13001f 	cmp	x0, x19
    fd80000053ac:	54ffeea1 	b.ne	fd8000005180 <vgic_add_lr+0x200>  // b.any
        interrupt->in_lr || (vgic_get_state(interrupt) & ACT)) {
    fd80000053b0:	3940b020 	ldrb	w0, [x1, #44]
                prev_interrupt->in_lr = false;
    fd80000053b4:	3900c43f 	strb	wzr, [x1, #49]
        interrupt->in_lr || (vgic_get_state(interrupt) & ACT)) {
    fd80000053b8:	370fee40 	tbnz	w0, #1, fd8000005180 <vgic_add_lr+0x200>
    interrupt->owner = NULL;
    fd80000053bc:	f900043f 	str	xzr, [x1, #8]
    fd80000053c0:	17ffff70 	b	fd8000005180 <vgic_add_lr+0x200>
    fd80000053c4:	d503201f 	nop
    fd80000053c8:	00013088 	.word	0x00013088
    fd80000053cc:	0000fd80 	.word	0x0000fd80
    fd80000053d0:	00010818 	.word	0x00010818
    fd80000053d4:	0000fd80 	.word	0x0000fd80
    fd80000053d8:	00011190 	.word	0x00011190
    fd80000053dc:	0000fd80 	.word	0x0000fd80
    fd80000053e0:	00011170 	.word	0x00011170
    fd80000053e4:	0000fd80 	.word	0x0000fd80
    fd80000053e8:	d503201f 	nop
    fd80000053ec:	d503201f 	nop

0000fd80000053f0 <vgic_route>:
{
    fd80000053f0:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    fd80000053f4:	910003fd 	mov	x29, sp
    fd80000053f8:	a90153f3 	stp	x19, x20, [sp, #16]
    fd80000053fc:	aa0103f3 	mov	x19, x1
    if ((interrupt->state == INV) || !interrupt->enabled) {
    fd8000005400:	3940b021 	ldrb	w1, [x1, #44]
    fd8000005404:	34000081 	cbz	w1, fd8000005414 <vgic_route+0x24>
    fd8000005408:	aa0003f4 	mov	x20, x0
    fd800000540c:	3940ca60 	ldrb	w0, [x19, #50]
    fd8000005410:	37000080 	tbnz	w0, #0, fd8000005420 <vgic_route+0x30>
}
    fd8000005414:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd8000005418:	a8c47bfd 	ldp	x29, x30, [sp], #64
    fd800000541c:	d65f03c0 	ret
}

static inline bool vgic_int_vcpu_is_target(struct vcpu* vcpu, struct vgic_int* interrupt)
{
    bool priv = gic_is_priv(interrupt->id);
    bool local = priv && (interrupt->phys.redist == vcpu->phys_id);
    fd8000005420:	b9402a60 	ldr	w0, [x19, #40]
    fd8000005424:	f9400e61 	ldr	x1, [x19, #24]
    fd8000005428:	71007c1f 	cmp	w0, #0x1f
    fd800000542c:	540006c9 	b.ls	fd8000005504 <vgic_route+0x114>  // b.plast
SYSREG_GEN_ACCESSORS(mpidr_el1);
    fd8000005430:	d53800a2 	mrs	x2, mpidr_el1
    return (interrupt->route & GICD_IROUTER_IRM_BIT);
    fd8000005434:	f9400a60 	ldr	x0, [x19, #16]
    bool routed_here =
        !priv && !(interrupt->phys.route ^ (sysreg_mpidr_el1_read() & MPIDR_AFF_MSK));
    bool any = !priv && vgic_broadcast(vcpu, interrupt);
    fd8000005438:	37f806c0 	tbnz	w0, #31, fd8000005510 <vgic_route+0x120>
    if (vgic_int_vcpu_is_target(vcpu, interrupt)) {
    fd800000543c:	eb22203f 	cmp	x1, w2, uxth
    fd8000005440:	54000680 	b.eq	fd8000005510 <vgic_route+0x120>  // b.none
    if (!interrupt->in_lr && vgic_int_has_other_target(vcpu, interrupt)) {
    fd8000005444:	3940c660 	ldrb	w0, [x19, #49]
    fd8000005448:	3707fe60 	tbnz	w0, #0, fd8000005414 <vgic_route+0x24>
    fd800000544c:	aa1303e1 	mov	x1, x19
    fd8000005450:	aa1403e0 	mov	x0, x20
    fd8000005454:	940009a3 	bl	fd8000007ae0 <vgic_int_has_other_target>
    fd8000005458:	3607fde0 	tbz	w0, #0, fd8000005414 <vgic_route+0x24>
            VGIC_MSG_DATA(vcpu->vm->id, vcpu->id, interrupt->id, 0, 0),
    fd800000545c:	f944ca80 	ldr	x0, [x20, #2448]
        struct cpu_msg msg = {
    fd8000005460:	90000001 	adrp	x1, fd8000005000 <vgic_add_lr+0x80>
    fd8000005464:	f942a423 	ldr	x3, [x1, #1352]
    fd8000005468:	52800021 	mov	w1, #0x1                   	// #1
            VGIC_MSG_DATA(vcpu->vm->id, vcpu->id, interrupt->id, 0, 0),
    fd800000546c:	f944be82 	ldr	x2, [x20, #2424]
    fd8000005470:	f9400000 	ldr	x0, [x0]
        struct cpu_msg msg = {
    fd8000005474:	f9400063 	ldr	x3, [x3]
    fd8000005478:	290607e3 	stp	w3, w1, [sp, #48]
            VGIC_MSG_DATA(vcpu->vm->id, vcpu->id, interrupt->id, 0, 0),
    fd800000547c:	b9402a61 	ldr	w1, [x19, #40]
    fd8000005480:	d3603c42 	ubfiz	x2, x2, #32, #16
    fd8000005484:	aa00c040 	orr	x0, x2, x0, lsl #48
    if ((GIC_VERSION == GICV2 && gic_is_priv(interrupt->id)) || !vgic_owns(vcpu, interrupt) ||
    fd8000005488:	f9400662 	ldr	x2, [x19, #8]
            VGIC_MSG_DATA(vcpu->vm->id, vcpu->id, interrupt->id, 0, 0),
    fd800000548c:	d3703821 	ubfiz	x1, x1, #16, #15
    fd8000005490:	aa010000 	orr	x0, x0, x1
    fd8000005494:	f90013f5 	str	x21, [sp, #32]
        struct cpu_msg msg = {
    fd8000005498:	f9001fe0 	str	x0, [sp, #56]
    if ((GIC_VERSION == GICV2 && gic_is_priv(interrupt->id)) || !vgic_owns(vcpu, interrupt) ||
    fd800000549c:	eb02029f 	cmp	x20, x2
    fd80000054a0:	54000440 	b.eq	fd8000005528 <vgic_route+0x138>  // b.none
        cpumap_t trgtlist = vgic_int_ptarget_mask(vcpu, interrupt) & ~(1ull << vcpu->phys_id);
    fd80000054a4:	aa1303e1 	mov	x1, x19
    fd80000054a8:	aa1403e0 	mov	x0, x20
    fd80000054ac:	9400099d 	bl	fd8000007b20 <vgic_int_ptarget_mask>
    fd80000054b0:	92401c00 	and	x0, x0, #0xff
        for (size_t i = 0; i < platform.cpu_num; i++) {
    fd80000054b4:	90000001 	adrp	x1, fd8000005000 <vgic_add_lr+0x80>
    fd80000054b8:	f942a835 	ldr	x21, [x1, #1360]
    fd80000054bc:	d2800013 	mov	x19, #0x0                   	// #0
        cpumap_t trgtlist = vgic_int_ptarget_mask(vcpu, interrupt) & ~(1ull << vcpu->phys_id);
    fd80000054c0:	f944c282 	ldr	x2, [x20, #2432]
    fd80000054c4:	d2800034 	mov	x20, #0x1                   	// #1
        for (size_t i = 0; i < platform.cpu_num; i++) {
    fd80000054c8:	f94002a1 	ldr	x1, [x21]
        cpumap_t trgtlist = vgic_int_ptarget_mask(vcpu, interrupt) & ~(1ull << vcpu->phys_id);
    fd80000054cc:	9ac22294 	lsl	x20, x20, x2
    fd80000054d0:	8a340014 	bic	x20, x0, x20
        for (size_t i = 0; i < platform.cpu_num; i++) {
    fd80000054d4:	b50000c1 	cbnz	x1, fd80000054ec <vgic_route+0xfc>
    fd80000054d8:	14000012 	b	fd8000005520 <vgic_route+0x130>
    fd80000054dc:	f94002a0 	ldr	x0, [x21]
    fd80000054e0:	91000673 	add	x19, x19, #0x1
    fd80000054e4:	eb00027f 	cmp	x19, x0
    fd80000054e8:	540001c2 	b.cs	fd8000005520 <vgic_route+0x130>  // b.hs, b.nlast
            if (trgtlist & (1ull << i)) {
    fd80000054ec:	9ad32680 	lsr	x0, x20, x19
    fd80000054f0:	3607ff60 	tbz	w0, #0, fd80000054dc <vgic_route+0xec>
                cpu_send_msg(i, &msg);
    fd80000054f4:	9100c3e1 	add	x1, sp, #0x30
    fd80000054f8:	aa1303e0 	mov	x0, x19
    fd80000054fc:	94001555 	bl	fd800000aa50 <cpu_send_msg>
    fd8000005500:	17fffff7 	b	fd80000054dc <vgic_route+0xec>
    if (vgic_int_vcpu_is_target(vcpu, interrupt)) {
    fd8000005504:	f944c280 	ldr	x0, [x20, #2432]
    fd8000005508:	eb01001f 	cmp	x0, x1
    fd800000550c:	54fff9c1 	b.ne	fd8000005444 <vgic_route+0x54>  // b.any
        vgic_add_lr(vcpu, interrupt);
    fd8000005510:	aa1303e1 	mov	x1, x19
    fd8000005514:	aa1403e0 	mov	x0, x20
    fd8000005518:	97fffe9a 	bl	fd8000004f80 <vgic_add_lr>
    fd800000551c:	17ffffca 	b	fd8000005444 <vgic_route+0x54>
    fd8000005520:	f94013f5 	ldr	x21, [sp, #32]
    fd8000005524:	17ffffbc 	b	fd8000005414 <vgic_route+0x24>
    if ((GIC_VERSION == GICV2 && gic_is_priv(interrupt->id)) || !vgic_owns(vcpu, interrupt) ||
    fd8000005528:	3940c660 	ldrb	w0, [x19, #49]
    fd800000552c:	3707fbc0 	tbnz	w0, #0, fd80000054a4 <vgic_route+0xb4>
        interrupt->in_lr || (vgic_get_state(interrupt) & ACT)) {
    fd8000005530:	aa1303e0 	mov	x0, x19
    fd8000005534:	97fffc93 	bl	fd8000004780 <vgic_get_state>
    fd8000005538:	370ffb60 	tbnz	w0, #1, fd80000054a4 <vgic_route+0xb4>
    interrupt->owner = NULL;
    fd800000553c:	f900067f 	str	xzr, [x19, #8]
    fd8000005540:	17ffffd9 	b	fd80000054a4 <vgic_route+0xb4>
    fd8000005544:	d503201f 	nop
    fd8000005548:	00012e78 	.word	0x00012e78
    fd800000554c:	0000fd80 	.word	0x0000fd80
    fd8000005550:	00012930 	.word	0x00012930
    fd8000005554:	0000fd80 	.word	0x0000fd80
    fd8000005558:	d503201f 	nop
    fd800000555c:	d503201f 	nop

0000fd8000005560 <vgic_int_update_enable>:
    if (enable != interrupt->enabled) {
    fd8000005560:	3940c823 	ldrb	w3, [x1, #50]
{
    fd8000005564:	12001c42 	and	w2, w2, #0xff
        return false;
    fd8000005568:	52800000 	mov	w0, #0x0                   	// #0
    if (enable != interrupt->enabled) {
    fd800000556c:	6b02007f 	cmp	w3, w2
    fd8000005570:	54000060 	b.eq	fd800000557c <vgic_int_update_enable+0x1c>  // b.none
        return true;
    fd8000005574:	52800020 	mov	w0, #0x1                   	// #1
        interrupt->enabled = enable;
    fd8000005578:	3900c822 	strb	w2, [x1, #50]
}
    fd800000557c:	d65f03c0 	ret

0000fd8000005580 <vgic_int_update_pend>:
    if (pend ^ !!(interrupt->state & PEND)) {
    fd8000005580:	3940b023 	ldrb	w3, [x1, #44]
{
    fd8000005584:	12001c42 	and	w2, w2, #0xff
        return false;
    fd8000005588:	52800000 	mov	w0, #0x0                   	// #0
    if (pend ^ !!(interrupt->state & PEND)) {
    fd800000558c:	12000064 	and	w4, w3, #0x1
    fd8000005590:	6b02009f 	cmp	w4, w2
    fd8000005594:	540000e0 	b.eq	fd80000055b0 <vgic_int_update_pend+0x30>  // b.none
            interrupt->state |= PEND;
    fd8000005598:	121f7860 	and	w0, w3, #0xfffffffe
        if (pend) {
    fd800000559c:	72000042 	ands	w2, w2, #0x1
            interrupt->state |= PEND;
    fd80000055a0:	32000063 	orr	w3, w3, #0x1
    fd80000055a4:	1a801063 	csel	w3, w3, w0, ne	// ne = any
        return true;
    fd80000055a8:	52800020 	mov	w0, #0x1                   	// #1
            interrupt->state |= PEND;
    fd80000055ac:	3900b023 	strb	w3, [x1, #44]
}
    fd80000055b0:	d65f03c0 	ret
    fd80000055b4:	d503201f 	nop
    fd80000055b8:	d503201f 	nop
    fd80000055bc:	d503201f 	nop

0000fd80000055c0 <vgic_int_update_act>:
    if (act ^ !!(interrupt->state & ACT)) {
    fd80000055c0:	3940b023 	ldrb	w3, [x1, #44]
{
    fd80000055c4:	12001c42 	and	w2, w2, #0xff
        return false;
    fd80000055c8:	52800000 	mov	w0, #0x0                   	// #0
    if (act ^ !!(interrupt->state & ACT)) {
    fd80000055cc:	d3410464 	ubfx	x4, x3, #1, #1
    fd80000055d0:	6b02009f 	cmp	w4, w2
    fd80000055d4:	540000e0 	b.eq	fd80000055f0 <vgic_int_update_act+0x30>  // b.none
            interrupt->state |= ACT;
    fd80000055d8:	121e7860 	and	w0, w3, #0xfffffffd
        if (act) {
    fd80000055dc:	72000042 	ands	w2, w2, #0x1
            interrupt->state |= ACT;
    fd80000055e0:	321f0063 	orr	w3, w3, #0x2
    fd80000055e4:	1a801063 	csel	w3, w3, w0, ne	// ne = any
        return true;
    fd80000055e8:	52800020 	mov	w0, #0x1                   	// #1
            interrupt->state |= ACT;
    fd80000055ec:	3900b023 	strb	w3, [x1, #44]
}
    fd80000055f0:	d65f03c0 	ret
    fd80000055f4:	d503201f 	nop
    fd80000055f8:	d503201f 	nop
    fd80000055fc:	d503201f 	nop

0000fd8000005600 <vgic_int_set_field>:
{
    fd8000005600:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    fd8000005604:	910003fd 	mov	x29, sp
    fd8000005608:	f9001bf7 	str	x23, [sp, #48]
    spin_lock(&interrupt->lock);
    fd800000560c:	91008057 	add	x23, x2, #0x20
{
    fd8000005610:	a90153f3 	stp	x19, x20, [sp, #16]
    fd8000005614:	aa0203f3 	mov	x19, x2
    fd8000005618:	aa0103f4 	mov	x20, x1
    fd800000561c:	a9025bf5 	stp	x21, x22, [sp, #32]
    fd8000005620:	aa0303f5 	mov	x21, x3
    fd8000005624:	aa0003f6 	mov	x22, x0
    __asm__ volatile(
    fd8000005628:	910012e3 	add	x3, x23, #0x4
    fd800000562c:	885ffee0 	ldaxr	w0, [x23]
    fd8000005630:	11000401 	add	w1, w0, #0x1
    fd8000005634:	88027ee1 	stxr	w2, w1, [x23]
    fd8000005638:	35ffffa2 	cbnz	w2, fd800000562c <vgic_int_set_field+0x2c>
    fd800000563c:	88dffc61 	ldar	w1, [x3]
    fd8000005640:	6b01001f 	cmp	w0, w1
    fd8000005644:	54000060 	b.eq	fd8000005650 <vgic_int_set_field+0x50>  // b.none
    fd8000005648:	d503205f 	wfe
    fd800000564c:	17fffffc 	b	fd800000563c <vgic_int_set_field+0x3c>
    if (interrupt->owner == vcpu) {
    fd8000005650:	f9400660 	ldr	x0, [x19, #8]
    fd8000005654:	eb00029f 	cmp	x20, x0
    fd8000005658:	54000420 	b.eq	fd80000056dc <vgic_int_set_field+0xdc>  // b.none
    } else if (interrupt->owner == NULL) {
    fd800000565c:	b40003e0 	cbz	x0, fd80000056d8 <vgic_int_set_field+0xd8>
            VGIC_MSG_DATA(vcpu->vm->id, 0, interrupt->id, handlers->regid, data),
    fd8000005660:	f944ca81 	ldr	x1, [x20, #2448]
        struct cpu_msg msg = {
    fd8000005664:	90000002 	adrp	x2, fd8000005000 <vgic_add_lr+0x80>
    fd8000005668:	f943b045 	ldr	x5, [x2, #1888]
            VGIC_MSG_DATA(vcpu->vm->id, 0, interrupt->id, handlers->regid, data),
    fd800000566c:	92401eb5 	and	x21, x21, #0xff
    fd8000005670:	f9400ac3 	ldr	x3, [x22, #16]
        struct cpu_msg msg = {
    fd8000005674:	52800066 	mov	w6, #0x3                   	// #3
            VGIC_MSG_DATA(vcpu->vm->id, 0, interrupt->id, handlers->regid, data),
    fd8000005678:	f9400022 	ldr	x2, [x1]
        cpu_send_msg(interrupt->owner->phys_id, &msg);
    fd800000567c:	910103e1 	add	x1, sp, #0x40
            VGIC_MSG_DATA(vcpu->vm->id, 0, interrupt->id, handlers->regid, data),
    fd8000005680:	b9402a64 	ldr	w4, [x19, #40]
    fd8000005684:	d3781c63 	ubfiz	x3, x3, #8, #8
        struct cpu_msg msg = {
    fd8000005688:	f94000a5 	ldr	x5, [x5]
            VGIC_MSG_DATA(vcpu->vm->id, 0, interrupt->id, handlers->regid, data),
    fd800000568c:	aa150063 	orr	x3, x3, x21
    fd8000005690:	d3703884 	ubfiz	x4, x4, #16, #15
        struct cpu_msg msg = {
    fd8000005694:	29081be5 	stp	w5, w6, [sp, #64]
        cpu_send_msg(interrupt->owner->phys_id, &msg);
    fd8000005698:	f944c000 	ldr	x0, [x0, #2432]
            VGIC_MSG_DATA(vcpu->vm->id, 0, interrupt->id, handlers->regid, data),
    fd800000569c:	aa02c082 	orr	x2, x4, x2, lsl #48
    fd80000056a0:	aa030042 	orr	x2, x2, x3
        struct cpu_msg msg = {
    fd80000056a4:	f90027e2 	str	x2, [sp, #72]
        cpu_send_msg(interrupt->owner->phys_id, &msg);
    fd80000056a8:	940014ea 	bl	fd800000aa50 <cpu_send_msg>
    __asm__ volatile(
    fd80000056ac:	910012e1 	add	x1, x23, #0x4
    fd80000056b0:	b9400020 	ldr	w0, [x1]
    fd80000056b4:	11000400 	add	w0, w0, #0x1
    fd80000056b8:	889ffc20 	stlr	w0, [x1]
    fd80000056bc:	d5033b9f 	dsb	ish
    fd80000056c0:	d503209f 	sev
}
    fd80000056c4:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd80000056c8:	a9425bf5 	ldp	x21, x22, [sp, #32]
    fd80000056cc:	f9401bf7 	ldr	x23, [sp, #48]
    fd80000056d0:	a8c57bfd 	ldp	x29, x30, [sp], #80
    fd80000056d4:	d65f03c0 	ret
        interrupt->owner = vcpu;
    fd80000056d8:	f9000674 	str	x20, [x19, #8]
        vgic_remove_lr(vcpu, interrupt);
    fd80000056dc:	aa1303e1 	mov	x1, x19
    fd80000056e0:	aa1403e0 	mov	x0, x20
    fd80000056e4:	97fffce3 	bl	fd8000004a70 <vgic_remove_lr>
        if (handlers->update_field(vcpu, interrupt, data) && vgic_int_is_hw(interrupt)) {
    fd80000056e8:	f9401ac3 	ldr	x3, [x22, #48]
    fd80000056ec:	aa1503e2 	mov	x2, x21
    fd80000056f0:	aa1303e1 	mov	x1, x19
    fd80000056f4:	aa1403e0 	mov	x0, x20
    fd80000056f8:	d63f0060 	blr	x3
    fd80000056fc:	36000160 	tbz	w0, #0, fd8000005728 <vgic_int_set_field+0x128>
    return !(interrupt->id < GIC_MAX_SGIS) && interrupt->hw;
    fd8000005700:	b9402a60 	ldr	w0, [x19, #40]
    fd8000005704:	71003c1f 	cmp	w0, #0xf
    fd8000005708:	54000109 	b.ls	fd8000005728 <vgic_int_set_field+0x128>  // b.plast
    fd800000570c:	3940c260 	ldrb	w0, [x19, #48]
    fd8000005710:	360000c0 	tbz	w0, #0, fd8000005728 <vgic_int_set_field+0x128>
            handlers->update_hw(vcpu, interrupt);
    fd8000005714:	f9401ec2 	ldr	x2, [x22, #56]
    fd8000005718:	aa1303e1 	mov	x1, x19
    fd800000571c:	aa1403e0 	mov	x0, x20
    fd8000005720:	d63f0040 	blr	x2
    fd8000005724:	d503201f 	nop
        vgic_route(vcpu, interrupt);
    fd8000005728:	aa1403e0 	mov	x0, x20
    fd800000572c:	aa1303e1 	mov	x1, x19
    fd8000005730:	97ffff30 	bl	fd80000053f0 <vgic_route>
    if ((GIC_VERSION == GICV2 && gic_is_priv(interrupt->id)) || !vgic_owns(vcpu, interrupt) ||
    fd8000005734:	f9400660 	ldr	x0, [x19, #8]
    fd8000005738:	eb00029f 	cmp	x20, x0
    fd800000573c:	54fffb81 	b.ne	fd80000056ac <vgic_int_set_field+0xac>  // b.any
    fd8000005740:	3940c660 	ldrb	w0, [x19, #49]
    fd8000005744:	3707fb40 	tbnz	w0, #0, fd80000056ac <vgic_int_set_field+0xac>
        interrupt->in_lr || (vgic_get_state(interrupt) & ACT)) {
    fd8000005748:	aa1303e0 	mov	x0, x19
    fd800000574c:	97fffc0d 	bl	fd8000004780 <vgic_get_state>
    fd8000005750:	370ffae0 	tbnz	w0, #1, fd80000056ac <vgic_int_set_field+0xac>
    interrupt->owner = NULL;
    fd8000005754:	f900067f 	str	xzr, [x19, #8]
    fd8000005758:	17ffffd5 	b	fd80000056ac <vgic_int_set_field+0xac>
    fd800000575c:	d503201f 	nop
    fd8000005760:	00012e78 	.word	0x00012e78
    fd8000005764:	0000fd80 	.word	0x0000fd80
    fd8000005768:	d503201f 	nop
    fd800000576c:	d503201f 	nop

0000fd8000005770 <vgic_emul_generic_access>:
{
    fd8000005770:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
    fd8000005774:	910003fd 	mov	x29, sp
    fd8000005778:	a90153f3 	stp	x19, x20, [sp, #16]
    size_t first_int = (GICD_REG_MASK(acc->addr) - handlers->regroup_base) * 8 / field_width;
    fd800000577c:	79400013 	ldrh	w19, [x0]
{
    fd8000005780:	a90573fb 	stp	x27, x28, [sp, #80]
    fd8000005784:	aa0003fc 	mov	x28, x0
    fd8000005788:	aa0103fb 	mov	x27, x1
    size_t field_width = handlers->field_width;
    fd800000578c:	a941d020 	ldp	x0, x20, [x1, #24]
{
    fd8000005790:	a9025bf5 	stp	x21, x22, [sp, #32]
    fd8000005794:	a90363f7 	stp	x23, x24, [sp, #48]
    fd8000005798:	12001c57 	and	w23, w2, #0xff
    fd800000579c:	a9046bf9 	stp	x25, x26, [sp, #64]
    size_t first_int = (GICD_REG_MASK(acc->addr) - handlers->regroup_base) * 8 / field_width;
    fd80000057a0:	cb000273 	sub	x19, x19, x0
    unsigned long val = acc->write ? vcpu_readreg(cpu()->vcpu, acc->reg) : 0;
    fd80000057a4:	39402380 	ldrb	w0, [x28, #8]
    size_t first_int = (GICD_REG_MASK(acc->addr) - handlers->regroup_base) * 8 / field_width;
    fd80000057a8:	d37df273 	lsl	x19, x19, #3
{
    fd80000057ac:	f90033e3 	str	x3, [sp, #96]
    size_t first_int = (GICD_REG_MASK(acc->addr) - handlers->regroup_base) * 8 / field_width;
    fd80000057b0:	9ad40a73 	udiv	x19, x19, x20
    return int_id < GIC_MAX_SGIS;
}

static inline bool gic_is_priv(irqid_t int_id)
{
    return int_id < GIC_CPU_PRIV;
    fd80000057b4:	71007e7f 	cmp	w19, #0x1f
    fd80000057b8:	1a9f87f6 	cset	w22, ls	// ls = plast
    unsigned long val = acc->write ? vcpu_readreg(cpu()->vcpu, acc->reg) : 0;
    fd80000057bc:	37000d20 	tbnz	w0, #0, fd8000005960 <vgic_emul_generic_access+0x1f0>
    if (valid_access) {
    fd80000057c0:	6b1602ff 	cmp	w23, w22
    fd80000057c4:	540007e1 	b.ne	fd80000058c0 <vgic_emul_generic_access+0x150>  // b.any
        for (size_t i = 0; i < ((acc->width * 8) / field_width); i++) {
    fd80000057c8:	12000003 	and	w3, w0, #0x1
    unsigned long val = acc->write ? vcpu_readreg(cpu()->vcpu, acc->reg) : 0;
    fd80000057cc:	d280001a 	mov	x26, #0x0                   	// #0
        for (size_t i = 0; i < ((acc->width * 8) / field_width); i++) {
    fd80000057d0:	f9400b80 	ldr	x0, [x28, #16]
    fd80000057d4:	eb000e9f 	cmp	x20, x0, lsl #3
    fd80000057d8:	54000768 	b.hi	fd80000058c4 <vgic_emul_generic_access+0x154>  // b.pmore
    fd80000057dc:	f94033e2 	ldr	x2, [sp, #96]
BIT_OPS_GEN(bit, unsigned long, (1UL), BIT_MASK);
    fd80000057e0:	51000680 	sub	w0, w20, #0x1
    fd80000057e4:	d2813401 	mov	x1, #0x9a0                 	// #2464
    fd80000057e8:	d2800058 	mov	x24, #0x2                   	// #2
    fd80000057ec:	92800016 	mov	x22, #0xffffffffffffffff    	// #-1
    fd80000057f0:	9ac02318 	lsl	x24, x24, x0
    fd80000057f4:	9ad422d6 	lsl	x22, x22, x20
    fd80000057f8:	d1000700 	sub	x0, x24, #0x1
    fd80000057fc:	9b017c41 	mul	x1, x2, x1
    unsigned long mask = (1ull << field_width) - 1;
    fd8000005800:	2a1403f5 	mov	w21, w20
    fd8000005804:	52800019 	mov	w25, #0x0                   	// #0
        for (size_t i = 0; i < ((acc->width * 8) / field_width); i++) {
    fd8000005808:	d2800018 	mov	x24, #0x0                   	// #0
            struct vgic_int* interrupt = vgic_get_int(cpu()->vcpu, first_int + i, vgicr_id);
    fd800000580c:	d2dfc017 	mov	x23, #0xfe0000000000        	// #279275953455104
    fd8000005810:	a90707e0 	stp	x0, x1, [sp, #112]
    fd8000005814:	aa3603e0 	mvn	x0, x22
    fd8000005818:	52800016 	mov	w22, #0x0                   	// #0
    fd800000581c:	f90037e0 	str	x0, [sp, #104]
    fd8000005820:	f9402ae0 	ldr	x0, [x23, #80]
    if (int_id < GIC_CPU_PRIV) {
    fd8000005824:	71007e7f 	cmp	w19, #0x1f
    fd8000005828:	2a1303e2 	mov	w2, w19
    fd800000582c:	54000629 	b.ls	fd80000058f0 <vgic_emul_generic_access+0x180>  // b.plast
    } else if (int_id < vcpu->vm->arch.vgicd.int_num) {
    fd8000005830:	f944c801 	ldr	x1, [x0, #2448]
    fd8000005834:	f940542a 	ldr	x10, [x1, #168]
    fd8000005838:	eb02015f 	cmp	x10, x2
    fd800000583c:	54000329 	b.ls	fd80000058a0 <vgic_emul_generic_access+0x130>  // b.plast
        return &vcpu->vm->arch.vgicd.interrupts[int_id - GIC_CPU_PRIV];
    fd8000005840:	f9404c22 	ldr	x2, [x1, #152]
    fd8000005844:	51008261 	sub	w1, w19, #0x20
    fd8000005848:	52800704 	mov	w4, #0x38                  	// #56
    fd800000584c:	9ba40821 	umaddl	x1, w1, w4, x2
            if (interrupt == NULL) {
    fd8000005850:	b4000281 	cbz	x1, fd80000058a0 <vgic_emul_generic_access+0x130>
            if (acc->write) {
    fd8000005854:	35000723 	cbnz	w3, fd8000005938 <vgic_emul_generic_access+0x1c8>
                val |= (handlers->read_field(cpu()->vcpu, interrupt) & mask) << (i * field_width);
    fd8000005858:	f9401762 	ldr	x2, [x27, #40]
    fd800000585c:	d63f0040 	blr	x2
    fd8000005860:	f94037e1 	ldr	x1, [sp, #104]
    fd8000005864:	8a010002 	and	x2, x0, x1
    fd8000005868:	9ad92042 	lsl	x2, x2, x25
    fd800000586c:	aa02035a 	orr	x26, x26, x2
        for (size_t i = 0; i < ((acc->width * 8) / field_width); i++) {
    fd8000005870:	f9400b82 	ldr	x2, [x28, #16]
    fd8000005874:	91000718 	add	x24, x24, #0x1
    if (!acc->write) {
    fd8000005878:	39402380 	ldrb	w0, [x28, #8]
        for (size_t i = 0; i < ((acc->width * 8) / field_width); i++) {
    fd800000587c:	11000673 	add	w19, w19, #0x1
    fd8000005880:	0b1502d6 	add	w22, w22, w21
    fd8000005884:	0b150339 	add	w25, w25, w21
    fd8000005888:	d37df042 	lsl	x2, x2, #3
    fd800000588c:	12000003 	and	w3, w0, #0x1
    fd8000005890:	9ad40842 	udiv	x2, x2, x20
    fd8000005894:	eb18005f 	cmp	x2, x24
    fd8000005898:	54fffc48 	b.hi	fd8000005820 <vgic_emul_generic_access+0xb0>  // b.pmore
    fd800000589c:	d503201f 	nop
    if (!acc->write) {
    fd80000058a0:	34000123 	cbz	w3, fd80000058c4 <vgic_emul_generic_access+0x154>
}
    fd80000058a4:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd80000058a8:	a9425bf5 	ldp	x21, x22, [sp, #32]
    fd80000058ac:	a94363f7 	ldp	x23, x24, [sp, #48]
    fd80000058b0:	a9446bf9 	ldp	x25, x26, [sp, #64]
    fd80000058b4:	a94573fb 	ldp	x27, x28, [sp, #80]
    fd80000058b8:	a8c87bfd 	ldp	x29, x30, [sp], #128
    fd80000058bc:	d65f03c0 	ret
    unsigned long val = acc->write ? vcpu_readreg(cpu()->vcpu, acc->reg) : 0;
    fd80000058c0:	d280001a 	mov	x26, #0x0                   	// #0
        vcpu_writereg(cpu()->vcpu, acc->reg, val);
    fd80000058c4:	d2dfc000 	mov	x0, #0xfe0000000000        	// #279275953455104
    fd80000058c8:	aa1a03e2 	mov	x2, x26
}
    fd80000058cc:	a94153f3 	ldp	x19, x20, [sp, #16]
        vcpu_writereg(cpu()->vcpu, acc->reg, val);
    fd80000058d0:	f9400f81 	ldr	x1, [x28, #24]
}
    fd80000058d4:	a9425bf5 	ldp	x21, x22, [sp, #32]
    fd80000058d8:	a94363f7 	ldp	x23, x24, [sp, #48]
    fd80000058dc:	a9446bf9 	ldp	x25, x26, [sp, #64]
    fd80000058e0:	a94573fb 	ldp	x27, x28, [sp, #80]
        vcpu_writereg(cpu()->vcpu, acc->reg, val);
    fd80000058e4:	f9402800 	ldr	x0, [x0, #80]
}
    fd80000058e8:	a8c87bfd 	ldp	x29, x30, [sp], #128
        vcpu_writereg(cpu()->vcpu, acc->reg, val);
    fd80000058ec:	17ffefd1 	b	fd8000001830 <vcpu_writereg>
        struct vcpu* target_vcpu = vgicr_id == vcpu->id ? vcpu : vm_get_vcpu(vcpu->vm, vgicr_id);
    fd80000058f0:	d2804804 	mov	x4, #0x240                 	// #576
    fd80000058f4:	52800701 	mov	w1, #0x38                  	// #56
    fd80000058f8:	f944bc02 	ldr	x2, [x0, #2424]
    fd80000058fc:	9ba11261 	umaddl	x1, w19, w1, x4
    fd8000005900:	f94033e4 	ldr	x4, [sp, #96]
    fd8000005904:	eb02009f 	cmp	x4, x2
    fd8000005908:	54000280 	b.eq	fd8000005958 <vgic_emul_generic_access+0x1e8>  // b.none
    fd800000590c:	f944c80a 	ldr	x10, [x0, #2448]
    return NULL;
    fd8000005910:	d2800002 	mov	x2, #0x0                   	// #0
    if (vcpuid < vm->cpu_num) {
    fd8000005914:	f94033e4 	ldr	x4, [sp, #96]
    fd8000005918:	f940254b 	ldr	x11, [x10, #72]
    fd800000591c:	eb0b009f 	cmp	x4, x11
    fd8000005920:	54000082 	b.cs	fd8000005930 <vgic_emul_generic_access+0x1c0>  // b.hs, b.nlast
        return &vm->vcpus[vcpuid];
    fd8000005924:	f9402142 	ldr	x2, [x10, #64]
    fd8000005928:	f9403fe4 	ldr	x4, [sp, #120]
    fd800000592c:	8b040042 	add	x2, x2, x4
        return &target_vcpu->arch.vgic_priv.interrupts[int_id];
    fd8000005930:	8b010041 	add	x1, x2, x1
            if (acc->write) {
    fd8000005934:	34fff923 	cbz	w3, fd8000005858 <vgic_emul_generic_access+0xe8>
                vgic_int_set_field(handlers, cpu()->vcpu, interrupt, data);
    fd8000005938:	f9403be4 	ldr	x4, [sp, #112]
    fd800000593c:	aa0103e2 	mov	x2, x1
    fd8000005940:	9ad62743 	lsr	x3, x26, x22
    fd8000005944:	aa0003e1 	mov	x1, x0
    fd8000005948:	8a040063 	and	x3, x3, x4
    fd800000594c:	aa1b03e0 	mov	x0, x27
    fd8000005950:	97ffff2c 	bl	fd8000005600 <vgic_int_set_field>
    fd8000005954:	17ffffc7 	b	fd8000005870 <vgic_emul_generic_access+0x100>
        return &target_vcpu->arch.vgic_priv.interrupts[int_id];
    fd8000005958:	8b010001 	add	x1, x0, x1
            if (interrupt == NULL) {
    fd800000595c:	17ffffbe 	b	fd8000005854 <vgic_emul_generic_access+0xe4>
    unsigned long val = acc->write ? vcpu_readreg(cpu()->vcpu, acc->reg) : 0;
    fd8000005960:	d2dfc000 	mov	x0, #0xfe0000000000        	// #279275953455104
    fd8000005964:	f9400f81 	ldr	x1, [x28, #24]
    fd8000005968:	f9402800 	ldr	x0, [x0, #80]
    fd800000596c:	97ffefa9 	bl	fd8000001810 <vcpu_readreg>
    fd8000005970:	aa0003fa 	mov	x26, x0
    if (valid_access) {
    fd8000005974:	6b1602ff 	cmp	w23, w22
    fd8000005978:	54000080 	b.eq	fd8000005988 <vgic_emul_generic_access+0x218>  // b.none
    if (!acc->write) {
    fd800000597c:	39402380 	ldrb	w0, [x28, #8]
    fd8000005980:	12000003 	and	w3, w0, #0x1
    fd8000005984:	17ffffc7 	b	fd80000058a0 <vgic_emul_generic_access+0x130>
        for (size_t i = 0; i < ((acc->width * 8) / field_width); i++) {
    fd8000005988:	f9400b81 	ldr	x1, [x28, #16]
    if (!acc->write) {
    fd800000598c:	39402380 	ldrb	w0, [x28, #8]
        for (size_t i = 0; i < ((acc->width * 8) / field_width); i++) {
    fd8000005990:	eb010e9f 	cmp	x20, x1, lsl #3
    fd8000005994:	12000003 	and	w3, w0, #0x1
    fd8000005998:	54fff229 	b.ls	fd80000057dc <vgic_emul_generic_access+0x6c>  // b.plast
    fd800000599c:	17ffffc1 	b	fd80000058a0 <vgic_emul_generic_access+0x130>

0000fd80000059a0 <vgic_get_reg_handler_info>:
    if (id < VGIC_REG_HANDLER_ID_NUM) {
    fd80000059a0:	7100241f 	cmp	w0, #0x9
    fd80000059a4:	540000a8 	b.hi	fd80000059b8 <vgic_get_reg_handler_info+0x18>  // b.pmore
        return reg_handler_info_table[id];
    fd80000059a8:	90000001 	adrp	x1, fd8000005000 <vgic_add_lr+0x80>
    fd80000059ac:	f944e021 	ldr	x1, [x1, #2496]
    fd80000059b0:	f8605820 	ldr	x0, [x1, w0, uxtw #3]
}
    fd80000059b4:	d65f03c0 	ret
        return NULL;
    fd80000059b8:	d2800000 	mov	x0, #0x0                   	// #0
}
    fd80000059bc:	d65f03c0 	ret
    fd80000059c0:	00012350 	.word	0x00012350
    fd80000059c4:	0000fd80 	.word	0x0000fd80
    fd80000059c8:	d503201f 	nop
    fd80000059cc:	d503201f 	nop

0000fd80000059d0 <vgic_check_reg_alignment>:
    if ((!(handlers->alignment & acc->width) || ((acc->addr & (acc->width - 1)) != 0)) && (acc->addr != 0x80a0070) && (acc->addr != 0x80a0078) && (acc->addr != 0x80c0070) && (acc->addr != 0x80c0078)) {
    fd80000059d0:	f9400422 	ldr	x2, [x1, #8]
    fd80000059d4:	f9400803 	ldr	x3, [x0, #16]
    fd80000059d8:	f9400001 	ldr	x1, [x0]
    fd80000059dc:	ea03005f 	tst	x2, x3
    fd80000059e0:	540000a0 	b.eq	fd80000059f4 <vgic_check_reg_alignment+0x24>  // b.none
    fd80000059e4:	d1000464 	sub	x4, x3, #0x1
        return true;
    fd80000059e8:	52800020 	mov	w0, #0x1                   	// #1
    if ((!(handlers->alignment & acc->width) || ((acc->addr & (acc->width - 1)) != 0)) && (acc->addr != 0x80a0070) && (acc->addr != 0x80a0078) && (acc->addr != 0x80c0070) && (acc->addr != 0x80c0078)) {
    fd80000059ec:	ea01009f 	tst	x4, x1
    fd80000059f0:	54000100 	b.eq	fd8000005a10 <vgic_check_reg_alignment+0x40>  // b.none
    fd80000059f4:	927cf824 	and	x4, x1, #0xfffffffffffffff7
    fd80000059f8:	92800de0 	mov	x0, #0xffffffffffffff90    	// #-112
    fd80000059fc:	f2befea0 	movk	x0, #0xf7f5, lsl #16
    fd8000005a00:	8b000084 	add	x4, x4, x0
    fd8000005a04:	f26ef89f 	tst	x4, #0xfffffffffffdffff
        return true;
    fd8000005a08:	52800020 	mov	w0, #0x1                   	// #1
    if ((!(handlers->alignment & acc->width) || ((acc->addr & (acc->width - 1)) != 0)) && (acc->addr != 0x80a0070) && (acc->addr != 0x80a0078) && (acc->addr != 0x80c0070) && (acc->addr != 0x80c0078)) {
    fd8000005a0c:	54000041 	b.ne	fd8000005a14 <vgic_check_reg_alignment+0x44>  // b.any
}
    fd8000005a10:	d65f03c0 	ret
{
    fd8000005a14:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    fd8000005a18:	910003fd 	mov	x29, sp
        console_printk("VGIC: In addr 0x%x, algin=0x%x, width=0x%x\n",acc->addr,handlers->alignment,acc->width);
    fd8000005a1c:	90000000 	adrp	x0, fd8000005000 <vgic_add_lr+0x80>
    fd8000005a20:	f9451c00 	ldr	x0, [x0, #2616]
    fd8000005a24:	9400197f 	bl	fd800000c020 <console_printk>
        return false;
    fd8000005a28:	52800000 	mov	w0, #0x0                   	// #0
}
    fd8000005a2c:	a8c17bfd 	ldp	x29, x30, [sp], #16
    fd8000005a30:	d65f03c0 	ret
    fd8000005a34:	d503201f 	nop
    fd8000005a38:	00010858 	.word	0x00010858
    fd8000005a3c:	0000fd80 	.word	0x0000fd80

0000fd8000005a40 <vgicd_emul_handler>:
{
    fd8000005a40:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    fd8000005a44:	910003fd 	mov	x29, sp
    switch (GICD_REG_MASK(acc->addr) >> 7) {
    fd8000005a48:	f9400001 	ldr	x1, [x0]
{
    fd8000005a4c:	a90153f3 	stp	x19, x20, [sp, #16]
    fd8000005a50:	aa0003f3 	mov	x19, x0
    fd8000005a54:	a9025bf5 	stp	x21, x22, [sp, #32]
    switch (GICD_REG_MASK(acc->addr) >> 7) {
    fd8000005a58:	d3473c20 	ubfx	x0, x1, #7, #9
    fd8000005a5c:	f100141f 	cmp	x0, #0x5
    fd8000005a60:	54000ba0 	b.eq	fd8000005bd4 <vgicd_emul_handler+0x194>  // b.none
    fd8000005a64:	54000189 	b.ls	fd8000005a94 <vgicd_emul_handler+0x54>  // b.plast
    fd8000005a68:	f100601f 	cmp	x0, #0x18
    fd8000005a6c:	54000a40 	b.eq	fd8000005bb4 <vgicd_emul_handler+0x174>  // b.none
    fd8000005a70:	54000908 	b.hi	fd8000005b90 <vgicd_emul_handler+0x150>  // b.pmore
    fd8000005a74:	f100181f 	cmp	x0, #0x6
    fd8000005a78:	54000380 	b.eq	fd8000005ae8 <vgicd_emul_handler+0xa8>  // b.none
    fd8000005a7c:	f1001c1f 	cmp	x0, #0x7
    fd8000005a80:	54000b21 	b.ne	fd8000005be4 <vgicd_emul_handler+0x1a4>  // b.any
            handler_info = &iactiver_info;
    fd8000005a84:	90000000 	adrp	x0, fd8000005000 <vgic_add_lr+0x80>
    fd8000005a88:	f9463015 	ldr	x21, [x0, #3168]
    fd8000005a8c:	910742b5 	add	x21, x21, #0x1d0
    fd8000005a90:	1400000c 	b	fd8000005ac0 <vgicd_emul_handler+0x80>
    switch (GICD_REG_MASK(acc->addr) >> 7) {
    fd8000005a94:	f1000c1f 	cmp	x0, #0x3
    fd8000005a98:	54000960 	b.eq	fd8000005bc4 <vgicd_emul_handler+0x184>  // b.none
    fd8000005a9c:	f100101f 	cmp	x0, #0x4
    fd8000005aa0:	54000820 	b.eq	fd8000005ba4 <vgicd_emul_handler+0x164>  // b.none
    fd8000005aa4:	b40002a0 	cbz	x0, fd8000005af8 <vgicd_emul_handler+0xb8>
    fd8000005aa8:	f100081f 	cmp	x0, #0x2
    fd8000005aac:	540009c1 	b.ne	fd8000005be4 <vgicd_emul_handler+0x1a4>  // b.any
    fd8000005ab0:	90000000 	adrp	x0, fd8000005000 <vgic_add_lr+0x80>
    fd8000005ab4:	f9463015 	ldr	x21, [x0, #3168]
    fd8000005ab8:	910242b5 	add	x21, x21, #0x90
    fd8000005abc:	d503201f 	nop
    if (vgic_check_reg_alignment(acc, handler_info)) {
    fd8000005ac0:	aa1503e1 	mov	x1, x21
    fd8000005ac4:	aa1303e0 	mov	x0, x19
    fd8000005ac8:	97ffffc2 	bl	fd80000059d0 <vgic_check_reg_alignment>
    fd8000005acc:	2a0003f4 	mov	w20, w0
    fd8000005ad0:	370001d4 	tbnz	w20, #0, fd8000005b08 <vgicd_emul_handler+0xc8>
}
    fd8000005ad4:	a9425bf5 	ldp	x21, x22, [sp, #32]
    fd8000005ad8:	2a1403e0 	mov	w0, w20
    fd8000005adc:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd8000005ae0:	a8c37bfd 	ldp	x29, x30, [sp], #48
    fd8000005ae4:	d65f03c0 	ret
            handler_info = &isactiver_info;
    fd8000005ae8:	90000000 	adrp	x0, fd8000005000 <vgic_add_lr+0x80>
    fd8000005aec:	f9463015 	ldr	x21, [x0, #3168]
    fd8000005af0:	910442b5 	add	x21, x21, #0x110
    fd8000005af4:	17fffff3 	b	fd8000005ac0 <vgicd_emul_handler+0x80>
            handler_info = &vgicd_misc_info;
    fd8000005af8:	90000000 	adrp	x0, fd8000005000 <vgic_add_lr+0x80>
    fd8000005afc:	f9463015 	ldr	x21, [x0, #3168]
    fd8000005b00:	910142b5 	add	x21, x21, #0x50
    fd8000005b04:	17ffffef 	b	fd8000005ac0 <vgicd_emul_handler+0x80>
        spin_lock(&cpu()->vcpu->vm->arch.vgicd.lock);
    fd8000005b08:	d2dfc016 	mov	x22, #0xfe0000000000        	// #279275953455104
    fd8000005b0c:	f9402ac0 	ldr	x0, [x22, #80]
    fd8000005b10:	f944c800 	ldr	x0, [x0, #2448]
    __asm__ volatile(
    fd8000005b14:	91028003 	add	x3, x0, #0xa0
    fd8000005b18:	91029004 	add	x4, x0, #0xa4
    fd8000005b1c:	885ffc60 	ldaxr	w0, [x3]
    fd8000005b20:	11000401 	add	w1, w0, #0x1
    fd8000005b24:	88027c61 	stxr	w2, w1, [x3]
    fd8000005b28:	35ffffa2 	cbnz	w2, fd8000005b1c <vgicd_emul_handler+0xdc>
    fd8000005b2c:	88dffc81 	ldar	w1, [x4]
    fd8000005b30:	6b01001f 	cmp	w0, w1
    fd8000005b34:	54000060 	b.eq	fd8000005b40 <vgicd_emul_handler+0x100>  // b.none
    fd8000005b38:	d503205f 	wfe
    fd8000005b3c:	17fffffc 	b	fd8000005b2c <vgicd_emul_handler+0xec>
        handler_info->reg_access(acc, handler_info, false, cpu()->vcpu->id);
    fd8000005b40:	f9402ac2 	ldr	x2, [x22, #80]
    fd8000005b44:	aa1303e0 	mov	x0, x19
    fd8000005b48:	f94002a4 	ldr	x4, [x21]
    fd8000005b4c:	aa1503e1 	mov	x1, x21
    fd8000005b50:	f944bc43 	ldr	x3, [x2, #2424]
    fd8000005b54:	52800002 	mov	w2, #0x0                   	// #0
    fd8000005b58:	d63f0080 	blr	x4
        spin_unlock(&cpu()->vcpu->vm->arch.vgicd.lock);
    fd8000005b5c:	f9402ac0 	ldr	x0, [x22, #80]
    __asm__ volatile(
    fd8000005b60:	f944c800 	ldr	x0, [x0, #2448]
    fd8000005b64:	91029001 	add	x1, x0, #0xa4
    fd8000005b68:	b9400020 	ldr	w0, [x1]
    fd8000005b6c:	11000400 	add	w0, w0, #0x1
    fd8000005b70:	889ffc20 	stlr	w0, [x1]
    fd8000005b74:	d5033b9f 	dsb	ish
    fd8000005b78:	d503209f 	sev
}
    fd8000005b7c:	a9425bf5 	ldp	x21, x22, [sp, #32]
    fd8000005b80:	2a1403e0 	mov	w0, w20
    fd8000005b84:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd8000005b88:	a8c37bfd 	ldp	x29, x30, [sp], #48
    fd8000005b8c:	d65f03c0 	ret
    switch (GICD_REG_MASK(acc->addr) >> 7) {
    fd8000005b90:	f100781f 	cmp	x0, #0x1e
    fd8000005b94:	54000281 	b.ne	fd8000005be4 <vgicd_emul_handler+0x1a4>  // b.any
            handler_info = &sgir_info;
    fd8000005b98:	90000000 	adrp	x0, fd8000005000 <vgic_add_lr+0x80>
    fd8000005b9c:	f9463415 	ldr	x21, [x0, #3176]
    fd8000005ba0:	17ffffc8 	b	fd8000005ac0 <vgicd_emul_handler+0x80>
            handler_info = &ispendr_info;
    fd8000005ba4:	90000000 	adrp	x0, fd8000005000 <vgic_add_lr+0x80>
    fd8000005ba8:	f9463015 	ldr	x21, [x0, #3168]
    fd8000005bac:	910542b5 	add	x21, x21, #0x150
    fd8000005bb0:	17ffffc4 	b	fd8000005ac0 <vgicd_emul_handler+0x80>
            handler_info = &icfgr_info;
    fd8000005bb4:	90000000 	adrp	x0, fd8000005000 <vgic_add_lr+0x80>
    fd8000005bb8:	f9463015 	ldr	x21, [x0, #3168]
    fd8000005bbc:	910842b5 	add	x21, x21, #0x210
    fd8000005bc0:	17ffffc0 	b	fd8000005ac0 <vgicd_emul_handler+0x80>
            handler_info = &icenabler_info;
    fd8000005bc4:	90000000 	adrp	x0, fd8000005000 <vgic_add_lr+0x80>
    fd8000005bc8:	f9463015 	ldr	x21, [x0, #3168]
    fd8000005bcc:	910342b5 	add	x21, x21, #0xd0
    fd8000005bd0:	17ffffbc 	b	fd8000005ac0 <vgicd_emul_handler+0x80>
            handler_info = &icpendr_info;
    fd8000005bd4:	90000000 	adrp	x0, fd8000005000 <vgic_add_lr+0x80>
    fd8000005bd8:	f9463015 	ldr	x21, [x0, #3168]
    fd8000005bdc:	910642b5 	add	x21, x21, #0x190
    fd8000005be0:	17ffffb8 	b	fd8000005ac0 <vgicd_emul_handler+0x80>
            size_t acc_off = GICD_REG_MASK(acc->addr);
    fd8000005be4:	92403c21 	and	x1, x1, #0xffff
            if (GICD_IS_REG(IPRIORITYR, acc_off)) {
    fd8000005be8:	d1100020 	sub	x0, x1, #0x400
    fd8000005bec:	f10ffc1f 	cmp	x0, #0x3ff
    fd8000005bf0:	54000209 	b.ls	fd8000005c30 <vgicd_emul_handler+0x1f0>  // b.plast
            } else if (GICD_IS_REG(ITARGETSR, acc_off)) {
    fd8000005bf4:	d1200020 	sub	x0, x1, #0x800
    fd8000005bf8:	f10ffc1f 	cmp	x0, #0x3ff
    fd8000005bfc:	54000229 	b.ls	fd8000005c40 <vgicd_emul_handler+0x200>  // b.plast
            } else if (GICD_IS_REG(IROUTER, acc_off)) {
    fd8000005c00:	d1401822 	sub	x2, x1, #0x6, lsl #12
    fd8000005c04:	d283ffe0 	mov	x0, #0x1fff                	// #8191
    fd8000005c08:	eb00005f 	cmp	x2, x0
    fd8000005c0c:	54000209 	b.ls	fd8000005c4c <vgicd_emul_handler+0x20c>  // b.plast
            } else if (GICD_IS_REG(ID, acc_off)) {
    fd8000005c10:	929ff9e0 	mov	x0, #0xffffffffffff0030    	// #-65488
    fd8000005c14:	8b000021 	add	x1, x1, x0
    fd8000005c18:	f100bc3f 	cmp	x1, #0x2f
                handler_info = &vgicd_pidr_info;
    fd8000005c1c:	90000000 	adrp	x0, fd8000005000 <vgic_add_lr+0x80>
    fd8000005c20:	f9463015 	ldr	x21, [x0, #3168]
            } else if (GICD_IS_REG(ID, acc_off)) {
    fd8000005c24:	540001a8 	b.hi	fd8000005c58 <vgicd_emul_handler+0x218>  // b.pmore
                handler_info = &vgicd_pidr_info;
    fd8000005c28:	910a42b5 	add	x21, x21, #0x290
    fd8000005c2c:	17ffffa5 	b	fd8000005ac0 <vgicd_emul_handler+0x80>
                handler_info = &ipriorityr_info;
    fd8000005c30:	90000000 	adrp	x0, fd8000005000 <vgic_add_lr+0x80>
    fd8000005c34:	f9463015 	ldr	x21, [x0, #3168]
    fd8000005c38:	910942b5 	add	x21, x21, #0x250
    fd8000005c3c:	17ffffa1 	b	fd8000005ac0 <vgicd_emul_handler+0x80>
                handler_info = &itargetr_info;
    fd8000005c40:	90000000 	adrp	x0, fd8000005000 <vgic_add_lr+0x80>
    fd8000005c44:	f9463815 	ldr	x21, [x0, #3184]
    fd8000005c48:	17ffff9e 	b	fd8000005ac0 <vgicd_emul_handler+0x80>
                handler_info = &irouter_info;
    fd8000005c4c:	90000000 	adrp	x0, fd8000005000 <vgic_add_lr+0x80>
    fd8000005c50:	f9463c15 	ldr	x21, [x0, #3192]
    fd8000005c54:	17ffff9b 	b	fd8000005ac0 <vgicd_emul_handler+0x80>
                handler_info = &razwi_info;
    fd8000005c58:	910b42b5 	add	x21, x21, #0x2d0
    fd8000005c5c:	17ffff99 	b	fd8000005ac0 <vgicd_emul_handler+0x80>
    fd8000005c60:	00012350 	.word	0x00012350
    fd8000005c64:	0000fd80 	.word	0x0000fd80
    fd8000005c68:	000126a0 	.word	0x000126a0
    fd8000005c6c:	0000fd80 	.word	0x0000fd80
    fd8000005c70:	000126e0 	.word	0x000126e0
    fd8000005c74:	0000fd80 	.word	0x0000fd80
    fd8000005c78:	000127e0 	.word	0x000127e0
    fd8000005c7c:	0000fd80 	.word	0x0000fd80

0000fd8000005c80 <vgic_inject_hw>:
    if (int_id < GIC_CPU_PRIV) {
    fd8000005c80:	71007c3f 	cmp	w1, #0x1f
    fd8000005c84:	540004c9 	b.ls	fd8000005d1c <vgic_inject_hw+0x9c>  // b.plast
    } else if (int_id < vcpu->vm->arch.vgicd.int_num) {
    fd8000005c88:	f944c802 	ldr	x2, [x0, #2448]
    fd8000005c8c:	2a0103e3 	mov	w3, w1
    fd8000005c90:	f9405444 	ldr	x4, [x2, #168]
    fd8000005c94:	eb03009f 	cmp	x4, x3
    fd8000005c98:	540004a9 	b.ls	fd8000005d2c <vgic_inject_hw+0xac>  // b.plast
        return &vcpu->vm->arch.vgicd.interrupts[int_id - GIC_CPU_PRIV];
    fd8000005c9c:	f9404c42 	ldr	x2, [x2, #152]
    fd8000005ca0:	51008021 	sub	w1, w1, #0x20
    fd8000005ca4:	52800703 	mov	w3, #0x38                  	// #56
    fd8000005ca8:	9ba30821 	umaddl	x1, w1, w3, x2
{
    fd8000005cac:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    fd8000005cb0:	910003fd 	mov	x29, sp
    fd8000005cb4:	f9000bf3 	str	x19, [sp, #16]
    spin_lock(&interrupt->lock);
    fd8000005cb8:	91008033 	add	x19, x1, #0x20
    __asm__ volatile(
    fd8000005cbc:	91001265 	add	x5, x19, #0x4
    fd8000005cc0:	885ffe62 	ldaxr	w2, [x19]
    fd8000005cc4:	11000443 	add	w3, w2, #0x1
    fd8000005cc8:	88047e63 	stxr	w4, w3, [x19]
    fd8000005ccc:	35ffffa4 	cbnz	w4, fd8000005cc0 <vgic_inject_hw+0x40>
    fd8000005cd0:	88dffca3 	ldar	w3, [x5]
    fd8000005cd4:	6b03005f 	cmp	w2, w3
    fd8000005cd8:	54000060 	b.eq	fd8000005ce4 <vgic_inject_hw+0x64>  // b.none
    fd8000005cdc:	d503205f 	wfe
    fd8000005ce0:	17fffffc 	b	fd8000005cd0 <vgic_inject_hw+0x50>
    interrupt->state = PEND;
    fd8000005ce4:	52800022 	mov	w2, #0x1                   	// #1
    interrupt->owner = vcpu;
    fd8000005ce8:	f9000420 	str	x0, [x1, #8]
    interrupt->state = PEND;
    fd8000005cec:	3900b022 	strb	w2, [x1, #44]
    interrupt->in_lr = false;
    fd8000005cf0:	3900c43f 	strb	wzr, [x1, #49]
    vgic_add_lr(vcpu, interrupt);
    fd8000005cf4:	97fffca3 	bl	fd8000004f80 <vgic_add_lr>
    __asm__ volatile(
    fd8000005cf8:	91001261 	add	x1, x19, #0x4
    fd8000005cfc:	b9400020 	ldr	w0, [x1]
    fd8000005d00:	11000400 	add	w0, w0, #0x1
    fd8000005d04:	889ffc20 	stlr	w0, [x1]
    fd8000005d08:	d5033b9f 	dsb	ish
    fd8000005d0c:	d503209f 	sev
}
    fd8000005d10:	f9400bf3 	ldr	x19, [sp, #16]
    fd8000005d14:	a8c27bfd 	ldp	x29, x30, [sp], #32
    fd8000005d18:	d65f03c0 	ret
        return &target_vcpu->arch.vgic_priv.interrupts[int_id];
    fd8000005d1c:	52800702 	mov	w2, #0x38                  	// #56
    fd8000005d20:	9ba20021 	umaddl	x1, w1, w2, x0
    fd8000005d24:	91090021 	add	x1, x1, #0x240
    fd8000005d28:	17ffffe1 	b	fd8000005cac <vgic_inject_hw+0x2c>
    __asm__ volatile(
    fd8000005d2c:	d2800401 	mov	x1, #0x20                  	// #32
    fd8000005d30:	91001024 	add	x4, x1, #0x4
    fd8000005d34:	885ffc25 	ldaxr	w5, [x1]
    fd8000005d38:	110004a2 	add	w2, w5, #0x1
    fd8000005d3c:	88037c22 	stxr	w3, w2, [x1]
    fd8000005d40:	35ffffa3 	cbnz	w3, fd8000005d34 <vgic_inject_hw+0xb4>
    fd8000005d44:	88dffc82 	ldar	w2, [x4]
    fd8000005d48:	6b0200bf 	cmp	w5, w2
    fd8000005d4c:	54000060 	b.eq	fd8000005d58 <vgic_inject_hw+0xd8>  // b.none
    fd8000005d50:	d503205f 	wfe
    fd8000005d54:	17fffffc 	b	fd8000005d44 <vgic_inject_hw+0xc4>
    interrupt->owner = vcpu;
    fd8000005d58:	d2800001 	mov	x1, #0x0                   	// #0
    fd8000005d5c:	f9000420 	str	x0, [x1, #8]
    fd8000005d60:	d4207d00 	brk	#0x3e8
    fd8000005d64:	d503201f 	nop
    fd8000005d68:	d503201f 	nop
    fd8000005d6c:	d503201f 	nop

0000fd8000005d70 <vgic_inject>:
    if (int_id < GIC_CPU_PRIV) {
    fd8000005d70:	71007c3f 	cmp	w1, #0x1f
    fd8000005d74:	2a0103e3 	mov	w3, w1
    fd8000005d78:	540002e9 	b.ls	fd8000005dd4 <vgic_inject+0x64>  // b.plast
    } else if (int_id < vcpu->vm->arch.vgicd.int_num) {
    fd8000005d7c:	f944c802 	ldr	x2, [x0, #2448]
    fd8000005d80:	f9405444 	ldr	x4, [x2, #168]
    fd8000005d84:	eb03009f 	cmp	x4, x3
    fd8000005d88:	54000189 	b.ls	fd8000005db8 <vgic_inject+0x48>  // b.plast
        return &vcpu->vm->arch.vgicd.interrupts[int_id - GIC_CPU_PRIV];
    fd8000005d8c:	f9404c43 	ldr	x3, [x2, #152]
    fd8000005d90:	51008022 	sub	w2, w1, #0x20
    fd8000005d94:	52800704 	mov	w4, #0x38                  	// #56
    fd8000005d98:	9ba40c42 	umaddl	x2, w2, w4, x3
    if (interrupt != NULL) {
    fd8000005d9c:	b40000e2 	cbz	x2, fd8000005db8 <vgic_inject+0x48>
    return !(interrupt->id < GIC_MAX_SGIS) && interrupt->hw;
    fd8000005da0:	b9402843 	ldr	w3, [x2, #40]
    fd8000005da4:	71003c7f 	cmp	w3, #0xf
    fd8000005da8:	540000a9 	b.ls	fd8000005dbc <vgic_inject+0x4c>  // b.plast
    fd8000005dac:	3940c043 	ldrb	w3, [x2, #48]
    fd8000005db0:	36000063 	tbz	w3, #0, fd8000005dbc <vgic_inject+0x4c>
            vgic_inject_hw(vcpu, id);
    fd8000005db4:	17ffffb3 	b	fd8000005c80 <vgic_inject_hw>
}
    fd8000005db8:	d65f03c0 	ret
            vgic_int_set_field(&ispendr_info, vcpu, interrupt, true);
    fd8000005dbc:	90000001 	adrp	x1, fd8000005000 <vgic_add_lr+0x80>
    fd8000005dc0:	f946f424 	ldr	x4, [x1, #3560]
    fd8000005dc4:	d2800023 	mov	x3, #0x1                   	// #1
    fd8000005dc8:	aa0003e1 	mov	x1, x0
    fd8000005dcc:	91054080 	add	x0, x4, #0x150
    fd8000005dd0:	17fffe0c 	b	fd8000005600 <vgic_int_set_field>
        return &target_vcpu->arch.vgic_priv.interrupts[int_id];
    fd8000005dd4:	52800702 	mov	w2, #0x38                  	// #56
    fd8000005dd8:	9ba20022 	umaddl	x2, w1, w2, x0
    fd8000005ddc:	91090042 	add	x2, x2, #0x240
    if (interrupt != NULL) {
    fd8000005de0:	17fffff0 	b	fd8000005da0 <vgic_inject+0x30>
    fd8000005de4:	d503201f 	nop
    fd8000005de8:	00012350 	.word	0x00012350
    fd8000005dec:	0000fd80 	.word	0x0000fd80

0000fd8000005df0 <vgic_ipi_handler>:
{
    fd8000005df0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    if (vm_id != cpu()->vcpu->vm->id) {
    fd8000005df4:	d2dfc002 	mov	x2, #0xfe0000000000        	// #279275953455104
{
    fd8000005df8:	910003fd 	mov	x29, sp
    fd8000005dfc:	a90153f3 	stp	x19, x20, [sp, #16]
    if (vm_id != cpu()->vcpu->vm->id) {
    fd8000005e00:	f9402853 	ldr	x19, [x2, #80]
    fd8000005e04:	f944ca65 	ldr	x5, [x19, #2448]
    fd8000005e08:	f94000a2 	ldr	x2, [x5]
    fd8000005e0c:	eb41c05f 	cmp	x2, x1, lsr #48
    fd8000005e10:	54000561 	b.ne	fd8000005ebc <vgic_ipi_handler+0xcc>  // b.any
    irqid_t int_id = VGIC_MSG_INTID(data);
    fd8000005e14:	d350fc24 	lsr	x4, x1, #16
    switch (event) {
    fd8000005e18:	7100081f 	cmp	w0, #0x2
    irqid_t int_id = VGIC_MSG_INTID(data);
    fd8000005e1c:	12003887 	and	w7, w4, #0x7fff
    uint64_t val = VGIC_MSG_VAL(data);
    fd8000005e20:	92401c22 	and	x2, x1, #0xff
    switch (event) {
    fd8000005e24:	54000540 	b.eq	fd8000005ecc <vgic_ipi_handler+0xdc>  // b.none
    fd8000005e28:	540006c8 	b.hi	fd8000005f00 <vgic_ipi_handler+0x110>  // b.pmore
    fd8000005e2c:	340005a0 	cbz	w0, fd8000005ee0 <vgic_ipi_handler+0xf0>
    if (int_id < GIC_CPU_PRIV) {
    fd8000005e30:	f27b249f 	tst	x4, #0x7fe0
    fd8000005e34:	2a0703e0 	mov	w0, w7
    fd8000005e38:	54000c60 	b.eq	fd8000005fc4 <vgic_ipi_handler+0x1d4>  // b.none
    } else if (int_id < vcpu->vm->arch.vgicd.int_num) {
    fd8000005e3c:	f94054a1 	ldr	x1, [x5, #168]
    fd8000005e40:	eb00003f 	cmp	x1, x0
    fd8000005e44:	54000589 	b.ls	fd8000005ef4 <vgic_ipi_handler+0x104>  // b.plast
        return &vcpu->vm->arch.vgicd.interrupts[int_id - GIC_CPU_PRIV];
    fd8000005e48:	f9404ca0 	ldr	x0, [x5, #152]
    fd8000005e4c:	510080e7 	sub	w7, w7, #0x20
    fd8000005e50:	52800701 	mov	w1, #0x38                  	// #56
    fd8000005e54:	9ba100f3 	umaddl	x19, w7, w1, x0
            if (interrupt != NULL) {
    fd8000005e58:	b40004f3 	cbz	x19, fd8000005ef4 <vgic_ipi_handler+0x104>
                spin_lock(&interrupt->lock);
    fd8000005e5c:	91008274 	add	x20, x19, #0x20
    fd8000005e60:	91001283 	add	x3, x20, #0x4
    fd8000005e64:	885ffe80 	ldaxr	w0, [x20]
    fd8000005e68:	11000401 	add	w1, w0, #0x1
    fd8000005e6c:	88027e81 	stxr	w2, w1, [x20]
    fd8000005e70:	35ffffa2 	cbnz	w2, fd8000005e64 <vgic_ipi_handler+0x74>
    fd8000005e74:	88dffc61 	ldar	w1, [x3]
    fd8000005e78:	6b01001f 	cmp	w0, w1
    fd8000005e7c:	54000060 	b.eq	fd8000005e88 <vgic_ipi_handler+0x98>  // b.none
    fd8000005e80:	d503205f 	wfe
    fd8000005e84:	17fffffc 	b	fd8000005e74 <vgic_ipi_handler+0x84>
                if (vgic_get_ownership(cpu()->vcpu, interrupt)) {
    fd8000005e88:	d2dfc000 	mov	x0, #0xfe0000000000        	// #279275953455104
    if (interrupt->owner == vcpu) {
    fd8000005e8c:	f9400661 	ldr	x1, [x19, #8]
                if (vgic_get_ownership(cpu()->vcpu, interrupt)) {
    fd8000005e90:	f9402800 	ldr	x0, [x0, #80]
    if (interrupt->owner == vcpu) {
    fd8000005e94:	eb01001f 	cmp	x0, x1
    fd8000005e98:	54000a20 	b.eq	fd8000005fdc <vgic_ipi_handler+0x1ec>  // b.none
    } else if (interrupt->owner == NULL) {
    fd8000005e9c:	b40009e1 	cbz	x1, fd8000005fd8 <vgic_ipi_handler+0x1e8>
    __asm__ volatile(
    fd8000005ea0:	91001281 	add	x1, x20, #0x4
    fd8000005ea4:	b9400020 	ldr	w0, [x1]
    fd8000005ea8:	11000400 	add	w0, w0, #0x1
    fd8000005eac:	889ffc20 	stlr	w0, [x1]
    fd8000005eb0:	d5033b9f 	dsb	ish
    fd8000005eb4:	d503209f 	sev
}
    fd8000005eb8:	1400000f 	b	fd8000005ef4 <vgic_ipi_handler+0x104>
        ERROR("received vgic3 msg target to another vcpu");
    fd8000005ebc:	b0000000 	adrp	x0, fd8000006000 <vgic_ipi_handler+0x210>
    fd8000005ec0:	f9402400 	ldr	x0, [x0, #72]
    fd8000005ec4:	94001857 	bl	fd800000c020 <console_printk>
    fd8000005ec8:	14000000 	b	fd8000005ec8 <vgic_ipi_handler+0xd8>
            vgic_inject(cpu()->vcpu, int_id, val);
    fd8000005ecc:	aa1303e0 	mov	x0, x19
    fd8000005ed0:	2a0703e1 	mov	w1, w7
}
    fd8000005ed4:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd8000005ed8:	a8c27bfd 	ldp	x29, x30, [sp], #32
            vgic_inject(cpu()->vcpu, int_id, val);
    fd8000005edc:	17ffffa5 	b	fd8000005d70 <vgic_inject>
    if (cpu()->vcpu->vm->arch.vgicd.CTLR & VGIC_ENABLE_MASK) {
    fd8000005ee0:	b940b0a0 	ldr	w0, [x5, #176]
    fd8000005ee4:	36080460 	tbz	w0, #1, fd8000005f70 <vgic_ipi_handler+0x180>
SYSREG_GEN_ACCESSORS(ich_hcr_el2);
    fd8000005ee8:	d53ccb00 	mrs	x0, ich_hcr_el2
    sysreg_ich_hcr_el2_write(hcr);
    fd8000005eec:	32000000 	orr	w0, w0, #0x1
    fd8000005ef0:	d51ccb00 	msr	ich_hcr_el2, x0
}
    fd8000005ef4:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd8000005ef8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    fd8000005efc:	d65f03c0 	ret
    switch (event) {
    fd8000005f00:	71000c1f 	cmp	w0, #0x3
    fd8000005f04:	54ffff81 	b.ne	fd8000005ef4 <vgic_ipi_handler+0x104>  // b.any
            uint64_t reg_id = VGIC_MSG_REG(data);
    fd8000005f08:	d3483c23 	ubfx	x3, x1, #8, #8
        return NULL;
    fd8000005f0c:	d2800000 	mov	x0, #0x0                   	// #0
    if (id < VGIC_REG_HANDLER_ID_NUM) {
    fd8000005f10:	f100247f 	cmp	x3, #0x9
    fd8000005f14:	54000088 	b.hi	fd8000005f24 <vgic_ipi_handler+0x134>  // b.pmore
        return reg_handler_info_table[id];
    fd8000005f18:	b0000000 	adrp	x0, fd8000006000 <vgic_ipi_handler+0x210>
    fd8000005f1c:	f9402800 	ldr	x0, [x0, #80]
    fd8000005f20:	f8637800 	ldr	x0, [x0, x3, lsl #3]
    if (int_id < GIC_CPU_PRIV) {
    fd8000005f24:	f27b249f 	tst	x4, #0x7fe0
    fd8000005f28:	2a0703e3 	mov	w3, w7
    fd8000005f2c:	540002a0 	b.eq	fd8000005f80 <vgic_ipi_handler+0x190>  // b.none
    } else if (int_id < vcpu->vm->arch.vgicd.int_num) {
    fd8000005f30:	f94054a1 	ldr	x1, [x5, #168]
    fd8000005f34:	eb01007f 	cmp	x3, x1
    fd8000005f38:	54fffde2 	b.cs	fd8000005ef4 <vgic_ipi_handler+0x104>  // b.hs, b.nlast
        return &vcpu->vm->arch.vgicd.interrupts[int_id - GIC_CPU_PRIV];
    fd8000005f3c:	f9404ca3 	ldr	x3, [x5, #152]
    fd8000005f40:	510080e1 	sub	w1, w7, #0x20
    fd8000005f44:	52800704 	mov	w4, #0x38                  	// #56
    fd8000005f48:	9ba40c21 	umaddl	x1, w1, w4, x3
            if (handlers != NULL && interrupt != NULL) {
    fd8000005f4c:	f100001f 	cmp	x0, #0x0
    fd8000005f50:	fa401824 	ccmp	x1, #0x0, #0x4, ne	// ne = any
    fd8000005f54:	54fffd00 	b.eq	fd8000005ef4 <vgic_ipi_handler+0x104>  // b.none
                vgic_int_set_field(handlers, cpu()->vcpu, interrupt, val);
    fd8000005f58:	aa0203e3 	mov	x3, x2
    fd8000005f5c:	aa0103e2 	mov	x2, x1
    fd8000005f60:	aa1303e1 	mov	x1, x19
}
    fd8000005f64:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd8000005f68:	a8c27bfd 	ldp	x29, x30, [sp], #32
                vgic_int_set_field(handlers, cpu()->vcpu, interrupt, val);
    fd8000005f6c:	17fffda5 	b	fd8000005600 <vgic_int_set_field>
    fd8000005f70:	d53ccb00 	mrs	x0, ich_hcr_el2
    fd8000005f74:	927f7800 	and	x0, x0, #0xfffffffe
    fd8000005f78:	d51ccb00 	msr	ich_hcr_el2, x0
}
    fd8000005f7c:	17ffffde 	b	fd8000005ef4 <vgic_ipi_handler+0x104>
        struct vcpu* target_vcpu = vgicr_id == vcpu->id ? vcpu : vm_get_vcpu(vcpu->vm, vgicr_id);
    fd8000005f80:	f944be68 	ldr	x8, [x19, #2424]
    fd8000005f84:	d360bc24 	ubfx	x4, x1, #32, #16
    fd8000005f88:	aa1303e3 	mov	x3, x19
    fd8000005f8c:	eb08009f 	cmp	x4, x8
    fd8000005f90:	54000100 	b.eq	fd8000005fb0 <vgic_ipi_handler+0x1c0>  // b.none
    if (vcpuid < vm->cpu_num) {
    fd8000005f94:	f94024a1 	ldr	x1, [x5, #72]
    return NULL;
    fd8000005f98:	d2800003 	mov	x3, #0x0                   	// #0
    if (vcpuid < vm->cpu_num) {
    fd8000005f9c:	eb01009f 	cmp	x4, x1
    fd8000005fa0:	54000082 	b.cs	fd8000005fb0 <vgic_ipi_handler+0x1c0>  // b.hs, b.nlast
        return &vm->vcpus[vcpuid];
    fd8000005fa4:	f94020a1 	ldr	x1, [x5, #64]
    fd8000005fa8:	d2813403 	mov	x3, #0x9a0                 	// #2464
    fd8000005fac:	9b030483 	madd	x3, x4, x3, x1
        return &target_vcpu->arch.vgic_priv.interrupts[int_id];
    fd8000005fb0:	52800704 	mov	w4, #0x38                  	// #56
    fd8000005fb4:	d2804801 	mov	x1, #0x240                 	// #576
    fd8000005fb8:	9ba404e1 	umaddl	x1, w7, w4, x1
    fd8000005fbc:	8b010061 	add	x1, x3, x1
    fd8000005fc0:	17ffffe3 	b	fd8000005f4c <vgic_ipi_handler+0x15c>
    fd8000005fc4:	52800701 	mov	w1, #0x38                  	// #56
    fd8000005fc8:	d2804800 	mov	x0, #0x240                 	// #576
    fd8000005fcc:	9ba100e7 	umaddl	x7, w7, w1, x0
    fd8000005fd0:	8b070273 	add	x19, x19, x7
            if (interrupt != NULL) {
    fd8000005fd4:	17ffffa2 	b	fd8000005e5c <vgic_ipi_handler+0x6c>
        interrupt->owner = vcpu;
    fd8000005fd8:	f9000660 	str	x0, [x19, #8]
    bool local = priv && (interrupt->phys.redist == vcpu->phys_id);
    fd8000005fdc:	b9402a62 	ldr	w2, [x19, #40]
    fd8000005fe0:	f9400e61 	ldr	x1, [x19, #24]
    fd8000005fe4:	71007c5f 	cmp	w2, #0x1f
    fd8000005fe8:	54000208 	b.hi	fd8000006028 <vgic_ipi_handler+0x238>  // b.pmore
                    if (vgic_int_vcpu_is_target(cpu()->vcpu, interrupt)) {
    fd8000005fec:	f944c002 	ldr	x2, [x0, #2432]
    fd8000005ff0:	eb02003f 	cmp	x1, x2
    fd8000005ff4:	54000240 	b.eq	fd800000603c <vgic_ipi_handler+0x24c>  // b.none
                    vgic_yield_ownership(cpu()->vcpu, interrupt);
    fd8000005ff8:	d2dfc001 	mov	x1, #0xfe0000000000        	// #279275953455104
    if ((GIC_VERSION == GICV2 && gic_is_priv(interrupt->id)) || !vgic_owns(vcpu, interrupt) ||
    fd8000005ffc:	f9400660 	ldr	x0, [x19, #8]
    fd8000006000:	f9402821 	ldr	x1, [x1, #80]
    fd8000006004:	eb00003f 	cmp	x1, x0
    fd8000006008:	54fff4c1 	b.ne	fd8000005ea0 <vgic_ipi_handler+0xb0>  // b.any
    fd800000600c:	3940c660 	ldrb	w0, [x19, #49]
    fd8000006010:	3707f480 	tbnz	w0, #0, fd8000005ea0 <vgic_ipi_handler+0xb0>
        interrupt->in_lr || (vgic_get_state(interrupt) & ACT)) {
    fd8000006014:	aa1303e0 	mov	x0, x19
    fd8000006018:	97fff9da 	bl	fd8000004780 <vgic_get_state>
    fd800000601c:	370ff420 	tbnz	w0, #1, fd8000005ea0 <vgic_ipi_handler+0xb0>
    interrupt->owner = NULL;
    fd8000006020:	f900067f 	str	xzr, [x19, #8]
    fd8000006024:	17ffff9f 	b	fd8000005ea0 <vgic_ipi_handler+0xb0>
SYSREG_GEN_ACCESSORS(mpidr_el1);
    fd8000006028:	d53800a2 	mrs	x2, mpidr_el1
    return (interrupt->route & GICD_IROUTER_IRM_BIT);
    fd800000602c:	f9400a63 	ldr	x3, [x19, #16]
    bool any = !priv && vgic_broadcast(vcpu, interrupt);
    fd8000006030:	37f80063 	tbnz	w3, #31, fd800000603c <vgic_ipi_handler+0x24c>
                    if (vgic_int_vcpu_is_target(cpu()->vcpu, interrupt)) {
    fd8000006034:	eb22203f 	cmp	x1, w2, uxth
    fd8000006038:	54fffe01 	b.ne	fd8000005ff8 <vgic_ipi_handler+0x208>  // b.any
                        vgic_add_lr(cpu()->vcpu, interrupt);
    fd800000603c:	aa1303e1 	mov	x1, x19
    fd8000006040:	97fffbd0 	bl	fd8000004f80 <vgic_add_lr>
    fd8000006044:	17ffffed 	b	fd8000005ff8 <vgic_ipi_handler+0x208>
    fd8000006048:	00010888 	.word	0x00010888
    fd800000604c:	0000fd80 	.word	0x0000fd80
    fd8000006050:	00012350 	.word	0x00012350
    fd8000006054:	0000fd80 	.word	0x0000fd80
    fd8000006058:	d503201f 	nop
    fd800000605c:	d503201f 	nop

0000fd8000006060 <vgic_handle_trapped_eoir>:
        spin_unlock(&interrupt->lock);
    }
}

void vgic_handle_trapped_eoir(struct vcpu* vcpu)
{
    fd8000006060:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    fd8000006064:	910003fd 	mov	x29, sp
    fd8000006068:	a90153f3 	stp	x19, x20, [sp, #16]
    fd800000606c:	aa0003f3 	mov	x19, x0
    fd8000006070:	f90013f5 	str	x21, [sp, #32]
SYSREG_GEN_ACCESSORS(ich_eisr_el2);
    fd8000006074:	d53ccb60 	mrs	x0, ich_eisr_el2
    uint64_t eisr = gich_get_eisr();
    int64_t lr_ind = bit64_ffs(eisr & BIT64_MASK(0, NUM_LRS));
    fd8000006078:	90000001 	adrp	x1, fd8000006000 <vgic_ipi_handler+0x210>
    fd800000607c:	f941a835 	ldr	x21, [x1, #848]
    fd8000006080:	d2800021 	mov	x1, #0x1                   	// #1
    fd8000006084:	f94002a4 	ldr	x4, [x21]
    fd8000006088:	51000482 	sub	w2, w4, #0x1
    fd800000608c:	9ac22022 	lsl	x2, x1, x2
    fd8000006090:	8b020042 	add	x2, x2, x2
    fd8000006094:	d1000443 	sub	x3, x2, #0x1
BIT_OPS_GEN(bit64, uint64_t, UINT64_C(1), BIT64_MASK);
    fd8000006098:	d2800002 	mov	x2, #0x0                   	// #0
    fd800000609c:	8a000063 	and	x3, x3, x0
    fd80000060a0:	37000103 	tbnz	w3, #0, fd80000060c0 <vgic_handle_trapped_eoir+0x60>
    fd80000060a4:	d503201f 	nop
    fd80000060a8:	91000442 	add	x2, x2, #0x1
    fd80000060ac:	8b010021 	add	x1, x1, x1
    fd80000060b0:	f101005f 	cmp	x2, #0x40
    fd80000060b4:	54000300 	b.eq	fd8000006114 <vgic_handle_trapped_eoir+0xb4>  // b.none
    fd80000060b8:	ea01007f 	tst	x3, x1
    fd80000060bc:	54ffff60 	b.eq	fd80000060a8 <vgic_handle_trapped_eoir+0x48>  // b.none
    while (lr_ind >= 0) {
    fd80000060c0:	b100045f 	cmn	x2, #0x1
    fd80000060c4:	54001280 	b.eq	fd8000006314 <vgic_handle_trapped_eoir+0x2b4>  // b.none
    if (i >= NUM_LRS) {
    fd80000060c8:	eb04005f 	cmp	x2, x4
    fd80000060cc:	540001c2 	b.cs	fd8000006104 <vgic_handle_trapped_eoir+0xa4>  // b.hs, b.nlast
    switch (i) {
    fd80000060d0:	f1003c5f 	cmp	x2, #0xf
    fd80000060d4:	54000068 	b.hi	fd80000060e0 <vgic_handle_trapped_eoir+0x80>  // b.pmore
    fd80000060d8:	71003c5f 	cmp	w2, #0xf
    fd80000060dc:	54000089 	b.ls	fd80000060ec <vgic_handle_trapped_eoir+0x8c>  // b.plast
    fd80000060e0:	d2804801 	mov	x1, #0x240                 	// #576
        return &target_vcpu->arch.vgic_priv.interrupts[int_id];
    fd80000060e4:	8b010261 	add	x1, x19, x1
        unsigned long lr_val = gich_read_lr(lr_ind);
        gich_write_lr(lr_ind, 0);

        struct vgic_int* interrupt = vgic_get_int(vcpu, GICH_LR_VID(lr_val), vcpu->id);
        if (interrupt == NULL) {
    fd80000060e8:	1400001e 	b	fd8000006160 <vgic_handle_trapped_eoir+0x100>
    fd80000060ec:	90000000 	adrp	x0, fd8000006000 <vgic_ipi_handler+0x210>
    fd80000060f0:	f941b000 	ldr	x0, [x0, #864]
    fd80000060f4:	78625800 	ldrh	w0, [x0, w2, uxtw #1]
    fd80000060f8:	10000061 	adr	x1, fd8000006104 <vgic_handle_trapped_eoir+0xa4>
    fd80000060fc:	8b20a820 	add	x0, x1, w0, sxth #2
    fd8000006100:	d61f0000 	br	x0
        ERROR("gic: trying to read inexistent list register");
    fd8000006104:	90000000 	adrp	x0, fd8000006000 <vgic_ipi_handler+0x210>
    fd8000006108:	f941ac00 	ldr	x0, [x0, #856]
    fd800000610c:	940017c5 	bl	fd800000c020 <console_printk>
    fd8000006110:	14000000 	b	fd8000006110 <vgic_handle_trapped_eoir+0xb0>
    fd8000006114:	f100003f 	cmp	x1, #0x0
    fd8000006118:	da9f1042 	csinv	x2, x2, xzr, ne	// ne = any
    fd800000611c:	17ffffe9 	b	fd80000060c0 <vgic_handle_trapped_eoir+0x60>
SYSREG_GEN_ACCESSORS(ich_lr14_el2);
    fd8000006120:	d53ccdc0 	mrs	x0, ich_lr14_el2
    fd8000006124:	d2800001 	mov	x1, #0x0                   	// #0
    fd8000006128:	d51ccdc1 	msr	ich_lr14_el2, x1
            break;
    fd800000612c:	d503201f 	nop
    if (int_id < GIC_CPU_PRIV) {
    fd8000006130:	71007c1f 	cmp	w0, #0x1f
        struct vgic_int* interrupt = vgic_get_int(vcpu, GICH_LR_VID(lr_val), vcpu->id);
    fd8000006134:	2a0003e1 	mov	w1, w0
    if (int_id < GIC_CPU_PRIV) {
    fd8000006138:	54000d69 	b.ls	fd80000062e4 <vgic_handle_trapped_eoir+0x284>  // b.plast
    } else if (int_id < vcpu->vm->arch.vgicd.int_num) {
    fd800000613c:	f944ca63 	ldr	x3, [x19, #2448]
    fd8000006140:	f9405465 	ldr	x5, [x3, #168]
    fd8000006144:	eb2040bf 	cmp	x5, w0, uxtw
    fd8000006148:	54fffc09 	b.ls	fd80000060c8 <vgic_handle_trapped_eoir+0x68>  // b.plast
        return &vcpu->vm->arch.vgicd.interrupts[int_id - GIC_CPU_PRIV];
    fd800000614c:	f9404c60 	ldr	x0, [x3, #152]
    fd8000006150:	51008021 	sub	w1, w1, #0x20
    fd8000006154:	52800703 	mov	w3, #0x38                  	// #56
    fd8000006158:	9ba30021 	umaddl	x1, w1, w3, x0
        if (interrupt == NULL) {
    fd800000615c:	b4fffb61 	cbz	x1, fd80000060c8 <vgic_handle_trapped_eoir+0x68>
            continue;
        }

        spin_lock(&interrupt->lock);
    fd8000006160:	91008034 	add	x20, x1, #0x20
    __asm__ volatile(
    fd8000006164:	91001284 	add	x4, x20, #0x4
    fd8000006168:	885ffe80 	ldaxr	w0, [x20]
    fd800000616c:	11000402 	add	w2, w0, #0x1
    fd8000006170:	88037e82 	stxr	w3, w2, [x20]
    fd8000006174:	35ffffa3 	cbnz	w3, fd8000006168 <vgic_handle_trapped_eoir+0x108>
    fd8000006178:	88dffc82 	ldar	w2, [x4]
    fd800000617c:	6b02001f 	cmp	w0, w2
    fd8000006180:	54000060 	b.eq	fd800000618c <vgic_handle_trapped_eoir+0x12c>  // b.none
    fd8000006184:	d503205f 	wfe
    fd8000006188:	17fffffc 	b	fd8000006178 <vgic_handle_trapped_eoir+0x118>
        interrupt->in_lr = false;
        if (interrupt->id < GIC_MAX_SGIS) {
    fd800000618c:	b9402820 	ldr	w0, [x1, #40]
        interrupt->in_lr = false;
    fd8000006190:	3900c43f 	strb	wzr, [x1, #49]
        if (interrupt->id < GIC_MAX_SGIS) {
    fd8000006194:	71003c1f 	cmp	w0, #0xf
    fd8000006198:	54000b08 	b.hi	fd80000062f8 <vgic_handle_trapped_eoir+0x298>  // b.pmore
            vgic_add_lr(vcpu, interrupt);
    fd800000619c:	aa1303e0 	mov	x0, x19
    fd80000061a0:	97fffb78 	bl	fd8000004f80 <vgic_add_lr>
    __asm__ volatile(
    fd80000061a4:	91001281 	add	x1, x20, #0x4
    fd80000061a8:	b9400020 	ldr	w0, [x1]
    fd80000061ac:	11000400 	add	w0, w0, #0x1
    fd80000061b0:	889ffc20 	stlr	w0, [x1]
    fd80000061b4:	d5033b9f 	dsb	ish
    fd80000061b8:	d503209f 	sev
SYSREG_GEN_ACCESSORS(ich_eisr_el2);
    fd80000061bc:	d53ccb60 	mrs	x0, ich_eisr_el2
        } else {
            vgic_yield_ownership(vcpu, interrupt);
        }
        spin_unlock(&interrupt->lock);
        eisr = gich_get_eisr();
        lr_ind = bit64_ffs(eisr & BIT64_MASK(0, NUM_LRS));
    fd80000061c0:	f94002a4 	ldr	x4, [x21]
    fd80000061c4:	d2800021 	mov	x1, #0x1                   	// #1
    fd80000061c8:	51000482 	sub	w2, w4, #0x1
    fd80000061cc:	9ac22022 	lsl	x2, x1, x2
    fd80000061d0:	8b020042 	add	x2, x2, x2
    fd80000061d4:	d1000443 	sub	x3, x2, #0x1
    fd80000061d8:	d2800002 	mov	x2, #0x0                   	// #0
    fd80000061dc:	8a000063 	and	x3, x3, x0
    fd80000061e0:	3707f743 	tbnz	w3, #0, fd80000060c8 <vgic_handle_trapped_eoir+0x68>
    fd80000061e4:	d503201f 	nop
    fd80000061e8:	91000442 	add	x2, x2, #0x1
    fd80000061ec:	8b010021 	add	x1, x1, x1
    fd80000061f0:	f101005f 	cmp	x2, #0x40
    fd80000061f4:	54000900 	b.eq	fd8000006314 <vgic_handle_trapped_eoir+0x2b4>  // b.none
    fd80000061f8:	ea01007f 	tst	x3, x1
    fd80000061fc:	54ffff60 	b.eq	fd80000061e8 <vgic_handle_trapped_eoir+0x188>  // b.none
    fd8000006200:	17ffffb0 	b	fd80000060c0 <vgic_handle_trapped_eoir+0x60>
SYSREG_GEN_ACCESSORS(ich_lr15_el2);
    fd8000006204:	d53ccde0 	mrs	x0, ich_lr15_el2
    fd8000006208:	d2800001 	mov	x1, #0x0                   	// #0
    fd800000620c:	d51ccde1 	msr	ich_lr15_el2, x1
    fd8000006210:	17ffffc8 	b	fd8000006130 <vgic_handle_trapped_eoir+0xd0>
SYSREG_GEN_ACCESSORS(ich_lr1_el2);
    fd8000006214:	d53ccc20 	mrs	x0, ich_lr1_el2
    fd8000006218:	d2800001 	mov	x1, #0x0                   	// #0
    fd800000621c:	d51ccc21 	msr	ich_lr1_el2, x1
    fd8000006220:	17ffffc4 	b	fd8000006130 <vgic_handle_trapped_eoir+0xd0>
SYSREG_GEN_ACCESSORS(ich_lr6_el2);
    fd8000006224:	d53cccc0 	mrs	x0, ich_lr6_el2
    fd8000006228:	d2800001 	mov	x1, #0x0                   	// #0
    fd800000622c:	d51cccc1 	msr	ich_lr6_el2, x1
    fd8000006230:	17ffffc0 	b	fd8000006130 <vgic_handle_trapped_eoir+0xd0>
SYSREG_GEN_ACCESSORS(ich_lr7_el2);
    fd8000006234:	d53ccce0 	mrs	x0, ich_lr7_el2
    fd8000006238:	d2800001 	mov	x1, #0x0                   	// #0
    fd800000623c:	d51ccce1 	msr	ich_lr7_el2, x1
    fd8000006240:	17ffffbc 	b	fd8000006130 <vgic_handle_trapped_eoir+0xd0>
SYSREG_GEN_ACCESSORS(ich_lr8_el2);
    fd8000006244:	d53ccd00 	mrs	x0, ich_lr8_el2
    fd8000006248:	d2800001 	mov	x1, #0x0                   	// #0
    fd800000624c:	d51ccd01 	msr	ich_lr8_el2, x1
    fd8000006250:	17ffffb8 	b	fd8000006130 <vgic_handle_trapped_eoir+0xd0>
SYSREG_GEN_ACCESSORS(ich_lr9_el2);
    fd8000006254:	d53ccd20 	mrs	x0, ich_lr9_el2
    fd8000006258:	d2800001 	mov	x1, #0x0                   	// #0
    fd800000625c:	d51ccd21 	msr	ich_lr9_el2, x1
    fd8000006260:	17ffffb4 	b	fd8000006130 <vgic_handle_trapped_eoir+0xd0>
SYSREG_GEN_ACCESSORS(ich_lr10_el2);
    fd8000006264:	d53ccd40 	mrs	x0, ich_lr10_el2
    fd8000006268:	d2800001 	mov	x1, #0x0                   	// #0
    fd800000626c:	d51ccd41 	msr	ich_lr10_el2, x1
    fd8000006270:	17ffffb0 	b	fd8000006130 <vgic_handle_trapped_eoir+0xd0>
SYSREG_GEN_ACCESSORS(ich_lr11_el2);
    fd8000006274:	d53ccd60 	mrs	x0, ich_lr11_el2
    fd8000006278:	d2800001 	mov	x1, #0x0                   	// #0
    fd800000627c:	d51ccd61 	msr	ich_lr11_el2, x1
    fd8000006280:	17ffffac 	b	fd8000006130 <vgic_handle_trapped_eoir+0xd0>
SYSREG_GEN_ACCESSORS(ich_lr12_el2);
    fd8000006284:	d53ccd80 	mrs	x0, ich_lr12_el2
    fd8000006288:	d2800001 	mov	x1, #0x0                   	// #0
    fd800000628c:	d51ccd81 	msr	ich_lr12_el2, x1
    fd8000006290:	17ffffa8 	b	fd8000006130 <vgic_handle_trapped_eoir+0xd0>
SYSREG_GEN_ACCESSORS(ich_lr13_el2);
    fd8000006294:	d53ccda0 	mrs	x0, ich_lr13_el2
    fd8000006298:	d2800001 	mov	x1, #0x0                   	// #0
    fd800000629c:	d51ccda1 	msr	ich_lr13_el2, x1
    fd80000062a0:	17ffffa4 	b	fd8000006130 <vgic_handle_trapped_eoir+0xd0>
SYSREG_GEN_ACCESSORS(ich_lr2_el2);
    fd80000062a4:	d53ccc40 	mrs	x0, ich_lr2_el2
    fd80000062a8:	d2800001 	mov	x1, #0x0                   	// #0
    fd80000062ac:	d51ccc41 	msr	ich_lr2_el2, x1
    fd80000062b0:	17ffffa0 	b	fd8000006130 <vgic_handle_trapped_eoir+0xd0>
SYSREG_GEN_ACCESSORS(ich_lr3_el2);
    fd80000062b4:	d53ccc60 	mrs	x0, ich_lr3_el2
    fd80000062b8:	d2800001 	mov	x1, #0x0                   	// #0
    fd80000062bc:	d51ccc61 	msr	ich_lr3_el2, x1
    fd80000062c0:	17ffff9c 	b	fd8000006130 <vgic_handle_trapped_eoir+0xd0>
SYSREG_GEN_ACCESSORS(ich_lr4_el2);
    fd80000062c4:	d53ccc80 	mrs	x0, ich_lr4_el2
    fd80000062c8:	d2800001 	mov	x1, #0x0                   	// #0
    fd80000062cc:	d51ccc81 	msr	ich_lr4_el2, x1
    fd80000062d0:	17ffff98 	b	fd8000006130 <vgic_handle_trapped_eoir+0xd0>
SYSREG_GEN_ACCESSORS(ich_lr5_el2);
    fd80000062d4:	d53ccca0 	mrs	x0, ich_lr5_el2
    fd80000062d8:	d2800001 	mov	x1, #0x0                   	// #0
    fd80000062dc:	d51ccca1 	msr	ich_lr5_el2, x1
    fd80000062e0:	17ffff94 	b	fd8000006130 <vgic_handle_trapped_eoir+0xd0>
    fd80000062e4:	52800702 	mov	w2, #0x38                  	// #56
    fd80000062e8:	d2804800 	mov	x0, #0x240                 	// #576
    fd80000062ec:	9ba20021 	umaddl	x1, w1, w2, x0
        return &target_vcpu->arch.vgic_priv.interrupts[int_id];
    fd80000062f0:	8b010261 	add	x1, x19, x1
        if (interrupt == NULL) {
    fd80000062f4:	17ffff9b 	b	fd8000006160 <vgic_handle_trapped_eoir+0x100>
    if ((GIC_VERSION == GICV2 && gic_is_priv(interrupt->id)) || !vgic_owns(vcpu, interrupt) ||
    fd80000062f8:	f9400420 	ldr	x0, [x1, #8]
    fd80000062fc:	eb00027f 	cmp	x19, x0
    fd8000006300:	54fff521 	b.ne	fd80000061a4 <vgic_handle_trapped_eoir+0x144>  // b.any
        interrupt->in_lr || (vgic_get_state(interrupt) & ACT)) {
    fd8000006304:	3940b020 	ldrb	w0, [x1, #44]
    fd8000006308:	370ff4e0 	tbnz	w0, #1, fd80000061a4 <vgic_handle_trapped_eoir+0x144>
    interrupt->owner = NULL;
    fd800000630c:	f900043f 	str	xzr, [x1, #8]
    fd8000006310:	17ffffa5 	b	fd80000061a4 <vgic_handle_trapped_eoir+0x144>
    }
}
    fd8000006314:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd8000006318:	f94013f5 	ldr	x21, [sp, #32]
    fd800000631c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    fd8000006320:	d65f03c0 	ret
SYSREG_GEN_ACCESSORS(ich_lr0_el2);
    fd8000006324:	d2800005 	mov	x5, #0x0                   	// #0
    fd8000006328:	d53ccc00 	mrs	x0, ich_lr0_el2
    fd800000632c:	d51ccc05 	msr	ich_lr0_el2, x5
    if (int_id < GIC_CPU_PRIV) {
    fd8000006330:	71007c1f 	cmp	w0, #0x1f
        struct vgic_int* interrupt = vgic_get_int(vcpu, GICH_LR_VID(lr_val), vcpu->id);
    fd8000006334:	2a0003e1 	mov	w1, w0
    if (int_id < GIC_CPU_PRIV) {
    fd8000006338:	54fffd69 	b.ls	fd80000062e4 <vgic_handle_trapped_eoir+0x284>  // b.plast
    } else if (int_id < vcpu->vm->arch.vgicd.int_num) {
    fd800000633c:	f944ca63 	ldr	x3, [x19, #2448]
    fd8000006340:	f9405466 	ldr	x6, [x3, #168]
    fd8000006344:	eb2040df 	cmp	x6, w0, uxtw
    fd8000006348:	54fff028 	b.hi	fd800000614c <vgic_handle_trapped_eoir+0xec>  // b.pmore
    fd800000634c:	17fffff7 	b	fd8000006328 <vgic_handle_trapped_eoir+0x2c8>
    fd8000006350:	00013088 	.word	0x00013088
    fd8000006354:	0000fd80 	.word	0x0000fd80
    fd8000006358:	000107d8 	.word	0x000107d8
    fd800000635c:	0000fd80 	.word	0x0000fd80
    fd8000006360:	000111b0 	.word	0x000111b0
    fd8000006364:	0000fd80 	.word	0x0000fd80
    fd8000006368:	d503201f 	nop
    fd800000636c:	d503201f 	nop

0000fd8000006370 <gic_maintenance_handler>:

void gic_maintenance_handler(irqid_t irq_id)
{
    fd8000006370:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
    fd8000006374:	910003fd 	mov	x29, sp
    fd8000006378:	a9025bf5 	stp	x21, x22, [sp, #32]
SYSREG_GEN_ACCESSORS(ich_misr_el2);
    fd800000637c:	d53ccb55 	mrs	x21, ich_misr_el2
    uint32_t misr = gich_get_misr();

    if (misr & GICH_MISR_EOI) {
    fd8000006380:	37001fd5 	tbnz	w21, #0, fd8000006778 <gic_maintenance_handler+0x408>
        vgic_handle_trapped_eoir(cpu()->vcpu);
    }

    if (misr & (GICH_MISR_NP | GICH_MISR_U)) {
    fd8000006384:	52800140 	mov	w0, #0xa                   	// #10
    fd8000006388:	6a15001f 	tst	w0, w21
    fd800000638c:	54000841 	b.ne	fd8000006494 <gic_maintenance_handler+0x124>  // b.any
        vgic_refill_lrs(cpu()->vcpu, !!(misr & GICH_MISR_NP));
    }

    if (misr & GICH_MISR_LRPEN) {
    fd8000006390:	361007d5 	tbz	w21, #2, fd8000006488 <gic_maintenance_handler+0x118>
    fd8000006394:	a90363f7 	stp	x23, x24, [sp, #48]
SYSREG_GEN_ACCESSORS(ich_hcr_el2);
    fd8000006398:	d53ccb00 	mrs	x0, ich_hcr_el2
        uint32_t hcr_el2 = gich_get_hcr();
        while (hcr_el2 & GICH_HCR_EOICount_MASK) {
    fd800000639c:	12bf0017 	mov	w23, #0x7ffffff             	// #134217727
    return sysreg_ich_hcr_el2_read();
    fd80000063a0:	2a0003f5 	mov	w21, w0
    fd80000063a4:	6b17001f 	cmp	w0, w23
    fd80000063a8:	54003989 	b.ls	fd8000006ad8 <gic_maintenance_handler+0x768>  // b.plast
            vgic_eoir_highest_spilled_active(cpu()->vcpu);
            hcr_el2 -= (1U << GICH_HCR_EOICount_OFF);
    fd80000063ac:	52bf0018 	mov	w24, #0xf8000000            	// #-134217728
    fd80000063b0:	a90153f3 	stp	x19, x20, [sp, #16]
    fd80000063b4:	9101a3f4 	add	x20, sp, #0x68
    fd80000063b8:	a9046bf9 	stp	x25, x26, [sp, #64]
            vgic_eoir_highest_spilled_active(cpu()->vcpu);
    fd80000063bc:	d2dfc019 	mov	x25, #0xfe0000000000        	// #279275953455104
    fd80000063c0:	1400000e 	b	fd80000063f8 <gic_maintenance_handler+0x88>
    } else if (interrupt->owner == NULL) {
    fd80000063c4:	b4001d61 	cbz	x1, fd8000006770 <gic_maintenance_handler+0x400>
    fd80000063c8:	91001261 	add	x1, x19, #0x4
    fd80000063cc:	b9400020 	ldr	w0, [x1]
    fd80000063d0:	11000400 	add	w0, w0, #0x1
    fd80000063d4:	889ffc20 	stlr	w0, [x1]
    fd80000063d8:	d5033b9f 	dsb	ish
    fd80000063dc:	d503209f 	sev
    sysreg_ich_hcr_el2_write(hcr);
    fd80000063e0:	0b1802a0 	add	w0, w21, w24
    fd80000063e4:	d51ccb00 	msr	ich_hcr_el2, x0
    fd80000063e8:	d53ccb00 	mrs	x0, ich_hcr_el2
        while (hcr_el2 & GICH_HCR_EOICount_MASK) {
    fd80000063ec:	6b17001f 	cmp	w0, w23
    return sysreg_ich_hcr_el2_read();
    fd80000063f0:	2a0003f5 	mov	w21, w0
    fd80000063f4:	54000449 	b.ls	fd800000647c <gic_maintenance_handler+0x10c>  // b.plast
            vgic_eoir_highest_spilled_active(cpu()->vcpu);
    fd80000063f8:	f9402b36 	ldr	x22, [x25, #80]
    struct vgic_int* interrupt = vgic_highest_prio_spilled(vcpu, ACT, &list);
    fd80000063fc:	aa1403e2 	mov	x2, x20
    fd8000006400:	52800041 	mov	w1, #0x2                   	// #2
    struct list* list = NULL;
    fd8000006404:	f90037ff 	str	xzr, [sp, #104]
    struct vgic_int* interrupt = vgic_highest_prio_spilled(vcpu, ACT, &list);
    fd8000006408:	aa1603e0 	mov	x0, x22
    fd800000640c:	97fff86d 	bl	fd80000045c0 <vgic_highest_prio_spilled.constprop.0>
    if (interrupt != NULL) {
    fd8000006410:	b4fffe80 	cbz	x0, fd80000063e0 <gic_maintenance_handler+0x70>
        spin_lock(&interrupt->lock);
    fd8000006414:	91008013 	add	x19, x0, #0x20
    __asm__ volatile(
    fd8000006418:	91001264 	add	x4, x19, #0x4
    fd800000641c:	885ffe61 	ldaxr	w1, [x19]
    fd8000006420:	11000422 	add	w2, w1, #0x1
    fd8000006424:	88037e62 	stxr	w3, w2, [x19]
    fd8000006428:	35ffffa3 	cbnz	w3, fd800000641c <gic_maintenance_handler+0xac>
    fd800000642c:	88dffc82 	ldar	w2, [x4]
    fd8000006430:	6b02003f 	cmp	w1, w2
    fd8000006434:	54000060 	b.eq	fd8000006440 <gic_maintenance_handler+0xd0>  // b.none
    fd8000006438:	d503205f 	wfe
    fd800000643c:	17fffffc 	b	fd800000642c <gic_maintenance_handler+0xbc>
    if (interrupt->owner == vcpu) {
    fd8000006440:	f9400401 	ldr	x1, [x0, #8]
    fd8000006444:	eb0102df 	cmp	x22, x1
    fd8000006448:	54fffbe1 	b.ne	fd80000063c4 <gic_maintenance_handler+0x54>  // b.any
            interrupt->state &= ~ACT;
    fd800000644c:	3940b001 	ldrb	w1, [x0, #44]
    return !(interrupt->id < GIC_MAX_SGIS) && interrupt->hw;
    fd8000006450:	b9402802 	ldr	w2, [x0, #40]
            interrupt->state &= ~ACT;
    fd8000006454:	121e7823 	and	w3, w1, #0xfffffffd
    fd8000006458:	3900b003 	strb	w3, [x0, #44]
    return !(interrupt->id < GIC_MAX_SGIS) && interrupt->hw;
    fd800000645c:	71003c5f 	cmp	w2, #0xf
    fd8000006460:	540012c9 	b.ls	fd80000066b8 <gic_maintenance_handler+0x348>  // b.plast
    fd8000006464:	3940c003 	ldrb	w3, [x0, #48]
    fd8000006468:	36001283 	tbz	w3, #0, fd80000066b8 <gic_maintenance_handler+0x348>
                gic_set_act(interrupt->id, false);
    fd800000646c:	2a0203e0 	mov	w0, w2
    fd8000006470:	52800001 	mov	w1, #0x0                   	// #0
    fd8000006474:	94000963 	bl	fd8000008a00 <gic_set_act>
    fd8000006478:	17ffffd4 	b	fd80000063c8 <gic_maintenance_handler+0x58>
    fd800000647c:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd8000006480:	a94363f7 	ldp	x23, x24, [sp, #48]
    fd8000006484:	a9446bf9 	ldp	x25, x26, [sp, #64]
            gich_set_hcr(hcr_el2);
            hcr_el2 = gich_get_hcr();
        }
    }
}
    fd8000006488:	a9425bf5 	ldp	x21, x22, [sp, #32]
    fd800000648c:	a8c77bfd 	ldp	x29, x30, [sp], #112
    fd8000006490:	d65f03c0 	ret
        vgic_refill_lrs(cpu()->vcpu, !!(misr & GICH_MISR_NP));
    fd8000006494:	d2dfc000 	mov	x0, #0xfe0000000000        	// #279275953455104
    fd8000006498:	121d02a2 	and	w2, w21, #0x8
    fd800000649c:	a90153f3 	stp	x19, x20, [sp, #16]
    fd80000064a0:	a90363f7 	stp	x23, x24, [sp, #48]
    fd80000064a4:	a9046bf9 	stp	x25, x26, [sp, #64]
    fd80000064a8:	f940281a 	ldr	x26, [x0, #80]
SYSREG_GEN_ACCESSORS(ich_elrsr_el2);
    fd80000064ac:	a90573fb 	stp	x27, x28, [sp, #80]
    fd80000064b0:	d53ccba3 	mrs	x3, ich_elrsr_el2
    ssize_t lr_ind = bit64_ffs(elrsr & BIT64_MASK(0, NUM_LRS));
    fd80000064b4:	90000000 	adrp	x0, fd8000006000 <vgic_ipi_handler+0x210>
    fd80000064b8:	f9458816 	ldr	x22, [x0, #2832]
    fd80000064bc:	d2800020 	mov	x0, #0x1                   	// #1
    fd80000064c0:	d2800013 	mov	x19, #0x0                   	// #0
    fd80000064c4:	f94002c1 	ldr	x1, [x22]
    fd80000064c8:	51000421 	sub	w1, w1, #0x1
    fd80000064cc:	9ac12001 	lsl	x1, x0, x1
    fd80000064d0:	8b010021 	add	x1, x1, x1
    fd80000064d4:	d1000421 	sub	x1, x1, #0x1
    fd80000064d8:	8a030021 	and	x1, x1, x3
    fd80000064dc:	370000e1 	tbnz	w1, #0, fd80000064f8 <gic_maintenance_handler+0x188>
    fd80000064e0:	91000673 	add	x19, x19, #0x1
    fd80000064e4:	8b000000 	add	x0, x0, x0
    fd80000064e8:	f101027f 	cmp	x19, #0x40
    fd80000064ec:	54001e40 	b.eq	fd80000068b4 <gic_maintenance_handler+0x544>  // b.none
    fd80000064f0:	ea00003f 	tst	x1, x0
    fd80000064f4:	54ffff60 	b.eq	fd80000064e0 <gic_maintenance_handler+0x170>  // b.none
    spin_lock(&vcpu->vm->arch.vgic_spilled_lock);
    fd80000064f8:	f944cb40 	ldr	x0, [x26, #2448]
    unsigned flags = npie ? PEND : ACT | PEND;
    fd80000064fc:	7100005f 	cmp	w2, #0x0
    fd8000006500:	52800037 	mov	w23, #0x1                   	// #1
    fd8000006504:	5280007b 	mov	w27, #0x3                   	// #3
    fd8000006508:	91038003 	add	x3, x0, #0xe0
    fd800000650c:	1a97037b 	csel	w27, w27, w23, eq	// eq = none
    fd8000006510:	91039004 	add	x4, x0, #0xe4
    fd8000006514:	885ffc60 	ldaxr	w0, [x3]
    fd8000006518:	11000401 	add	w1, w0, #0x1
    fd800000651c:	88027c61 	stxr	w2, w1, [x3]
    fd8000006520:	35ffffa2 	cbnz	w2, fd8000006514 <gic_maintenance_handler+0x1a4>
    fd8000006524:	88dffc81 	ldar	w1, [x4]
    fd8000006528:	6b01001f 	cmp	w0, w1
    fd800000652c:	54000060 	b.eq	fd8000006538 <gic_maintenance_handler+0x1c8>  // b.none
    fd8000006530:	d503205f 	wfe
    fd8000006534:	17fffffc 	b	fd8000006524 <gic_maintenance_handler+0x1b4>
    while (lr_ind >= 0) {
    fd8000006538:	b100067f 	cmn	x19, #0x1
    fd800000653c:	54000540 	b.eq	fd80000065e4 <gic_maintenance_handler+0x274>  // b.none
    fd8000006540:	9101a3f4 	add	x20, sp, #0x68
        lr_ind = bit64_ffs(elrsr & BIT64_MASK(0, NUM_LRS));
    fd8000006544:	d2800038 	mov	x24, #0x1                   	// #1
        struct vgic_int* irq = vgic_highest_prio_spilled(vcpu, flags, &list);
    fd8000006548:	aa1403e2 	mov	x2, x20
    fd800000654c:	2a1b03e1 	mov	w1, w27
    fd8000006550:	aa1a03e0 	mov	x0, x26
        struct list* list = NULL;
    fd8000006554:	f90037ff 	str	xzr, [sp, #104]
        struct vgic_int* irq = vgic_highest_prio_spilled(vcpu, flags, &list);
    fd8000006558:	97fff81a 	bl	fd80000045c0 <vgic_highest_prio_spilled.constprop.0>
    fd800000655c:	aa0003f9 	mov	x25, x0
        if (irq != NULL) {
    fd8000006560:	b40003a0 	cbz	x0, fd80000065d4 <gic_maintenance_handler+0x264>
            spin_lock(&irq->lock);
    fd8000006564:	9100801c 	add	x28, x0, #0x20
    fd8000006568:	91001383 	add	x3, x28, #0x4
    fd800000656c:	885fff80 	ldaxr	w0, [x28]
    fd8000006570:	11000401 	add	w1, w0, #0x1
    fd8000006574:	88027f81 	stxr	w2, w1, [x28]
    fd8000006578:	35ffffa2 	cbnz	w2, fd800000656c <gic_maintenance_handler+0x1fc>
    fd800000657c:	88dffc61 	ldar	w1, [x3]
    fd8000006580:	6b01001f 	cmp	w0, w1
    fd8000006584:	54000060 	b.eq	fd8000006590 <gic_maintenance_handler+0x220>  // b.none
    fd8000006588:	d503205f 	wfe
    fd800000658c:	17fffffc 	b	fd800000657c <gic_maintenance_handler+0x20c>
    if (interrupt->owner == vcpu) {
    fd8000006590:	f9400720 	ldr	x0, [x25, #8]
    fd8000006594:	eb00035f 	cmp	x26, x0
    fd8000006598:	54000420 	b.eq	fd800000661c <gic_maintenance_handler+0x2ac>  // b.none
    } else if (interrupt->owner == NULL) {
    fd800000659c:	b40003e0 	cbz	x0, fd8000006618 <gic_maintenance_handler+0x2a8>
    __asm__ volatile(
    fd80000065a0:	91001381 	add	x1, x28, #0x4
    fd80000065a4:	b9400020 	ldr	w0, [x1]
    fd80000065a8:	11000400 	add	w0, w0, #0x1
    fd80000065ac:	889ffc20 	stlr	w0, [x1]
    fd80000065b0:	d5033b9f 	dsb	ish
    fd80000065b4:	d503209f 	sev
        struct vgic_int* irq = vgic_highest_prio_spilled(vcpu, flags, &list);
    fd80000065b8:	aa1403e2 	mov	x2, x20
    fd80000065bc:	2a1b03e1 	mov	w1, w27
    fd80000065c0:	aa1a03e0 	mov	x0, x26
        struct list* list = NULL;
    fd80000065c4:	f90037ff 	str	xzr, [sp, #104]
        struct vgic_int* irq = vgic_highest_prio_spilled(vcpu, flags, &list);
    fd80000065c8:	97fff7fe 	bl	fd80000045c0 <vgic_highest_prio_spilled.constprop.0>
    fd80000065cc:	aa0003f9 	mov	x25, x0
        if (irq != NULL) {
    fd80000065d0:	b5fffca0 	cbnz	x0, fd8000006564 <gic_maintenance_handler+0x1f4>
SYSREG_GEN_ACCESSORS(ich_hcr_el2);
    fd80000065d4:	d53ccb00 	mrs	x0, ich_hcr_el2
            gich_set_hcr(hcr & ~(GICH_HCR_NPIE_BIT | GICH_HCR_UIE_BIT));
    fd80000065d8:	12800141 	mov	w1, #0xfffffff5            	// #-11
    fd80000065dc:	0a010000 	and	w0, w0, w1
    fd80000065e0:	d51ccb00 	msr	ich_hcr_el2, x0
    fd80000065e4:	f944cb40 	ldr	x0, [x26, #2448]
    fd80000065e8:	91039001 	add	x1, x0, #0xe4
    fd80000065ec:	b9400020 	ldr	w0, [x1]
    fd80000065f0:	11000400 	add	w0, w0, #0x1
    fd80000065f4:	889ffc20 	stlr	w0, [x1]
    fd80000065f8:	d5033b9f 	dsb	ish
    fd80000065fc:	d503209f 	sev
    fd8000006600:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd8000006604:	a94363f7 	ldp	x23, x24, [sp, #48]
    fd8000006608:	a9446bf9 	ldp	x25, x26, [sp, #64]
    fd800000660c:	a94573fb 	ldp	x27, x28, [sp, #80]
    if (misr & GICH_MISR_LRPEN) {
    fd8000006610:	3617f3d5 	tbz	w21, #2, fd8000006488 <gic_maintenance_handler+0x118>
    fd8000006614:	17ffff60 	b	fd8000006394 <gic_maintenance_handler+0x24>
        interrupt->owner = vcpu;
    fd8000006618:	f900073a 	str	x26, [x25, #8]
                list_rm(list, &irq->node);
    fd800000661c:	f94037e2 	ldr	x2, [sp, #104]
    return (list->head == NULL);
}

static inline bool list_rm(struct list* list, node_t* node)
{
    if (list != NULL && node != NULL) {
    fd8000006620:	b5000fc2 	cbnz	x2, fd8000006818 <gic_maintenance_handler+0x4a8>
    irqid_t prev_int_id = vcpu->arch.vgic_priv.curr_lrs[lr_ind];
    fd8000006624:	8b130b5b 	add	x27, x26, x19, lsl #2
    if ((prev_int_id != interrupt->id) && !gic_is_priv(prev_int_id)) {
    fd8000006628:	b9402b21 	ldr	w1, [x25, #40]
    irqid_t prev_int_id = vcpu->arch.vgic_priv.curr_lrs[lr_ind];
    fd800000662c:	b9414360 	ldr	w0, [x27, #320]
    if ((prev_int_id != interrupt->id) && !gic_is_priv(prev_int_id)) {
    fd8000006630:	6b00003f 	cmp	w1, w0
    fd8000006634:	7a5f1800 	ccmp	w0, #0x1f, #0x0, ne	// ne = any
    fd8000006638:	54000b48 	b.hi	fd80000067a0 <gic_maintenance_handler+0x430>  // b.pmore
    unsigned state = vgic_get_state(interrupt);
    fd800000663c:	aa1903e0 	mov	x0, x25
    fd8000006640:	97fff850 	bl	fd8000004780 <vgic_get_state>
    gic_lr_t lr = ((interrupt->id << GICH_LR_VID_OFF) & GICH_LR_VID_MSK);
    fd8000006644:	b9402b22 	ldr	w2, [x25, #40]
    unsigned state = vgic_get_state(interrupt);
    fd8000006648:	12001c00 	and	w0, w0, #0xff
    lr |= (((gic_lr_t)interrupt->prio << GICH_LR_PRIO_OFF) & GICH_LR_PRIO_MSK) | GICH_LR_GRP_BIT;
    fd800000664c:	3940b721 	ldrb	w1, [x25, #45]
    gic_lr_t lr = ((interrupt->id << GICH_LR_VID_OFF) & GICH_LR_VID_MSK);
    fd8000006650:	2a0203e3 	mov	w3, w2
    return !(interrupt->id < GIC_MAX_SGIS) && interrupt->hw;
    fd8000006654:	71003c5f 	cmp	w2, #0xf
    lr |= (((gic_lr_t)interrupt->prio << GICH_LR_PRIO_OFF) & GICH_LR_PRIO_MSK) | GICH_LR_GRP_BIT;
    fd8000006658:	aa01c061 	orr	x1, x3, x1, lsl #48
    fd800000665c:	b2440024 	orr	x4, x1, #0x1000000000000000
    return !(interrupt->id < GIC_MAX_SGIS) && interrupt->hw;
    fd8000006660:	54000409 	b.ls	fd80000066e0 <gic_maintenance_handler+0x370>  // b.plast
    fd8000006664:	3940c325 	ldrb	w5, [x25, #48]
    fd8000006668:	36000325 	tbz	w5, #0, fd80000066cc <gic_maintenance_handler+0x35c>
        lr |= ((gic_lr_t)interrupt->id << GICH_LR_PID_OFF) & GICH_LR_PID_MSK;
    fd800000666c:	d3602463 	ubfiz	x3, x3, #32, #10
            lr |= ((gic_lr_t)state << GICH_LR_STATE_OFF) & GICH_LR_STATE_MSK;
    fd8000006670:	71000c1f 	cmp	w0, #0x3
    fd8000006674:	aa010061 	orr	x1, x3, x1
    fd8000006678:	d2f60003 	mov	x3, #0xb000000000000000    	// #-5764607523034234880
    fd800000667c:	aa00f820 	orr	x0, x1, x0, lsl #62
    fd8000006680:	aa030021 	orr	x1, x1, x3
    fd8000006684:	b2440400 	orr	x0, x0, #0x3000000000000000
    interrupt->state = 0;
    fd8000006688:	3900b33f 	strb	wzr, [x25, #44]
            lr |= ((gic_lr_t)state << GICH_LR_STATE_OFF) & GICH_LR_STATE_MSK;
    fd800000668c:	9a800020 	csel	x0, x1, x0, eq	// eq = none
    interrupt->lr = lr_ind;
    fd8000006690:	3900bf33 	strb	w19, [x25, #47]
    if (i >= NUM_LRS) {
    fd8000006694:	f94002c1 	ldr	x1, [x22]
    interrupt->in_lr = true;
    fd8000006698:	3900c737 	strb	w23, [x25, #49]
    vcpu->arch.vgic_priv.curr_lrs[lr_ind] = interrupt->id;
    fd800000669c:	b9014362 	str	w2, [x27, #320]
    fd80000066a0:	eb01027f 	cmp	x19, x1
    fd80000066a4:	540002e3 	b.cc	fd8000006700 <gic_maintenance_handler+0x390>  // b.lo, b.ul, b.last
        ERROR("gic: trying to write inexistent list register");
    fd80000066a8:	90000000 	adrp	x0, fd8000006000 <vgic_ipi_handler+0x210>
    fd80000066ac:	f9458c00 	ldr	x0, [x0, #2840]
    fd80000066b0:	9400165c 	bl	fd800000c020 <console_printk>
    fd80000066b4:	14000000 	b	fd80000066b4 <gic_maintenance_handler+0x344>
                if (interrupt->state & PEND) {
    fd80000066b8:	3607e881 	tbz	w1, #0, fd80000063c8 <gic_maintenance_handler+0x58>
                    vgic_add_lr(vcpu, interrupt);
    fd80000066bc:	aa0003e1 	mov	x1, x0
    fd80000066c0:	aa1603e0 	mov	x0, x22
    fd80000066c4:	97fffa2f 	bl	fd8000004f80 <vgic_add_lr>
    fd80000066c8:	17ffff40 	b	fd80000063c8 <gic_maintenance_handler+0x58>
            lr |= GICH_LR_EOI_BIT;
    fd80000066cc:	d2c04003 	mov	x3, #0x20000000000         	// #2199023255552
    fd80000066d0:	71007c5f 	cmp	w2, #0x1f
    fd80000066d4:	f2e20003 	movk	x3, #0x1000, lsl #48
    fd80000066d8:	aa030021 	orr	x1, x1, x3
    fd80000066dc:	9a848024 	csel	x4, x1, x4, hi	// hi = pmore
    if (i >= NUM_LRS) {
    fd80000066e0:	f94002c1 	ldr	x1, [x22]
    interrupt->state = 0;
    fd80000066e4:	3900b33f 	strb	wzr, [x25, #44]
    interrupt->lr = lr_ind;
    fd80000066e8:	3900bf33 	strb	w19, [x25, #47]
        lr |= ((gic_lr_t)state << GICH_LR_STATE_OFF) & GICH_LR_STATE_MSK;
    fd80000066ec:	aa00f880 	orr	x0, x4, x0, lsl #62
    interrupt->in_lr = true;
    fd80000066f0:	3900c737 	strb	w23, [x25, #49]
    fd80000066f4:	eb01027f 	cmp	x19, x1
    vcpu->arch.vgic_priv.curr_lrs[lr_ind] = interrupt->id;
    fd80000066f8:	b9014362 	str	w2, [x27, #320]
    fd80000066fc:	54fffd62 	b.cs	fd80000066a8 <gic_maintenance_handler+0x338>  // b.hs, b.nlast
    switch (i) {
    fd8000006700:	f1003e7f 	cmp	x19, #0xf
    fd8000006704:	54000068 	b.hi	fd8000006710 <gic_maintenance_handler+0x3a0>  // b.pmore
    fd8000006708:	71003e7f 	cmp	w19, #0xf
    fd800000670c:	540003e9 	b.ls	fd8000006788 <gic_maintenance_handler+0x418>  // b.plast
    fd8000006710:	91001381 	add	x1, x28, #0x4
    fd8000006714:	b9400020 	ldr	w0, [x1]
    fd8000006718:	11000400 	add	w0, w0, #0x1
    fd800000671c:	889ffc20 	stlr	w0, [x1]
    fd8000006720:	d5033b9f 	dsb	ish
    fd8000006724:	d503209f 	sev
SYSREG_GEN_ACCESSORS(ich_elrsr_el2);
    fd8000006728:	d53ccba2 	mrs	x2, ich_elrsr_el2
        lr_ind = bit64_ffs(elrsr & BIT64_MASK(0, NUM_LRS));
    fd800000672c:	f94002c0 	ldr	x0, [x22]
    fd8000006730:	d2800013 	mov	x19, #0x0                   	// #0
    fd8000006734:	51000400 	sub	w0, w0, #0x1
    fd8000006738:	9ac02300 	lsl	x0, x24, x0
    fd800000673c:	8b000000 	add	x0, x0, x0
    fd8000006740:	d1000401 	sub	x1, x0, #0x1
    fd8000006744:	8a020021 	and	x1, x1, x2
    fd8000006748:	37000101 	tbnz	w1, #0, fd8000006768 <gic_maintenance_handler+0x3f8>
    fd800000674c:	d2800020 	mov	x0, #0x1                   	// #1
    fd8000006750:	91000673 	add	x19, x19, #0x1
    fd8000006754:	8b000000 	add	x0, x0, x0
    fd8000006758:	f101027f 	cmp	x19, #0x40
    fd800000675c:	54fff440 	b.eq	fd80000065e4 <gic_maintenance_handler+0x274>  // b.none
    fd8000006760:	ea00003f 	tst	x1, x0
    fd8000006764:	54ffff60 	b.eq	fd8000006750 <gic_maintenance_handler+0x3e0>  // b.none
        flags = ACT | PEND;
    fd8000006768:	5280007b 	mov	w27, #0x3                   	// #3
    fd800000676c:	17ffff77 	b	fd8000006548 <gic_maintenance_handler+0x1d8>
        interrupt->owner = vcpu;
    fd8000006770:	f9000416 	str	x22, [x0, #8]
        ret = true;
    fd8000006774:	17ffff36 	b	fd800000644c <gic_maintenance_handler+0xdc>
        vgic_handle_trapped_eoir(cpu()->vcpu);
    fd8000006778:	d2dfc000 	mov	x0, #0xfe0000000000        	// #279275953455104
    fd800000677c:	f9402800 	ldr	x0, [x0, #80]
    fd8000006780:	97fffe38 	bl	fd8000006060 <vgic_handle_trapped_eoir>
    fd8000006784:	17ffff00 	b	fd8000006384 <gic_maintenance_handler+0x14>
    fd8000006788:	90000001 	adrp	x1, fd8000006000 <vgic_ipi_handler+0x210>
    fd800000678c:	f9459021 	ldr	x1, [x1, #2848]
    fd8000006790:	78735821 	ldrh	w1, [x1, w19, uxtw #1]
    fd8000006794:	10000073 	adr	x19, fd80000067a0 <gic_maintenance_handler+0x430>
    fd8000006798:	8b21aa61 	add	x1, x19, w1, sxth #2
    fd800000679c:	d61f0020 	br	x1
    } else if (int_id < vcpu->vm->arch.vgicd.int_num) {
    fd80000067a0:	f944cb41 	ldr	x1, [x26, #2448]
    fd80000067a4:	f9405422 	ldr	x2, [x1, #168]
    fd80000067a8:	eb20405f 	cmp	x2, w0, uxtw
    fd80000067ac:	54fff489 	b.ls	fd800000663c <gic_maintenance_handler+0x2cc>  // b.plast
        return &vcpu->vm->arch.vgicd.interrupts[int_id - GIC_CPU_PRIV];
    fd80000067b0:	f9404c21 	ldr	x1, [x1, #152]
    fd80000067b4:	51008000 	sub	w0, w0, #0x20
    fd80000067b8:	52800702 	mov	w2, #0x38                  	// #56
    fd80000067bc:	9ba20400 	umaddl	x0, w0, w2, x1
        if (prev_interrupt != NULL) {
    fd80000067c0:	b4fff3e0 	cbz	x0, fd800000663c <gic_maintenance_handler+0x2cc>
            spin_lock(&prev_interrupt->lock);
    fd80000067c4:	91008001 	add	x1, x0, #0x20
    __asm__ volatile(
    fd80000067c8:	91001025 	add	x5, x1, #0x4
    fd80000067cc:	885ffc22 	ldaxr	w2, [x1]
    fd80000067d0:	11000443 	add	w3, w2, #0x1
    fd80000067d4:	88047c23 	stxr	w4, w3, [x1]
    fd80000067d8:	35ffffa4 	cbnz	w4, fd80000067cc <gic_maintenance_handler+0x45c>
    fd80000067dc:	88dffca3 	ldar	w3, [x5]
    fd80000067e0:	6b03005f 	cmp	w2, w3
    fd80000067e4:	54000060 	b.eq	fd80000067f0 <gic_maintenance_handler+0x480>  // b.none
    fd80000067e8:	d503205f 	wfe
    fd80000067ec:	17fffffc 	b	fd80000067dc <gic_maintenance_handler+0x46c>
            if (vgic_owns(vcpu, prev_interrupt) && prev_interrupt->in_lr &&
    fd80000067f0:	f9400402 	ldr	x2, [x0, #8]
    fd80000067f4:	eb02035f 	cmp	x26, x2
    fd80000067f8:	54001740 	b.eq	fd8000006ae0 <gic_maintenance_handler+0x770>  // b.none
    __asm__ volatile(
    fd80000067fc:	91001021 	add	x1, x1, #0x4
    fd8000006800:	b9400020 	ldr	w0, [x1]
    fd8000006804:	11000400 	add	w0, w0, #0x1
    fd8000006808:	889ffc20 	stlr	w0, [x1]
    fd800000680c:	d5033b9f 	dsb	ish
    fd8000006810:	d503209f 	sev
}
    fd8000006814:	17ffff8a 	b	fd800000663c <gic_maintenance_handler+0x2cc>
        spin_lock(&list->lock);
    fd8000006818:	91004044 	add	x4, x2, #0x10
    __asm__ volatile(
    fd800000681c:	91001085 	add	x5, x4, #0x4
    fd8000006820:	885ffc80 	ldaxr	w0, [x4]
    fd8000006824:	11000401 	add	w1, w0, #0x1
    fd8000006828:	88037c81 	stxr	w3, w1, [x4]
    fd800000682c:	35ffffa3 	cbnz	w3, fd8000006820 <gic_maintenance_handler+0x4b0>
    fd8000006830:	88dffca1 	ldar	w1, [x5]
    fd8000006834:	6b01001f 	cmp	w0, w1
    fd8000006838:	54000060 	b.eq	fd8000006844 <gic_maintenance_handler+0x4d4>  // b.none
    fd800000683c:	d503205f 	wfe
    fd8000006840:	17fffffc 	b	fd8000006830 <gic_maintenance_handler+0x4c0>

        node_t* temp = list->head;
    fd8000006844:	f9400041 	ldr	x1, [x2]
        node_t* temp_prev = NULL;
        while (temp != NULL && temp != node) {
    fd8000006848:	f100003f 	cmp	x1, #0x0
    fd800000684c:	1a9f07e0 	cset	w0, ne	// ne = any
    fd8000006850:	7100001f 	cmp	w0, #0x0
    fd8000006854:	fa411324 	ccmp	x25, x1, #0x4, ne	// ne = any
    fd8000006858:	54000340 	b.eq	fd80000068c0 <gic_maintenance_handler+0x550>  // b.none
    fd800000685c:	d503201f 	nop
            temp_prev = temp;
            temp = *temp;
    fd8000006860:	aa0103e3 	mov	x3, x1
    fd8000006864:	f9400021 	ldr	x1, [x1]
        while (temp != NULL && temp != node) {
    fd8000006868:	f100003f 	cmp	x1, #0x0
    fd800000686c:	1a9f07e0 	cset	w0, ne	// ne = any
    fd8000006870:	7100001f 	cmp	w0, #0x0
    fd8000006874:	fa411324 	ccmp	x25, x1, #0x4, ne	// ne = any
    fd8000006878:	54ffff41 	b.ne	fd8000006860 <gic_maintenance_handler+0x4f0>  // b.any
        }
        if (temp != NULL && temp == node) {
    fd800000687c:	7100001f 	cmp	w0, #0x0
    fd8000006880:	fa411320 	ccmp	x25, x1, #0x0, ne	// ne = any
    fd8000006884:	540000a1 	b.ne	fd8000006898 <gic_maintenance_handler+0x528>  // b.any
            /* found the node, remove it */
            if (temp_prev != NULL) {
                *temp_prev = *temp;
    fd8000006888:	f9400020 	ldr	x0, [x1]
    fd800000688c:	f9000060 	str	x0, [x3]
            } else {
                list->head = *temp;
            }

            if (list->head == NULL) {
    fd8000006890:	f9400040 	ldr	x0, [x2]
    fd8000006894:	b40013a0 	cbz	x0, fd8000006b08 <gic_maintenance_handler+0x798>
    __asm__ volatile(
    fd8000006898:	91001081 	add	x1, x4, #0x4
    fd800000689c:	b9400020 	ldr	w0, [x1]
    fd80000068a0:	11000400 	add	w0, w0, #0x1
    fd80000068a4:	889ffc20 	stlr	w0, [x1]
    fd80000068a8:	d5033b9f 	dsb	ish
    fd80000068ac:	d503209f 	sev
}
    fd80000068b0:	17ffff5d 	b	fd8000006624 <gic_maintenance_handler+0x2b4>
    fd80000068b4:	f100001f 	cmp	x0, #0x0
    fd80000068b8:	da9f1273 	csinv	x19, x19, xzr, ne	// ne = any
    fd80000068bc:	17ffff0f 	b	fd80000064f8 <gic_maintenance_handler+0x188>
        if (temp != NULL && temp == node) {
    fd80000068c0:	7100001f 	cmp	w0, #0x0
    fd80000068c4:	fa411320 	ccmp	x25, x1, #0x0, ne	// ne = any
    fd80000068c8:	54fffe81 	b.ne	fd8000006898 <gic_maintenance_handler+0x528>  // b.any
                list->head = *temp;
    fd80000068cc:	f9400020 	ldr	x0, [x1]
    fd80000068d0:	f9000040 	str	x0, [x2]
    fd80000068d4:	17fffff0 	b	fd8000006894 <gic_maintenance_handler+0x524>
SYSREG_GEN_ACCESSORS(ich_lr14_el2);
    fd80000068d8:	d51ccdc0 	msr	ich_lr14_el2, x0
    __asm__ volatile(
    fd80000068dc:	91001381 	add	x1, x28, #0x4
    fd80000068e0:	b9400020 	ldr	w0, [x1]
    fd80000068e4:	11000400 	add	w0, w0, #0x1
    fd80000068e8:	889ffc20 	stlr	w0, [x1]
    fd80000068ec:	d5033b9f 	dsb	ish
    fd80000068f0:	d503209f 	sev
            if (!got_ownership) {
    fd80000068f4:	17ffff8d 	b	fd8000006728 <gic_maintenance_handler+0x3b8>
SYSREG_GEN_ACCESSORS(ich_lr8_el2);
    fd80000068f8:	d51ccd00 	msr	ich_lr8_el2, x0
    fd80000068fc:	91001381 	add	x1, x28, #0x4
    fd8000006900:	b9400020 	ldr	w0, [x1]
    fd8000006904:	11000400 	add	w0, w0, #0x1
    fd8000006908:	889ffc20 	stlr	w0, [x1]
    fd800000690c:	d5033b9f 	dsb	ish
    fd8000006910:	d503209f 	sev
    fd8000006914:	17ffff85 	b	fd8000006728 <gic_maintenance_handler+0x3b8>
SYSREG_GEN_ACCESSORS(ich_lr13_el2);
    fd8000006918:	d51ccda0 	msr	ich_lr13_el2, x0
    fd800000691c:	91001381 	add	x1, x28, #0x4
    fd8000006920:	b9400020 	ldr	w0, [x1]
    fd8000006924:	11000400 	add	w0, w0, #0x1
    fd8000006928:	889ffc20 	stlr	w0, [x1]
    fd800000692c:	d5033b9f 	dsb	ish
    fd8000006930:	d503209f 	sev
    fd8000006934:	17ffff7d 	b	fd8000006728 <gic_maintenance_handler+0x3b8>
SYSREG_GEN_ACCESSORS(ich_lr15_el2);
    fd8000006938:	d51ccde0 	msr	ich_lr15_el2, x0
    fd800000693c:	91001381 	add	x1, x28, #0x4
    fd8000006940:	b9400020 	ldr	w0, [x1]
    fd8000006944:	11000400 	add	w0, w0, #0x1
    fd8000006948:	889ffc20 	stlr	w0, [x1]
    fd800000694c:	d5033b9f 	dsb	ish
    fd8000006950:	d503209f 	sev
    fd8000006954:	17ffff75 	b	fd8000006728 <gic_maintenance_handler+0x3b8>
SYSREG_GEN_ACCESSORS(ich_lr4_el2);
    fd8000006958:	d51ccc80 	msr	ich_lr4_el2, x0
    fd800000695c:	91001381 	add	x1, x28, #0x4
    fd8000006960:	b9400020 	ldr	w0, [x1]
    fd8000006964:	11000400 	add	w0, w0, #0x1
    fd8000006968:	889ffc20 	stlr	w0, [x1]
    fd800000696c:	d5033b9f 	dsb	ish
    fd8000006970:	d503209f 	sev
    fd8000006974:	17ffff6d 	b	fd8000006728 <gic_maintenance_handler+0x3b8>
SYSREG_GEN_ACCESSORS(ich_lr5_el2);
    fd8000006978:	d51ccca0 	msr	ich_lr5_el2, x0
    fd800000697c:	91001381 	add	x1, x28, #0x4
    fd8000006980:	b9400020 	ldr	w0, [x1]
    fd8000006984:	11000400 	add	w0, w0, #0x1
    fd8000006988:	889ffc20 	stlr	w0, [x1]
    fd800000698c:	d5033b9f 	dsb	ish
    fd8000006990:	d503209f 	sev
    fd8000006994:	17ffff65 	b	fd8000006728 <gic_maintenance_handler+0x3b8>
SYSREG_GEN_ACCESSORS(ich_lr6_el2);
    fd8000006998:	d51cccc0 	msr	ich_lr6_el2, x0
    fd800000699c:	91001381 	add	x1, x28, #0x4
    fd80000069a0:	b9400020 	ldr	w0, [x1]
    fd80000069a4:	11000400 	add	w0, w0, #0x1
    fd80000069a8:	889ffc20 	stlr	w0, [x1]
    fd80000069ac:	d5033b9f 	dsb	ish
    fd80000069b0:	d503209f 	sev
    fd80000069b4:	17ffff5d 	b	fd8000006728 <gic_maintenance_handler+0x3b8>
SYSREG_GEN_ACCESSORS(ich_lr7_el2);
    fd80000069b8:	d51ccce0 	msr	ich_lr7_el2, x0
    fd80000069bc:	91001381 	add	x1, x28, #0x4
    fd80000069c0:	b9400020 	ldr	w0, [x1]
    fd80000069c4:	11000400 	add	w0, w0, #0x1
    fd80000069c8:	889ffc20 	stlr	w0, [x1]
    fd80000069cc:	d5033b9f 	dsb	ish
    fd80000069d0:	d503209f 	sev
    fd80000069d4:	17ffff55 	b	fd8000006728 <gic_maintenance_handler+0x3b8>
SYSREG_GEN_ACCESSORS(ich_lr0_el2);
    fd80000069d8:	d51ccc00 	msr	ich_lr0_el2, x0
    fd80000069dc:	91001381 	add	x1, x28, #0x4
    fd80000069e0:	b9400020 	ldr	w0, [x1]
    fd80000069e4:	11000400 	add	w0, w0, #0x1
    fd80000069e8:	889ffc20 	stlr	w0, [x1]
    fd80000069ec:	d5033b9f 	dsb	ish
    fd80000069f0:	d503209f 	sev
    fd80000069f4:	17ffff4d 	b	fd8000006728 <gic_maintenance_handler+0x3b8>
SYSREG_GEN_ACCESSORS(ich_lr9_el2);
    fd80000069f8:	d51ccd20 	msr	ich_lr9_el2, x0
    fd80000069fc:	91001381 	add	x1, x28, #0x4
    fd8000006a00:	b9400020 	ldr	w0, [x1]
    fd8000006a04:	11000400 	add	w0, w0, #0x1
    fd8000006a08:	889ffc20 	stlr	w0, [x1]
    fd8000006a0c:	d5033b9f 	dsb	ish
    fd8000006a10:	d503209f 	sev
    fd8000006a14:	17ffff45 	b	fd8000006728 <gic_maintenance_handler+0x3b8>
SYSREG_GEN_ACCESSORS(ich_lr10_el2);
    fd8000006a18:	d51ccd40 	msr	ich_lr10_el2, x0
    fd8000006a1c:	91001381 	add	x1, x28, #0x4
    fd8000006a20:	b9400020 	ldr	w0, [x1]
    fd8000006a24:	11000400 	add	w0, w0, #0x1
    fd8000006a28:	889ffc20 	stlr	w0, [x1]
    fd8000006a2c:	d5033b9f 	dsb	ish
    fd8000006a30:	d503209f 	sev
    fd8000006a34:	17ffff3d 	b	fd8000006728 <gic_maintenance_handler+0x3b8>
SYSREG_GEN_ACCESSORS(ich_lr11_el2);
    fd8000006a38:	d51ccd60 	msr	ich_lr11_el2, x0
    fd8000006a3c:	91001381 	add	x1, x28, #0x4
    fd8000006a40:	b9400020 	ldr	w0, [x1]
    fd8000006a44:	11000400 	add	w0, w0, #0x1
    fd8000006a48:	889ffc20 	stlr	w0, [x1]
    fd8000006a4c:	d5033b9f 	dsb	ish
    fd8000006a50:	d503209f 	sev
    fd8000006a54:	17ffff35 	b	fd8000006728 <gic_maintenance_handler+0x3b8>
SYSREG_GEN_ACCESSORS(ich_lr12_el2);
    fd8000006a58:	d51ccd80 	msr	ich_lr12_el2, x0
    fd8000006a5c:	91001381 	add	x1, x28, #0x4
    fd8000006a60:	b9400020 	ldr	w0, [x1]
    fd8000006a64:	11000400 	add	w0, w0, #0x1
    fd8000006a68:	889ffc20 	stlr	w0, [x1]
    fd8000006a6c:	d5033b9f 	dsb	ish
    fd8000006a70:	d503209f 	sev
    fd8000006a74:	17ffff2d 	b	fd8000006728 <gic_maintenance_handler+0x3b8>
SYSREG_GEN_ACCESSORS(ich_lr1_el2);
    fd8000006a78:	d51ccc20 	msr	ich_lr1_el2, x0
    fd8000006a7c:	91001381 	add	x1, x28, #0x4
    fd8000006a80:	b9400020 	ldr	w0, [x1]
    fd8000006a84:	11000400 	add	w0, w0, #0x1
    fd8000006a88:	889ffc20 	stlr	w0, [x1]
    fd8000006a8c:	d5033b9f 	dsb	ish
    fd8000006a90:	d503209f 	sev
    fd8000006a94:	17ffff25 	b	fd8000006728 <gic_maintenance_handler+0x3b8>
SYSREG_GEN_ACCESSORS(ich_lr2_el2);
    fd8000006a98:	d51ccc40 	msr	ich_lr2_el2, x0
    fd8000006a9c:	91001381 	add	x1, x28, #0x4
    fd8000006aa0:	b9400020 	ldr	w0, [x1]
    fd8000006aa4:	11000400 	add	w0, w0, #0x1
    fd8000006aa8:	889ffc20 	stlr	w0, [x1]
    fd8000006aac:	d5033b9f 	dsb	ish
    fd8000006ab0:	d503209f 	sev
    fd8000006ab4:	17ffff1d 	b	fd8000006728 <gic_maintenance_handler+0x3b8>
SYSREG_GEN_ACCESSORS(ich_lr3_el2);
    fd8000006ab8:	d51ccc60 	msr	ich_lr3_el2, x0
    fd8000006abc:	91001381 	add	x1, x28, #0x4
    fd8000006ac0:	b9400020 	ldr	w0, [x1]
    fd8000006ac4:	11000400 	add	w0, w0, #0x1
    fd8000006ac8:	889ffc20 	stlr	w0, [x1]
    fd8000006acc:	d5033b9f 	dsb	ish
    fd8000006ad0:	d503209f 	sev
    fd8000006ad4:	17ffff15 	b	fd8000006728 <gic_maintenance_handler+0x3b8>
    fd8000006ad8:	a94363f7 	ldp	x23, x24, [sp, #48]
    fd8000006adc:	17fffe6b 	b	fd8000006488 <gic_maintenance_handler+0x118>
            if (vgic_owns(vcpu, prev_interrupt) && prev_interrupt->in_lr &&
    fd8000006ae0:	3940c402 	ldrb	w2, [x0, #49]
    fd8000006ae4:	3607e8c2 	tbz	w2, #0, fd80000067fc <gic_maintenance_handler+0x48c>
                (prev_interrupt->lr == lr_ind)) {
    fd8000006ae8:	3940bc02 	ldrb	w2, [x0, #47]
            if (vgic_owns(vcpu, prev_interrupt) && prev_interrupt->in_lr &&
    fd8000006aec:	eb02027f 	cmp	x19, x2
    fd8000006af0:	54ffe861 	b.ne	fd80000067fc <gic_maintenance_handler+0x48c>  // b.any
        interrupt->in_lr || (vgic_get_state(interrupt) & ACT)) {
    fd8000006af4:	3940b002 	ldrb	w2, [x0, #44]
                prev_interrupt->in_lr = false;
    fd8000006af8:	3900c41f 	strb	wzr, [x0, #49]
        interrupt->in_lr || (vgic_get_state(interrupt) & ACT)) {
    fd8000006afc:	370fe802 	tbnz	w2, #1, fd80000067fc <gic_maintenance_handler+0x48c>
    interrupt->owner = NULL;
    fd8000006b00:	f900041f 	str	xzr, [x0, #8]
    fd8000006b04:	17ffff3e 	b	fd80000067fc <gic_maintenance_handler+0x48c>
                list->tail = NULL;
    fd8000006b08:	f900045f 	str	xzr, [x2, #8]
    fd8000006b0c:	17ffff63 	b	fd8000006898 <gic_maintenance_handler+0x528>
    fd8000006b10:	00013088 	.word	0x00013088
    fd8000006b14:	0000fd80 	.word	0x0000fd80
    fd8000006b18:	00010818 	.word	0x00010818
    fd8000006b1c:	0000fd80 	.word	0x0000fd80
    fd8000006b20:	000111d0 	.word	0x000111d0
    fd8000006b24:	0000fd80 	.word	0x0000fd80
    fd8000006b28:	d503201f 	nop
    fd8000006b2c:	d503201f 	nop

0000fd8000006b30 <vgic_get_itln>:
     * By default the guest sees the real platforms interrupt line number in the virtual gic.
     * However a user can control this using the interrupt_num in the platform description
     * configuration which be at least the number of ppis and a multiple of 32.
     */

    size_t vtyper_itln = bit32_extract(gicd->TYPER, GICD_TYPER_ITLN_OFF, GICD_TYPER_ITLN_LEN);
    fd8000006b30:	90000001 	adrp	x1, fd8000006000 <vgic_ipi_handler+0x210>
    fd8000006b34:	f945b421 	ldr	x1, [x1, #2920]

    if (vgic_dscrp->interrupt_num > GIC_MAX_PPIS) {
    fd8000006b38:	f9400c00 	ldr	x0, [x0, #24]
    size_t vtyper_itln = bit32_extract(gicd->TYPER, GICD_TYPER_ITLN_OFF, GICD_TYPER_ITLN_LEN);
    fd8000006b3c:	f9400022 	ldr	x2, [x1]
    fd8000006b40:	91007c01 	add	x1, x0, #0x1f
    fd8000006b44:	f100401f 	cmp	x0, #0x10
    fd8000006b48:	d345fc21 	lsr	x1, x1, #5
    fd8000006b4c:	b9400440 	ldr	w0, [x2, #4]
    fd8000006b50:	d1000421 	sub	x1, x1, #0x1
    fd8000006b54:	92401021 	and	x1, x1, #0x1f
    fd8000006b58:	92401000 	and	x0, x0, #0x1f
        vtyper_itln =
            (ALIGN(vgic_dscrp->interrupt_num, 32) / 32 - 1) & BIT32_MASK(0, GICD_TYPER_ITLN_LEN);
    }

    return vtyper_itln;
}
    fd8000006b5c:	9a808020 	csel	x0, x1, x0, hi	// hi = pmore
    fd8000006b60:	d65f03c0 	ret
    fd8000006b64:	d503201f 	nop
    fd8000006b68:	00013070 	.word	0x00013070
    fd8000006b6c:	0000fd80 	.word	0x0000fd80

0000fd8000006b70 <vgic_set_hw>:

void vgic_set_hw(struct vm* vm, irqid_t id)
{
    if (id < GIC_MAX_SGIS) {
    fd8000006b70:	71003c3f 	cmp	w1, #0xf
    fd8000006b74:	540005c9 	b.ls	fd8000006c2c <vgic_set_hw+0xbc>  // b.plast
    }

    struct vgic_int* interrupt = NULL;

    if (id < GIC_CPU_PRIV) {
        for (vcpuid_t vcpuid = 0; vcpuid < vm->cpu_num; vcpuid++) {
    fd8000006b78:	f9402402 	ldr	x2, [x0, #72]
    if (id < GIC_CPU_PRIV) {
    fd8000006b7c:	71007c3f 	cmp	w1, #0x1f
    fd8000006b80:	54000588 	b.hi	fd8000006c30 <vgic_set_hw+0xc0>  // b.pmore
        for (vcpuid_t vcpuid = 0; vcpuid < vm->cpu_num; vcpuid++) {
    fd8000006b84:	b4000542 	cbz	x2, fd8000006c2c <vgic_set_hw+0xbc>
    fd8000006b88:	52800704 	mov	w4, #0x38                  	// #56
    fd8000006b8c:	d2804802 	mov	x2, #0x240                 	// #576
    fd8000006b90:	d2800005 	mov	x5, #0x0                   	// #0
    fd8000006b94:	d2800003 	mov	x3, #0x0                   	// #0
    fd8000006b98:	9ba40824 	umaddl	x4, w1, w4, x2
            interrupt = vgic_get_int(vm_get_vcpu(vm, vcpuid), id, vcpuid);
            if (interrupt != NULL) {
                spin_lock(&interrupt->lock);
                interrupt->hw = true;
    fd8000006b9c:	52800026 	mov	w6, #0x1                   	// #1
    fd8000006ba0:	f9402001 	ldr	x1, [x0, #64]
    fd8000006ba4:	8b050021 	add	x1, x1, x5
        struct vcpu* target_vcpu = vgicr_id == vcpu->id ? vcpu : vm_get_vcpu(vcpu->vm, vgicr_id);
    fd8000006ba8:	f944bc22 	ldr	x2, [x1, #2424]
    fd8000006bac:	eb03005f 	cmp	x2, x3
    fd8000006bb0:	54000100 	b.eq	fd8000006bd0 <vgic_set_hw+0x60>  // b.none
    fd8000006bb4:	f944c822 	ldr	x2, [x1, #2448]
    return NULL;
    fd8000006bb8:	d2800001 	mov	x1, #0x0                   	// #0
    if (vcpuid < vm->cpu_num) {
    fd8000006bbc:	f9402447 	ldr	x7, [x2, #72]
    fd8000006bc0:	eb0300ff 	cmp	x7, x3
    fd8000006bc4:	54000069 	b.ls	fd8000006bd0 <vgic_set_hw+0x60>  // b.plast
        return &vm->vcpus[vcpuid];
    fd8000006bc8:	f9402041 	ldr	x1, [x2, #64]
    fd8000006bcc:	8b050021 	add	x1, x1, x5
        return &target_vcpu->arch.vgic_priv.interrupts[int_id];
    fd8000006bd0:	8b040021 	add	x1, x1, x4
                spin_lock(&interrupt->lock);
    fd8000006bd4:	91008022 	add	x2, x1, #0x20
    __asm__ volatile(
    fd8000006bd8:	9100902a 	add	x10, x1, #0x24
    fd8000006bdc:	885ffc47 	ldaxr	w7, [x2]
    fd8000006be0:	110004e8 	add	w8, w7, #0x1
    fd8000006be4:	88097c48 	stxr	w9, w8, [x2]
    fd8000006be8:	35ffffa9 	cbnz	w9, fd8000006bdc <vgic_set_hw+0x6c>
    fd8000006bec:	88dffd48 	ldar	w8, [x10]
    fd8000006bf0:	6b0800ff 	cmp	w7, w8
    fd8000006bf4:	54000060 	b.eq	fd8000006c00 <vgic_set_hw+0x90>  // b.none
    fd8000006bf8:	d503205f 	wfe
    fd8000006bfc:	17fffffc 	b	fd8000006bec <vgic_set_hw+0x7c>
                interrupt->hw = true;
    fd8000006c00:	3900c026 	strb	w6, [x1, #48]
    __asm__ volatile(
    fd8000006c04:	b9400141 	ldr	w1, [x10]
    fd8000006c08:	11000421 	add	w1, w1, #0x1
    fd8000006c0c:	889ffd41 	stlr	w1, [x10]
    fd8000006c10:	d5033b9f 	dsb	ish
    fd8000006c14:	d503209f 	sev
        for (vcpuid_t vcpuid = 0; vcpuid < vm->cpu_num; vcpuid++) {
    fd8000006c18:	f9402401 	ldr	x1, [x0, #72]
    fd8000006c1c:	91000463 	add	x3, x3, #0x1
    fd8000006c20:	912680a5 	add	x5, x5, #0x9a0
    fd8000006c24:	eb03003f 	cmp	x1, x3
    fd8000006c28:	54fffbc8 	b.hi	fd8000006ba0 <vgic_set_hw+0x30>  // b.pmore
            spin_unlock(&interrupt->lock);
        } else {
            WARNING("trying to link non-existent virtual irq to physical irq")
        }
    }
}
    fd8000006c2c:	d65f03c0 	ret
    if (vcpuid < vm->cpu_num) {
    fd8000006c30:	b4000422 	cbz	x2, fd8000006cb4 <vgic_set_hw+0x144>
    } else if (int_id < vcpu->vm->arch.vgicd.int_num) {
    fd8000006c34:	f9402000 	ldr	x0, [x0, #64]
    fd8000006c38:	f944c800 	ldr	x0, [x0, #2448]
    fd8000006c3c:	f9405402 	ldr	x2, [x0, #168]
    fd8000006c40:	eb21405f 	cmp	x2, w1, uxtw
    fd8000006c44:	54000329 	b.ls	fd8000006ca8 <vgic_set_hw+0x138>  // b.plast
        return &vcpu->vm->arch.vgicd.interrupts[int_id - GIC_CPU_PRIV];
    fd8000006c48:	f9404c00 	ldr	x0, [x0, #152]
    fd8000006c4c:	51008021 	sub	w1, w1, #0x20
    fd8000006c50:	52800702 	mov	w2, #0x38                  	// #56
    fd8000006c54:	9ba20021 	umaddl	x1, w1, w2, x0
        if (interrupt != NULL) {
    fd8000006c58:	b4000281 	cbz	x1, fd8000006ca8 <vgic_set_hw+0x138>
            spin_lock(&interrupt->lock);
    fd8000006c5c:	91008020 	add	x0, x1, #0x20
    __asm__ volatile(
    fd8000006c60:	91009025 	add	x5, x1, #0x24
    fd8000006c64:	885ffc02 	ldaxr	w2, [x0]
    fd8000006c68:	11000443 	add	w3, w2, #0x1
    fd8000006c6c:	88047c03 	stxr	w4, w3, [x0]
    fd8000006c70:	35ffffa4 	cbnz	w4, fd8000006c64 <vgic_set_hw+0xf4>
    fd8000006c74:	88dffca3 	ldar	w3, [x5]
    fd8000006c78:	6b03005f 	cmp	w2, w3
    fd8000006c7c:	54000060 	b.eq	fd8000006c88 <vgic_set_hw+0x118>  // b.none
    fd8000006c80:	d503205f 	wfe
    fd8000006c84:	17fffffc 	b	fd8000006c74 <vgic_set_hw+0x104>
            interrupt->hw = true;
    fd8000006c88:	52800022 	mov	w2, #0x1                   	// #1
    fd8000006c8c:	3900c022 	strb	w2, [x1, #48]
    __asm__ volatile(
    fd8000006c90:	b94000a0 	ldr	w0, [x5]
    fd8000006c94:	11000400 	add	w0, w0, #0x1
    fd8000006c98:	889ffca0 	stlr	w0, [x5]
    fd8000006c9c:	d5033b9f 	dsb	ish
    fd8000006ca0:	d503209f 	sev
}
    fd8000006ca4:	d65f03c0 	ret
            WARNING("trying to link non-existent virtual irq to physical irq")
    fd8000006ca8:	90000000 	adrp	x0, fd8000006000 <vgic_ipi_handler+0x210>
    fd8000006cac:	f9466000 	ldr	x0, [x0, #3264]
    fd8000006cb0:	140014dc 	b	fd800000c020 <console_printk>
    } else if (int_id < vcpu->vm->arch.vgicd.int_num) {
    fd8000006cb4:	f944c840 	ldr	x0, [x2, #2448]
    fd8000006cb8:	d4207d00 	brk	#0x3e8
    fd8000006cbc:	d503201f 	nop
    fd8000006cc0:	000108c0 	.word	0x000108c0
    fd8000006cc4:	0000fd80 	.word	0x0000fd80
	...

0000fd8000006cd0 <vmm_arch_init>:
#include <vmm.h>
#include <arch/sysregs.h>
#include <interrupts.h>

void vmm_arch_init()
{
    fd8000006cd0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    fd8000006cd4:	910003fd 	mov	x29, sp
    vmm_arch_profile_init();
    fd8000006cd8:	97ffebde 	bl	fd8000001c50 <vmm_arch_profile_init>
SYSREG_GEN_ACCESSORS(hcr_el2);
    fd8000006cdc:	d2800320 	mov	x0, #0x19                  	// #25
    fd8000006ce0:	f2b00100 	movk	x0, #0x8008, lsl #16
    fd8000006ce4:	f2c06000 	movk	x0, #0x300, lsl #32
    fd8000006ce8:	d51c1100 	msr	hcr_el2, x0
SYSREG_GEN_ACCESSORS(cptr_el2);
    fd8000006cec:	d2800000 	mov	x0, #0x0                   	// #0
    fd8000006cf0:	d51c1140 	msr	cptr_el2, x0
    uint64_t hcr = HCR_VM_BIT | HCR_RW_BIT | HCR_IMO_BIT | HCR_FMO_BIT | HCR_TSC_BIT | HCR_APK_BIT |
        HCR_API_BIT;

    sysreg_hcr_el2_write(hcr);  //configuration controls for virtualization, define whether operations are trapped to EL2
    sysreg_cptr_el2_write(0);
}
    fd8000006cf4:	a8c17bfd 	ldp	x29, x30, [sp], #16
    fd8000006cf8:	d65f03c0 	ret
    fd8000006cfc:	00000000 	udf	#0

0000fd8000006d00 <psci_wake_from_off>:
/* --------------------------------
    SMC Trapping
--------------------------------- */

void psci_wake_from_off()
{
    fd8000006d00:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    fd8000006d04:	910003fd 	mov	x29, sp
    fd8000006d08:	f9000bf3 	str	x19, [sp, #16]
    if (cpu()->vcpu == NULL) {
    fd8000006d0c:	d2dfc013 	mov	x19, #0xfe0000000000        	// #279275953455104
    fd8000006d10:	f9402a60 	ldr	x0, [x19, #80]
    fd8000006d14:	b40002c0 	cbz	x0, fd8000006d6c <psci_wake_from_off+0x6c>
    __asm__ volatile(
    fd8000006d18:	91256003 	add	x3, x0, #0x958
    fd8000006d1c:	91257004 	add	x4, x0, #0x95c
    fd8000006d20:	885ffc60 	ldaxr	w0, [x3]
    fd8000006d24:	11000401 	add	w1, w0, #0x1
    fd8000006d28:	88027c61 	stxr	w2, w1, [x3]
    fd8000006d2c:	35ffffa2 	cbnz	w2, fd8000006d20 <psci_wake_from_off+0x20>
    fd8000006d30:	88dffc81 	ldar	w1, [x4]
    fd8000006d34:	6b01001f 	cmp	w0, w1
    fd8000006d38:	54000060 	b.eq	fd8000006d44 <psci_wake_from_off+0x44>  // b.none
    fd8000006d3c:	d503205f 	wfe
    fd8000006d40:	17fffffc 	b	fd8000006d30 <psci_wake_from_off+0x30>
        return;
    }

    /* update vcpu()->psci_ctx */
    spin_lock(&cpu()->vcpu->arch.psci_ctx.lock);
    if (cpu()->vcpu->arch.psci_ctx.state == ON_PENDING) {
    fd8000006d44:	f9402a60 	ldr	x0, [x19, #80]
    fd8000006d48:	b9497001 	ldr	w1, [x0, #2416]
    fd8000006d4c:	7100083f 	cmp	w1, #0x2
    fd8000006d50:	54000140 	b.eq	fd8000006d78 <psci_wake_from_off+0x78>  // b.none
    __asm__ volatile(
    fd8000006d54:	91257001 	add	x1, x0, #0x95c
    fd8000006d58:	b9400020 	ldr	w0, [x1]
    fd8000006d5c:	11000400 	add	w0, w0, #0x1
    fd8000006d60:	889ffc20 	stlr	w0, [x1]
    fd8000006d64:	d5033b9f 	dsb	ish
    fd8000006d68:	d503209f 	sev
        vcpu_arch_reset(cpu()->vcpu, cpu()->vcpu->arch.psci_ctx.entrypoint);
        cpu()->vcpu->arch.psci_ctx.state = ON;
        vcpu_writereg(cpu()->vcpu, 0, cpu()->vcpu->arch.psci_ctx.context_id);
    }
    spin_unlock(&cpu()->vcpu->arch.psci_ctx.lock);
}
    fd8000006d6c:	f9400bf3 	ldr	x19, [sp, #16]
    fd8000006d70:	a8c27bfd 	ldp	x29, x30, [sp], #32
    fd8000006d74:	d65f03c0 	ret
        vcpu_arch_reset(cpu()->vcpu, cpu()->vcpu->arch.psci_ctx.entrypoint);
    fd8000006d78:	f944b001 	ldr	x1, [x0, #2400]
    fd8000006d7c:	97fff1e1 	bl	fd8000003500 <vcpu_arch_reset>
        cpu()->vcpu->arch.psci_ctx.state = ON;
    fd8000006d80:	f9402a60 	ldr	x0, [x19, #80]
        vcpu_writereg(cpu()->vcpu, 0, cpu()->vcpu->arch.psci_ctx.context_id);
    fd8000006d84:	d2800001 	mov	x1, #0x0                   	// #0
    fd8000006d88:	f944b402 	ldr	x2, [x0, #2408]
        cpu()->vcpu->arch.psci_ctx.state = ON;
    fd8000006d8c:	b909701f 	str	wzr, [x0, #2416]
        vcpu_writereg(cpu()->vcpu, 0, cpu()->vcpu->arch.psci_ctx.context_id);
    fd8000006d90:	97ffeaa8 	bl	fd8000001830 <vcpu_writereg>
    spin_unlock(&cpu()->vcpu->arch.psci_ctx.lock);
    fd8000006d94:	f9402a60 	ldr	x0, [x19, #80]
    fd8000006d98:	17ffffef 	b	fd8000006d54 <psci_wake_from_off+0x54>
    fd8000006d9c:	d503201f 	nop

0000fd8000006da0 <psci_cpumsg_handler>:

void psci_cpumsg_handler(uint32_t event, uint64_t data)
{
    switch (event) {
    fd8000006da0:	34000040 	cbz	w0, fd8000006da8 <psci_cpumsg_handler+0x8>
        case PSCI_MSG_ON:
            psci_wake_from_off();
            break;
    }
}
    fd8000006da4:	d65f03c0 	ret
            psci_wake_from_off();
    fd8000006da8:	17ffffd6 	b	fd8000006d00 <psci_wake_from_off>
    fd8000006dac:	d503201f 	nop

0000fd8000006db0 <psci_cpu_suspend_handler>:
     * since powerlevel and stateid are implementation defined.
     */
    uint32_t state_type = power_state & PSCI_STATE_TYPE_BIT;
    int32_t ret;

    if (state_type) {
    fd8000006db0:	37800080 	tbnz	w0, #16, fd8000006dc0 <psci_cpu_suspend_handler+0x10>
         *  TODO: ideally we would emmit a standby request to PSCI (currently, ATF), but when we
         * do, we do not wake up on interrupts on the current development target zcu104. We should
         * understand why. To circunvent this, we directly emmit a wfi
         */
        // ret = psci_standby();
        asm volatile("wfi\n\r");
    fd8000006db4:	d503207f 	wfi
        ret = PSCI_E_SUCCESS;
    }

    return ret;
}
    fd8000006db8:	52800000 	mov	w0, #0x0                   	// #0
    fd8000006dbc:	d65f03c0 	ret
        spin_lock(&cpu()->vcpu->arch.psci_ctx.lock);
    fd8000006dc0:	d2dfc003 	mov	x3, #0xfe0000000000        	// #279275953455104
    fd8000006dc4:	f9402860 	ldr	x0, [x3, #80]
    __asm__ volatile(
    fd8000006dc8:	91256006 	add	x6, x0, #0x958
    fd8000006dcc:	91257007 	add	x7, x0, #0x95c
    fd8000006dd0:	885ffcc0 	ldaxr	w0, [x6]
    fd8000006dd4:	11000404 	add	w4, w0, #0x1
    fd8000006dd8:	88057cc4 	stxr	w5, w4, [x6]
    fd8000006ddc:	35ffffa5 	cbnz	w5, fd8000006dd0 <psci_cpu_suspend_handler+0x20>
    fd8000006de0:	88dffce4 	ldar	w4, [x7]
    fd8000006de4:	6b04001f 	cmp	w0, w4
    fd8000006de8:	54000060 	b.eq	fd8000006df4 <psci_cpu_suspend_handler+0x44>  // b.none
    fd8000006dec:	d503205f 	wfe
    fd8000006df0:	17fffffc 	b	fd8000006de0 <psci_cpu_suspend_handler+0x30>
        cpu()->vcpu->arch.psci_ctx.entrypoint = entrypoint;
    fd8000006df4:	f9402860 	ldr	x0, [x3, #80]
    fd8000006df8:	f904b001 	str	x1, [x0, #2400]
    __asm__ volatile(
    fd8000006dfc:	91257001 	add	x1, x0, #0x95c
        cpu()->vcpu->arch.psci_ctx.context_id = context_id;
    fd8000006e00:	f904b402 	str	x2, [x0, #2408]
    fd8000006e04:	b9400020 	ldr	w0, [x1]
    fd8000006e08:	11000400 	add	w0, w0, #0x1
    fd8000006e0c:	889ffc20 	stlr	w0, [x1]
    fd8000006e10:	d5033b9f 	dsb	ish
    fd8000006e14:	d503209f 	sev
        ret = psci_power_down(PSCI_WAKEUP_POWERDOWN);
    fd8000006e18:	52800020 	mov	w0, #0x1                   	// #1
    fd8000006e1c:	17ffebd1 	b	fd8000001d60 <psci_power_down>

0000fd8000006e20 <psci_cpu_off_handler>:

int32_t psci_cpu_off_handler(void)
{
    fd8000006e20:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    fd8000006e24:	910003fd 	mov	x29, sp
    fd8000006e28:	f9000bf3 	str	x19, [sp, #16]
    /**
     *  Right now we only support one vcpu por cpu, so passthrough the request directly to the
     *  monitor psci implementation. Later another vcpu, will call cpu_on on this vcpu()->
     */

    spin_lock(&cpu()->vcpu->arch.psci_ctx.lock);
    fd8000006e2c:	d2dfc013 	mov	x19, #0xfe0000000000        	// #279275953455104
    fd8000006e30:	f9402a60 	ldr	x0, [x19, #80]
    __asm__ volatile(
    fd8000006e34:	91256003 	add	x3, x0, #0x958
    fd8000006e38:	91257004 	add	x4, x0, #0x95c
    fd8000006e3c:	885ffc60 	ldaxr	w0, [x3]
    fd8000006e40:	11000401 	add	w1, w0, #0x1
    fd8000006e44:	88027c61 	stxr	w2, w1, [x3]
    fd8000006e48:	35ffffa2 	cbnz	w2, fd8000006e3c <psci_cpu_off_handler+0x1c>
    fd8000006e4c:	88dffc81 	ldar	w1, [x4]
    fd8000006e50:	6b01001f 	cmp	w0, w1
    fd8000006e54:	54000060 	b.eq	fd8000006e60 <psci_cpu_off_handler+0x40>  // b.none
    fd8000006e58:	d503205f 	wfe
    fd8000006e5c:	17fffffc 	b	fd8000006e4c <psci_cpu_off_handler+0x2c>
    cpu()->vcpu->arch.psci_ctx.state = OFF;
    fd8000006e60:	f9402a60 	ldr	x0, [x19, #80]
    fd8000006e64:	52800021 	mov	w1, #0x1                   	// #1
    fd8000006e68:	b9097001 	str	w1, [x0, #2416]
    __asm__ volatile(
    fd8000006e6c:	91257001 	add	x1, x0, #0x95c
    fd8000006e70:	b9400020 	ldr	w0, [x1]
    fd8000006e74:	11000400 	add	w0, w0, #0x1
    fd8000006e78:	889ffc20 	stlr	w0, [x1]
    fd8000006e7c:	d5033b9f 	dsb	ish
    fd8000006e80:	d503209f 	sev
    spin_unlock(&cpu()->vcpu->arch.psci_ctx.lock);

    cpu_idle();
    fd8000006e84:	94000f8b 	bl	fd800000acb0 <cpu_idle>

    spin_lock(&cpu()->vcpu->arch.psci_ctx.lock);
    fd8000006e88:	f9402a60 	ldr	x0, [x19, #80]
    __asm__ volatile(
    fd8000006e8c:	91256003 	add	x3, x0, #0x958
    fd8000006e90:	91257004 	add	x4, x0, #0x95c
    fd8000006e94:	885ffc60 	ldaxr	w0, [x3]
    fd8000006e98:	11000401 	add	w1, w0, #0x1
    fd8000006e9c:	88027c61 	stxr	w2, w1, [x3]
    fd8000006ea0:	35ffffa2 	cbnz	w2, fd8000006e94 <psci_cpu_off_handler+0x74>
    fd8000006ea4:	88dffc81 	ldar	w1, [x4]
    fd8000006ea8:	6b01001f 	cmp	w0, w1
    fd8000006eac:	54000060 	b.eq	fd8000006eb8 <psci_cpu_off_handler+0x98>  // b.none
    fd8000006eb0:	d503205f 	wfe
    fd8000006eb4:	17fffffc 	b	fd8000006ea4 <psci_cpu_off_handler+0x84>
    cpu()->vcpu->arch.psci_ctx.state = ON;
    fd8000006eb8:	f9402a60 	ldr	x0, [x19, #80]
    __asm__ volatile(
    fd8000006ebc:	91257001 	add	x1, x0, #0x95c
    fd8000006ec0:	b909701f 	str	wzr, [x0, #2416]
    fd8000006ec4:	b9400020 	ldr	w0, [x1]
    fd8000006ec8:	11000400 	add	w0, w0, #0x1
    fd8000006ecc:	889ffc20 	stlr	w0, [x1]
    fd8000006ed0:	d5033b9f 	dsb	ish
    fd8000006ed4:	d503209f 	sev
    spin_unlock(&cpu()->vcpu->arch.psci_ctx.lock);

    return PSCI_E_DENIED;
}
    fd8000006ed8:	f9400bf3 	ldr	x19, [sp, #16]
    fd8000006edc:	12800040 	mov	w0, #0xfffffffd            	// #-3
    fd8000006ee0:	a8c27bfd 	ldp	x29, x30, [sp], #32
    fd8000006ee4:	d65f03c0 	ret
    fd8000006ee8:	d503201f 	nop
    fd8000006eec:	d503201f 	nop

0000fd8000006ef0 <psci_cpu_on_handler>:

int32_t psci_cpu_on_handler(unsigned long target_cpu, unsigned long entrypoint,
    unsigned long context_id)
{
    fd8000006ef0:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    fd8000006ef4:	910003fd 	mov	x29, sp
    fd8000006ef8:	a90153f3 	stp	x19, x20, [sp, #16]
    int32_t ret;
    struct vm* vm = cpu()->vcpu->vm;
    fd8000006efc:	d2dfc013 	mov	x19, #0xfe0000000000        	// #279275953455104
    fd8000006f00:	f9402a63 	ldr	x3, [x19, #80]
{
    fd8000006f04:	a9025bf5 	stp	x21, x22, [sp, #32]
    fd8000006f08:	aa0103f6 	mov	x22, x1
    fd8000006f0c:	aa0203f5 	mov	x21, x2
    struct vcpu* target_vcpu = vm_get_vcpu_by_mpidr(vm, target_cpu);
    fd8000006f10:	aa0003e1 	mov	x1, x0
    struct vm* vm = cpu()->vcpu->vm;
    fd8000006f14:	f944c874 	ldr	x20, [x3, #2448]
    struct vcpu* target_vcpu = vm_get_vcpu_by_mpidr(vm, target_cpu);
    fd8000006f18:	aa1403e0 	mov	x0, x20
    fd8000006f1c:	97fff149 	bl	fd8000003440 <vm_get_vcpu_by_mpidr>

    if (target_vcpu != NULL) {
    fd8000006f20:	b40007e0 	cbz	x0, fd800000701c <psci_cpu_on_handler+0x12c>
        bool already_on = true;
        spin_lock(&cpu()->vcpu->arch.psci_ctx.lock);
    fd8000006f24:	f9402a63 	ldr	x3, [x19, #80]
    __asm__ volatile(
    fd8000006f28:	91256064 	add	x4, x3, #0x958
    fd8000006f2c:	91257065 	add	x5, x3, #0x95c
    fd8000006f30:	885ffc81 	ldaxr	w1, [x4]
    fd8000006f34:	11000422 	add	w2, w1, #0x1
    fd8000006f38:	88037c82 	stxr	w3, w2, [x4]
    fd8000006f3c:	35ffffa3 	cbnz	w3, fd8000006f30 <psci_cpu_on_handler+0x40>
    fd8000006f40:	88dffca2 	ldar	w2, [x5]
    fd8000006f44:	6b02003f 	cmp	w1, w2
    fd8000006f48:	54000060 	b.eq	fd8000006f54 <psci_cpu_on_handler+0x64>  // b.none
    fd8000006f4c:	d503205f 	wfe
    fd8000006f50:	17fffffc 	b	fd8000006f40 <psci_cpu_on_handler+0x50>
        if (target_vcpu->arch.psci_ctx.state == OFF) {
    fd8000006f54:	b9497001 	ldr	w1, [x0, #2416]
    fd8000006f58:	7100043f 	cmp	w1, #0x1
    fd8000006f5c:	540001a0 	b.eq	fd8000006f90 <psci_cpu_on_handler+0xa0>  // b.none
    __asm__ volatile(
    fd8000006f60:	f9402a60 	ldr	x0, [x19, #80]
    fd8000006f64:	91257001 	add	x1, x0, #0x95c
    fd8000006f68:	b9400020 	ldr	w0, [x1]
    fd8000006f6c:	11000400 	add	w0, w0, #0x1
    fd8000006f70:	889ffc20 	stlr	w0, [x1]
    fd8000006f74:	d5033b9f 	dsb	ish
    fd8000006f78:	d503209f 	sev
    } else {
        ret = PSCI_E_INVALID_PARAMS;
    }

    return ret;
}
    fd8000006f7c:	a94153f3 	ldp	x19, x20, [sp, #16]
            return PSCI_E_ALREADY_ON;
    fd8000006f80:	12800060 	mov	w0, #0xfffffffc            	// #-4
}
    fd8000006f84:	a9425bf5 	ldp	x21, x22, [sp, #32]
    fd8000006f88:	a8c47bfd 	ldp	x29, x30, [sp], #64
    fd8000006f8c:	d65f03c0 	ret
            target_vcpu->arch.psci_ctx.state = ON_PENDING;
    fd8000006f90:	52800041 	mov	w1, #0x2                   	// #2
            target_vcpu->arch.psci_ctx.entrypoint = entrypoint;
    fd8000006f94:	f904b016 	str	x22, [x0, #2400]
            target_vcpu->arch.psci_ctx.context_id = context_id;
    fd8000006f98:	f904b415 	str	x21, [x0, #2408]
            target_vcpu->arch.psci_ctx.state = ON_PENDING;
    fd8000006f9c:	b9097001 	str	w1, [x0, #2416]
    DMB(ish);
}

static inline void fence_sync_write()
{
    DSB(ishst);
    fd8000006fa0:	d5033a9f 	dsb	ishst
    fd8000006fa4:	f9402a61 	ldr	x1, [x19, #80]
    fd8000006fa8:	91257022 	add	x2, x1, #0x95c
    fd8000006fac:	b9400041 	ldr	w1, [x2]
    fd8000006fb0:	11000421 	add	w1, w1, #0x1
    fd8000006fb4:	889ffc41 	stlr	w1, [x2]
    fd8000006fb8:	d5033b9f 	dsb	ish
    fd8000006fbc:	d503209f 	sev
    fd8000006fc0:	f9402681 	ldr	x1, [x20, #72]
        cpuid_t pcpuid = vm_translate_to_pcpuid(vm, target_vcpu->id);
    fd8000006fc4:	f944bc00 	ldr	x0, [x0, #2424]
    fd8000006fc8:	eb01001f 	cmp	x0, x1
    fd8000006fcc:	54000282 	b.cs	fd800000701c <psci_cpu_on_handler+0x12c>  // b.hs, b.nlast
        return &vm->vcpus[vcpuid];
    fd8000006fd0:	f9402281 	ldr	x1, [x20, #64]
    fd8000006fd4:	d2813402 	mov	x2, #0x9a0                 	// #2464
    fd8000006fd8:	9b020400 	madd	x0, x0, x2, x1

static inline cpuid_t vm_translate_to_pcpuid(struct vm* vm, vcpuid_t vcpuid)
{
    struct vcpu* vcpu = vm_get_vcpu(vm, vcpuid);

    if (vcpu == NULL) {
    fd8000006fdc:	b4000200 	cbz	x0, fd800000701c <psci_cpu_on_handler+0x12c>
        return INVALID_CPUID;
    } else {
        return vcpu->phys_id;
    fd8000006fe0:	f944c000 	ldr	x0, [x0, #2432]
        if (pcpuid == INVALID_CPUID) {
    fd8000006fe4:	b100041f 	cmn	x0, #0x1
    fd8000006fe8:	540001a0 	b.eq	fd800000701c <psci_cpu_on_handler+0x12c>  // b.none
            struct cpu_msg msg = { PSCI_CPUMSG_ID, PSCI_MSG_ON };
    fd8000006fec:	b0000001 	adrp	x1, fd8000007000 <psci_cpu_on_handler+0x110>
    fd8000006ff0:	f9401822 	ldr	x2, [x1, #48]
            cpu_send_msg(pcpuid, &msg);
    fd8000006ff4:	9100c3e1 	add	x1, sp, #0x30
            struct cpu_msg msg = { PSCI_CPUMSG_ID, PSCI_MSG_ON };
    fd8000006ff8:	29077fff 	stp	wzr, wzr, [sp, #56]
    fd8000006ffc:	f9400042 	ldr	x2, [x2]
    fd8000007000:	29067fe2 	stp	w2, wzr, [sp, #48]
            cpu_send_msg(pcpuid, &msg);
    fd8000007004:	94000e93 	bl	fd800000aa50 <cpu_send_msg>
}
    fd8000007008:	a94153f3 	ldp	x19, x20, [sp, #16]
            ret = PSCI_E_SUCCESS;
    fd800000700c:	52800000 	mov	w0, #0x0                   	// #0
}
    fd8000007010:	a9425bf5 	ldp	x21, x22, [sp, #32]
    fd8000007014:	a8c47bfd 	ldp	x29, x30, [sp], #64
    fd8000007018:	d65f03c0 	ret
    fd800000701c:	a94153f3 	ldp	x19, x20, [sp, #16]
        ret = PSCI_E_INVALID_PARAMS;
    fd8000007020:	12800020 	mov	w0, #0xfffffffe            	// #-2
}
    fd8000007024:	a9425bf5 	ldp	x21, x22, [sp, #32]
    fd8000007028:	a8c47bfd 	ldp	x29, x30, [sp], #64
    fd800000702c:	d65f03c0 	ret
    fd8000007030:	00012e80 	.word	0x00012e80
    fd8000007034:	0000fd80 	.word	0x0000fd80
    fd8000007038:	d503201f 	nop
    fd800000703c:	d503201f 	nop

0000fd8000007040 <psci_affinity_info_handler>:
    /**
     * TODO
     */

    return 0;
}
    fd8000007040:	52800000 	mov	w0, #0x0                   	// #0
    fd8000007044:	d65f03c0 	ret
    fd8000007048:	d503201f 	nop
    fd800000704c:	d503201f 	nop

0000fd8000007050 <psci_features_handler>:

int32_t psci_features_handler(uint32_t feature_id)
{
    int32_t ret = PSCI_E_NOT_SUPPORTED;

    switch (feature_id) {
    fd8000007050:	52800021 	mov	w1, #0x1                   	// #1
    fd8000007054:	72b88001 	movk	w1, #0xc400, lsl #16
    fd8000007058:	6b01001f 	cmp	w0, w1
    fd800000705c:	54000280 	b.eq	fd80000070ac <psci_features_handler+0x5c>  // b.none
    fd8000007060:	54000128 	b.hi	fd8000007084 <psci_features_handler+0x34>  // b.pmore
    fd8000007064:	52800081 	mov	w1, #0x4                   	// #4
    fd8000007068:	72b08001 	movk	w1, #0x8400, lsl #16
    fd800000706c:	6b01001f 	cmp	w0, w1
    fd8000007070:	54000168 	b.hi	fd800000709c <psci_features_handler+0x4c>  // b.pmore
    fd8000007074:	12af8001 	mov	w1, #0x83ffffff            	// #-2080374785
    fd8000007078:	6b01001f 	cmp	w0, w1
    fd800000707c:	5a9f83e0 	csetm	w0, ls	// ls = plast
            ret = PSCI_E_SUCCESS;
            break;
    }

    return ret;
}
    fd8000007080:	d65f03c0 	ret
    switch (feature_id) {
    fd8000007084:	529fffa1 	mov	w1, #0xfffd                	// #65533
    fd8000007088:	72a77fe1 	movk	w1, #0x3bff, lsl #16
    fd800000708c:	0b010000 	add	w0, w0, w1
    fd8000007090:	7100041f 	cmp	w0, #0x1
    fd8000007094:	5a9f93e0 	csetm	w0, hi	// hi = pmore
}
    fd8000007098:	d65f03c0 	ret
    switch (feature_id) {
    fd800000709c:	11001821 	add	w1, w1, #0x6
    fd80000070a0:	6b01001f 	cmp	w0, w1
    fd80000070a4:	5a9f03e0 	csetm	w0, ne	// ne = any
}
    fd80000070a8:	d65f03c0 	ret
    switch (feature_id) {
    fd80000070ac:	52800000 	mov	w0, #0x0                   	// #0
}
    fd80000070b0:	d65f03c0 	ret
    fd80000070b4:	d503201f 	nop
    fd80000070b8:	d503201f 	nop
    fd80000070bc:	d503201f 	nop

0000fd80000070c0 <psci_smc_handler>:

int32_t psci_smc_handler(uint32_t smc_fid, unsigned long x1, unsigned long x2, unsigned long x3)
{
    fd80000070c0:	2a0003e4 	mov	w4, w0
    int32_t ret = PSCI_E_NOT_SUPPORTED;

    switch (smc_fid) {
    fd80000070c4:	528000c0 	mov	w0, #0x6                   	// #6
    fd80000070c8:	72b08000 	movk	w0, #0x8400, lsl #16
    fd80000070cc:	6b00009f 	cmp	w4, w0
    fd80000070d0:	54000800 	b.eq	fd80000071d0 <psci_smc_handler+0x110>  // b.none
    fd80000070d4:	aa0103e5 	mov	x5, x1
    fd80000070d8:	aa0203e1 	mov	x1, x2
    fd80000070dc:	540001a8 	b.hi	fd8000007110 <psci_smc_handler+0x50>  // b.pmore
    fd80000070e0:	51001002 	sub	w2, w0, #0x4
    fd80000070e4:	6b02009f 	cmp	w4, w2
    fd80000070e8:	54000720 	b.eq	fd80000071cc <psci_smc_handler+0x10c>  // b.none
    fd80000070ec:	54000589 	b.ls	fd800000719c <psci_smc_handler+0xdc>  // b.plast
    fd80000070f0:	11000440 	add	w0, w2, #0x1
    fd80000070f4:	6b00009f 	cmp	w4, w0
    fd80000070f8:	54000640 	b.eq	fd80000071c0 <psci_smc_handler+0x100>  // b.none
    fd80000070fc:	11000842 	add	w2, w2, #0x2
            ret = psci_cpu_on_handler(x1, x2, x3);
            break;

        case PSCI_AFFINITY_INFO_SMC32:
        case PSCI_AFFINITY_INFO_SMC64:
            ret = psci_affinity_info_handler(x1, x2);
    fd8000007100:	52800000 	mov	w0, #0x0                   	// #0
    switch (smc_fid) {
    fd8000007104:	6b02009f 	cmp	w4, w2
    fd8000007108:	540001c1 	b.ne	fd8000007140 <psci_smc_handler+0x80>  // b.any
        default:
            INFO("unkown psci smc_fid 0x%lx", smc_fid);
    }

    return ret;
}
    fd800000710c:	d65f03c0 	ret
    switch (smc_fid) {
    fd8000007110:	52800022 	mov	w2, #0x1                   	// #1
    fd8000007114:	72b88002 	movk	w2, #0xc400, lsl #16
    fd8000007118:	6b02009f 	cmp	w4, w2
    fd800000711c:	540004c0 	b.eq	fd80000071b4 <psci_smc_handler+0xf4>  // b.none
    fd8000007120:	54000229 	b.ls	fd8000007164 <psci_smc_handler+0xa4>  // b.plast
    fd8000007124:	11000842 	add	w2, w2, #0x2
    fd8000007128:	6b02009f 	cmp	w4, w2
    fd800000712c:	540004a0 	b.eq	fd80000071c0 <psci_smc_handler+0x100>  // b.none
    fd8000007130:	11000442 	add	w2, w2, #0x1
            ret = psci_affinity_info_handler(x1, x2);
    fd8000007134:	52800000 	mov	w0, #0x0                   	// #0
    switch (smc_fid) {
    fd8000007138:	6b02009f 	cmp	w4, w2
    fd800000713c:	54fffe80 	b.eq	fd800000710c <psci_smc_handler+0x4c>  // b.none
{
    fd8000007140:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
            INFO("unkown psci smc_fid 0x%lx", smc_fid);
    fd8000007144:	90000000 	adrp	x0, fd8000007000 <psci_cpu_on_handler+0x110>
    fd8000007148:	2a0403e1 	mov	w1, w4
{
    fd800000714c:	910003fd 	mov	x29, sp
            INFO("unkown psci smc_fid 0x%lx", smc_fid);
    fd8000007150:	f9410000 	ldr	x0, [x0, #512]
    fd8000007154:	940013b3 	bl	fd800000c020 <console_printk>
    int32_t ret = PSCI_E_NOT_SUPPORTED;
    fd8000007158:	12800000 	mov	w0, #0xffffffff            	// #-1
}
    fd800000715c:	a8c17bfd 	ldp	x29, x30, [sp], #16
    fd8000007160:	d65f03c0 	ret
    switch (smc_fid) {
    fd8000007164:	11001000 	add	w0, w0, #0x4
    fd8000007168:	6b00009f 	cmp	w4, w0
    fd800000716c:	54fffea1 	b.ne	fd8000007140 <psci_smc_handler+0x80>  // b.any
    switch (feature_id) {
    fd8000007170:	6b0200bf 	cmp	w5, w2
            ret = psci_affinity_info_handler(x1, x2);
    fd8000007174:	52800000 	mov	w0, #0x0                   	// #0
    switch (feature_id) {
    fd8000007178:	54fffca0 	b.eq	fd800000710c <psci_smc_handler+0x4c>  // b.none
    fd800000717c:	54000348 	b.hi	fd80000071e4 <psci_smc_handler+0x124>  // b.pmore
    fd8000007180:	51001880 	sub	w0, w4, #0x6
    fd8000007184:	6b0000bf 	cmp	w5, w0
    fd8000007188:	54000288 	b.hi	fd80000071d8 <psci_smc_handler+0x118>  // b.pmore
    fd800000718c:	12af8000 	mov	w0, #0x83ffffff            	// #-2080374785
    fd8000007190:	6b0000bf 	cmp	w5, w0
    fd8000007194:	5a9f83e0 	csetm	w0, ls	// ls = plast
    fd8000007198:	d65f03c0 	ret
    switch (smc_fid) {
    fd800000719c:	51001800 	sub	w0, w0, #0x6
    fd80000071a0:	6b00009f 	cmp	w4, w0
    fd80000071a4:	54000160 	b.eq	fd80000071d0 <psci_smc_handler+0x110>  // b.none
    fd80000071a8:	51000442 	sub	w2, w2, #0x1
    fd80000071ac:	6b02009f 	cmp	w4, w2
    fd80000071b0:	54fffc81 	b.ne	fd8000007140 <psci_smc_handler+0x80>  // b.any
            ret = psci_cpu_suspend_handler(x1, x2, x3);
    fd80000071b4:	aa0303e2 	mov	x2, x3
    fd80000071b8:	2a0503e0 	mov	w0, w5
    fd80000071bc:	17fffefd 	b	fd8000006db0 <psci_cpu_suspend_handler>
            ret = psci_cpu_on_handler(x1, x2, x3);
    fd80000071c0:	aa0303e2 	mov	x2, x3
    fd80000071c4:	aa0503e0 	mov	x0, x5
    fd80000071c8:	17ffff4a 	b	fd8000006ef0 <psci_cpu_on_handler>
            ret = psci_cpu_off_handler();
    fd80000071cc:	17ffff15 	b	fd8000006e20 <psci_cpu_off_handler>
    switch (smc_fid) {
    fd80000071d0:	52800040 	mov	w0, #0x2                   	// #2
    fd80000071d4:	d65f03c0 	ret
    switch (feature_id) {
    fd80000071d8:	6b0400bf 	cmp	w5, w4
    fd80000071dc:	5a9f03e0 	csetm	w0, ne	// ne = any
    fd80000071e0:	d65f03c0 	ret
    fd80000071e4:	529fffa0 	mov	w0, #0xfffd                	// #65533
    fd80000071e8:	72a77fe0 	movk	w0, #0x3bff, lsl #16
    fd80000071ec:	0b050000 	add	w0, w0, w5
    fd80000071f0:	7100041f 	cmp	w0, #0x1
    fd80000071f4:	5a9f93e0 	csetm	w0, hi	// hi = pmore
    fd80000071f8:	d65f03c0 	ret
    fd80000071fc:	d503201f 	nop
    fd8000007200:	00010908 	.word	0x00010908
    fd8000007204:	0000fd80 	.word	0x0000fd80
	...

0000fd8000007210 <vgic_int_get_route>:
    return prev_route != interrupt->route;
}

unsigned long vgic_int_get_route(struct vcpu* vcpu, struct vgic_int* interrupt)
{
    if (gic_is_priv(interrupt->id)) {
    fd8000007210:	b9402822 	ldr	w2, [x1, #40]
        return 0;
    fd8000007214:	d2800000 	mov	x0, #0x0                   	// #0
    if (gic_is_priv(interrupt->id)) {
    fd8000007218:	71007c5f 	cmp	w2, #0x1f
    fd800000721c:	54000049 	b.ls	fd8000007224 <vgic_int_get_route+0x14>  // b.plast
    }
    return interrupt->route;
    fd8000007220:	f9400820 	ldr	x0, [x1, #16]
}
    fd8000007224:	d65f03c0 	ret
    fd8000007228:	d503201f 	nop
    fd800000722c:	d503201f 	nop

0000fd8000007230 <vgic_int_set_route>:
{
    fd8000007230:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    fd8000007234:	910003fd 	mov	x29, sp
    fd8000007238:	a90153f3 	stp	x19, x20, [sp, #16]
    fd800000723c:	aa0103f4 	mov	x20, x1
    if (gic_is_priv(interrupt->id)) {
    fd8000007240:	b9402821 	ldr	w1, [x1, #40]
    fd8000007244:	71007c3f 	cmp	w1, #0x1f
    fd8000007248:	54000329 	b.ls	fd80000072ac <vgic_int_set_route+0x7c>  // b.plast
    fd800000724c:	f90013f5 	str	x21, [sp, #32]
    fd8000007250:	aa0203f3 	mov	x19, x2
    unsigned long prev_route = interrupt->route;
    fd8000007254:	f9400a95 	ldr	x21, [x20, #16]
    if (route & GICD_IROUTER_IRM_BIT) {
    fd8000007258:	36f80162 	tbz	w2, #31, fd8000007284 <vgic_int_set_route+0x54>
        phys_route = cpu_id_to_mpidr(vcpu->phys_id);
    fd800000725c:	f944c000 	ldr	x0, [x0, #2432]
    fd8000007260:	97fff21c 	bl	fd8000003ad0 <cpu_id_to_mpidr>
    interrupt->route = route & GICD_IROUTER_RES0_MSK;
    fd8000007264:	92409e73 	and	x19, x19, #0xffffffffff
    return prev_route != interrupt->route;
    fd8000007268:	eb15027f 	cmp	x19, x21
    fd800000726c:	f94013f5 	ldr	x21, [sp, #32]
    interrupt->phys.route = phys_route;
    fd8000007270:	a9010293 	stp	x19, x0, [x20, #16]
    return prev_route != interrupt->route;
    fd8000007274:	1a9f07e0 	cset	w0, ne	// ne = any
}
    fd8000007278:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd800000727c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    fd8000007280:	d65f03c0 	ret
        struct vcpu* tvcpu = vm_get_vcpu_by_mpidr(vcpu->vm, route & MPIDR_AFF_MSK);
    fd8000007284:	f944c800 	ldr	x0, [x0, #2448]
    fd8000007288:	92403c41 	and	x1, x2, #0xffff
    fd800000728c:	97fff06d 	bl	fd8000003440 <vm_get_vcpu_by_mpidr>
    fd8000007290:	aa0003e1 	mov	x1, x0
            phys_route = GICD_IROUTER_INV;
    fd8000007294:	929fffe0 	mov	x0, #0xffffffffffff0000    	// #-65536
        if (tvcpu != NULL) {
    fd8000007298:	b4fffe61 	cbz	x1, fd8000007264 <vgic_int_set_route+0x34>
            phys_route = cpu_id_to_mpidr(tvcpu->phys_id) & MPIDR_AFF_MSK;
    fd800000729c:	f944c020 	ldr	x0, [x1, #2432]
    fd80000072a0:	97fff20c 	bl	fd8000003ad0 <cpu_id_to_mpidr>
    fd80000072a4:	92403c00 	and	x0, x0, #0xffff
    fd80000072a8:	17ffffef 	b	fd8000007264 <vgic_int_set_route+0x34>
}
    fd80000072ac:	a94153f3 	ldp	x19, x20, [sp, #16]
        return false;
    fd80000072b0:	52800000 	mov	w0, #0x0                   	// #0
}
    fd80000072b4:	a8c37bfd 	ldp	x29, x30, [sp], #48
    fd80000072b8:	d65f03c0 	ret
    fd80000072bc:	d503201f 	nop

0000fd80000072c0 <vgic_int_set_route_hw>:

void vgic_int_set_route_hw(struct vcpu* vcpu, struct vgic_int* interrupt)
{
    fd80000072c0:	aa0103e0 	mov	x0, x1
    gicd_set_route(interrupt->id, interrupt->phys.route);
    fd80000072c4:	f9400c21 	ldr	x1, [x1, #24]
    fd80000072c8:	b9402800 	ldr	w0, [x0, #40]
    fd80000072cc:	14000561 	b	fd8000008850 <gicd_set_route>

0000fd80000072d0 <vgicr_emul_typer_access>:
}

void vgicr_emul_typer_access(struct emul_access* acc, struct vgic_reg_handler_info* handlers,
    bool gicr_access, vcpuid_t vgicr_id)
{
    bool word_access = (acc->width == 4);
    fd80000072d0:	f9400805 	ldr	x5, [x0, #16]
{
    fd80000072d4:	aa0003e1 	mov	x1, x0
    bool top_access = word_access && ((acc->addr & 0x4) != 0);
    fd80000072d8:	52800004 	mov	w4, #0x0                   	// #0
    fd80000072dc:	f10010bf 	cmp	x5, #0x4
    fd80000072e0:	54000061 	b.ne	fd80000072ec <vgicr_emul_typer_access+0x1c>  // b.any
    fd80000072e4:	f9400004 	ldr	x4, [x0]
    fd80000072e8:	53020884 	ubfx	w4, w4, #2, #1

    if (!acc->write) {
    fd80000072ec:	39402020 	ldrb	w0, [x1, #8]
    fd80000072f0:	37000280 	tbnz	w0, #0, fd8000007340 <vgicr_emul_typer_access+0x70>
        struct vcpu* vcpu = vm_get_vcpu(cpu()->vcpu->vm, vgicr_id);
    fd80000072f4:	d2dfc000 	mov	x0, #0xfe0000000000        	// #279275953455104
    fd80000072f8:	f9402800 	ldr	x0, [x0, #80]
    fd80000072fc:	f944c802 	ldr	x2, [x0, #2448]
    if (vcpuid < vm->cpu_num) {
    fd8000007300:	f9402446 	ldr	x6, [x2, #72]
    fd8000007304:	eb06007f 	cmp	x3, x6
    fd8000007308:	540001e2 	b.cs	fd8000007344 <vgicr_emul_typer_access+0x74>  // b.hs, b.nlast
        uint64_t typer = vcpu->arch.vgic_priv.vgicr.TYPER;
    fd800000730c:	f9402042 	ldr	x2, [x2, #64]
    fd8000007310:	d2813406 	mov	x6, #0x9a0                 	// #2464
    fd8000007314:	9b060863 	madd	x3, x3, x6, x2
    fd8000007318:	f9409862 	ldr	x2, [x3, #304]

        if (top_access) {
    fd800000731c:	350000c4 	cbnz	w4, fd8000007334 <vgicr_emul_typer_access+0x64>
            typer >>= 32;
        } else if (word_access) {
            typer &= BIT_MASK(0, 32);
        }

        vcpu_writereg(cpu()->vcpu, acc->reg, typer);
    fd8000007320:	f9400c21 	ldr	x1, [x1, #24]
            typer &= BIT_MASK(0, 32);
    fd8000007324:	f10010bf 	cmp	x5, #0x4
    fd8000007328:	92407c43 	and	x3, x2, #0xffffffff
    fd800000732c:	9a820062 	csel	x2, x3, x2, eq	// eq = none
        vcpu_writereg(cpu()->vcpu, acc->reg, typer);
    fd8000007330:	17ffe940 	b	fd8000001830 <vcpu_writereg>
    fd8000007334:	f9400c21 	ldr	x1, [x1, #24]
            typer >>= 32;
    fd8000007338:	d360fc42 	lsr	x2, x2, #32
        vcpu_writereg(cpu()->vcpu, acc->reg, typer);
    fd800000733c:	17ffe93d 	b	fd8000001830 <vcpu_writereg>
    }
}
    fd8000007340:	d65f03c0 	ret
        uint64_t typer = vcpu->arch.vgic_priv.vgicr.TYPER;
    fd8000007344:	d2800000 	mov	x0, #0x0                   	// #0
    fd8000007348:	f9409800 	ldr	x0, [x0, #304]
    fd800000734c:	d4207d00 	brk	#0x3e8

0000fd8000007350 <vgicd_emul_router_access>:
    }
}

void vgicd_emul_router_access(struct emul_access* acc, struct vgic_reg_handler_info* handlers,
    bool gicr_access, vcpuid_t vgicr_id)
{
    fd8000007350:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    bool word_access = (acc->width == 4);
    bool top_access = word_access && ((acc->addr & 0x4) != 0);
    vaddr_t aligned_addr = acc->addr & ~((vaddr_t)0x7);
    size_t irq_id = (GICD_REG_MASK(aligned_addr) - offsetof(struct gicd_hw, IROUTER)) / 8;

    struct vgic_int* interrupt = vgic_get_int(cpu()->vcpu, irq_id, cpu()->vcpu->id);
    fd8000007354:	d2dfc004 	mov	x4, #0xfe0000000000        	// #279275953455104
{
    fd8000007358:	910003fd 	mov	x29, sp
    fd800000735c:	a90153f3 	stp	x19, x20, [sp, #16]
    fd8000007360:	aa0003f3 	mov	x19, x0
    struct vgic_int* interrupt = vgic_get_int(cpu()->vcpu, irq_id, cpu()->vcpu->id);
    fd8000007364:	f9402880 	ldr	x0, [x4, #80]
{
    fd8000007368:	a9025bf5 	stp	x21, x22, [sp, #32]
    bool top_access = word_access && ((acc->addr & 0x4) != 0);
    fd800000736c:	f9400264 	ldr	x4, [x19]
{
    fd8000007370:	a90363f7 	stp	x23, x24, [sp, #48]
    fd8000007374:	12001c57 	and	w23, w2, #0xff
    bool word_access = (acc->width == 4);
    fd8000007378:	f9400a76 	ldr	x22, [x19, #16]
    size_t irq_id = (GICD_REG_MASK(aligned_addr) - offsetof(struct gicd_hw, IROUTER)) / 8;
    fd800000737c:	927d3085 	and	x5, x4, #0xfff8
    struct vgic_int* interrupt = vgic_get_int(cpu()->vcpu, irq_id, cpu()->vcpu->id);
    fd8000007380:	f944bc02 	ldr	x2, [x0, #2424]
    size_t irq_id = (GICD_REG_MASK(aligned_addr) - offsetof(struct gicd_hw, IROUTER)) / 8;
    fd8000007384:	d14018a5 	sub	x5, x5, #0x6, lsl #12
    bool top_access = word_access && ((acc->addr & 0x4) != 0);
    fd8000007388:	53020884 	ubfx	w4, w4, #2, #1
    fd800000738c:	f10012df 	cmp	x22, #0x4
{
    fd8000007390:	aa0103f8 	mov	x24, x1
    bool top_access = word_access && ((acc->addr & 0x4) != 0);
    fd8000007394:	1a9f0095 	csel	w21, w4, wzr, eq	// eq = none
    struct vgic_int* interrupt = vgic_get_int(cpu()->vcpu, irq_id, cpu()->vcpu->id);
    fd8000007398:	d34388a1 	ubfx	x1, x5, #3, #32
{
    fd800000739c:	f90023f9 	str	x25, [sp, #64]
    fd80000073a0:	aa0303f9 	mov	x25, x3
    struct vgic_int* interrupt = vgic_get_int(cpu()->vcpu, irq_id, cpu()->vcpu->id);
    fd80000073a4:	97fff543 	bl	fd80000048b0 <vgic_get_int>

    if (interrupt == NULL) {
    fd80000073a8:	b4000600 	cbz	x0, fd8000007468 <vgicd_emul_router_access+0x118>
    fd80000073ac:	aa0003f4 	mov	x20, x0
    if (gic_is_priv(interrupt->id)) {
    fd80000073b0:	b9402800 	ldr	w0, [x0, #40]
        return 0;
    fd80000073b4:	d2800017 	mov	x23, #0x0                   	// #0
    if (gic_is_priv(interrupt->id)) {
    fd80000073b8:	71007c1f 	cmp	w0, #0x1f
    fd80000073bc:	54000049 	b.ls	fd80000073c4 <vgicd_emul_router_access+0x74>  // b.plast
    return interrupt->route;
    fd80000073c0:	f9400a97 	ldr	x23, [x20, #16]
    }

    uint64_t route = vgic_int_get_route(cpu()->vcpu, interrupt);
    if (!acc->write) {
        if (top_access) {
            vcpu_writereg(cpu()->vcpu, acc->reg, (uint32_t)(route >> 32));
    fd80000073c4:	d2dfc000 	mov	x0, #0xfe0000000000        	// #279275953455104
    if (!acc->write) {
    fd80000073c8:	39402262 	ldrb	w2, [x19, #8]
            vcpu_writereg(cpu()->vcpu, acc->reg, (uint32_t)(route >> 32));
    fd80000073cc:	f9400e61 	ldr	x1, [x19, #24]
    fd80000073d0:	f9402800 	ldr	x0, [x0, #80]
    if (!acc->write) {
    fd80000073d4:	37000182 	tbnz	w2, #0, fd8000007404 <vgicd_emul_router_access+0xb4>
            vcpu_writereg(cpu()->vcpu, acc->reg, (uint32_t)(route >> 32));
    fd80000073d8:	d360fee2 	lsr	x2, x23, #32
        if (top_access) {
    fd80000073dc:	35000095 	cbnz	w21, fd80000073ec <vgicd_emul_router_access+0x9c>
        } else if (word_access) {
            vcpu_writereg(cpu()->vcpu, acc->reg, (uint32_t)route);
        } else {
            vcpu_writereg(cpu()->vcpu, acc->reg, route);
    fd80000073e0:	aa1703e2 	mov	x2, x23
        } else if (word_access) {
    fd80000073e4:	f10012df 	cmp	x22, #0x4
    fd80000073e8:	54000320 	b.eq	fd800000744c <vgicd_emul_router_access+0xfc>  // b.none
        } else {
            route = reg_value;
        }
        vgic_int_set_field(handlers, cpu()->vcpu, interrupt, route);
    }
}
    fd80000073ec:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd80000073f0:	a9425bf5 	ldp	x21, x22, [sp, #32]
    fd80000073f4:	a94363f7 	ldp	x23, x24, [sp, #48]
    fd80000073f8:	f94023f9 	ldr	x25, [sp, #64]
    fd80000073fc:	a8c57bfd 	ldp	x29, x30, [sp], #80
            vcpu_writereg(cpu()->vcpu, acc->reg, (uint32_t)route);
    fd8000007400:	17ffe90c 	b	fd8000001830 <vcpu_writereg>
        uint64_t reg_value = vcpu_readreg(cpu()->vcpu, acc->reg);
    fd8000007404:	97ffe903 	bl	fd8000001810 <vcpu_readreg>
        if (top_access) {
    fd8000007408:	350001d5 	cbnz	w21, fd8000007440 <vgicd_emul_router_access+0xf0>
            route = (route & BIT64_MASK(32, 32)) | (reg_value & BIT64_MASK(0, 32));
    fd800000740c:	b3407c17 	bfxil	x23, x0, #0, #32
    fd8000007410:	f10012df 	cmp	x22, #0x4
    fd8000007414:	9a8002e3 	csel	x3, x23, x0, eq	// eq = none
}
    fd8000007418:	a9425bf5 	ldp	x21, x22, [sp, #32]
        vgic_int_set_field(handlers, cpu()->vcpu, interrupt, route);
    fd800000741c:	aa1403e2 	mov	x2, x20
}
    fd8000007420:	a94153f3 	ldp	x19, x20, [sp, #16]
        vgic_int_set_field(handlers, cpu()->vcpu, interrupt, route);
    fd8000007424:	aa1803e0 	mov	x0, x24
}
    fd8000007428:	a94363f7 	ldp	x23, x24, [sp, #48]
        vgic_int_set_field(handlers, cpu()->vcpu, interrupt, route);
    fd800000742c:	d2dfc001 	mov	x1, #0xfe0000000000        	// #279275953455104
}
    fd8000007430:	f94023f9 	ldr	x25, [sp, #64]
    fd8000007434:	a8c57bfd 	ldp	x29, x30, [sp], #80
        vgic_int_set_field(handlers, cpu()->vcpu, interrupt, route);
    fd8000007438:	f9402821 	ldr	x1, [x1, #80]
    fd800000743c:	17fff871 	b	fd8000005600 <vgic_int_set_field>
            route = (route & BIT64_MASK(0, 32)) | ((reg_value & BIT64_MASK(0, 32)) << 32);
    fd8000007440:	92407ef7 	and	x23, x23, #0xffffffff
    fd8000007444:	aa0082e3 	orr	x3, x23, x0, lsl #32
    fd8000007448:	17fffff4 	b	fd8000007418 <vgicd_emul_router_access+0xc8>
}
    fd800000744c:	a94153f3 	ldp	x19, x20, [sp, #16]
            vcpu_writereg(cpu()->vcpu, acc->reg, (uint32_t)route);
    fd8000007450:	2a1703e2 	mov	w2, w23
}
    fd8000007454:	a9425bf5 	ldp	x21, x22, [sp, #32]
    fd8000007458:	a94363f7 	ldp	x23, x24, [sp, #48]
    fd800000745c:	f94023f9 	ldr	x25, [sp, #64]
    fd8000007460:	a8c57bfd 	ldp	x29, x30, [sp], #80
            vcpu_writereg(cpu()->vcpu, acc->reg, (uint32_t)route);
    fd8000007464:	17ffe8f3 	b	fd8000001830 <vcpu_writereg>
}
    fd8000007468:	a9425bf5 	ldp	x21, x22, [sp, #32]
        return vgic_emul_razwi(acc, handlers, gicr_access, vgicr_id);
    fd800000746c:	aa1903e3 	mov	x3, x25
}
    fd8000007470:	f94023f9 	ldr	x25, [sp, #64]
        return vgic_emul_razwi(acc, handlers, gicr_access, vgicr_id);
    fd8000007474:	2a1703e2 	mov	w2, w23
    fd8000007478:	aa1803e1 	mov	x1, x24
    fd800000747c:	aa1303e0 	mov	x0, x19
}
    fd8000007480:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd8000007484:	a94363f7 	ldp	x23, x24, [sp, #48]
    fd8000007488:	a8c57bfd 	ldp	x29, x30, [sp], #80
        return vgic_emul_razwi(acc, handlers, gicr_access, vgicr_id);
    fd800000748c:	17fff3d9 	b	fd80000043f0 <vgic_emul_razwi>

0000fd8000007490 <vgicr_emul_handler>:
{
    return (acc->addr - cpu()->vcpu->vm->arch.vgicr_addr) / sizeof(struct gicr_hw);
}

bool vgicr_emul_handler(struct emul_access* acc)
{
    fd8000007490:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    struct vgic_reg_handler_info* handler_info = NULL;
    switch (GICR_REG_MASK(acc->addr)) {
    fd8000007494:	d2804002 	mov	x2, #0x200                 	// #512
    fd8000007498:	f2a00022 	movk	x2, #0x1, lsl #16
{
    fd800000749c:	910003fd 	mov	x29, sp
    switch (GICR_REG_MASK(acc->addr)) {
    fd80000074a0:	f9400001 	ldr	x1, [x0]
{
    fd80000074a4:	a90153f3 	stp	x19, x20, [sp, #16]
    fd80000074a8:	aa0003f4 	mov	x20, x0
    fd80000074ac:	a9025bf5 	stp	x21, x22, [sp, #32]
    switch (GICR_REG_MASK(acc->addr)) {
    fd80000074b0:	92404020 	and	x0, x1, #0x1ffff
    fd80000074b4:	eb02001f 	cmp	x0, x2
    fd80000074b8:	54001700 	b.eq	fd8000007798 <vgicr_emul_handler+0x308>  // b.none
    fd80000074bc:	54000a48 	b.hi	fd8000007604 <vgicr_emul_handler+0x174>  // b.pmore
    fd80000074c0:	d1040042 	sub	x2, x2, #0x100
    fd80000074c4:	eb02001f 	cmp	x0, x2
    fd80000074c8:	54001740 	b.eq	fd80000077b0 <vgicr_emul_handler+0x320>  // b.none
    fd80000074cc:	91020042 	add	x2, x2, #0x80
    fd80000074d0:	eb02001f 	cmp	x0, x2
    fd80000074d4:	54000dc0 	b.eq	fd800000768c <vgicr_emul_handler+0x1fc>  // b.none
    fd80000074d8:	b5000e00 	cbnz	x0, fd8000007698 <vgicr_emul_handler+0x208>
        case GICR_REG_OFF(CTLR):
            handler_info = &vgicr_ctrl_info;
    fd80000074dc:	90000000 	adrp	x0, fd8000007000 <psci_cpu_on_handler+0x110>
    fd80000074e0:	f9441016 	ldr	x22, [x0, #2080]
    fd80000074e4:	d503201f 	nop
                console_printk("GICv3: Inside razwi rEmulation in address:0x%x\n",acc->addr);
            }
        }
    }

    if (vgic_check_reg_alignment(acc, handler_info)) {
    fd80000074e8:	aa1603e1 	mov	x1, x22
    fd80000074ec:	aa1403e0 	mov	x0, x20
    fd80000074f0:	97fff938 	bl	fd80000059d0 <vgic_check_reg_alignment>
    fd80000074f4:	2a0003f5 	mov	w21, w0
    fd80000074f8:	36000a35 	tbz	w21, #0, fd800000763c <vgicr_emul_handler+0x1ac>
    return (acc->addr - cpu()->vcpu->vm->arch.vgicr_addr) / sizeof(struct gicr_hw);
    fd80000074fc:	d2dfc000 	mov	x0, #0xfe0000000000        	// #279275953455104
    fd8000007500:	f9400283 	ldr	x3, [x20]
    fd8000007504:	f9402813 	ldr	x19, [x0, #80]
    fd8000007508:	f944ca60 	ldr	x0, [x19, #2448]
        vcpuid_t vgicr_id = vgicr_get_id(acc);
        struct vcpu* vcpu =
            vgicr_id == cpu()->vcpu->id ? cpu()->vcpu : vm_get_vcpu(cpu()->vcpu->vm, vgicr_id);
    fd800000750c:	f944be61 	ldr	x1, [x19, #2424]
    return (acc->addr - cpu()->vcpu->vm->arch.vgicr_addr) / sizeof(struct gicr_hw);
    fd8000007510:	f9406002 	ldr	x2, [x0, #192]
    fd8000007514:	cb020063 	sub	x3, x3, x2
    fd8000007518:	d351fc63 	lsr	x3, x3, #17
            vgicr_id == cpu()->vcpu->id ? cpu()->vcpu : vm_get_vcpu(cpu()->vcpu->vm, vgicr_id);
    fd800000751c:	eb03003f 	cmp	x1, x3
    fd8000007520:	54000100 	b.eq	fd8000007540 <vgicr_emul_handler+0xb0>  // b.none
    fd8000007524:	f9402401 	ldr	x1, [x0, #72]
    return NULL;
    fd8000007528:	d2800013 	mov	x19, #0x0                   	// #0
    if (vcpuid < vm->cpu_num) {
    fd800000752c:	eb03003f 	cmp	x1, x3
    fd8000007530:	54000089 	b.ls	fd8000007540 <vgicr_emul_handler+0xb0>  // b.plast
        return &vm->vcpus[vcpuid];
    fd8000007534:	f9402000 	ldr	x0, [x0, #64]
    fd8000007538:	d2813413 	mov	x19, #0x9a0                 	// #2464
    fd800000753c:	9b130073 	madd	x19, x3, x19, x0
        spin_lock(&vcpu->arch.vgic_priv.vgicr.lock);
    fd8000007540:	9104a273 	add	x19, x19, #0x128
    __asm__ volatile(
    fd8000007544:	91001264 	add	x4, x19, #0x4
    fd8000007548:	885ffe60 	ldaxr	w0, [x19]
    fd800000754c:	11000401 	add	w1, w0, #0x1
    fd8000007550:	88027e61 	stxr	w2, w1, [x19]
    fd8000007554:	35ffffa2 	cbnz	w2, fd8000007548 <vgicr_emul_handler+0xb8>
    fd8000007558:	88dffc81 	ldar	w1, [x4]
    fd800000755c:	6b01001f 	cmp	w0, w1
    fd8000007560:	54000060 	b.eq	fd800000756c <vgicr_emul_handler+0xdc>  // b.none
    fd8000007564:	d503205f 	wfe
    fd8000007568:	17fffffc 	b	fd8000007558 <vgicr_emul_handler+0xc8>

        //Only for testing
        if(acc->addr == 0x80a0070 || acc->addr == 0x80c0070) {//if acces the propbaser 
    fd800000756c:	f9400280 	ldr	x0, [x20]
    fd8000007570:	92800de1 	mov	x1, #0xffffffffffffff90    	// #-112
    fd8000007574:	f2befea1 	movk	x1, #0xf7f5, lsl #16
    fd8000007578:	8b010002 	add	x2, x0, x1
    fd800000757c:	f26ef85f 	tst	x2, #0xfffffffffffdffff
    fd8000007580:	54000b61 	b.ne	fd80000076ec <vgicr_emul_handler+0x25c>  // b.any
            if (!acc->write) {
                // paddr_t prop_baser_pa;
                // vaddr_t prop_baser_vm = vcpu_readreg(cpu()->vcpu, acc->reg);
                // mem_translate(&cpu()->as, (vaddr_t)prop_baser_vm, &prop_baser_pa); //?
                // gicr->PROPBASER = prop_baser_pa;
                vcpu_writereg(cpu()->vcpu, acc->reg,gicr[cpu()->id].PROPBASER);
    fd8000007584:	d2dfc016 	mov	x22, #0xfe0000000000        	// #279275953455104
            if (!acc->write) {
    fd8000007588:	39402283 	ldrb	w3, [x20, #8]
                vcpu_writereg(cpu()->vcpu, acc->reg,gicr[cpu()->id].PROPBASER);
    fd800000758c:	f9400e81 	ldr	x1, [x20, #24]
    fd8000007590:	f94002c2 	ldr	x2, [x22]
    fd8000007594:	f9001bf7 	str	x23, [sp, #48]
    fd8000007598:	90000000 	adrp	x0, fd8000007000 <psci_cpu_on_handler+0x110>
    fd800000759c:	f9443817 	ldr	x23, [x0, #2160]
    fd80000075a0:	f9402ac0 	ldr	x0, [x22, #80]
    fd80000075a4:	f94002e4 	ldr	x4, [x23]
    fd80000075a8:	8b024494 	add	x20, x4, x2, lsl #17
            if (!acc->write) {
    fd80000075ac:	37000d43 	tbnz	w3, #0, fd8000007754 <vgicr_emul_handler+0x2c4>
                vcpu_writereg(cpu()->vcpu, acc->reg,gicr[cpu()->id].PROPBASER);
    fd80000075b0:	f9403a82 	ldr	x2, [x20, #112]
    fd80000075b4:	97ffe89f 	bl	fd8000001830 <vcpu_writereg>
                console_printk("VGIC3: Propbaser read from cpu %d -> 0x%x\n",cpu()->id,gicr[cpu()->id].PROPBASER);
    fd80000075b8:	f94002e2 	ldr	x2, [x23]
    fd80000075bc:	90000000 	adrp	x0, fd8000007000 <psci_cpu_on_handler+0x110>
    fd80000075c0:	f9443c00 	ldr	x0, [x0, #2168]
    fd80000075c4:	f94002c1 	ldr	x1, [x22]
    fd80000075c8:	8b014442 	add	x2, x2, x1, lsl #17
    fd80000075cc:	f9403842 	ldr	x2, [x2, #112]
    fd80000075d0:	94001294 	bl	fd800000c020 <console_printk>
    fd80000075d4:	f9401bf7 	ldr	x23, [sp, #48]
    __asm__ volatile(
    fd80000075d8:	91001261 	add	x1, x19, #0x4
    fd80000075dc:	b9400020 	ldr	w0, [x1]
    fd80000075e0:	11000400 	add	w0, w0, #0x1
    fd80000075e4:	889ffc20 	stlr	w0, [x1]
    fd80000075e8:	d5033b9f 	dsb	ish
    fd80000075ec:	d503209f 	sev
        return true;
    } else {
        console_printk("GICv3: Not aligned rEmulation in address:0x%x\n",acc->addr);
        return false;
    }
}
    fd80000075f0:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd80000075f4:	2a1503e0 	mov	w0, w21
    fd80000075f8:	a9425bf5 	ldp	x21, x22, [sp, #32]
    fd80000075fc:	a8c47bfd 	ldp	x29, x30, [sp], #64
    fd8000007600:	d65f03c0 	ret
    switch (GICR_REG_MASK(acc->addr)) {
    fd8000007604:	91040042 	add	x2, x2, #0x100
    fd8000007608:	eb02001f 	cmp	x0, x2
    fd800000760c:	54000cc0 	b.eq	fd80000077a4 <vgicr_emul_handler+0x314>  // b.none
    fd8000007610:	54000288 	b.hi	fd8000007660 <vgicr_emul_handler+0x1d0>  // b.pmore
    fd8000007614:	d1020042 	sub	x2, x2, #0x80
    fd8000007618:	eb02001f 	cmp	x0, x2
    fd800000761c:	540003e1 	b.ne	fd8000007698 <vgicr_emul_handler+0x208>  // b.any
            handler_info = &icpendr_info;
    fd8000007620:	90000000 	adrp	x0, fd8000007000 <psci_cpu_on_handler+0x110>
    fd8000007624:	f9442416 	ldr	x22, [x0, #2120]
    if (vgic_check_reg_alignment(acc, handler_info)) {
    fd8000007628:	aa1403e0 	mov	x0, x20
    fd800000762c:	aa1603e1 	mov	x1, x22
    fd8000007630:	97fff8e8 	bl	fd80000059d0 <vgic_check_reg_alignment>
    fd8000007634:	2a0003f5 	mov	w21, w0
    fd8000007638:	3707f635 	tbnz	w21, #0, fd80000074fc <vgicr_emul_handler+0x6c>
        console_printk("GICv3: Not aligned rEmulation in address:0x%x\n",acc->addr);
    fd800000763c:	f9400281 	ldr	x1, [x20]
    fd8000007640:	90000000 	adrp	x0, fd8000007000 <psci_cpu_on_handler+0x110>
    fd8000007644:	f9444400 	ldr	x0, [x0, #2184]
    fd8000007648:	94001276 	bl	fd800000c020 <console_printk>
}
    fd800000764c:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd8000007650:	2a1503e0 	mov	w0, w21
    fd8000007654:	a9425bf5 	ldp	x21, x22, [sp, #32]
    fd8000007658:	a8c47bfd 	ldp	x29, x30, [sp], #64
    fd800000765c:	d65f03c0 	ret
    switch (GICR_REG_MASK(acc->addr)) {
    fd8000007660:	92404023 	and	x3, x1, #0x1ffff
    fd8000007664:	91240044 	add	x4, x2, #0x900
    fd8000007668:	927df863 	and	x3, x3, #0xfffffffffffffffb
    fd800000766c:	eb04007f 	cmp	x3, x4
    fd8000007670:	54000080 	b.eq	fd8000007680 <vgicr_emul_handler+0x1f0>  // b.none
    fd8000007674:	91020042 	add	x2, x2, #0x80
    fd8000007678:	eb02001f 	cmp	x0, x2
    fd800000767c:	540000e1 	b.ne	fd8000007698 <vgicr_emul_handler+0x208>  // b.any
            handler_info = &icfgr_info;
    fd8000007680:	90000000 	adrp	x0, fd8000007000 <psci_cpu_on_handler+0x110>
    fd8000007684:	f9442816 	ldr	x22, [x0, #2128]
    fd8000007688:	17ffff98 	b	fd80000074e8 <vgicr_emul_handler+0x58>
            handler_info = &icenabler_info;
    fd800000768c:	90000000 	adrp	x0, fd8000007000 <psci_cpu_on_handler+0x110>
    fd8000007690:	f9442016 	ldr	x22, [x0, #2112]
    fd8000007694:	17ffff95 	b	fd80000074e8 <vgicr_emul_handler+0x58>
            size_t base_offset = acc->addr - cpu()->vcpu->vm->arch.vgicr_addr;
    fd8000007698:	d2dfc000 	mov	x0, #0xfe0000000000        	// #279275953455104
    fd800000769c:	f9402800 	ldr	x0, [x0, #80]
    fd80000076a0:	f944c800 	ldr	x0, [x0, #2448]
    fd80000076a4:	f9406000 	ldr	x0, [x0, #192]
    fd80000076a8:	cb000020 	sub	x0, x1, x0
            size_t acc_offset = GICR_REG_MASK(base_offset);
    fd80000076ac:	92404000 	and	x0, x0, #0x1ffff
            if (GICR_IS_REG(TYPER, acc_offset)) {
    fd80000076b0:	d1002002 	sub	x2, x0, #0x8
    fd80000076b4:	f1001c5f 	cmp	x2, #0x7
    fd80000076b8:	54000989 	b.ls	fd80000077e8 <vgicr_emul_handler+0x358>  // b.plast
            } else if (GICR_IS_REG(IPRIORITYR, acc_offset)) {
    fd80000076bc:	d1404002 	sub	x2, x0, #0x10, lsl #12
    fd80000076c0:	d1100042 	sub	x2, x2, #0x400
    fd80000076c4:	f1007c5f 	cmp	x2, #0x1f
    fd80000076c8:	54000989 	b.ls	fd80000077f8 <vgicr_emul_handler+0x368>  // b.plast
            } else if (GICR_IS_REG(ID, acc_offset)) {
    fd80000076cc:	929ff9e2 	mov	x2, #0xffffffffffff0030    	// #-65488
    fd80000076d0:	8b020000 	add	x0, x0, x2
    fd80000076d4:	f100bc1f 	cmp	x0, #0x2f
    fd80000076d8:	54000968 	b.hi	fd8000007804 <vgicr_emul_handler+0x374>  // b.pmore
                handler_info = &vgicr_pidr_info;
    fd80000076dc:	90000000 	adrp	x0, fd8000007000 <psci_cpu_on_handler+0x110>
    fd80000076e0:	f9441016 	ldr	x22, [x0, #2080]
    fd80000076e4:	910202d6 	add	x22, x22, #0x80
    fd80000076e8:	17ffff80 	b	fd80000074e8 <vgicr_emul_handler+0x58>
        } else if(acc->addr == 0x80a0078 || acc->addr == 0x80c0078) {     //access the pendbaser
    fd80000076ec:	d1002021 	sub	x1, x1, #0x8
    fd80000076f0:	8b010000 	add	x0, x0, x1
    fd80000076f4:	f26ef81f 	tst	x0, #0xfffffffffffdffff
    fd80000076f8:	54000441 	b.ne	fd8000007780 <vgicr_emul_handler+0x2f0>  // b.any
                vcpu_writereg(cpu()->vcpu, acc->reg,gicr[cpu()->id].PROPBASER);
    fd80000076fc:	d2dfc016 	mov	x22, #0xfe0000000000        	// #279275953455104
             if (!acc->write) {
    fd8000007700:	39402283 	ldrb	w3, [x20, #8]
                vcpu_writereg(cpu()->vcpu, acc->reg,gicr[cpu()->id].PROPBASER);
    fd8000007704:	f9400e81 	ldr	x1, [x20, #24]
                vcpu_writereg(cpu()->vcpu, acc->reg,gicr[cpu()->id].PENDBASER);
    fd8000007708:	f94002c2 	ldr	x2, [x22]
    fd800000770c:	f9001bf7 	str	x23, [sp, #48]
                vcpu_writereg(cpu()->vcpu, acc->reg,gicr[cpu()->id].PROPBASER);
    fd8000007710:	90000000 	adrp	x0, fd8000007000 <psci_cpu_on_handler+0x110>
    fd8000007714:	f9443817 	ldr	x23, [x0, #2160]
    fd8000007718:	f9402ac0 	ldr	x0, [x22, #80]
                vcpu_writereg(cpu()->vcpu, acc->reg,gicr[cpu()->id].PENDBASER);
    fd800000771c:	f94002e4 	ldr	x4, [x23]
    fd8000007720:	8b024494 	add	x20, x4, x2, lsl #17
             if (!acc->write) {
    fd8000007724:	370004c3 	tbnz	w3, #0, fd80000077bc <vgicr_emul_handler+0x32c>
                vcpu_writereg(cpu()->vcpu, acc->reg,gicr[cpu()->id].PENDBASER);
    fd8000007728:	f9403e82 	ldr	x2, [x20, #120]
    fd800000772c:	97ffe841 	bl	fd8000001830 <vcpu_writereg>
                console_printk("VGIC3: Propbaser read from cpu %d -> 0x%x\n",cpu()->id,gicr[cpu()->id].PENDBASER);
    fd8000007730:	f94002e2 	ldr	x2, [x23]
    fd8000007734:	90000000 	adrp	x0, fd8000007000 <psci_cpu_on_handler+0x110>
    fd8000007738:	f9443c00 	ldr	x0, [x0, #2168]
    fd800000773c:	f94002c1 	ldr	x1, [x22]
    fd8000007740:	8b014442 	add	x2, x2, x1, lsl #17
    fd8000007744:	f9403c42 	ldr	x2, [x2, #120]
    fd8000007748:	94001236 	bl	fd800000c020 <console_printk>
    fd800000774c:	f9401bf7 	ldr	x23, [sp, #48]
    fd8000007750:	17ffffa2 	b	fd80000075d8 <vgicr_emul_handler+0x148>
                gicr[cpu()->id].PROPBASER = vcpu_readreg(cpu()->vcpu, acc->reg);
    fd8000007754:	97ffe82f 	bl	fd8000001810 <vcpu_readreg>
    fd8000007758:	f9003a80 	str	x0, [x20, #112]
                console_printk("VGIC3: Propbaser write from cpu %d -> 0x%x\n",cpu()->id,gicr[cpu()->id].PROPBASER);
    fd800000775c:	f94002e2 	ldr	x2, [x23]
    fd8000007760:	90000000 	adrp	x0, fd8000007000 <psci_cpu_on_handler+0x110>
    fd8000007764:	f9444000 	ldr	x0, [x0, #2176]
    fd8000007768:	f94002c1 	ldr	x1, [x22]
    fd800000776c:	8b014442 	add	x2, x2, x1, lsl #17
    fd8000007770:	f9403842 	ldr	x2, [x2, #112]
    fd8000007774:	9400122b 	bl	fd800000c020 <console_printk>
    fd8000007778:	f9401bf7 	ldr	x23, [sp, #48]
    fd800000777c:	17ffff97 	b	fd80000075d8 <vgicr_emul_handler+0x148>
            handler_info->reg_access(acc, handler_info, true, vgicr_id);
    fd8000007780:	f94002c4 	ldr	x4, [x22]
    fd8000007784:	aa1403e0 	mov	x0, x20
    fd8000007788:	aa1603e1 	mov	x1, x22
    fd800000778c:	52800022 	mov	w2, #0x1                   	// #1
    fd8000007790:	d63f0080 	blr	x4
    fd8000007794:	17ffff91 	b	fd80000075d8 <vgicr_emul_handler+0x148>
            handler_info = &ispendr_info;
    fd8000007798:	90000000 	adrp	x0, fd8000007000 <psci_cpu_on_handler+0x110>
    fd800000779c:	f9441816 	ldr	x22, [x0, #2096]
    fd80000077a0:	17ffff52 	b	fd80000074e8 <vgicr_emul_handler+0x58>
            handler_info = &iactiver_info;
    fd80000077a4:	90000000 	adrp	x0, fd8000007000 <psci_cpu_on_handler+0x110>
    fd80000077a8:	f9441c16 	ldr	x22, [x0, #2104]
    fd80000077ac:	17ffff4f 	b	fd80000074e8 <vgicr_emul_handler+0x58>
    switch (GICR_REG_MASK(acc->addr)) {
    fd80000077b0:	90000000 	adrp	x0, fd8000007000 <psci_cpu_on_handler+0x110>
    fd80000077b4:	f9441416 	ldr	x22, [x0, #2088]
    fd80000077b8:	17ffff4c 	b	fd80000074e8 <vgicr_emul_handler+0x58>
                gicr[cpu()->id].PENDBASER = vcpu_readreg(cpu()->vcpu, acc->reg);
    fd80000077bc:	97ffe815 	bl	fd8000001810 <vcpu_readreg>
    fd80000077c0:	f9003e80 	str	x0, [x20, #120]
                console_printk("VGIC3: Propbaser write from cpu %d -> 0x%x\n",cpu()->id,gicr[cpu()->id].PENDBASER);
    fd80000077c4:	f94002e2 	ldr	x2, [x23]
    fd80000077c8:	90000000 	adrp	x0, fd8000007000 <psci_cpu_on_handler+0x110>
    fd80000077cc:	f9444000 	ldr	x0, [x0, #2176]
    fd80000077d0:	f94002c1 	ldr	x1, [x22]
    fd80000077d4:	8b014442 	add	x2, x2, x1, lsl #17
    fd80000077d8:	f9403c42 	ldr	x2, [x2, #120]
    fd80000077dc:	94001211 	bl	fd800000c020 <console_printk>
    fd80000077e0:	f9401bf7 	ldr	x23, [sp, #48]
    fd80000077e4:	17ffff7d 	b	fd80000075d8 <vgicr_emul_handler+0x148>
                handler_info = &vgicr_typer_info;
    fd80000077e8:	90000000 	adrp	x0, fd8000007000 <psci_cpu_on_handler+0x110>
    fd80000077ec:	f9441016 	ldr	x22, [x0, #2080]
    fd80000077f0:	910102d6 	add	x22, x22, #0x40
    fd80000077f4:	17ffff3d 	b	fd80000074e8 <vgicr_emul_handler+0x58>
                handler_info = &ipriorityr_info;
    fd80000077f8:	90000000 	adrp	x0, fd8000007000 <psci_cpu_on_handler+0x110>
    fd80000077fc:	f9443016 	ldr	x22, [x0, #2144]
    fd8000007800:	17ffff3a 	b	fd80000074e8 <vgicr_emul_handler+0x58>
                console_printk("GICv3: Inside razwi rEmulation in address:0x%x\n",acc->addr);
    fd8000007804:	90000000 	adrp	x0, fd8000007000 <psci_cpu_on_handler+0x110>
    fd8000007808:	f9443400 	ldr	x0, [x0, #2152]
    fd800000780c:	94001205 	bl	fd800000c020 <console_printk>
                handler_info = &razwi_info;
    fd8000007810:	90000000 	adrp	x0, fd8000007000 <psci_cpu_on_handler+0x110>
    fd8000007814:	f9442c16 	ldr	x22, [x0, #2136]
    fd8000007818:	17ffff34 	b	fd80000074e8 <vgicr_emul_handler+0x58>
    fd800000781c:	d503201f 	nop
    fd8000007820:	00012720 	.word	0x00012720
    fd8000007824:	0000fd80 	.word	0x0000fd80
    fd8000007828:	000123e0 	.word	0x000123e0
    fd800000782c:	0000fd80 	.word	0x0000fd80
    fd8000007830:	000124a0 	.word	0x000124a0
    fd8000007834:	0000fd80 	.word	0x0000fd80
    fd8000007838:	00012520 	.word	0x00012520
    fd800000783c:	0000fd80 	.word	0x0000fd80
    fd8000007840:	00012420 	.word	0x00012420
    fd8000007844:	0000fd80 	.word	0x0000fd80
    fd8000007848:	000124e0 	.word	0x000124e0
    fd800000784c:	0000fd80 	.word	0x0000fd80
    fd8000007850:	00012560 	.word	0x00012560
    fd8000007854:	0000fd80 	.word	0x0000fd80
    fd8000007858:	00012620 	.word	0x00012620
    fd800000785c:	0000fd80 	.word	0x0000fd80
    fd8000007860:	000125a0 	.word	0x000125a0
    fd8000007864:	0000fd80 	.word	0x0000fd80
    fd8000007868:	00010930 	.word	0x00010930
    fd800000786c:	0000fd80 	.word	0x0000fd80
    fd8000007870:	00013080 	.word	0x00013080
    fd8000007874:	0000fd80 	.word	0x0000fd80
    fd8000007878:	00010960 	.word	0x00010960
    fd800000787c:	0000fd80 	.word	0x0000fd80
    fd8000007880:	00010990 	.word	0x00010990
    fd8000007884:	0000fd80 	.word	0x0000fd80
    fd8000007888:	000109c0 	.word	0x000109c0
    fd800000788c:	0000fd80 	.word	0x0000fd80

0000fd8000007890 <vgic_icc_sgir_handler>:

bool vgic_icc_sgir_handler(struct emul_access* acc)
{
    fd8000007890:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    fd8000007894:	910003fd 	mov	x29, sp
    fd8000007898:	a90153f3 	stp	x19, x20, [sp, #16]
    fd800000789c:	aa0003f3 	mov	x19, x0
    if (acc->write) {
    fd80000078a0:	39402000 	ldrb	w0, [x0, #8]
    fd80000078a4:	370000a0 	tbnz	w0, #0, fd80000078b8 <vgic_icc_sgir_handler+0x28>
        }
        vgic_send_sgi_msg(cpu()->vcpu, trgtlist, int_id);
    }

    return true;
}
    fd80000078a8:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd80000078ac:	52800020 	mov	w0, #0x1                   	// #1
    fd80000078b0:	a8c37bfd 	ldp	x29, x30, [sp], #48
    fd80000078b4:	d65f03c0 	ret
        uint64_t sgir = vcpu_readreg(cpu()->vcpu, acc->reg);
    fd80000078b8:	f9400e61 	ldr	x1, [x19, #24]
    fd80000078bc:	f90013f5 	str	x21, [sp, #32]
    fd80000078c0:	d2dfc015 	mov	x21, #0xfe0000000000        	// #279275953455104
    fd80000078c4:	f9402aa0 	ldr	x0, [x21, #80]
    fd80000078c8:	97ffe7d2 	bl	fd8000001810 <vcpu_readreg>
    fd80000078cc:	aa0003f4 	mov	x20, x0
        if (acc->multi_reg) {
    fd80000078d0:	3940a261 	ldrb	w1, [x19, #40]
    fd80000078d4:	37000241 	tbnz	w1, #0, fd800000791c <vgic_icc_sgir_handler+0x8c>
            trgtlist = cpu()->vcpu->vm->cpus & ~(1U << cpu()->vcpu->phys_id);
    fd80000078d8:	d2dfc013 	mov	x19, #0xfe0000000000        	// #279275953455104
    fd80000078dc:	d3586e95 	ubfx	x21, x20, #24, #4
    fd80000078e0:	f9402a60 	ldr	x0, [x19, #80]
    fd80000078e4:	f944c803 	ldr	x3, [x0, #2448]
        if (sgir & ICC_SGIR_IRM_BIT) {
    fd80000078e8:	b64002d4 	tbz	x20, #40, fd8000007940 <vgic_icc_sgir_handler+0xb0>
            trgtlist = cpu()->vcpu->vm->cpus & ~(1U << cpu()->vcpu->phys_id);
    fd80000078ec:	f944c004 	ldr	x4, [x0, #2432]
    fd80000078f0:	52800021 	mov	w1, #0x1                   	// #1
    fd80000078f4:	f9402862 	ldr	x2, [x3, #80]
    fd80000078f8:	1ac42021 	lsl	w1, w1, w4
    fd80000078fc:	0a210041 	bic	w1, w2, w1
        vgic_send_sgi_msg(cpu()->vcpu, trgtlist, int_id);
    fd8000007900:	2a1503e2 	mov	w2, w21
    fd8000007904:	97fff42b 	bl	fd80000049b0 <vgic_send_sgi_msg>
}
    fd8000007908:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd800000790c:	52800020 	mov	w0, #0x1                   	// #1
        vgic_send_sgi_msg(cpu()->vcpu, trgtlist, int_id);
    fd8000007910:	f94013f5 	ldr	x21, [sp, #32]
}
    fd8000007914:	a8c37bfd 	ldp	x29, x30, [sp], #48
    fd8000007918:	d65f03c0 	ret
            uint64_t sgir_high = vcpu_readreg(cpu()->vcpu, acc->reg_high);
    fd800000791c:	f9401261 	ldr	x1, [x19, #32]
            trgtlist = cpu()->vcpu->vm->cpus & ~(1U << cpu()->vcpu->phys_id);
    fd8000007920:	d2dfc013 	mov	x19, #0xfe0000000000        	// #279275953455104
            uint64_t sgir_high = vcpu_readreg(cpu()->vcpu, acc->reg_high);
    fd8000007924:	f9402aa0 	ldr	x0, [x21, #80]
    fd8000007928:	97ffe7ba 	bl	fd8000001810 <vcpu_readreg>
            sgir |= (sgir_high << 32);
    fd800000792c:	aa008294 	orr	x20, x20, x0, lsl #32
            trgtlist = cpu()->vcpu->vm->cpus & ~(1U << cpu()->vcpu->phys_id);
    fd8000007930:	f9402a60 	ldr	x0, [x19, #80]
    fd8000007934:	d3586e95 	ubfx	x21, x20, #24, #4
    fd8000007938:	f944c803 	ldr	x3, [x0, #2448]
        if (sgir & ICC_SGIR_IRM_BIT) {
    fd800000793c:	b747fd94 	tbnz	x20, #40, fd80000078ec <vgic_icc_sgir_handler+0x5c>
            trgtlist = vm_translate_to_pcpu_mask(cpu()->vcpu->vm, ICC_SGIR_TRGLSTFLT(sgir),
    fd8000007940:	f9402462 	ldr	x2, [x3, #72]
    fd8000007944:	92403e81 	and	x1, x20, #0xffff
    fd8000007948:	aa0303e0 	mov	x0, x3
    fd800000794c:	9400111d 	bl	fd800000bdc0 <vm_translate_to_pcpu_mask>
    fd8000007950:	aa0003e1 	mov	x1, x0
        vgic_send_sgi_msg(cpu()->vcpu, trgtlist, int_id);
    fd8000007954:	f9402a60 	ldr	x0, [x19, #80]
    fd8000007958:	17ffffea 	b	fd8000007900 <vgic_icc_sgir_handler+0x70>
    fd800000795c:	d503201f 	nop

0000fd8000007960 <vgicr_emul_ctrl_access>:
{
    fd8000007960:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    fd8000007964:	910003fd 	mov	x29, sp
    fd8000007968:	a90153f3 	stp	x19, x20, [sp, #16]
    val |= (gicr[cpu()->id].CTLR & 0x1);
    fd800000796c:	d2dfc013 	mov	x19, #0xfe0000000000        	// #279275953455104
    fd8000007970:	90000001 	adrp	x1, fd8000007000 <psci_cpu_on_handler+0x110>
    fd8000007974:	f944fc34 	ldr	x20, [x1, #2552]
    fd8000007978:	f9400262 	ldr	x2, [x19]
    fd800000797c:	f9400284 	ldr	x4, [x20]
    fd8000007980:	d36fb842 	lsl	x2, x2, #17
    if (!acc->write) {
    fd8000007984:	39402003 	ldrb	w3, [x0, #8]
        vcpu_writereg(cpu()->vcpu, acc->reg, val);
    fd8000007988:	f9400c01 	ldr	x1, [x0, #24]
    val |= (gicr[cpu()->id].CTLR & 0x1);
    fd800000798c:	b8626882 	ldr	w2, [x4, x2]
        vcpu_writereg(cpu()->vcpu, acc->reg, val);
    fd8000007990:	f9402a60 	ldr	x0, [x19, #80]
    if (!acc->write) {
    fd8000007994:	37000143 	tbnz	w3, #0, fd80000079bc <vgicr_emul_ctrl_access+0x5c>
    val |= (gicr[cpu()->id].CTLR & 0x1);
    fd8000007998:	12000053 	and	w19, w2, #0x1
        vcpu_writereg(cpu()->vcpu, acc->reg, val);
    fd800000799c:	92400042 	and	x2, x2, #0x1
    fd80000079a0:	97ffe7a4 	bl	fd8000001830 <vcpu_writereg>
        console_printk("VGICv3: rCTRL value readed: 0x%x\n",val);
    fd80000079a4:	2a1303e1 	mov	w1, w19
    fd80000079a8:	90000000 	adrp	x0, fd8000007000 <psci_cpu_on_handler+0x110>
    fd80000079ac:	f9450000 	ldr	x0, [x0, #2560]
}
    fd80000079b0:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd80000079b4:	a8c27bfd 	ldp	x29, x30, [sp], #32
        console_printk("VGICv3: rCTRL value readed: 0x%x\n",val);
    fd80000079b8:	1400119a 	b	fd800000c020 <console_printk>
        gicr[cpu()->id].CTLR |= (vcpu_readreg(cpu()->vcpu, acc->reg)&0x1);
    fd80000079bc:	97ffe795 	bl	fd8000001810 <vcpu_readreg>
    fd80000079c0:	92400004 	and	x4, x0, #0x1
    fd80000079c4:	f9400261 	ldr	x1, [x19]
        console_printk("VGICv3: rCTRL value set to: 0x%x\n",gicr[cpu()->id].CTLR);
    fd80000079c8:	90000000 	adrp	x0, fd8000007000 <psci_cpu_on_handler+0x110>
    fd80000079cc:	f9450400 	ldr	x0, [x0, #2568]
        gicr[cpu()->id].CTLR |= (vcpu_readreg(cpu()->vcpu, acc->reg)&0x1);
    fd80000079d0:	f9400282 	ldr	x2, [x20]
    fd80000079d4:	d36fb821 	lsl	x1, x1, #17
}
    fd80000079d8:	a94153f3 	ldp	x19, x20, [sp, #16]
        gicr[cpu()->id].CTLR |= (vcpu_readreg(cpu()->vcpu, acc->reg)&0x1);
    fd80000079dc:	b8616843 	ldr	w3, [x2, x1]
    fd80000079e0:	2a040063 	orr	w3, w3, w4
    fd80000079e4:	b8216843 	str	w3, [x2, x1]
}
    fd80000079e8:	a8c27bfd 	ldp	x29, x30, [sp], #32
        console_printk("VGICv3: rCTRL value set to: 0x%x\n",gicr[cpu()->id].CTLR);
    fd80000079ec:	b8616841 	ldr	w1, [x2, x1]
    fd80000079f0:	1400118c 	b	fd800000c020 <console_printk>
    fd80000079f4:	d503201f 	nop
    fd80000079f8:	00013080 	.word	0x00013080
    fd80000079fc:	0000fd80 	.word	0x0000fd80
    fd8000007a00:	000109f0 	.word	0x000109f0
    fd8000007a04:	0000fd80 	.word	0x0000fd80
    fd8000007a08:	00010a18 	.word	0x00010a18
    fd8000007a0c:	0000fd80 	.word	0x0000fd80

0000fd8000007a10 <vgic_icc_sre_handler>:

bool vgic_icc_sre_handler(struct emul_access* acc)
{
    if (!acc->write) {
    fd8000007a10:	39402001 	ldrb	w1, [x0, #8]
    fd8000007a14:	36000061 	tbz	w1, #0, fd8000007a20 <vgic_icc_sre_handler+0x10>
        vcpu_writereg(cpu()->vcpu, acc->reg, 0x1);
    }
    return true;
}
    fd8000007a18:	52800020 	mov	w0, #0x1                   	// #1
    fd8000007a1c:	d65f03c0 	ret
{
    fd8000007a20:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
        vcpu_writereg(cpu()->vcpu, acc->reg, 0x1);
    fd8000007a24:	d2dfc003 	mov	x3, #0xfe0000000000        	// #279275953455104
    fd8000007a28:	d2800022 	mov	x2, #0x1                   	// #1
{
    fd8000007a2c:	910003fd 	mov	x29, sp
        vcpu_writereg(cpu()->vcpu, acc->reg, 0x1);
    fd8000007a30:	f9400c01 	ldr	x1, [x0, #24]
    fd8000007a34:	f9402860 	ldr	x0, [x3, #80]
    fd8000007a38:	97ffe77e 	bl	fd8000001830 <vcpu_writereg>
}
    fd8000007a3c:	52800020 	mov	w0, #0x1                   	// #1
    fd8000007a40:	a8c17bfd 	ldp	x29, x30, [sp], #16
    fd8000007a44:	d65f03c0 	ret
    fd8000007a48:	d503201f 	nop
    fd8000007a4c:	d503201f 	nop

0000fd8000007a50 <vgicr_emul_pidr_access>:
{
    fd8000007a50:	aa0003e1 	mov	x1, x0
    if (!acc->write) {
    fd8000007a54:	39402000 	ldrb	w0, [x0, #8]
    fd8000007a58:	370003a0 	tbnz	w0, #0, fd8000007acc <vgicr_emul_pidr_access+0x7c>
        cpuid_t pgicr_id = vm_translate_to_pcpuid(cpu()->vcpu->vm, vgicr_id);
    fd8000007a5c:	d2dfc000 	mov	x0, #0xfe0000000000        	// #279275953455104
        unsigned long val = 0;
    fd8000007a60:	d2800002 	mov	x2, #0x0                   	// #0
    fd8000007a64:	f9400024 	ldr	x4, [x1]
        cpuid_t pgicr_id = vm_translate_to_pcpuid(cpu()->vcpu->vm, vgicr_id);
    fd8000007a68:	f9402800 	ldr	x0, [x0, #80]
    fd8000007a6c:	f9400c21 	ldr	x1, [x1, #24]
    fd8000007a70:	f944c805 	ldr	x5, [x0, #2448]
    if (vcpuid < vm->cpu_num) {
    fd8000007a74:	f94024a6 	ldr	x6, [x5, #72]
    fd8000007a78:	eb06007f 	cmp	x3, x6
    fd8000007a7c:	54000262 	b.cs	fd8000007ac8 <vgicr_emul_pidr_access+0x78>  // b.hs, b.nlast
        return &vm->vcpus[vcpuid];
    fd8000007a80:	f94020a5 	ldr	x5, [x5, #64]
    fd8000007a84:	d2813406 	mov	x6, #0x9a0                 	// #2464
    fd8000007a88:	9b061463 	madd	x3, x3, x6, x5
    if (vcpu == NULL) {
    fd8000007a8c:	b40001e3 	cbz	x3, fd8000007ac8 <vgicr_emul_pidr_access+0x78>
        return vcpu->phys_id;
    fd8000007a90:	f944c063 	ldr	x3, [x3, #2432]
        if (pgicr_id != INVALID_CPUID) {
    fd8000007a94:	b100047f 	cmn	x3, #0x1
    fd8000007a98:	54000180 	b.eq	fd8000007ac8 <vgicr_emul_pidr_access+0x78>  // b.none
            val = gicr[pgicr_id].ID[((acc->addr & 0xff) - 0xd0) / 4];
    fd8000007a9c:	90000002 	adrp	x2, fd8000007000 <psci_cpu_on_handler+0x110>
    fd8000007aa0:	f9456842 	ldr	x2, [x2, #2768]
    fd8000007aa4:	92401c84 	and	x4, x4, #0xff
    fd8000007aa8:	d1034084 	sub	x4, x4, #0xd0
    fd8000007aac:	927ef484 	and	x4, x4, #0xfffffffffffffffc
    fd8000007ab0:	f9400042 	ldr	x2, [x2]
    fd8000007ab4:	8b034443 	add	x3, x2, x3, lsl #17
    fd8000007ab8:	91403063 	add	x3, x3, #0xc, lsl #12
    fd8000007abc:	8b040063 	add	x3, x3, x4
    fd8000007ac0:	b97fd062 	ldr	w2, [x3, #16336]
    fd8000007ac4:	2a0203e2 	mov	w2, w2
        vcpu_writereg(cpu()->vcpu, acc->reg, val);
    fd8000007ac8:	17ffe75a 	b	fd8000001830 <vcpu_writereg>
}
    fd8000007acc:	d65f03c0 	ret
    fd8000007ad0:	00013080 	.word	0x00013080
    fd8000007ad4:	0000fd80 	.word	0x0000fd80
    fd8000007ad8:	d503201f 	nop
    fd8000007adc:	d503201f 	nop

0000fd8000007ae0 <vgic_int_has_other_target>:
        !priv && !(interrupt->phys.route ^ (sysreg_mpidr_el1_read() & MPIDR_AFF_MSK));
    fd8000007ae0:	f9400c22 	ldr	x2, [x1, #24]
    fd8000007ae4:	b9402823 	ldr	w3, [x1, #40]
    bool route_valid = interrupt->phys.route != GICD_IROUTER_INV;
    fd8000007ae8:	b140405f 	cmn	x2, #0x10, lsl #12
    fd8000007aec:	1a9f07e0 	cset	w0, ne	// ne = any
        !priv && !(interrupt->phys.route ^ (sysreg_mpidr_el1_read() & MPIDR_AFF_MSK));
    fd8000007af0:	71007c7f 	cmp	w3, #0x1f
    fd8000007af4:	54000109 	b.ls	fd8000007b14 <vgic_int_has_other_target+0x34>  // b.plast
SYSREG_GEN_ACCESSORS(mpidr_el1);
    fd8000007af8:	d53800a3 	mrs	x3, mpidr_el1
    return (interrupt->route & GICD_IROUTER_IRM_BIT);
    fd8000007afc:	f9400821 	ldr	x1, [x1, #16]
    fd8000007b00:	eb23205f 	cmp	x2, w3, uxth
    return any || (!routed_here && route_valid);
    fd8000007b04:	1a9f07e2 	cset	w2, ne	// ne = any
    fd8000007b08:	0a020000 	and	w0, w0, w2
    fd8000007b0c:	f2610021 	ands	x1, x1, #0x80000000
    fd8000007b10:	1a9f0400 	csinc	w0, w0, wzr, eq	// eq = none
}
    fd8000007b14:	d65f03c0 	ret
    fd8000007b18:	d503201f 	nop
    fd8000007b1c:	d503201f 	nop

0000fd8000007b20 <vgic_int_ptarget_mask>:
    fd8000007b20:	f9400820 	ldr	x0, [x1, #16]
    if (vgic_broadcast(vcpu, interrupt)) {
    fd8000007b24:	36f80160 	tbz	w0, #31, fd8000007b50 <vgic_int_ptarget_mask+0x30>
        return cpu()->vcpu->vm->cpus & ~(1U << cpu()->vcpu->phys_id);
    fd8000007b28:	d2dfc001 	mov	x1, #0xfe0000000000        	// #279275953455104
    fd8000007b2c:	52800020 	mov	w0, #0x1                   	// #1
    fd8000007b30:	f9402821 	ldr	x1, [x1, #80]
    fd8000007b34:	f944c823 	ldr	x3, [x1, #2448]
    fd8000007b38:	f944c022 	ldr	x2, [x1, #2432]
    fd8000007b3c:	f9402861 	ldr	x1, [x3, #80]
    fd8000007b40:	1ac22000 	lsl	w0, w0, w2
    fd8000007b44:	0a200020 	bic	w0, w1, w0
    fd8000007b48:	12001c00 	and	w0, w0, #0xff
}
    fd8000007b4c:	d65f03c0 	ret
        return (1 << interrupt->phys.route);
    fd8000007b50:	f9400c21 	ldr	x1, [x1, #24]
    fd8000007b54:	52800020 	mov	w0, #0x1                   	// #1
    fd8000007b58:	1ac12000 	lsl	w0, w0, w1
    fd8000007b5c:	12001c00 	and	w0, w0, #0xff
}
    fd8000007b60:	d65f03c0 	ret
    fd8000007b64:	d503201f 	nop
    fd8000007b68:	d503201f 	nop
    fd8000007b6c:	d503201f 	nop

0000fd8000007b70 <vgic_init>:

void vgic_init(struct vm* vm, const struct vgic_dscrp* vgic_dscrp)
{
    fd8000007b70:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    fd8000007b74:	910003fd 	mov	x29, sp
    fd8000007b78:	a90153f3 	stp	x19, x20, [sp, #16]
    fd8000007b7c:	aa0003f3 	mov	x19, x0
    fd8000007b80:	aa0103f4 	mov	x20, x1
    vm->arch.vgicr_addr = vgic_dscrp->gicr_addr;
    vm->arch.vgicd.CTLR = 0;
    size_t vtyper_itln = vgic_get_itln(vgic_dscrp);
    fd8000007b84:	aa0103e0 	mov	x0, x1
    vm->arch.vgicr_addr = vgic_dscrp->gicr_addr;
    fd8000007b88:	f9400821 	ldr	x1, [x1, #16]
    vm->arch.vgicd.CTLR = 0;
    fd8000007b8c:	b900b27f 	str	wzr, [x19, #176]
    vm->arch.vgicr_addr = vgic_dscrp->gicr_addr;
    fd8000007b90:	f9006261 	str	x1, [x19, #192]
    size_t vtyper_itln = vgic_get_itln(vgic_dscrp);
    fd8000007b94:	97fffbe7 	bl	fd8000006b30 <vgic_get_itln>
    vm->arch.vgicd.int_num = 32 * (vtyper_itln + 1);
    vm->arch.vgicd.TYPER = ((vtyper_itln << GICD_TYPER_ITLN_OFF) & GICD_TYPER_ITLN_MSK) |
        (((vm->cpu_num - 1) << GICD_TYPER_CPUNUM_OFF) & GICD_TYPER_CPUNUM_MSK) |
        (((15 - 1) << GICD_TYPER_IDBITS_OFF) & GICD_TYPER_IDBITS_MSK) | 0x20000; //LPI support
    vm->arch.vgicd.IIDR = gicd->IIDR;
    fd8000007b98:	90000001 	adrp	x1, fd8000007000 <psci_cpu_on_handler+0x110>
    fd8000007b9c:	f946b822 	ldr	x2, [x1, #3440]
    vm->arch.vgicd.int_num = 32 * (vtyper_itln + 1);
    fd8000007ba0:	91000401 	add	x1, x0, #0x1
        (((vm->cpu_num - 1) << GICD_TYPER_CPUNUM_OFF) & GICD_TYPER_CPUNUM_MSK) |
    fd8000007ba4:	f9402663 	ldr	x3, [x19, #72]

    size_t vgic_int_size = vm->arch.vgicd.int_num * sizeof(struct vgic_int);
    fd8000007ba8:	d280e006 	mov	x6, #0x700                 	// #1792
    vm->arch.vgicd.IIDR = gicd->IIDR;
    fd8000007bac:	f9400045 	ldr	x5, [x2]
        (((vm->cpu_num - 1) << GICD_TYPER_CPUNUM_OFF) & GICD_TYPER_CPUNUM_MSK) |
    fd8000007bb0:	51000463 	sub	w3, w3, #0x1
    vm->arch.vgicd.TYPER = ((vtyper_itln << GICD_TYPER_ITLN_OFF) & GICD_TYPER_ITLN_MSK) |
    fd8000007bb4:	12001002 	and	w2, w0, #0x1f
    size_t vgic_int_size = vm->arch.vgicd.int_num * sizeof(struct vgic_int);
    fd8000007bb8:	9b067c20 	mul	x0, x1, x6
        (((vm->cpu_num - 1) << GICD_TYPER_CPUNUM_OFF) & GICD_TYPER_CPUNUM_MSK) |
    fd8000007bbc:	531b0863 	ubfiz	w3, w3, #5, #3
    vm->arch.vgicd.int_num = 32 * (vtyper_itln + 1);
    fd8000007bc0:	d37be824 	lsl	x4, x1, #5
    vm->arch.vgicd.TYPER = ((vtyper_itln << GICD_TYPER_ITLN_OFF) & GICD_TYPER_ITLN_MSK) |
    fd8000007bc4:	2a020063 	orr	w3, w3, w2
    vm->arch.vgicd.IIDR = gicd->IIDR;
    fd8000007bc8:	b94008a1 	ldr	w1, [x5, #8]
        (((15 - 1) << GICD_TYPER_IDBITS_OFF) & GICD_TYPER_IDBITS_MSK) | 0x20000; //LPI support
    fd8000007bcc:	52a00e42 	mov	w2, #0x720000              	// #7471104
    fd8000007bd0:	2a020063 	orr	w3, w3, w2
    vm->arch.vgicd.interrupts = mem_alloc_page(NUM_PAGES(vgic_int_size), SEC_HYP_VM, false);
    fd8000007bd4:	913ffc00 	add	x0, x0, #0xfff
    vm->arch.vgicd.int_num = 32 * (vtyper_itln + 1);
    fd8000007bd8:	f9005664 	str	x4, [x19, #168]
    vm->arch.vgicd.IIDR = gicd->IIDR;
    fd8000007bdc:	29168663 	stp	w3, w1, [x19, #180]
    vm->arch.vgicd.interrupts = mem_alloc_page(NUM_PAGES(vgic_int_size), SEC_HYP_VM, false);
    fd8000007be0:	52800002 	mov	w2, #0x0                   	// #0
    fd8000007be4:	d34cfc00 	lsr	x0, x0, #12
    fd8000007be8:	52800061 	mov	w1, #0x3                   	// #3
    fd8000007bec:	94000925 	bl	fd800000a080 <mem_alloc_page>
    fd8000007bf0:	f9004e60 	str	x0, [x19, #152]
    if (vm->arch.vgicd.interrupts == NULL) {
    fd8000007bf4:	b4000b40 	cbz	x0, fd8000007d5c <vgic_init+0x1ec>
        ERROR("failed to alloc vgic");
    }

    for (size_t i = 0; i < vm->arch.vgicd.int_num; i++) {
    fd8000007bf8:	f9405661 	ldr	x1, [x19, #168]
    fd8000007bfc:	b4000241 	cbz	x1, fd8000007c44 <vgic_init+0xd4>
    fd8000007c00:	aa0003e2 	mov	x2, x0
    fd8000007c04:	d2800705 	mov	x5, #0x38                  	// #56
    fd8000007c08:	52800400 	mov	w0, #0x20                  	// #32
        vm->arch.vgicd.interrupts[i].owner = NULL;
        vm->arch.vgicd.interrupts[i].lock = SPINLOCK_INITVAL;
        vm->arch.vgicd.interrupts[i].id = i + GIC_CPU_PRIV;
        vm->arch.vgicd.interrupts[i].state = INV;
    fd8000007c0c:	12801fe4 	mov	w4, #0xffffff00            	// #-256
        vm->arch.vgicd.interrupts[i].prio = GIC_LOWEST_PRIO;
        vm->arch.vgicd.interrupts[i].cfg = 0;
        vm->arch.vgicd.interrupts[i].route = GICD_IROUTER_INV;
    fd8000007c10:	929fffe3 	mov	x3, #0xffffffffffff0000    	// #-65536
    fd8000007c14:	9b050821 	madd	x1, x1, x5, x2
    fd8000007c18:	a9008c5f 	stp	xzr, x3, [x2, #8]
        vm->arch.vgicd.interrupts[i].lock = SPINLOCK_INITVAL;
    fd8000007c1c:	a901fc43 	stp	x3, xzr, [x2, #24]
    for (size_t i = 0; i < vm->arch.vgicd.int_num; i++) {
    fd8000007c20:	9100e042 	add	x2, x2, #0x38
        vm->arch.vgicd.interrupts[i].id = i + GIC_CPU_PRIV;
    fd8000007c24:	b81f0040 	stur	w0, [x2, #-16]
    for (size_t i = 0; i < vm->arch.vgicd.int_num; i++) {
    fd8000007c28:	11000400 	add	w0, w0, #0x1
        vm->arch.vgicd.interrupts[i].state = INV;
    fd8000007c2c:	781f4044 	sturh	w4, [x2, #-12]
        vm->arch.vgicd.interrupts[i].cfg = 0;
    fd8000007c30:	381f605f 	sturb	wzr, [x2, #-10]
        vm->arch.vgicd.interrupts[i].phys.route = GICD_IROUTER_INV;
        vm->arch.vgicd.interrupts[i].hw = false;
    fd8000007c34:	781f805f 	sturh	wzr, [x2, #-8]
        vm->arch.vgicd.interrupts[i].in_lr = false;
        vm->arch.vgicd.interrupts[i].enabled = false;
    fd8000007c38:	381fa05f 	sturb	wzr, [x2, #-6]
    for (size_t i = 0; i < vm->arch.vgicd.int_num; i++) {
    fd8000007c3c:	eb02003f 	cmp	x1, x2
    fd8000007c40:	54fffec1 	b.ne	fd8000007c18 <vgic_init+0xa8>  // b.any
    }

    vm->arch.vgicd_emul = (struct emul_mem){ .va_base = vgic_dscrp->gicd_addr,
    fd8000007c44:	90000001 	adrp	x1, fd8000007000 <psci_cpu_on_handler+0x110>
    fd8000007c48:	f946bc22 	ldr	x2, [x1, #3448]
    fd8000007c4c:	d2a00023 	mov	x3, #0x10000               	// #65536
    fd8000007c50:	f9400280 	ldr	x0, [x20]
    fd8000007c54:	a90e827f 	stp	xzr, x0, [x19, #232]
        .size = ALIGN(sizeof(struct gicd_hw), PAGE_SIZE),
        .handler = vgicd_emul_handler };
    vm_emul_add_mem(vm, &vm->arch.vgicd_emul);
    fd8000007c58:	9103a261 	add	x1, x19, #0xe8
    vm->arch.vgicd_emul = (struct emul_mem){ .va_base = vgic_dscrp->gicd_addr,
    fd8000007c5c:	a90f8a63 	stp	x3, x2, [x19, #248]
    vm_emul_add_mem(vm, &vm->arch.vgicd_emul);
    fd8000007c60:	aa1303e0 	mov	x0, x19
    fd8000007c64:	94000fd7 	bl	fd800000bbc0 <vm_emul_add_mem>

    for (vcpuid_t vcpuid = 0; vcpuid < vm->cpu_num; vcpuid++) {
    fd8000007c68:	f9402667 	ldr	x7, [x19, #72]
    fd8000007c6c:	b40003c7 	cbz	x7, fd8000007ce4 <vgic_init+0x174>
        typer |= ((uint64_t)vcpu->arch.vmpidr & MPIDR_AFF_MSK) << GICR_TYPER_AFFVAL_OFF;
        typer |= !!(vcpu->id == vcpu->vm->cpu_num - 1) << GICR_TYPER_LAST_OFF;
        typer |= 0x1; //enable PLPIS
        vcpu->arch.vgic_priv.vgicr.TYPER = typer;
        //vcpu->arch.vgic_priv.vgicr.CTLR |= 0x1; //enable LPIs in CTRL;
        vcpu->arch.vgic_priv.vgicr.IIDR = gicr[cpu()->id].IIDR;
    fd8000007c70:	90000000 	adrp	x0, fd8000007000 <psci_cpu_on_handler+0x110>
    fd8000007c74:	f946c400 	ldr	x0, [x0, #3464]
    fd8000007c78:	d2dfc001 	mov	x1, #0xfe0000000000        	// #279275953455104
    fd8000007c7c:	f9402262 	ldr	x2, [x19, #64]
    fd8000007c80:	d2813406 	mov	x6, #0x9a0                 	// #2464
    fd8000007c84:	f9400000 	ldr	x0, [x0]
    fd8000007c88:	f9400021 	ldr	x1, [x1]
    fd8000007c8c:	9b0608e6 	madd	x6, x7, x6, x2
    fd8000007c90:	8b014401 	add	x1, x0, x1, lsl #17
    fd8000007c94:	d503201f 	nop
        typer |= !!(vcpu->id == vcpu->vm->cpu_num - 1) << GICR_TYPER_LAST_OFF;
    fd8000007c98:	f944c840 	ldr	x0, [x2, #2448]
        uint64_t typer = (uint64_t)vcpu->id << GICR_TYPER_PRCNUM_OFF;
    fd8000007c9c:	f944bc44 	ldr	x4, [x2, #2424]
        typer |= !!(vcpu->id == vcpu->vm->cpu_num - 1) << GICR_TYPER_LAST_OFF;
    fd8000007ca0:	f9402400 	ldr	x0, [x0, #72]
        typer |= ((uint64_t)vcpu->arch.vmpidr & MPIDR_AFF_MSK) << GICR_TYPER_AFFVAL_OFF;
    fd8000007ca4:	f9409043 	ldr	x3, [x2, #288]
        typer |= !!(vcpu->id == vcpu->vm->cpu_num - 1) << GICR_TYPER_LAST_OFF;
    fd8000007ca8:	d1000400 	sub	x0, x0, #0x1
    fd8000007cac:	eb04001f 	cmp	x0, x4
        vcpu->arch.vgic_priv.vgicr.IIDR = gicr[cpu()->id].IIDR;
    fd8000007cb0:	b9400425 	ldr	w5, [x1, #4]
        typer |= !!(vcpu->id == vcpu->vm->cpu_num - 1) << GICR_TYPER_LAST_OFF;
    fd8000007cb4:	9a9f17e0 	cset	x0, eq	// eq = none
        uint64_t typer = (uint64_t)vcpu->id << GICR_TYPER_PRCNUM_OFF;
    fd8000007cb8:	d378dc84 	lsl	x4, x4, #8
        typer |= ((uint64_t)vcpu->arch.vmpidr & MPIDR_AFF_MSK) << GICR_TYPER_AFFVAL_OFF;
    fd8000007cbc:	d3603c63 	ubfiz	x3, x3, #32, #16
        vcpu->arch.vgic_priv.vgicr.IIDR = gicr[cpu()->id].IIDR;
    fd8000007cc0:	b9013c45 	str	w5, [x2, #316]
        typer |= 0x1; //enable PLPIS
    fd8000007cc4:	b2400063 	orr	x3, x3, #0x1
    fd8000007cc8:	aa001080 	orr	x0, x4, x0, lsl #4
    fd8000007ccc:	aa000063 	orr	x3, x3, x0
        vcpu->arch.vgic_priv.vgicr.TYPER = typer;
    fd8000007cd0:	f9009843 	str	x3, [x2, #304]
    for (vcpuid_t vcpuid = 0; vcpuid < vm->cpu_num; vcpuid++) {
    fd8000007cd4:	91268042 	add	x2, x2, #0x9a0
    fd8000007cd8:	eb0200df 	cmp	x6, x2
    fd8000007cdc:	54fffde1 	b.ne	fd8000007c98 <vgic_init+0x128>  // b.any
    }

    vm->arch.vgicr_emul = (struct emul_mem){ .va_base = vgic_dscrp->gicr_addr,
        .size = ALIGN(sizeof(struct gicr_hw), PAGE_SIZE) * vm->cpu_num,
    fd8000007ce0:	d36fb8e7 	lsl	x7, x7, #17
    vm->arch.vgicr_emul = (struct emul_mem){ .va_base = vgic_dscrp->gicr_addr,
    fd8000007ce4:	90000001 	adrp	x1, fd8000007000 <psci_cpu_on_handler+0x110>
    fd8000007ce8:	f946c822 	ldr	x2, [x1, #3472]
        .handler = vgicr_emul_handler };
    vm_emul_add_mem(vm, &vm->arch.vgicr_emul);
    fd8000007cec:	91042261 	add	x1, x19, #0x108
    vm->arch.vgicr_emul = (struct emul_mem){ .va_base = vgic_dscrp->gicr_addr,
    fd8000007cf0:	f9400a80 	ldr	x0, [x20, #16]
    fd8000007cf4:	a910827f 	stp	xzr, x0, [x19, #264]
    vm_emul_add_mem(vm, &vm->arch.vgicr_emul);
    fd8000007cf8:	aa1303e0 	mov	x0, x19
    vm->arch.vgicr_emul = (struct emul_mem){ .va_base = vgic_dscrp->gicr_addr,
    fd8000007cfc:	a9118a67 	stp	x7, x2, [x19, #280]

    vm->arch.icc_sgir_emul = (struct emul_reg){ .addr = SYSREG_ENC_ADDR(3, 0, 12, 11, 5),
    fd8000007d00:	d28602d4 	mov	x20, #0x3016                	// #12310
    fd8000007d04:	f2a00754 	movk	x20, #0x3a, lsl #16
    vm_emul_add_mem(vm, &vm->arch.vgicr_emul);
    fd8000007d08:	94000fae 	bl	fd800000bbc0 <vm_emul_add_mem>
    vm->arch.icc_sgir_emul = (struct emul_reg){ .addr = SYSREG_ENC_ADDR(3, 0, 12, 11, 5),
    fd8000007d0c:	a912d27f 	stp	xzr, x20, [x19, #296]
    fd8000007d10:	90000000 	adrp	x0, fd8000007000 <psci_cpu_on_handler+0x110>
    fd8000007d14:	f946cc00 	ldr	x0, [x0, #3480]
    fd8000007d18:	f9009e60 	str	x0, [x19, #312]
        .handler = vgic_icc_sgir_handler };
    vm_emul_add_reg(vm, &vm->arch.icc_sgir_emul);
    fd8000007d1c:	9104a261 	add	x1, x19, #0x128
    fd8000007d20:	aa1303e0 	mov	x0, x19
    fd8000007d24:	94000fc7 	bl	fd800000bc40 <vm_emul_add_reg>

    vm->arch.icc_sre_emul = (struct emul_reg){ .addr = SYSREG_ENC_ADDR(3, 0, 12, 12, 5),
    fd8000007d28:	91000a94 	add	x20, x20, #0x2
    fd8000007d2c:	90000000 	adrp	x0, fd8000007000 <psci_cpu_on_handler+0x110>
    fd8000007d30:	f946d000 	ldr	x0, [x0, #3488]
    fd8000007d34:	a914527f 	stp	xzr, x20, [x19, #320]
        .handler = vgic_icc_sre_handler };
    vm_emul_add_reg(vm, &vm->arch.icc_sre_emul);
    fd8000007d38:	91050261 	add	x1, x19, #0x140
    vm->arch.icc_sre_emul = (struct emul_reg){ .addr = SYSREG_ENC_ADDR(3, 0, 12, 12, 5),
    fd8000007d3c:	f900aa60 	str	x0, [x19, #336]
    vm_emul_add_reg(vm, &vm->arch.icc_sre_emul);
    fd8000007d40:	aa1303e0 	mov	x0, x19
    fd8000007d44:	94000fbf 	bl	fd800000bc40 <vm_emul_add_reg>
        list->tail = NULL;
    fd8000007d48:	a90cfe7f 	stp	xzr, xzr, [x19, #200]
        list->lock = SPINLOCK_INITVAL;
    fd8000007d4c:	a90dfe7f 	stp	xzr, xzr, [x19, #216]

    list_init(&vm->arch.vgic_spilled);
    vm->arch.vgic_spilled_lock = SPINLOCK_INITVAL;
}
    fd8000007d50:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd8000007d54:	a8c27bfd 	ldp	x29, x30, [sp], #32
    fd8000007d58:	d65f03c0 	ret
        ERROR("failed to alloc vgic");
    fd8000007d5c:	90000000 	adrp	x0, fd8000007000 <psci_cpu_on_handler+0x110>
    fd8000007d60:	f946c000 	ldr	x0, [x0, #3456]
    fd8000007d64:	940010af 	bl	fd800000c020 <console_printk>
    fd8000007d68:	14000000 	b	fd8000007d68 <vgic_init+0x1f8>
    fd8000007d6c:	d503201f 	nop
    fd8000007d70:	00013070 	.word	0x00013070
    fd8000007d74:	0000fd80 	.word	0x0000fd80
    fd8000007d78:	00005a40 	.word	0x00005a40
    fd8000007d7c:	0000fd80 	.word	0x0000fd80
    fd8000007d80:	00010a40 	.word	0x00010a40
    fd8000007d84:	0000fd80 	.word	0x0000fd80
    fd8000007d88:	00013080 	.word	0x00013080
    fd8000007d8c:	0000fd80 	.word	0x0000fd80
    fd8000007d90:	00007490 	.word	0x00007490
    fd8000007d94:	0000fd80 	.word	0x0000fd80
    fd8000007d98:	00007890 	.word	0x00007890
    fd8000007d9c:	0000fd80 	.word	0x0000fd80
    fd8000007da0:	00007a10 	.word	0x00007a10
    fd8000007da4:	0000fd80 	.word	0x0000fd80
    fd8000007da8:	d503201f 	nop
    fd8000007dac:	d503201f 	nop

0000fd8000007db0 <vgic_cpu_init>:
        vcpu->arch.vgic_priv.interrupts[i].id = i;
        vcpu->arch.vgic_priv.interrupts[i].state = INV;
        vcpu->arch.vgic_priv.interrupts[i].prio = GIC_LOWEST_PRIO;
        vcpu->arch.vgic_priv.interrupts[i].cfg = 0;
        vcpu->arch.vgic_priv.interrupts[i].route = GICD_IROUTER_INV;
        vcpu->arch.vgic_priv.interrupts[i].phys.redist = vcpu->phys_id;
    fd8000007db0:	f944c003 	ldr	x3, [x0, #2432]
    fd8000007db4:	91092001 	add	x1, x0, #0x248
    for (size_t i = 0; i < GIC_CPU_PRIV; i++) {
    fd8000007db8:	d2800002 	mov	x2, #0x0                   	// #0
        vcpu->arch.vgic_priv.interrupts[i].state = INV;
    fd8000007dbc:	12801fe5 	mov	w5, #0xffffff00            	// #-256
        vcpu->arch.vgic_priv.interrupts[i].route = GICD_IROUTER_INV;
    fd8000007dc0:	929fffe4 	mov	x4, #0xffffffffffff0000    	// #-65536
    fd8000007dc4:	d503201f 	nop
    fd8000007dc8:	a900103f 	stp	xzr, x4, [x1]
        vcpu->arch.vgic_priv.interrupts[i].lock = SPINLOCK_INITVAL;
    fd8000007dcc:	a9017c23 	stp	x3, xzr, [x1, #16]
    for (size_t i = 0; i < GIC_CPU_PRIV; i++) {
    fd8000007dd0:	9100e021 	add	x1, x1, #0x38
        vcpu->arch.vgic_priv.interrupts[i].id = i;
    fd8000007dd4:	b81e8022 	stur	w2, [x1, #-24]
    for (size_t i = 0; i < GIC_CPU_PRIV; i++) {
    fd8000007dd8:	91000442 	add	x2, x2, #0x1
        vcpu->arch.vgic_priv.interrupts[i].state = INV;
    fd8000007ddc:	781ec025 	sturh	w5, [x1, #-20]
    for (size_t i = 0; i < GIC_CPU_PRIV; i++) {
    fd8000007de0:	f100805f 	cmp	x2, #0x20
        vcpu->arch.vgic_priv.interrupts[i].cfg = 0;
    fd8000007de4:	381ee03f 	sturb	wzr, [x1, #-18]
        vcpu->arch.vgic_priv.interrupts[i].hw = false;
    fd8000007de8:	781f003f 	sturh	wzr, [x1, #-16]
        vcpu->arch.vgic_priv.interrupts[i].in_lr = false;
        vcpu->arch.vgic_priv.interrupts[i].enabled = false;
    fd8000007dec:	381f203f 	sturb	wzr, [x1, #-14]
    for (size_t i = 0; i < GIC_CPU_PRIV; i++) {
    fd8000007df0:	54fffec1 	b.ne	fd8000007dc8 <vgic_cpu_init+0x18>  // b.any
    fd8000007df4:	9109b801 	add	x1, x0, #0x26e
    fd8000007df8:	9117b803 	add	x3, x0, #0x5ee
    }

    for (size_t i = 0; i < GIC_MAX_SGIS; i++) {
        vcpu->arch.vgic_priv.interrupts[i].cfg = 0b10;
    fd8000007dfc:	52800042 	mov	w2, #0x2                   	// #2
    fd8000007e00:	38038422 	strb	w2, [x1], #56
    for (size_t i = 0; i < GIC_MAX_SGIS; i++) {
    fd8000007e04:	eb01007f 	cmp	x3, x1
    fd8000007e08:	54ffffc1 	b.ne	fd8000007e00 <vgic_cpu_init+0x50>  // b.any
        list->head = NULL;
    fd8000007e0c:	f904a01f 	str	xzr, [x0, #2368]
        list->tail = NULL;
    fd8000007e10:	f904a41f 	str	xzr, [x0, #2376]
        list->lock = SPINLOCK_INITVAL;
    fd8000007e14:	f904a81f 	str	xzr, [x0, #2384]
    }

    list_init(&vcpu->arch.vgic_spilled);
}
    fd8000007e18:	d65f03c0 	ret
    fd8000007e1c:	00000000 	udf	#0

0000fd8000007e20 <gich_num_lrs>:
SYSREG_GEN_ACCESSORS(ich_vtr_el2);
    fd8000007e20:	d53ccb20 	mrs	x0, ich_vtr_el2

size_t NUM_LRS;

size_t gich_num_lrs()
{
    return ((sysreg_ich_vtr_el2_read() & ICH_VTR_MSK) >> ICH_VTR_OFF) + 1;
    fd8000007e24:	92401400 	and	x0, x0, #0x3f
}
    fd8000007e28:	91000400 	add	x0, x0, #0x1
    fd8000007e2c:	d65f03c0 	ret

0000fd8000007e30 <gicc_save_state>:
SYSREG_GEN_ACCESSORS(icc_pmr_el1);
    fd8000007e30:	d5384601 	mrs	x1, icc_pmr_el1
    }
}

void gicc_save_state(struct gicc_state* state)
{
    state->PMR = sysreg_icc_pmr_el1_read();
    fd8000007e34:	b9000401 	str	w1, [x0, #4]
SYSREG_GEN_ACCESSORS(icc_bpr1_el1);
    fd8000007e38:	d538cc62 	mrs	x2, icc_bpr1_el1
    state->BPR = sysreg_icc_bpr1_el1_read();
    state->priv_ISENABLER = gicr[cpu()->id].ISENABLER0;
    fd8000007e3c:	90000001 	adrp	x1, fd8000007000 <psci_cpu_on_handler+0x110>
    fd8000007e40:	f947c825 	ldr	x5, [x1, #3984]
    fd8000007e44:	d2dfc003 	mov	x3, #0xfe0000000000        	// #279275953455104
    fd8000007e48:	91008004 	add	x4, x0, #0x20

    for (size_t i = 0; i < GIC_NUM_PRIO_REGS(GIC_CPU_PRIV); i++) {
    fd8000007e4c:	d2800001 	mov	x1, #0x0                   	// #0
    state->priv_ISENABLER = gicr[cpu()->id].ISENABLER0;
    fd8000007e50:	f9400063 	ldr	x3, [x3]
    state->BPR = sysreg_icc_bpr1_el1_read();
    fd8000007e54:	b9000802 	str	w2, [x0, #8]
    state->priv_ISENABLER = gicr[cpu()->id].ISENABLER0;
    fd8000007e58:	f94000a2 	ldr	x2, [x5]
    fd8000007e5c:	8b034443 	add	x3, x2, x3, lsl #17
    fd8000007e60:	91404062 	add	x2, x3, #0x10, lsl #12
    fd8000007e64:	b9410042 	ldr	w2, [x2, #256]
    fd8000007e68:	b9001c02 	str	w2, [x0, #28]
    for (size_t i = 0; i < GIC_NUM_PRIO_REGS(GIC_CPU_PRIV); i++) {
    fd8000007e6c:	d503201f 	nop
        state->priv_IPRIORITYR[i] = gicr[cpu()->id].IPRIORITYR[i];
    fd8000007e70:	91401022 	add	x2, x1, #0x4, lsl #12
    fd8000007e74:	8b020862 	add	x2, x3, x2, lsl #2
    fd8000007e78:	b9440042 	ldr	w2, [x2, #1024]
    fd8000007e7c:	b8217882 	str	w2, [x4, x1, lsl #2]
    for (size_t i = 0; i < GIC_NUM_PRIO_REGS(GIC_CPU_PRIV); i++) {
    fd8000007e80:	91000421 	add	x1, x1, #0x1
    fd8000007e84:	f100203f 	cmp	x1, #0x8
    fd8000007e88:	54ffff41 	b.ne	fd8000007e70 <gicc_save_state+0x40>  // b.any
SYSREG_GEN_ACCESSORS(ich_hcr_el2);
    fd8000007e8c:	d53ccb01 	mrs	x1, ich_hcr_el2
    }

    state->HCR = sysreg_ich_hcr_el2_read();
    fd8000007e90:	b9004001 	str	w1, [x0, #64]
SYSREG_GEN_ACCESSORS(ich_vtr_el2);
    fd8000007e94:	d53ccb21 	mrs	x1, ich_vtr_el2
    if (i >= NUM_LRS) {
    fd8000007e98:	f94004a3 	ldr	x3, [x5, #8]
    fd8000007e9c:	91012001 	add	x1, x0, #0x48
    for (size_t i = 0; i < gich_num_lrs(); i++) {
    fd8000007ea0:	d2800000 	mov	x0, #0x0                   	// #0
    fd8000007ea4:	eb00007f 	cmp	x3, x0
    fd8000007ea8:	540001a0 	b.eq	fd8000007edc <gicc_save_state+0xac>  // b.none
    switch (i) {
    fd8000007eac:	f1003c1f 	cmp	x0, #0xf
    fd8000007eb0:	54000068 	b.hi	fd8000007ebc <gicc_save_state+0x8c>  // b.pmore
    fd8000007eb4:	71003c1f 	cmp	w0, #0xf
    fd8000007eb8:	54000069 	b.ls	fd8000007ec4 <gicc_save_state+0x94>  // b.plast
    fd8000007ebc:	d2800002 	mov	x2, #0x0                   	// #0
    fd8000007ec0:	1400000e 	b	fd8000007ef8 <gicc_save_state+0xc8>
    fd8000007ec4:	90000002 	adrp	x2, fd8000007000 <psci_cpu_on_handler+0x110>
    fd8000007ec8:	f947d042 	ldr	x2, [x2, #4000]
    fd8000007ecc:	38604842 	ldrb	w2, [x2, w0, uxtw]
    fd8000007ed0:	10000064 	adr	x4, fd8000007edc <gicc_save_state+0xac>
    fd8000007ed4:	8b228882 	add	x2, x4, w2, sxtb #2
    fd8000007ed8:	d61f0040 	br	x2
{
    fd8000007edc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    fd8000007ee0:	910003fd 	mov	x29, sp
        ERROR("gic: trying to read inexistent list register");
    fd8000007ee4:	90000000 	adrp	x0, fd8000007000 <psci_cpu_on_handler+0x110>
    fd8000007ee8:	f947cc00 	ldr	x0, [x0, #3992]
    fd8000007eec:	9400104d 	bl	fd800000c020 <console_printk>
    fd8000007ef0:	14000000 	b	fd8000007ef0 <gicc_save_state+0xc0>
SYSREG_GEN_ACCESSORS(ich_lr14_el2);
    fd8000007ef4:	d53ccdc2 	mrs	x2, ich_lr14_el2
        state->LR[i] = gich_read_lr(i);
    fd8000007ef8:	f8207822 	str	x2, [x1, x0, lsl #3]
    for (size_t i = 0; i < gich_num_lrs(); i++) {
    fd8000007efc:	91000400 	add	x0, x0, #0x1
SYSREG_GEN_ACCESSORS(ich_vtr_el2);
    fd8000007f00:	d53ccb22 	mrs	x2, ich_vtr_el2
    return ((sysreg_ich_vtr_el2_read() & ICH_VTR_MSK) >> ICH_VTR_OFF) + 1;
    fd8000007f04:	92401442 	and	x2, x2, #0x3f
    fd8000007f08:	91000442 	add	x2, x2, #0x1
    for (size_t i = 0; i < gich_num_lrs(); i++) {
    fd8000007f0c:	eb02001f 	cmp	x0, x2
    fd8000007f10:	54fffca3 	b.cc	fd8000007ea4 <gicc_save_state+0x74>  // b.lo, b.ul, b.last
    fd8000007f14:	d65f03c0 	ret
SYSREG_GEN_ACCESSORS(ich_lr15_el2);
    fd8000007f18:	d53ccde2 	mrs	x2, ich_lr15_el2
            return sysreg_ich_lr15_el2_read();
    fd8000007f1c:	17fffff7 	b	fd8000007ef8 <gicc_save_state+0xc8>
SYSREG_GEN_ACCESSORS(ich_lr0_el2);
    fd8000007f20:	d53ccc02 	mrs	x2, ich_lr0_el2
            return sysreg_ich_lr0_el2_read();
    fd8000007f24:	17fffff5 	b	fd8000007ef8 <gicc_save_state+0xc8>
SYSREG_GEN_ACCESSORS(ich_lr1_el2);
    fd8000007f28:	d53ccc22 	mrs	x2, ich_lr1_el2
            return sysreg_ich_lr1_el2_read();
    fd8000007f2c:	17fffff3 	b	fd8000007ef8 <gicc_save_state+0xc8>
SYSREG_GEN_ACCESSORS(ich_lr2_el2);
    fd8000007f30:	d53ccc42 	mrs	x2, ich_lr2_el2
            return sysreg_ich_lr2_el2_read();
    fd8000007f34:	17fffff1 	b	fd8000007ef8 <gicc_save_state+0xc8>
SYSREG_GEN_ACCESSORS(ich_lr3_el2);
    fd8000007f38:	d53ccc62 	mrs	x2, ich_lr3_el2
            return sysreg_ich_lr3_el2_read();
    fd8000007f3c:	17ffffef 	b	fd8000007ef8 <gicc_save_state+0xc8>
SYSREG_GEN_ACCESSORS(ich_lr4_el2);
    fd8000007f40:	d53ccc82 	mrs	x2, ich_lr4_el2
            return sysreg_ich_lr4_el2_read();
    fd8000007f44:	17ffffed 	b	fd8000007ef8 <gicc_save_state+0xc8>
SYSREG_GEN_ACCESSORS(ich_lr5_el2);
    fd8000007f48:	d53ccca2 	mrs	x2, ich_lr5_el2
            return sysreg_ich_lr5_el2_read();
    fd8000007f4c:	17ffffeb 	b	fd8000007ef8 <gicc_save_state+0xc8>
SYSREG_GEN_ACCESSORS(ich_lr6_el2);
    fd8000007f50:	d53cccc2 	mrs	x2, ich_lr6_el2
            return sysreg_ich_lr6_el2_read();
    fd8000007f54:	17ffffe9 	b	fd8000007ef8 <gicc_save_state+0xc8>
SYSREG_GEN_ACCESSORS(ich_lr7_el2);
    fd8000007f58:	d53ccce2 	mrs	x2, ich_lr7_el2
            return sysreg_ich_lr7_el2_read();
    fd8000007f5c:	17ffffe7 	b	fd8000007ef8 <gicc_save_state+0xc8>
SYSREG_GEN_ACCESSORS(ich_lr8_el2);
    fd8000007f60:	d53ccd02 	mrs	x2, ich_lr8_el2
            return sysreg_ich_lr8_el2_read();
    fd8000007f64:	17ffffe5 	b	fd8000007ef8 <gicc_save_state+0xc8>
SYSREG_GEN_ACCESSORS(ich_lr9_el2);
    fd8000007f68:	d53ccd22 	mrs	x2, ich_lr9_el2
            return sysreg_ich_lr9_el2_read();
    fd8000007f6c:	17ffffe3 	b	fd8000007ef8 <gicc_save_state+0xc8>
SYSREG_GEN_ACCESSORS(ich_lr10_el2);
    fd8000007f70:	d53ccd42 	mrs	x2, ich_lr10_el2
            return sysreg_ich_lr10_el2_read();
    fd8000007f74:	17ffffe1 	b	fd8000007ef8 <gicc_save_state+0xc8>
SYSREG_GEN_ACCESSORS(ich_lr11_el2);
    fd8000007f78:	d53ccd62 	mrs	x2, ich_lr11_el2
            return sysreg_ich_lr11_el2_read();
    fd8000007f7c:	17ffffdf 	b	fd8000007ef8 <gicc_save_state+0xc8>
SYSREG_GEN_ACCESSORS(ich_lr12_el2);
    fd8000007f80:	d53ccd82 	mrs	x2, ich_lr12_el2
            return sysreg_ich_lr12_el2_read();
    fd8000007f84:	17ffffdd 	b	fd8000007ef8 <gicc_save_state+0xc8>
SYSREG_GEN_ACCESSORS(ich_lr13_el2);
    fd8000007f88:	d53ccda2 	mrs	x2, ich_lr13_el2
            return sysreg_ich_lr13_el2_read();
    fd8000007f8c:	17ffffdb 	b	fd8000007ef8 <gicc_save_state+0xc8>
    fd8000007f90:	00013080 	.word	0x00013080
    fd8000007f94:	0000fd80 	.word	0x0000fd80
    fd8000007f98:	000107d8 	.word	0x000107d8
    fd8000007f9c:	0000fd80 	.word	0x0000fd80
    fd8000007fa0:	000111f0 	.word	0x000111f0
    fd8000007fa4:	0000fd80 	.word	0x0000fd80
    fd8000007fa8:	d503201f 	nop
    fd8000007fac:	d503201f 	nop

0000fd8000007fb0 <gicc_restore_state>:
SYSREG_GEN_ACCESSORS(icc_sre_el2);
    fd8000007fb0:	d2800021 	mov	x1, #0x1                   	// #1
    fd8000007fb4:	d51cc9a1 	msr	icc_sre_el2, x1
SYSREG_GEN_ACCESSORS(icc_ctlr_el1);
    fd8000007fb8:	d2800042 	mov	x2, #0x2                   	// #2
    fd8000007fbc:	d518cc82 	msr	icc_ctlr_el1, x2
SYSREG_GEN_ACCESSORS(icc_igrpen1_el1);
    fd8000007fc0:	d518cce1 	msr	icc_igrpen1_el1, x1
void gicc_restore_state(struct gicc_state* state)
{
    sysreg_icc_sre_el2_write(ICC_SRE_SRE_BIT);
    sysreg_icc_ctlr_el1_write(ICC_CTLR_EOIMode_BIT);
    sysreg_icc_igrpen1_el1_write(ICC_IGRPEN_EL1_ENB_BIT);
    sysreg_icc_pmr_el1_write(state->PMR);
    fd8000007fc4:	b9400401 	ldr	w1, [x0, #4]
SYSREG_GEN_ACCESSORS(icc_pmr_el1);
    fd8000007fc8:	d5184601 	msr	icc_pmr_el1, x1
    sysreg_icc_bpr1_el1_write(state->BPR);
    fd8000007fcc:	b9400801 	ldr	w1, [x0, #8]
SYSREG_GEN_ACCESSORS(icc_bpr1_el1);
    fd8000007fd0:	d518cc61 	msr	icc_bpr1_el1, x1
    gicr[cpu()->id].ISENABLER0 = state->priv_ISENABLER;
    fd8000007fd4:	b0000001 	adrp	x1, fd8000008000 <gicc_restore_state+0x50>
    fd8000007fd8:	f9409026 	ldr	x6, [x1, #288]
    fd8000007fdc:	d2dfc001 	mov	x1, #0xfe0000000000        	// #279275953455104
    fd8000007fe0:	b9401c03 	ldr	w3, [x0, #28]
    fd8000007fe4:	91008005 	add	x5, x0, #0x20
    fd8000007fe8:	f9400024 	ldr	x4, [x1]

    for (size_t i = 0; i < GIC_NUM_PRIO_REGS(GIC_CPU_PRIV); i++) {
    fd8000007fec:	d2800001 	mov	x1, #0x0                   	// #0
    gicr[cpu()->id].ISENABLER0 = state->priv_ISENABLER;
    fd8000007ff0:	f94000c2 	ldr	x2, [x6]
    fd8000007ff4:	8b044444 	add	x4, x2, x4, lsl #17
    fd8000007ff8:	91404082 	add	x2, x4, #0x10, lsl #12
    fd8000007ffc:	b9010043 	str	w3, [x2, #256]
        gicr[cpu()->id].IPRIORITYR[i] = state->priv_IPRIORITYR[i];
    fd8000008000:	91401022 	add	x2, x1, #0x4, lsl #12
    fd8000008004:	b86178a3 	ldr	w3, [x5, x1, lsl #2]
    for (size_t i = 0; i < GIC_NUM_PRIO_REGS(GIC_CPU_PRIV); i++) {
    fd8000008008:	91000421 	add	x1, x1, #0x1
        gicr[cpu()->id].IPRIORITYR[i] = state->priv_IPRIORITYR[i];
    fd800000800c:	8b020882 	add	x2, x4, x2, lsl #2
    for (size_t i = 0; i < GIC_NUM_PRIO_REGS(GIC_CPU_PRIV); i++) {
    fd8000008010:	f100203f 	cmp	x1, #0x8
        gicr[cpu()->id].IPRIORITYR[i] = state->priv_IPRIORITYR[i];
    fd8000008014:	b9040043 	str	w3, [x2, #1024]
    for (size_t i = 0; i < GIC_NUM_PRIO_REGS(GIC_CPU_PRIV); i++) {
    fd8000008018:	54ffff41 	b.ne	fd8000008000 <gicc_restore_state+0x50>  // b.any
    }

    sysreg_ich_hcr_el2_write(state->HCR);
    fd800000801c:	b9404001 	ldr	w1, [x0, #64]
SYSREG_GEN_ACCESSORS(ich_hcr_el2);
    fd8000008020:	d51ccb01 	msr	ich_hcr_el2, x1
SYSREG_GEN_ACCESSORS(ich_vtr_el2);
    fd8000008024:	d53ccb21 	mrs	x1, ich_vtr_el2
    if (i >= NUM_LRS) {
    fd8000008028:	f94004c3 	ldr	x3, [x6, #8]
    fd800000802c:	91012001 	add	x1, x0, #0x48
    for (size_t i = 0; i < gich_num_lrs(); i++) {
    fd8000008030:	d2800000 	mov	x0, #0x0                   	// #0
        gich_write_lr(i, state->LR[i]);
    fd8000008034:	f8607822 	ldr	x2, [x1, x0, lsl #3]
    fd8000008038:	eb00007f 	cmp	x3, x0
    fd800000803c:	54000280 	b.eq	fd800000808c <gicc_restore_state+0xdc>  // b.none
    switch (i) {
    fd8000008040:	f1003c1f 	cmp	x0, #0xf
    fd8000008044:	54000168 	b.hi	fd8000008070 <gicc_restore_state+0xc0>  // b.pmore
    fd8000008048:	71003c1f 	cmp	w0, #0xf
    fd800000804c:	54000128 	b.hi	fd8000008070 <gicc_restore_state+0xc0>  // b.pmore
    fd8000008050:	90000004 	adrp	x4, fd8000008000 <gicc_restore_state+0x50>
    fd8000008054:	f9409884 	ldr	x4, [x4, #304]
    fd8000008058:	38604884 	ldrb	w4, [x4, w0, uxtw]
    fd800000805c:	10000065 	adr	x5, fd8000008068 <gicc_restore_state+0xb8>
    fd8000008060:	8b2488a4 	add	x4, x5, w4, sxtb #2
    fd8000008064:	d61f0080 	br	x4
SYSREG_GEN_ACCESSORS(ich_lr0_el2);
    fd8000008068:	d51ccc02 	msr	ich_lr0_el2, x2
            break;
    fd800000806c:	d503201f 	nop
    for (size_t i = 0; i < gich_num_lrs(); i++) {
    fd8000008070:	91000400 	add	x0, x0, #0x1
SYSREG_GEN_ACCESSORS(ich_vtr_el2);
    fd8000008074:	d53ccb22 	mrs	x2, ich_vtr_el2
    return ((sysreg_ich_vtr_el2_read() & ICH_VTR_MSK) >> ICH_VTR_OFF) + 1;
    fd8000008078:	92401442 	and	x2, x2, #0x3f
    fd800000807c:	91000442 	add	x2, x2, #0x1
    for (size_t i = 0; i < gich_num_lrs(); i++) {
    fd8000008080:	eb02001f 	cmp	x0, x2
    fd8000008084:	54fffd83 	b.cc	fd8000008034 <gicc_restore_state+0x84>  // b.lo, b.ul, b.last
    fd8000008088:	d65f03c0 	ret
{
    fd800000808c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    fd8000008090:	910003fd 	mov	x29, sp
        ERROR("gic: trying to write inexistent list register");
    fd8000008094:	90000000 	adrp	x0, fd8000008000 <gicc_restore_state+0x50>
    fd8000008098:	f9409400 	ldr	x0, [x0, #296]
    fd800000809c:	94000fe1 	bl	fd800000c020 <console_printk>
    fd80000080a0:	14000000 	b	fd80000080a0 <gicc_restore_state+0xf0>
SYSREG_GEN_ACCESSORS(ich_lr15_el2);
    fd80000080a4:	d51ccde2 	msr	ich_lr15_el2, x2
    fd80000080a8:	17fffff2 	b	fd8000008070 <gicc_restore_state+0xc0>
SYSREG_GEN_ACCESSORS(ich_lr1_el2);
    fd80000080ac:	d51ccc22 	msr	ich_lr1_el2, x2
    fd80000080b0:	17fffff0 	b	fd8000008070 <gicc_restore_state+0xc0>
SYSREG_GEN_ACCESSORS(ich_lr2_el2);
    fd80000080b4:	d51ccc42 	msr	ich_lr2_el2, x2
    fd80000080b8:	17ffffee 	b	fd8000008070 <gicc_restore_state+0xc0>
SYSREG_GEN_ACCESSORS(ich_lr3_el2);
    fd80000080bc:	d51ccc62 	msr	ich_lr3_el2, x2
    fd80000080c0:	17ffffec 	b	fd8000008070 <gicc_restore_state+0xc0>
SYSREG_GEN_ACCESSORS(ich_lr4_el2);
    fd80000080c4:	d51ccc82 	msr	ich_lr4_el2, x2
    fd80000080c8:	17ffffea 	b	fd8000008070 <gicc_restore_state+0xc0>
SYSREG_GEN_ACCESSORS(ich_lr5_el2);
    fd80000080cc:	d51ccca2 	msr	ich_lr5_el2, x2
    fd80000080d0:	17ffffe8 	b	fd8000008070 <gicc_restore_state+0xc0>
SYSREG_GEN_ACCESSORS(ich_lr6_el2);
    fd80000080d4:	d51cccc2 	msr	ich_lr6_el2, x2
    fd80000080d8:	17ffffe6 	b	fd8000008070 <gicc_restore_state+0xc0>
SYSREG_GEN_ACCESSORS(ich_lr7_el2);
    fd80000080dc:	d51ccce2 	msr	ich_lr7_el2, x2
    fd80000080e0:	17ffffe4 	b	fd8000008070 <gicc_restore_state+0xc0>
SYSREG_GEN_ACCESSORS(ich_lr8_el2);
    fd80000080e4:	d51ccd02 	msr	ich_lr8_el2, x2
    fd80000080e8:	17ffffe2 	b	fd8000008070 <gicc_restore_state+0xc0>
SYSREG_GEN_ACCESSORS(ich_lr9_el2);
    fd80000080ec:	d51ccd22 	msr	ich_lr9_el2, x2
    fd80000080f0:	17ffffe0 	b	fd8000008070 <gicc_restore_state+0xc0>
SYSREG_GEN_ACCESSORS(ich_lr10_el2);
    fd80000080f4:	d51ccd42 	msr	ich_lr10_el2, x2
    fd80000080f8:	17ffffde 	b	fd8000008070 <gicc_restore_state+0xc0>
SYSREG_GEN_ACCESSORS(ich_lr11_el2);
    fd80000080fc:	d51ccd62 	msr	ich_lr11_el2, x2
    fd8000008100:	17ffffdc 	b	fd8000008070 <gicc_restore_state+0xc0>
SYSREG_GEN_ACCESSORS(ich_lr12_el2);
    fd8000008104:	d51ccd82 	msr	ich_lr12_el2, x2
    fd8000008108:	17ffffda 	b	fd8000008070 <gicc_restore_state+0xc0>
SYSREG_GEN_ACCESSORS(ich_lr13_el2);
    fd800000810c:	d51ccda2 	msr	ich_lr13_el2, x2
    fd8000008110:	17ffffd8 	b	fd8000008070 <gicc_restore_state+0xc0>
SYSREG_GEN_ACCESSORS(ich_lr14_el2);
    fd8000008114:	d51ccdc2 	msr	ich_lr14_el2, x2
    fd8000008118:	17ffffd6 	b	fd8000008070 <gicc_restore_state+0xc0>
    fd800000811c:	d503201f 	nop
    fd8000008120:	00013080 	.word	0x00013080
    fd8000008124:	0000fd80 	.word	0x0000fd80
    fd8000008128:	00010818 	.word	0x00010818
    fd800000812c:	0000fd80 	.word	0x0000fd80
    fd8000008130:	00011200 	.word	0x00011200
    fd8000008134:	0000fd80 	.word	0x0000fd80
    fd8000008138:	d503201f 	nop
    fd800000813c:	d503201f 	nop

0000fd8000008140 <gic_cpu_init>:
    gicr[cpu()->id].WAKER &= ~GICR_WAKER_ProcessorSleep_BIT;
    fd8000008140:	90000000 	adrp	x0, fd8000008000 <gicc_restore_state+0x50>
    fd8000008144:	f9418402 	ldr	x2, [x0, #776]
    fd8000008148:	d2dfc000 	mov	x0, #0xfe0000000000        	// #279275953455104
    fd800000814c:	f9400000 	ldr	x0, [x0]
    fd8000008150:	f9400041 	ldr	x1, [x2]
    fd8000008154:	8b004420 	add	x0, x1, x0, lsl #17
    fd8000008158:	b9401401 	ldr	w1, [x0, #20]
    fd800000815c:	121e7821 	and	w1, w1, #0xfffffffd
    fd8000008160:	b9001401 	str	w1, [x0, #20]
    while (gicr[cpu()->id].WAKER & GICR_WAKER_ChildrenASleep_BIT) { }
    fd8000008164:	d503201f 	nop
    fd8000008168:	b9401401 	ldr	w1, [x0, #20]
    fd800000816c:	3717ffe1 	tbnz	w1, #2, fd8000008168 <gic_cpu_init+0x28>
    gicr[cpu()->id].IGROUPR0 = -1;
    fd8000008170:	91404000 	add	x0, x0, #0x10, lsl #12
    fd8000008174:	12800001 	mov	w1, #0xffffffff            	// #-1
    fd8000008178:	b9008001 	str	w1, [x0, #128]
    gicr[cpu()->id].ICENABLER0 = -1;
    fd800000817c:	b9018001 	str	w1, [x0, #384]
    gicr[cpu()->id].ICPENDR0 = -1;
    fd8000008180:	b9028001 	str	w1, [x0, #640]
    gicr[cpu()->id].ICACTIVER0 = -1;
    fd8000008184:	b9038001 	str	w1, [x0, #896]
        gicr[cpu()->id].IPRIORITYR[i] = -1;
    fd8000008188:	b9040001 	str	w1, [x0, #1024]
    fd800000818c:	b9040401 	str	w1, [x0, #1028]
    fd8000008190:	b9040801 	str	w1, [x0, #1032]
    fd8000008194:	b9040c01 	str	w1, [x0, #1036]
    fd8000008198:	b9041001 	str	w1, [x0, #1040]
    fd800000819c:	b9041401 	str	w1, [x0, #1044]
    fd80000081a0:	b9041801 	str	w1, [x0, #1048]
    fd80000081a4:	b9041c01 	str	w1, [x0, #1052]
SYSREG_GEN_ACCESSORS(ich_vtr_el2);
    fd80000081a8:	d53ccb20 	mrs	x0, ich_vtr_el2
    if (i >= NUM_LRS) {
    fd80000081ac:	f9400442 	ldr	x2, [x2, #8]
    for (size_t i = 0; i < gich_num_lrs(); i++) {
    fd80000081b0:	d2800000 	mov	x0, #0x0                   	// #0
    fd80000081b4:	eb00005f 	cmp	x2, x0
    fd80000081b8:	54000400 	b.eq	fd8000008238 <gic_cpu_init+0xf8>  // b.none
    switch (i) {
    fd80000081bc:	f1003c1f 	cmp	x0, #0xf
    fd80000081c0:	54000188 	b.hi	fd80000081f0 <gic_cpu_init+0xb0>  // b.pmore
    fd80000081c4:	71003c1f 	cmp	w0, #0xf
    fd80000081c8:	54000148 	b.hi	fd80000081f0 <gic_cpu_init+0xb0>  // b.pmore
    fd80000081cc:	90000001 	adrp	x1, fd8000008000 <gicc_restore_state+0x50>
    fd80000081d0:	f9418c21 	ldr	x1, [x1, #792]
    fd80000081d4:	38604821 	ldrb	w1, [x1, w0, uxtw]
    fd80000081d8:	10000063 	adr	x3, fd80000081e4 <gic_cpu_init+0xa4>
    fd80000081dc:	8b218861 	add	x1, x3, w1, sxtb #2
    fd80000081e0:	d61f0020 	br	x1
SYSREG_GEN_ACCESSORS(ich_lr0_el2);
    fd80000081e4:	d2800001 	mov	x1, #0x0                   	// #0
    fd80000081e8:	d51ccc01 	msr	ich_lr0_el2, x1
            break;
    fd80000081ec:	d503201f 	nop
    fd80000081f0:	91000400 	add	x0, x0, #0x1
SYSREG_GEN_ACCESSORS(ich_vtr_el2);
    fd80000081f4:	d53ccb21 	mrs	x1, ich_vtr_el2
    return ((sysreg_ich_vtr_el2_read() & ICH_VTR_MSK) >> ICH_VTR_OFF) + 1;
    fd80000081f8:	92401421 	and	x1, x1, #0x3f
    fd80000081fc:	91000421 	add	x1, x1, #0x1
    for (size_t i = 0; i < gich_num_lrs(); i++) {
    fd8000008200:	eb01001f 	cmp	x0, x1
    fd8000008204:	54fffd83 	b.cc	fd80000081b4 <gic_cpu_init+0x74>  // b.lo, b.ul, b.last
SYSREG_GEN_ACCESSORS(icc_pmr_el1);
    fd8000008208:	d2801fe0 	mov	x0, #0xff                  	// #255
    fd800000820c:	d5184600 	msr	icc_pmr_el1, x0
SYSREG_GEN_ACCESSORS(icc_bpr1_el1);
    fd8000008210:	d2800000 	mov	x0, #0x0                   	// #0
    fd8000008214:	d518cc60 	msr	icc_bpr1_el1, x0
SYSREG_GEN_ACCESSORS(icc_ctlr_el1);
    fd8000008218:	d2800040 	mov	x0, #0x2                   	// #2
    fd800000821c:	d518cc80 	msr	icc_ctlr_el1, x0
SYSREG_GEN_ACCESSORS(ich_hcr_el2);
    fd8000008220:	d53ccb00 	mrs	x0, ich_hcr_el2
    sysreg_ich_hcr_el2_write(sysreg_ich_hcr_el2_read() | ICH_HCR_LRENPIE_BIT);
    fd8000008224:	b27e0000 	orr	x0, x0, #0x4
    fd8000008228:	d51ccb00 	msr	ich_hcr_el2, x0
SYSREG_GEN_ACCESSORS(icc_igrpen1_el1);
    fd800000822c:	d2800020 	mov	x0, #0x1                   	// #1
    fd8000008230:	d518cce0 	msr	icc_igrpen1_el1, x0
    fd8000008234:	d65f03c0 	ret
    }
}

void gic_cpu_init()
{
    fd8000008238:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    fd800000823c:	910003fd 	mov	x29, sp
        ERROR("gic: trying to write inexistent list register");
    fd8000008240:	90000000 	adrp	x0, fd8000008000 <gicc_restore_state+0x50>
    fd8000008244:	f9418800 	ldr	x0, [x0, #784]
    fd8000008248:	94000f76 	bl	fd800000c020 <console_printk>
    fd800000824c:	14000000 	b	fd800000824c <gic_cpu_init+0x10c>
SYSREG_GEN_ACCESSORS(ich_lr14_el2);
    fd8000008250:	d2800001 	mov	x1, #0x0                   	// #0
    fd8000008254:	d51ccdc1 	msr	ich_lr14_el2, x1
    fd8000008258:	17ffffe6 	b	fd80000081f0 <gic_cpu_init+0xb0>
SYSREG_GEN_ACCESSORS(ich_lr15_el2);
    fd800000825c:	d2800001 	mov	x1, #0x0                   	// #0
    fd8000008260:	d51ccde1 	msr	ich_lr15_el2, x1
    fd8000008264:	17ffffe3 	b	fd80000081f0 <gic_cpu_init+0xb0>
SYSREG_GEN_ACCESSORS(ich_lr1_el2);
    fd8000008268:	d2800001 	mov	x1, #0x0                   	// #0
    fd800000826c:	d51ccc21 	msr	ich_lr1_el2, x1
    fd8000008270:	17ffffe0 	b	fd80000081f0 <gic_cpu_init+0xb0>
SYSREG_GEN_ACCESSORS(ich_lr2_el2);
    fd8000008274:	d2800001 	mov	x1, #0x0                   	// #0
    fd8000008278:	d51ccc41 	msr	ich_lr2_el2, x1
    fd800000827c:	17ffffdd 	b	fd80000081f0 <gic_cpu_init+0xb0>
SYSREG_GEN_ACCESSORS(ich_lr3_el2);
    fd8000008280:	d2800001 	mov	x1, #0x0                   	// #0
    fd8000008284:	d51ccc61 	msr	ich_lr3_el2, x1
    fd8000008288:	17ffffda 	b	fd80000081f0 <gic_cpu_init+0xb0>
SYSREG_GEN_ACCESSORS(ich_lr4_el2);
    fd800000828c:	d2800001 	mov	x1, #0x0                   	// #0
    fd8000008290:	d51ccc81 	msr	ich_lr4_el2, x1
    fd8000008294:	17ffffd7 	b	fd80000081f0 <gic_cpu_init+0xb0>
SYSREG_GEN_ACCESSORS(ich_lr5_el2);
    fd8000008298:	d2800001 	mov	x1, #0x0                   	// #0
    fd800000829c:	d51ccca1 	msr	ich_lr5_el2, x1
    fd80000082a0:	17ffffd4 	b	fd80000081f0 <gic_cpu_init+0xb0>
SYSREG_GEN_ACCESSORS(ich_lr6_el2);
    fd80000082a4:	d2800001 	mov	x1, #0x0                   	// #0
    fd80000082a8:	d51cccc1 	msr	ich_lr6_el2, x1
    fd80000082ac:	17ffffd1 	b	fd80000081f0 <gic_cpu_init+0xb0>
SYSREG_GEN_ACCESSORS(ich_lr7_el2);
    fd80000082b0:	d2800001 	mov	x1, #0x0                   	// #0
    fd80000082b4:	d51ccce1 	msr	ich_lr7_el2, x1
    fd80000082b8:	17ffffce 	b	fd80000081f0 <gic_cpu_init+0xb0>
SYSREG_GEN_ACCESSORS(ich_lr8_el2);
    fd80000082bc:	d2800001 	mov	x1, #0x0                   	// #0
    fd80000082c0:	d51ccd01 	msr	ich_lr8_el2, x1
    fd80000082c4:	17ffffcb 	b	fd80000081f0 <gic_cpu_init+0xb0>
SYSREG_GEN_ACCESSORS(ich_lr9_el2);
    fd80000082c8:	d2800001 	mov	x1, #0x0                   	// #0
    fd80000082cc:	d51ccd21 	msr	ich_lr9_el2, x1
    fd80000082d0:	17ffffc8 	b	fd80000081f0 <gic_cpu_init+0xb0>
SYSREG_GEN_ACCESSORS(ich_lr10_el2);
    fd80000082d4:	d2800001 	mov	x1, #0x0                   	// #0
    fd80000082d8:	d51ccd41 	msr	ich_lr10_el2, x1
    fd80000082dc:	17ffffc5 	b	fd80000081f0 <gic_cpu_init+0xb0>
SYSREG_GEN_ACCESSORS(ich_lr11_el2);
    fd80000082e0:	d2800001 	mov	x1, #0x0                   	// #0
    fd80000082e4:	d51ccd61 	msr	ich_lr11_el2, x1
    fd80000082e8:	17ffffc2 	b	fd80000081f0 <gic_cpu_init+0xb0>
SYSREG_GEN_ACCESSORS(ich_lr12_el2);
    fd80000082ec:	d2800001 	mov	x1, #0x0                   	// #0
    fd80000082f0:	d51ccd81 	msr	ich_lr12_el2, x1
    fd80000082f4:	17ffffbf 	b	fd80000081f0 <gic_cpu_init+0xb0>
SYSREG_GEN_ACCESSORS(ich_lr13_el2);
    fd80000082f8:	d2800001 	mov	x1, #0x0                   	// #0
    fd80000082fc:	d51ccda1 	msr	ich_lr13_el2, x1
    fd8000008300:	17ffffbc 	b	fd80000081f0 <gic_cpu_init+0xb0>
    fd8000008304:	d503201f 	nop
    fd8000008308:	00013080 	.word	0x00013080
    fd800000830c:	0000fd80 	.word	0x0000fd80
    fd8000008310:	00010818 	.word	0x00010818
    fd8000008314:	0000fd80 	.word	0x0000fd80
    fd8000008318:	00011210 	.word	0x00011210
    fd800000831c:	0000fd80 	.word	0x0000fd80

0000fd8000008320 <gic_map_mmio>:
    gicr_init();
    gicc_init();
}

void gic_map_mmio()
{
    fd8000008320:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    gicd = (void*)mem_alloc_map_dev(&cpu()->as, SEC_HYP_GLOBAL, INVALID_VA,
    fd8000008324:	d2800204 	mov	x4, #0x10                  	// #16
    fd8000008328:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
{
    fd800000832c:	910003fd 	mov	x29, sp
    fd8000008330:	a90153f3 	stp	x19, x20, [sp, #16]
    gicd = (void*)mem_alloc_map_dev(&cpu()->as, SEC_HYP_GLOBAL, INVALID_VA,
    fd8000008334:	90000000 	adrp	x0, fd8000008000 <gicc_restore_state+0x50>
    fd8000008338:	f941cc14 	ldr	x20, [x0, #920]
    fd800000833c:	d2800213 	mov	x19, #0x10                  	// #16
    fd8000008340:	f2dfc013 	movk	x19, #0xfe00, lsl #32
    fd8000008344:	52800001 	mov	w1, #0x0                   	// #0
    fd8000008348:	aa1303e0 	mov	x0, x19
    fd800000834c:	f9411e83 	ldr	x3, [x20, #568]
    fd8000008350:	94001ac8 	bl	fd800000ee70 <mem_alloc_map_dev>
    fd8000008354:	aa0003e6 	mov	x6, x0
        platform.arch.gic.gicd_addr, NUM_PAGES(sizeof(struct gicd_hw)));
    gicr = (void*)mem_alloc_map_dev(&cpu()->as, SEC_HYP_GLOBAL, INVALID_VA,
    fd8000008358:	f9412283 	ldr	x3, [x20, #576]
    gicd = (void*)mem_alloc_map_dev(&cpu()->as, SEC_HYP_GLOBAL, INVALID_VA,
    fd800000835c:	90000000 	adrp	x0, fd8000008000 <gicc_restore_state+0x50>
    fd8000008360:	f941d005 	ldr	x5, [x0, #928]
    gicr = (void*)mem_alloc_map_dev(&cpu()->as, SEC_HYP_GLOBAL, INVALID_VA,
    fd8000008364:	d2801004 	mov	x4, #0x80                  	// #128
    fd8000008368:	aa1303e0 	mov	x0, x19
    fd800000836c:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
    fd8000008370:	52800001 	mov	w1, #0x0                   	// #0
    gicd = (void*)mem_alloc_map_dev(&cpu()->as, SEC_HYP_GLOBAL, INVALID_VA,
    fd8000008374:	f90000a6 	str	x6, [x5]
    gicr = (void*)mem_alloc_map_dev(&cpu()->as, SEC_HYP_GLOBAL, INVALID_VA,
    fd8000008378:	94001abe 	bl	fd800000ee70 <mem_alloc_map_dev>
    fd800000837c:	90000001 	adrp	x1, fd8000008000 <gicc_restore_state+0x50>
    fd8000008380:	f941d421 	ldr	x1, [x1, #936]
        platform.arch.gic.gicr_addr, NUM_PAGES(sizeof(struct gicr_hw) * PLAT_CPU_NUM));
}
    fd8000008384:	a94153f3 	ldp	x19, x20, [sp, #16]
    gicr = (void*)mem_alloc_map_dev(&cpu()->as, SEC_HYP_GLOBAL, INVALID_VA,
    fd8000008388:	f9000020 	str	x0, [x1]
}
    fd800000838c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    fd8000008390:	d65f03c0 	ret
    fd8000008394:	d503201f 	nop
    fd8000008398:	00012930 	.word	0x00012930
    fd800000839c:	0000fd80 	.word	0x0000fd80
    fd80000083a0:	00013070 	.word	0x00013070
    fd80000083a4:	0000fd80 	.word	0x0000fd80
    fd80000083a8:	00013080 	.word	0x00013080
    fd80000083ac:	0000fd80 	.word	0x0000fd80

0000fd80000083b0 <gicr_set_prio>:
    __asm__ volatile(
    fd80000083b0:	90000003 	adrp	x3, fd8000008000 <gicc_restore_state+0x50>
    fd80000083b4:	f9422064 	ldr	x4, [x3, #1088]

void gicr_set_prio(irqid_t int_id, uint8_t prio, cpuid_t gicr_id)
{
    size_t reg_ind = GIC_PRIO_REG(int_id);
    fd80000083b8:	531d7000 	lsl	w0, w0, #3
{
    fd80000083bc:	12001c21 	and	w1, w1, #0xff
    fd80000083c0:	121d0405 	and	w5, w0, #0x18
    fd80000083c4:	91004083 	add	x3, x4, #0x10
    fd80000083c8:	91005089 	add	x9, x4, #0x14
    fd80000083cc:	885ffc66 	ldaxr	w6, [x3]
    fd80000083d0:	110004c7 	add	w7, w6, #0x1
    fd80000083d4:	88087c67 	stxr	w8, w7, [x3]
    fd80000083d8:	35ffffa8 	cbnz	w8, fd80000083cc <gicr_set_prio+0x1c>
    fd80000083dc:	88dffd27 	ldar	w7, [x9]
    fd80000083e0:	6b0700df 	cmp	w6, w7
    fd80000083e4:	54000060 	b.eq	fd80000083f0 <gicr_set_prio+0x40>  // b.none
    fd80000083e8:	d503205f 	wfe
    fd80000083ec:	17fffffc 	b	fd80000083dc <gicr_set_prio+0x2c>
    size_t off = GIC_PRIO_OFF(int_id);
    uint32_t mask = BIT32_MASK(off, GIC_PRIO_BITS);

    spin_lock(&gicr_lock);

    gicr[gicr_id].IPRIORITYR[reg_ind] =
    fd80000083f0:	f9400084 	ldr	x4, [x4]
    fd80000083f4:	53057c00 	lsr	w0, w0, #5
        (gicr[gicr_id].IPRIORITYR[reg_ind] & ~mask) | ((prio << off) & mask);
    fd80000083f8:	d36fb842 	lsl	x2, x2, #17
    fd80000083fc:	1ac52021 	lsl	w1, w1, w5
    fd8000008400:	8b000840 	add	x0, x2, x0, lsl #2
    uint32_t mask = BIT32_MASK(off, GIC_PRIO_BITS);
    fd8000008404:	52801fe2 	mov	w2, #0xff                  	// #255
    fd8000008408:	8b000080 	add	x0, x4, x0
    fd800000840c:	1ac52042 	lsl	w2, w2, w5
        (gicr[gicr_id].IPRIORITYR[reg_ind] & ~mask) | ((prio << off) & mask);
    fd8000008410:	91404000 	add	x0, x0, #0x10, lsl #12
    fd8000008414:	b9440004 	ldr	w4, [x0, #1024]
    fd8000008418:	4a040021 	eor	w1, w1, w4
    fd800000841c:	0a020021 	and	w1, w1, w2
    fd8000008420:	4a040021 	eor	w1, w1, w4
    gicr[gicr_id].IPRIORITYR[reg_ind] =
    fd8000008424:	b9040001 	str	w1, [x0, #1024]
    __asm__ volatile(
    fd8000008428:	b9400120 	ldr	w0, [x9]
    fd800000842c:	11000400 	add	w0, w0, #0x1
    fd8000008430:	889ffd20 	stlr	w0, [x9]
    fd8000008434:	d5033b9f 	dsb	ish
    fd8000008438:	d503209f 	sev

    spin_unlock(&gicr_lock);
}
    fd800000843c:	d65f03c0 	ret
    fd8000008440:	00013080 	.word	0x00013080
    fd8000008444:	0000fd80 	.word	0x0000fd80
    fd8000008448:	d503201f 	nop
    fd800000844c:	d503201f 	nop

0000fd8000008450 <gicr_get_prio>:
    __asm__ volatile(
    fd8000008450:	90000002 	adrp	x2, fd8000008000 <gicc_restore_state+0x50>
    fd8000008454:	f9426445 	ldr	x5, [x2, #1224]

uint8_t gicr_get_prio(irqid_t int_id, cpuid_t gicr_id)
{
    size_t reg_ind = GIC_PRIO_REG(int_id);
    fd8000008458:	d3427004 	ubfx	x4, x0, #2, #27
    size_t off = GIC_PRIO_OFF(int_id);
    fd800000845c:	531d0403 	ubfiz	w3, w0, #3, #2
    fd8000008460:	910040a2 	add	x2, x5, #0x10
    fd8000008464:	910050a8 	add	x8, x5, #0x14
    fd8000008468:	885ffc40 	ldaxr	w0, [x2]
    fd800000846c:	11000406 	add	w6, w0, #0x1
    fd8000008470:	88077c46 	stxr	w7, w6, [x2]
    fd8000008474:	35ffffa7 	cbnz	w7, fd8000008468 <gicr_get_prio+0x18>
    fd8000008478:	88dffd06 	ldar	w6, [x8]
    fd800000847c:	6b06001f 	cmp	w0, w6
    fd8000008480:	54000060 	b.eq	fd800000848c <gicr_get_prio+0x3c>  // b.none
    fd8000008484:	d503205f 	wfe
    fd8000008488:	17fffffc 	b	fd8000008478 <gicr_get_prio+0x28>

    spin_lock(&gicr_lock);

    uint8_t prio = gicr[gicr_id].IPRIORITYR[reg_ind] >> off & BIT32_MASK(off, GIC_PRIO_BITS);
    fd800000848c:	f94000a0 	ldr	x0, [x5]
    fd8000008490:	91401084 	add	x4, x4, #0x4, lsl #12
    fd8000008494:	8b014401 	add	x1, x0, x1, lsl #17
    fd8000008498:	8b040824 	add	x4, x1, x4, lsl #2
    fd800000849c:	b9440080 	ldr	w0, [x4, #1024]
    __asm__ volatile(
    fd80000084a0:	b9400101 	ldr	w1, [x8]
    fd80000084a4:	11000421 	add	w1, w1, #0x1
    fd80000084a8:	889ffd01 	stlr	w1, [x8]
    fd80000084ac:	d5033b9f 	dsb	ish
    fd80000084b0:	d503209f 	sev
    fd80000084b4:	52801fe1 	mov	w1, #0xff                  	// #255
    fd80000084b8:	1ac32402 	lsr	w2, w0, w3
    fd80000084bc:	1ac32020 	lsl	w0, w1, w3

    spin_unlock(&gicr_lock);

    return prio;
}
    fd80000084c0:	0a000040 	and	w0, w2, w0
    fd80000084c4:	d65f03c0 	ret
    fd80000084c8:	00013080 	.word	0x00013080
    fd80000084cc:	0000fd80 	.word	0x0000fd80

0000fd80000084d0 <gicr_set_icfgr>:
    __asm__ volatile(
    fd80000084d0:	90000003 	adrp	x3, fd8000008000 <gicc_restore_state+0x50>
    fd80000084d4:	f942cc63 	ldr	x3, [x3, #1432]

void gicr_set_icfgr(irqid_t int_id, uint8_t cfg, cpuid_t gicr_id)
{
    size_t reg_ind = (int_id * GIC_CONFIG_BITS) / (sizeof(uint32_t) * 8);
    fd80000084d8:	531f7800 	lsl	w0, w0, #1
    size_t off = (int_id * GIC_CONFIG_BITS) % (sizeof(uint32_t) * 8);
    uint32_t mask = ((1U << GIC_CONFIG_BITS) - 1) << off;
    fd80000084dc:	52800064 	mov	w4, #0x3                   	// #3
{
    fd80000084e0:	12001c21 	and	w1, w1, #0xff
    fd80000084e4:	121f0c05 	and	w5, w0, #0x1e
    fd80000084e8:	91004069 	add	x9, x3, #0x10
    fd80000084ec:	9100506a 	add	x10, x3, #0x14
    uint32_t mask = ((1U << GIC_CONFIG_BITS) - 1) << off;
    fd80000084f0:	1ac02084 	lsl	w4, w4, w0
    fd80000084f4:	885ffd26 	ldaxr	w6, [x9]
    fd80000084f8:	110004c7 	add	w7, w6, #0x1
    fd80000084fc:	88087d27 	stxr	w8, w7, [x9]
    fd8000008500:	35ffffa8 	cbnz	w8, fd80000084f4 <gicr_set_icfgr+0x24>
    fd8000008504:	88dffd47 	ldar	w7, [x10]
    fd8000008508:	6b0700df 	cmp	w6, w7
    fd800000850c:	54000060 	b.eq	fd8000008518 <gicr_set_icfgr+0x48>  // b.none
    fd8000008510:	d503205f 	wfe
    fd8000008514:	17fffffc 	b	fd8000008504 <gicr_set_icfgr+0x34>

    spin_lock(&gicr_lock);

    if (reg_ind == 0) {
    fd8000008518:	71007c1f 	cmp	w0, #0x1f
        gicr[gicr_id].ICFGR0 = (gicr[gicr_id].ICFGR0 & ~mask) | ((cfg << off) & mask);
    fd800000851c:	d36fb842 	lsl	x2, x2, #17
    fd8000008520:	f9400060 	ldr	x0, [x3]
    fd8000008524:	1ac52021 	lsl	w1, w1, w5
    fd8000008528:	8b020000 	add	x0, x0, x2
    fd800000852c:	91404000 	add	x0, x0, #0x10, lsl #12
    if (reg_ind == 0) {
    fd8000008530:	540001a8 	b.hi	fd8000008564 <gicr_set_icfgr+0x94>  // b.pmore
        gicr[gicr_id].ICFGR0 = (gicr[gicr_id].ICFGR0 & ~mask) | ((cfg << off) & mask);
    fd8000008534:	b94c0002 	ldr	w2, [x0, #3072]
    fd8000008538:	4a010041 	eor	w1, w2, w1
    fd800000853c:	0a040021 	and	w1, w1, w4
    fd8000008540:	4a020021 	eor	w1, w1, w2
    fd8000008544:	b90c0001 	str	w1, [x0, #3072]
    __asm__ volatile(
    fd8000008548:	91005061 	add	x1, x3, #0x14
    fd800000854c:	b9400020 	ldr	w0, [x1]
    fd8000008550:	11000400 	add	w0, w0, #0x1
    fd8000008554:	889ffc20 	stlr	w0, [x1]
    fd8000008558:	d5033b9f 	dsb	ish
    fd800000855c:	d503209f 	sev
    } else {
        gicr[gicr_id].ICFGR1 = (gicr[gicr_id].ICFGR1 & ~mask) | ((cfg << off) & mask);
    }

    spin_unlock(&gicr_lock);
}
    fd8000008560:	d65f03c0 	ret
        gicr[gicr_id].ICFGR1 = (gicr[gicr_id].ICFGR1 & ~mask) | ((cfg << off) & mask);
    fd8000008564:	b94c0402 	ldr	w2, [x0, #3076]
    fd8000008568:	4a010041 	eor	w1, w2, w1
    fd800000856c:	0a040021 	and	w1, w1, w4
    fd8000008570:	4a020021 	eor	w1, w1, w2
    fd8000008574:	b90c0401 	str	w1, [x0, #3076]
    fd8000008578:	91005061 	add	x1, x3, #0x14
    fd800000857c:	b9400020 	ldr	w0, [x1]
    fd8000008580:	11000400 	add	w0, w0, #0x1
    fd8000008584:	889ffc20 	stlr	w0, [x1]
    fd8000008588:	d5033b9f 	dsb	ish
    fd800000858c:	d503209f 	sev
}
    fd8000008590:	d65f03c0 	ret
    fd8000008594:	d503201f 	nop
    fd8000008598:	00013080 	.word	0x00013080
    fd800000859c:	0000fd80 	.word	0x0000fd80

0000fd80000085a0 <gicr_set_pend>:
    __asm__ volatile(
    fd80000085a0:	90000003 	adrp	x3, fd8000008000 <gicc_restore_state+0x50>
    fd80000085a4:	f9432063 	ldr	x3, [x3, #1600]

void gicr_set_pend(irqid_t int_id, bool pend, cpuid_t gicr_id)
{
    fd80000085a8:	12001c21 	and	w1, w1, #0xff
    fd80000085ac:	91004067 	add	x7, x3, #0x10
    fd80000085b0:	91005068 	add	x8, x3, #0x14
    fd80000085b4:	885ffce4 	ldaxr	w4, [x7]
    fd80000085b8:	11000485 	add	w5, w4, #0x1
    fd80000085bc:	88067ce5 	stxr	w6, w5, [x7]
    fd80000085c0:	35ffffa6 	cbnz	w6, fd80000085b4 <gicr_set_pend+0x14>
    fd80000085c4:	88dffd05 	ldar	w5, [x8]
    fd80000085c8:	6b05009f 	cmp	w4, w5
    fd80000085cc:	54000060 	b.eq	fd80000085d8 <gicr_set_pend+0x38>  // b.none
    fd80000085d0:	d503205f 	wfe
    fd80000085d4:	17fffffc 	b	fd80000085c4 <gicr_set_pend+0x24>
    spin_lock(&gicr_lock);
    if (pend) {
        gicr[gicr_id].ISPENDR0 = (1U) << (int_id);
    fd80000085d8:	52800024 	mov	w4, #0x1                   	// #1
    fd80000085dc:	d36fb842 	lsl	x2, x2, #17
    fd80000085e0:	1ac02080 	lsl	w0, w4, w0
    if (pend) {
    fd80000085e4:	36000181 	tbz	w1, #0, fd8000008614 <gicr_set_pend+0x74>
        gicr[gicr_id].ISPENDR0 = (1U) << (int_id);
    fd80000085e8:	f9400061 	ldr	x1, [x3]
    fd80000085ec:	8b020021 	add	x1, x1, x2
    fd80000085f0:	91404021 	add	x1, x1, #0x10, lsl #12
    fd80000085f4:	b9020020 	str	w0, [x1, #512]
    __asm__ volatile(
    fd80000085f8:	91005061 	add	x1, x3, #0x14
    fd80000085fc:	b9400020 	ldr	w0, [x1]
    fd8000008600:	11000400 	add	w0, w0, #0x1
    fd8000008604:	889ffc20 	stlr	w0, [x1]
    fd8000008608:	d5033b9f 	dsb	ish
    fd800000860c:	d503209f 	sev
    } else {
        gicr[gicr_id].ICPENDR0 = (1U) << (int_id);
    }
    spin_unlock(&gicr_lock);
}
    fd8000008610:	d65f03c0 	ret
        gicr[gicr_id].ICPENDR0 = (1U) << (int_id);
    fd8000008614:	f9400061 	ldr	x1, [x3]
    fd8000008618:	8b020021 	add	x1, x1, x2
    fd800000861c:	91404021 	add	x1, x1, #0x10, lsl #12
    fd8000008620:	b9028020 	str	w0, [x1, #640]
    fd8000008624:	91005061 	add	x1, x3, #0x14
    fd8000008628:	b9400020 	ldr	w0, [x1]
    fd800000862c:	11000400 	add	w0, w0, #0x1
    fd8000008630:	889ffc20 	stlr	w0, [x1]
    fd8000008634:	d5033b9f 	dsb	ish
    fd8000008638:	d503209f 	sev
}
    fd800000863c:	d65f03c0 	ret
    fd8000008640:	00013080 	.word	0x00013080
    fd8000008644:	0000fd80 	.word	0x0000fd80
    fd8000008648:	d503201f 	nop
    fd800000864c:	d503201f 	nop

0000fd8000008650 <gicr_get_pend>:

bool gicr_get_pend(irqid_t int_id, cpuid_t gicr_id)
{
    if (gic_is_priv(int_id)) {
    fd8000008650:	71007c1f 	cmp	w0, #0x1f
    fd8000008654:	54000188 	b.hi	fd8000008684 <gicr_get_pend+0x34>  // b.pmore
        return !!(gicr[gicr_id].ISPENDR0 & GIC_INT_MASK(int_id));
    fd8000008658:	90000002 	adrp	x2, fd8000008000 <gicc_restore_state+0x50>
    fd800000865c:	f9434843 	ldr	x3, [x2, #1680]
    fd8000008660:	52800022 	mov	w2, #0x1                   	// #1
    fd8000008664:	1ac02040 	lsl	w0, w2, w0
    fd8000008668:	f9400062 	ldr	x2, [x3]
    fd800000866c:	8b014441 	add	x1, x2, x1, lsl #17
    fd8000008670:	91404021 	add	x1, x1, #0x10, lsl #12
    fd8000008674:	b9420021 	ldr	w1, [x1, #512]
    fd8000008678:	6a01001f 	tst	w0, w1
    fd800000867c:	1a9f07e0 	cset	w0, ne	// ne = any
    } else {
        return false;
    }
}
    fd8000008680:	d65f03c0 	ret
        return false;
    fd8000008684:	52800000 	mov	w0, #0x0                   	// #0
}
    fd8000008688:	d65f03c0 	ret
    fd800000868c:	d503201f 	nop
    fd8000008690:	00013080 	.word	0x00013080
    fd8000008694:	0000fd80 	.word	0x0000fd80
    fd8000008698:	d503201f 	nop
    fd800000869c:	d503201f 	nop

0000fd80000086a0 <gicr_set_act>:
    __asm__ volatile(
    fd80000086a0:	90000003 	adrp	x3, fd8000008000 <gicc_restore_state+0x50>
    fd80000086a4:	f943a063 	ldr	x3, [x3, #1856]

void gicr_set_act(irqid_t int_id, bool act, cpuid_t gicr_id)
{
    fd80000086a8:	12001c21 	and	w1, w1, #0xff
    fd80000086ac:	91004067 	add	x7, x3, #0x10
    fd80000086b0:	91005068 	add	x8, x3, #0x14
    fd80000086b4:	885ffce4 	ldaxr	w4, [x7]
    fd80000086b8:	11000485 	add	w5, w4, #0x1
    fd80000086bc:	88067ce5 	stxr	w6, w5, [x7]
    fd80000086c0:	35ffffa6 	cbnz	w6, fd80000086b4 <gicr_set_act+0x14>
    fd80000086c4:	88dffd05 	ldar	w5, [x8]
    fd80000086c8:	6b05009f 	cmp	w4, w5
    fd80000086cc:	54000060 	b.eq	fd80000086d8 <gicr_set_act+0x38>  // b.none
    fd80000086d0:	d503205f 	wfe
    fd80000086d4:	17fffffc 	b	fd80000086c4 <gicr_set_act+0x24>
    spin_lock(&gicr_lock);

    if (act) {
        gicr[gicr_id].ISACTIVER0 = GIC_INT_MASK(int_id);
    fd80000086d8:	52800024 	mov	w4, #0x1                   	// #1
    fd80000086dc:	d36fb842 	lsl	x2, x2, #17
    fd80000086e0:	1ac02080 	lsl	w0, w4, w0
    if (act) {
    fd80000086e4:	36000181 	tbz	w1, #0, fd8000008714 <gicr_set_act+0x74>
        gicr[gicr_id].ISACTIVER0 = GIC_INT_MASK(int_id);
    fd80000086e8:	f9400061 	ldr	x1, [x3]
    fd80000086ec:	8b020021 	add	x1, x1, x2
    fd80000086f0:	91404021 	add	x1, x1, #0x10, lsl #12
    fd80000086f4:	b9030020 	str	w0, [x1, #768]
    __asm__ volatile(
    fd80000086f8:	91005061 	add	x1, x3, #0x14
    fd80000086fc:	b9400020 	ldr	w0, [x1]
    fd8000008700:	11000400 	add	w0, w0, #0x1
    fd8000008704:	889ffc20 	stlr	w0, [x1]
    fd8000008708:	d5033b9f 	dsb	ish
    fd800000870c:	d503209f 	sev
    } else {
        gicr[gicr_id].ICACTIVER0 = GIC_INT_MASK(int_id);
    }

    spin_unlock(&gicr_lock);
}
    fd8000008710:	d65f03c0 	ret
        gicr[gicr_id].ICACTIVER0 = GIC_INT_MASK(int_id);
    fd8000008714:	f9400061 	ldr	x1, [x3]
    fd8000008718:	8b020021 	add	x1, x1, x2
    fd800000871c:	91404021 	add	x1, x1, #0x10, lsl #12
    fd8000008720:	b9038020 	str	w0, [x1, #896]
    fd8000008724:	91005061 	add	x1, x3, #0x14
    fd8000008728:	b9400020 	ldr	w0, [x1]
    fd800000872c:	11000400 	add	w0, w0, #0x1
    fd8000008730:	889ffc20 	stlr	w0, [x1]
    fd8000008734:	d5033b9f 	dsb	ish
    fd8000008738:	d503209f 	sev
}
    fd800000873c:	d65f03c0 	ret
    fd8000008740:	00013080 	.word	0x00013080
    fd8000008744:	0000fd80 	.word	0x0000fd80
    fd8000008748:	d503201f 	nop
    fd800000874c:	d503201f 	nop

0000fd8000008750 <gicr_get_act>:

bool gicr_get_act(irqid_t int_id, cpuid_t gicr_id)
{
    if (gic_is_priv(int_id)) {
    fd8000008750:	71007c1f 	cmp	w0, #0x1f
    fd8000008754:	54000188 	b.hi	fd8000008784 <gicr_get_act+0x34>  // b.pmore
        return !!(gicr[gicr_id].ISACTIVER0 & GIC_INT_MASK(int_id));
    fd8000008758:	90000002 	adrp	x2, fd8000008000 <gicc_restore_state+0x50>
    fd800000875c:	f943c843 	ldr	x3, [x2, #1936]
    fd8000008760:	52800022 	mov	w2, #0x1                   	// #1
    fd8000008764:	1ac02040 	lsl	w0, w2, w0
    fd8000008768:	f9400062 	ldr	x2, [x3]
    fd800000876c:	8b014441 	add	x1, x2, x1, lsl #17
    fd8000008770:	91404021 	add	x1, x1, #0x10, lsl #12
    fd8000008774:	b9430021 	ldr	w1, [x1, #768]
    fd8000008778:	6a01001f 	tst	w0, w1
    fd800000877c:	1a9f07e0 	cset	w0, ne	// ne = any
    } else {
        return false;
    }
}
    fd8000008780:	d65f03c0 	ret
        return false;
    fd8000008784:	52800000 	mov	w0, #0x0                   	// #0
}
    fd8000008788:	d65f03c0 	ret
    fd800000878c:	d503201f 	nop
    fd8000008790:	00013080 	.word	0x00013080
    fd8000008794:	0000fd80 	.word	0x0000fd80
    fd8000008798:	d503201f 	nop
    fd800000879c:	d503201f 	nop

0000fd80000087a0 <gicr_set_enable>:

void gicr_set_enable(irqid_t int_id, bool en, cpuid_t gicr_id)
{
    uint32_t bit = GIC_INT_MASK(int_id);
    fd80000087a0:	52800023 	mov	w3, #0x1                   	// #1
{
    fd80000087a4:	12001c21 	and	w1, w1, #0xff
    uint32_t bit = GIC_INT_MASK(int_id);
    fd80000087a8:	1ac02060 	lsl	w0, w3, w0
    __asm__ volatile(
    fd80000087ac:	90000003 	adrp	x3, fd8000008000 <gicc_restore_state+0x50>
    fd80000087b0:	f9442063 	ldr	x3, [x3, #2112]
    fd80000087b4:	91004067 	add	x7, x3, #0x10
    fd80000087b8:	91005068 	add	x8, x3, #0x14
    fd80000087bc:	885ffce4 	ldaxr	w4, [x7]
    fd80000087c0:	11000485 	add	w5, w4, #0x1
    fd80000087c4:	88067ce5 	stxr	w6, w5, [x7]
    fd80000087c8:	35ffffa6 	cbnz	w6, fd80000087bc <gicr_set_enable+0x1c>
    fd80000087cc:	88dffd05 	ldar	w5, [x8]
    fd80000087d0:	6b05009f 	cmp	w4, w5
    fd80000087d4:	54000060 	b.eq	fd80000087e0 <gicr_set_enable+0x40>  // b.none
    fd80000087d8:	d503205f 	wfe
    fd80000087dc:	17fffffc 	b	fd80000087cc <gicr_set_enable+0x2c>

    spin_lock(&gicr_lock);
    if (en) {
        gicr[gicr_id].ISENABLER0 = bit;
    fd80000087e0:	d36fb842 	lsl	x2, x2, #17
    if (en) {
    fd80000087e4:	36000181 	tbz	w1, #0, fd8000008814 <gicr_set_enable+0x74>
        gicr[gicr_id].ISENABLER0 = bit;
    fd80000087e8:	f9400061 	ldr	x1, [x3]
    fd80000087ec:	8b020021 	add	x1, x1, x2
    fd80000087f0:	91404021 	add	x1, x1, #0x10, lsl #12
    fd80000087f4:	b9010020 	str	w0, [x1, #256]
    __asm__ volatile(
    fd80000087f8:	91005061 	add	x1, x3, #0x14
    fd80000087fc:	b9400020 	ldr	w0, [x1]
    fd8000008800:	11000400 	add	w0, w0, #0x1
    fd8000008804:	889ffc20 	stlr	w0, [x1]
    fd8000008808:	d5033b9f 	dsb	ish
    fd800000880c:	d503209f 	sev
    } else {
        gicr[gicr_id].ICENABLER0 = bit;
    }
    spin_unlock(&gicr_lock);
}
    fd8000008810:	d65f03c0 	ret
        gicr[gicr_id].ICENABLER0 = bit;
    fd8000008814:	f9400061 	ldr	x1, [x3]
    fd8000008818:	8b020021 	add	x1, x1, x2
    fd800000881c:	91404021 	add	x1, x1, #0x10, lsl #12
    fd8000008820:	b9018020 	str	w0, [x1, #384]
    fd8000008824:	91005061 	add	x1, x3, #0x14
    fd8000008828:	b9400020 	ldr	w0, [x1]
    fd800000882c:	11000400 	add	w0, w0, #0x1
    fd8000008830:	889ffc20 	stlr	w0, [x1]
    fd8000008834:	d5033b9f 	dsb	ish
    fd8000008838:	d503209f 	sev
}
    fd800000883c:	d65f03c0 	ret
    fd8000008840:	00013080 	.word	0x00013080
    fd8000008844:	0000fd80 	.word	0x0000fd80
    fd8000008848:	d503201f 	nop
    fd800000884c:	d503201f 	nop

0000fd8000008850 <gicd_set_route>:

void gicd_set_route(irqid_t int_id, unsigned long route)
{
    if (gic_is_priv(int_id)) {
    fd8000008850:	71007c1f 	cmp	w0, #0x1f
    fd8000008854:	54000048 	b.hi	fd800000885c <gicd_set_route+0xc>  // b.pmore
    spin_lock(&gicd_lock);

    gicd->IROUTER[int_id] = route & GICD_IROUTER_AFF_MSK;

    spin_unlock(&gicd_lock);
}
    fd8000008858:	d65f03c0 	ret
    __asm__ volatile(
    fd800000885c:	90000002 	adrp	x2, fd8000008000 <gicc_restore_state+0x50>
    fd8000008860:	f9446442 	ldr	x2, [x2, #2248]
    fd8000008864:	91007046 	add	x6, x2, #0x1c
    fd8000008868:	91006042 	add	x2, x2, #0x18
    fd800000886c:	885ffc43 	ldaxr	w3, [x2]
    fd8000008870:	11000464 	add	w4, w3, #0x1
    fd8000008874:	88057c44 	stxr	w5, w4, [x2]
    fd8000008878:	35ffffa5 	cbnz	w5, fd800000886c <gicd_set_route+0x1c>
    fd800000887c:	88dffcc4 	ldar	w4, [x6]
    fd8000008880:	6b04007f 	cmp	w3, w4
    fd8000008884:	54000060 	b.eq	fd8000008890 <gicd_set_route+0x40>  // b.none
    fd8000008888:	d503205f 	wfe
    fd800000888c:	17fffffc 	b	fd800000887c <gicd_set_route+0x2c>
    gicd->IROUTER[int_id] = route & GICD_IROUTER_AFF_MSK;
    fd8000008890:	90000003 	adrp	x3, fd8000008000 <gicc_restore_state+0x50>
    fd8000008894:	f9446863 	ldr	x3, [x3, #2256]
    fd8000008898:	92409c21 	and	x1, x1, #0xffffffffff
    fd800000889c:	9260f821 	and	x1, x1, #0xffffffff7fffffff
    fd80000088a0:	f9400063 	ldr	x3, [x3]
    fd80000088a4:	8b204c60 	add	x0, x3, w0, uxtw #3
    fd80000088a8:	f9300001 	str	x1, [x0, #24576]
    __asm__ volatile(
    fd80000088ac:	b94000c0 	ldr	w0, [x6]
    fd80000088b0:	11000400 	add	w0, w0, #0x1
    fd80000088b4:	889ffcc0 	stlr	w0, [x6]
    fd80000088b8:	d5033b9f 	dsb	ish
    fd80000088bc:	d503209f 	sev
}
    fd80000088c0:	d65f03c0 	ret
    fd80000088c4:	d503201f 	nop
    fd80000088c8:	00013080 	.word	0x00013080
    fd80000088cc:	0000fd80 	.word	0x0000fd80
    fd80000088d0:	00013070 	.word	0x00013070
    fd80000088d4:	0000fd80 	.word	0x0000fd80
    fd80000088d8:	d503201f 	nop
    fd80000088dc:	d503201f 	nop

0000fd80000088e0 <gic_send_sgi>:

void gic_send_sgi(cpuid_t cpu_target, irqid_t sgi_num)
{
    if (sgi_num < GIC_MAX_SGIS) {
    fd80000088e0:	71003c3f 	cmp	w1, #0xf
    fd80000088e4:	54000049 	b.ls	fd80000088ec <gic_send_sgi+0xc>  // b.plast
    fd80000088e8:	d65f03c0 	ret
{
    fd80000088ec:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    fd80000088f0:	910003fd 	mov	x29, sp
    fd80000088f4:	f9000bf3 	str	x19, [sp, #16]
    fd80000088f8:	2a0103f3 	mov	w19, w1
        unsigned long mpidr = cpu_id_to_mpidr(cpu_target) & MPIDR_AFF_MSK;
    fd80000088fc:	97ffec75 	bl	fd8000003ad0 <cpu_id_to_mpidr>
        /* We only support two affinity levels */
        uint64_t sgi = (MPIDR_AFF_LVL(mpidr, 1) << ICC_SGIR_AFF1_OFFSET) |
    fd8000008900:	d3483c01 	ubfx	x1, x0, #8, #8
            (1UL << MPIDR_AFF_LVL(mpidr, 0)) | (sgi_num << ICC_SGIR_SGIINTID_OFF);
    fd8000008904:	53081e73 	lsl	w19, w19, #24
    fd8000008908:	d2800022 	mov	x2, #0x1                   	// #1
        uint64_t sgi = (MPIDR_AFF_LVL(mpidr, 1) << ICC_SGIR_AFF1_OFFSET) |
    fd800000890c:	aa014261 	orr	x1, x19, x1, lsl #16
            (1UL << MPIDR_AFF_LVL(mpidr, 0)) | (sgi_num << ICC_SGIR_SGIINTID_OFF);
    fd8000008910:	9ac02042 	lsl	x2, x2, x0
        uint64_t sgi = (MPIDR_AFF_LVL(mpidr, 1) << ICC_SGIR_AFF1_OFFSET) |
    fd8000008914:	aa020021 	orr	x1, x1, x2
SYSREG_GEN_ACCESSORS(icc_sgi1r_el1);
    fd8000008918:	d518cba1 	msr	icc_sgi1r_el1, x1
        sysreg_icc_sgi1r_el1_write(sgi);
    }
}
    fd800000891c:	f9400bf3 	ldr	x19, [sp, #16]
    fd8000008920:	a8c27bfd 	ldp	x29, x30, [sp], #32
    fd8000008924:	d65f03c0 	ret
    fd8000008928:	d503201f 	nop
    fd800000892c:	d503201f 	nop

0000fd8000008930 <gic_set_prio>:

void gic_set_prio(irqid_t int_id, uint8_t prio)
{
    fd8000008930:	12001c21 	and	w1, w1, #0xff
    if (!gic_is_priv(int_id)) {
    fd8000008934:	71007c1f 	cmp	w0, #0x1f
    fd8000008938:	54000049 	b.ls	fd8000008940 <gic_set_prio+0x10>  // b.plast
        gicd_set_prio(int_id, prio);
    fd800000893c:	17ffedb1 	b	fd8000004000 <gicd_set_prio>
    } else {
        gicr_set_prio(int_id, prio, cpu()->id);
    fd8000008940:	d2dfc002 	mov	x2, #0xfe0000000000        	// #279275953455104
    fd8000008944:	f9400042 	ldr	x2, [x2]
    fd8000008948:	17fffe9a 	b	fd80000083b0 <gicr_set_prio>
    fd800000894c:	d503201f 	nop

0000fd8000008950 <gic_get_prio>:
    }
}

uint8_t gic_get_prio(irqid_t int_id)
{
    if (!gic_is_priv(int_id)) {
    fd8000008950:	71007c1f 	cmp	w0, #0x1f
    fd8000008954:	54000049 	b.ls	fd800000895c <gic_get_prio+0xc>  // b.plast
        return gicd_get_prio(int_id);
    fd8000008958:	17ffed76 	b	fd8000003f30 <gicd_get_prio>
    } else {
        return gicr_get_prio(int_id, cpu()->id);
    fd800000895c:	d2dfc001 	mov	x1, #0xfe0000000000        	// #279275953455104
    fd8000008960:	f9400021 	ldr	x1, [x1]
    fd8000008964:	17fffebb 	b	fd8000008450 <gicr_get_prio>
    fd8000008968:	d503201f 	nop
    fd800000896c:	d503201f 	nop

0000fd8000008970 <gic_set_icfgr>:
    }
}

void gic_set_icfgr(irqid_t int_id, uint8_t cfg)
{
    fd8000008970:	12001c21 	and	w1, w1, #0xff
    if (!gic_is_priv(int_id)) {
    fd8000008974:	71007c1f 	cmp	w0, #0x1f
    fd8000008978:	54000049 	b.ls	fd8000008980 <gic_set_icfgr+0x10>  // b.plast
        gicd_set_icfgr(int_id, cfg);
    fd800000897c:	17ffed7d 	b	fd8000003f70 <gicd_set_icfgr>
    } else {
        gicr_set_icfgr(int_id, cfg, cpu()->id);
    fd8000008980:	d2dfc002 	mov	x2, #0xfe0000000000        	// #279275953455104
    fd8000008984:	f9400042 	ldr	x2, [x2]
    fd8000008988:	17fffed2 	b	fd80000084d0 <gicr_set_icfgr>
    fd800000898c:	d503201f 	nop

0000fd8000008990 <gic_set_pend>:
    }
}

void gic_set_pend(irqid_t int_id, bool pend)
{
    fd8000008990:	12001c21 	and	w1, w1, #0xff
    if (!gic_is_priv(int_id)) {
    fd8000008994:	71007c1f 	cmp	w0, #0x1f
    fd8000008998:	54000049 	b.ls	fd80000089a0 <gic_set_pend+0x10>  // b.plast
        gicd_set_pend(int_id, pend);
    fd800000899c:	17ffedbd 	b	fd8000004090 <gicd_set_pend>
    } else {
        gicr_set_pend(int_id, pend, cpu()->id);
    fd80000089a0:	d2dfc002 	mov	x2, #0xfe0000000000        	// #279275953455104
    fd80000089a4:	f9400042 	ldr	x2, [x2]
    fd80000089a8:	17fffefe 	b	fd80000085a0 <gicr_set_pend>
    fd80000089ac:	d503201f 	nop

0000fd80000089b0 <gic_get_pend>:
    }
}

bool gic_get_pend(irqid_t int_id)
{
    fd80000089b0:	2a0003e1 	mov	w1, w0
    if (!gic_is_priv(int_id)) {
    fd80000089b4:	71007c1f 	cmp	w0, #0x1f
    fd80000089b8:	54000049 	b.ls	fd80000089c0 <gic_get_pend+0x10>  // b.plast
        return gicd_get_pend(int_id);
    fd80000089bc:	17ffedc5 	b	fd80000040d0 <gicd_get_pend>
        return !!(gicr[gicr_id].ISPENDR0 & GIC_INT_MASK(int_id));
    fd80000089c0:	90000000 	adrp	x0, fd8000008000 <gicc_restore_state+0x50>
    fd80000089c4:	f944fc03 	ldr	x3, [x0, #2552]
    } else {
        return gicr_get_pend(int_id, cpu()->id);
    fd80000089c8:	d2dfc000 	mov	x0, #0xfe0000000000        	// #279275953455104
        return !!(gicr[gicr_id].ISPENDR0 & GIC_INT_MASK(int_id));
    fd80000089cc:	52800022 	mov	w2, #0x1                   	// #1
    fd80000089d0:	f9400000 	ldr	x0, [x0]
    fd80000089d4:	1ac12041 	lsl	w1, w2, w1
    fd80000089d8:	f9400062 	ldr	x2, [x3]
    fd80000089dc:	8b004440 	add	x0, x2, x0, lsl #17
    fd80000089e0:	91404000 	add	x0, x0, #0x10, lsl #12
    fd80000089e4:	b9420000 	ldr	w0, [x0, #512]
    fd80000089e8:	6a00003f 	tst	w1, w0
    }
}
    fd80000089ec:	1a9f07e0 	cset	w0, ne	// ne = any
    fd80000089f0:	d65f03c0 	ret
    fd80000089f4:	d503201f 	nop
    fd80000089f8:	00013080 	.word	0x00013080
    fd80000089fc:	0000fd80 	.word	0x0000fd80

0000fd8000008a00 <gic_set_act>:

void gic_set_act(irqid_t int_id, bool act)
{
    fd8000008a00:	12001c21 	and	w1, w1, #0xff
    if (!gic_is_priv(int_id)) {
    fd8000008a04:	71007c1f 	cmp	w0, #0x1f
    fd8000008a08:	54000049 	b.ls	fd8000008a10 <gic_set_act+0x10>  // b.plast
        gicd_set_act(int_id, act);
    fd8000008a0c:	17ffedc1 	b	fd8000004110 <gicd_set_act>
    } else {
        gicr_set_act(int_id, act, cpu()->id);
    fd8000008a10:	d2dfc002 	mov	x2, #0xfe0000000000        	// #279275953455104
    fd8000008a14:	f9400042 	ldr	x2, [x2]
    fd8000008a18:	17ffff22 	b	fd80000086a0 <gicr_set_act>
    fd8000008a1c:	d503201f 	nop

0000fd8000008a20 <gic_get_act>:
    }
}

bool gic_get_act(irqid_t int_id)
{
    fd8000008a20:	2a0003e1 	mov	w1, w0
    if (!gic_is_priv(int_id)) {
    fd8000008a24:	71007c1f 	cmp	w0, #0x1f
    fd8000008a28:	54000049 	b.ls	fd8000008a30 <gic_get_act+0x10>  // b.plast
        return gicd_get_act(int_id);
    fd8000008a2c:	17ffedc9 	b	fd8000004150 <gicd_get_act>
        return !!(gicr[gicr_id].ISACTIVER0 & GIC_INT_MASK(int_id));
    fd8000008a30:	90000000 	adrp	x0, fd8000008000 <gicc_restore_state+0x50>
    fd8000008a34:	f9453403 	ldr	x3, [x0, #2664]
    } else {
        return gicr_get_act(int_id, cpu()->id);
    fd8000008a38:	d2dfc000 	mov	x0, #0xfe0000000000        	// #279275953455104
        return !!(gicr[gicr_id].ISACTIVER0 & GIC_INT_MASK(int_id));
    fd8000008a3c:	52800022 	mov	w2, #0x1                   	// #1
    fd8000008a40:	f9400000 	ldr	x0, [x0]
    fd8000008a44:	1ac12041 	lsl	w1, w2, w1
    fd8000008a48:	f9400062 	ldr	x2, [x3]
    fd8000008a4c:	8b004440 	add	x0, x2, x0, lsl #17
    fd8000008a50:	91404000 	add	x0, x0, #0x10, lsl #12
    fd8000008a54:	b9430000 	ldr	w0, [x0, #768]
    fd8000008a58:	6a00003f 	tst	w1, w0
    }
}
    fd8000008a5c:	1a9f07e0 	cset	w0, ne	// ne = any
    fd8000008a60:	d65f03c0 	ret
    fd8000008a64:	d503201f 	nop
    fd8000008a68:	00013080 	.word	0x00013080
    fd8000008a6c:	0000fd80 	.word	0x0000fd80

0000fd8000008a70 <gic_set_enable>:

void gic_set_enable(irqid_t int_id, bool en)
{
    fd8000008a70:	12001c21 	and	w1, w1, #0xff
    if (!gic_is_priv(int_id)) {
    fd8000008a74:	71007c1f 	cmp	w0, #0x1f
    fd8000008a78:	54000049 	b.ls	fd8000008a80 <gic_set_enable+0x10>  // b.plast
        gicd_set_enable(int_id, en);
    fd8000008a7c:	17ffedc5 	b	fd8000004190 <gicd_set_enable>
    } else {
        gicr_set_enable(int_id, en, cpu()->id);
    fd8000008a80:	d2dfc002 	mov	x2, #0xfe0000000000        	// #279275953455104
    fd8000008a84:	f9400042 	ldr	x2, [x2]
    fd8000008a88:	17ffff46 	b	fd80000087a0 <gicr_set_enable>
    fd8000008a8c:	00000000 	udf	#0

0000fd8000008a90 <memcpy>:
    size_t i;
    uint8_t* dst_tmp = dst;
    const uint8_t* src_tmp = src;
    static const size_t WORD_SIZE = sizeof(unsigned long);

    if (!((uintptr_t)src & (WORD_SIZE - 1)) && !((uintptr_t)dst & (WORD_SIZE - 1))) {
    fd8000008a90:	aa000023 	orr	x3, x1, x0
    fd8000008a94:	f2400863 	ands	x3, x3, #0x7
    fd8000008a98:	54000140 	b.eq	fd8000008ac0 <memcpy+0x30>  // b.none
                dst_tmp++;
                src_tmp++;
            }
        }
    } else {
        for (i = 0; i < count; i++) {
    fd8000008a9c:	d2800003 	mov	x3, #0x0                   	// #0
    fd8000008aa0:	b40000e2 	cbz	x2, fd8000008abc <memcpy+0x2c>
    fd8000008aa4:	d503201f 	nop
            dst_tmp[i] = src_tmp[i];
    fd8000008aa8:	38636824 	ldrb	w4, [x1, x3]
    fd8000008aac:	38236804 	strb	w4, [x0, x3]
        for (i = 0; i < count; i++) {
    fd8000008ab0:	91000463 	add	x3, x3, #0x1
    fd8000008ab4:	eb03005f 	cmp	x2, x3
    fd8000008ab8:	54ffff81 	b.ne	fd8000008aa8 <memcpy+0x18>  // b.any
        }
    }
    return dst;
}
    fd8000008abc:	d65f03c0 	ret
        for (i = 0; i < count; i += WORD_SIZE) {
    fd8000008ac0:	b4ffffe2 	cbz	x2, fd8000008abc <memcpy+0x2c>
            if (i + (WORD_SIZE - 1) > count - 1) {
    fd8000008ac4:	d1000447 	sub	x7, x2, #0x1
    fd8000008ac8:	f10018ff 	cmp	x7, #0x6
    fd8000008acc:	540002e9 	b.ls	fd8000008b28 <memcpy+0x98>  // b.plast
    fd8000008ad0:	d1002046 	sub	x6, x2, #0x8
    uint8_t* dst_tmp = dst;
    fd8000008ad4:	aa0003e4 	mov	x4, x0
    fd8000008ad8:	927df0c6 	and	x6, x6, #0xfffffffffffffff8
    fd8000008adc:	910020c6 	add	x6, x6, #0x8
    fd8000008ae0:	14000003 	b	fd8000008aec <memcpy+0x5c>
            if (i + (WORD_SIZE - 1) > count - 1) {
    fd8000008ae4:	eb0300df 	cmp	x6, x3
    fd8000008ae8:	540000c0 	b.eq	fd8000008b00 <memcpy+0x70>  // b.none
            *(unsigned long*)dst_tmp = *(unsigned long*)src_tmp;
    fd8000008aec:	f8408425 	ldr	x5, [x1], #8
    fd8000008af0:	f8008485 	str	x5, [x4], #8
        for (i = 0; i < count; i += WORD_SIZE) {
    fd8000008af4:	91002063 	add	x3, x3, #0x8
    fd8000008af8:	eb03005f 	cmp	x2, x3
    fd8000008afc:	54ffff48 	b.hi	fd8000008ae4 <memcpy+0x54>  // b.pmore
        if (i <= count - 1) {
    fd8000008b00:	eb07007f 	cmp	x3, x7
    fd8000008b04:	54fffdc8 	b.hi	fd8000008abc <memcpy+0x2c>  // b.pmore
                *dst_tmp = *src_tmp;
    fd8000008b08:	cb030021 	sub	x1, x1, x3
    fd8000008b0c:	cb030084 	sub	x4, x4, x3
    fd8000008b10:	38636825 	ldrb	w5, [x1, x3]
    fd8000008b14:	38236885 	strb	w5, [x4, x3]
            for (; i < count; i++) {
    fd8000008b18:	91000463 	add	x3, x3, #0x1
    fd8000008b1c:	eb03005f 	cmp	x2, x3
    fd8000008b20:	54ffff88 	b.hi	fd8000008b10 <memcpy+0x80>  // b.pmore
}
    fd8000008b24:	d65f03c0 	ret
    uint8_t* dst_tmp = dst;
    fd8000008b28:	aa0003e4 	mov	x4, x0
    fd8000008b2c:	17fffff7 	b	fd8000008b08 <memcpy+0x78>

0000fd8000008b30 <memset>:
void* memset(void* dest, int c, size_t count)
{
    uint8_t* d;
    d = (uint8_t*)dest;

    while (count--) {
    fd8000008b30:	8b020004 	add	x4, x0, x2
        *d = c;
    fd8000008b34:	12001c21 	and	w1, w1, #0xff
    d = (uint8_t*)dest;
    fd8000008b38:	aa0003e3 	mov	x3, x0
    while (count--) {
    fd8000008b3c:	b4000082 	cbz	x2, fd8000008b4c <memset+0x1c>
        *d = c;
    fd8000008b40:	38001461 	strb	w1, [x3], #1
    while (count--) {
    fd8000008b44:	eb03009f 	cmp	x4, x3
    fd8000008b48:	54ffffc1 	b.ne	fd8000008b40 <memset+0x10>  // b.any
        d++;
    }

    return dest;
}
    fd8000008b4c:	d65f03c0 	ret

0000fd8000008b50 <strcat>:

char* strcat(char* dest, char* src)
{
    char* save = dest;

    for (; *dest; ++dest)
    fd8000008b50:	39400002 	ldrb	w2, [x0]
    fd8000008b54:	aa0003e4 	mov	x4, x0
    fd8000008b58:	34000082 	cbz	w2, fd8000008b68 <strcat+0x18>
    fd8000008b5c:	d503201f 	nop
    fd8000008b60:	38401c82 	ldrb	w2, [x4, #1]!
    fd8000008b64:	35ffffe2 	cbnz	w2, fd8000008b60 <strcat+0x10>
    fd8000008b68:	d2800002 	mov	x2, #0x0                   	// #0
    fd8000008b6c:	d503201f 	nop
        ;
    while ((*dest++ = *src++) != 0) { }
    fd8000008b70:	38626823 	ldrb	w3, [x1, x2]
    fd8000008b74:	38226883 	strb	w3, [x4, x2]
    fd8000008b78:	91000442 	add	x2, x2, #0x1
    fd8000008b7c:	35ffffa3 	cbnz	w3, fd8000008b70 <strcat+0x20>

    return (save);
}
    fd8000008b80:	d65f03c0 	ret
    fd8000008b84:	d503201f 	nop
    fd8000008b88:	d503201f 	nop
    fd8000008b8c:	d503201f 	nop

0000fd8000008b90 <strlen>:

size_t strlen(const char* s)
{
    const char* sc;
    for (sc = s; *sc != '\0'; ++sc) {
    fd8000008b90:	39400001 	ldrb	w1, [x0]
    fd8000008b94:	340000e1 	cbz	w1, fd8000008bb0 <strlen+0x20>
    fd8000008b98:	aa0003e1 	mov	x1, x0
    fd8000008b9c:	d503201f 	nop
    fd8000008ba0:	38401c22 	ldrb	w2, [x1, #1]!
    fd8000008ba4:	35ffffe2 	cbnz	w2, fd8000008ba0 <strlen+0x10>
        /* Just iterate */
    }
    return sc - s;
    fd8000008ba8:	cb000020 	sub	x0, x1, x0
}
    fd8000008bac:	d65f03c0 	ret
    for (sc = s; *sc != '\0'; ++sc) {
    fd8000008bb0:	d2800000 	mov	x0, #0x0                   	// #0
}
    fd8000008bb4:	d65f03c0 	ret
    fd8000008bb8:	d503201f 	nop
    fd8000008bbc:	d503201f 	nop

0000fd8000008bc0 <strnlen>:

size_t strnlen(const char* s, size_t n)
{
    const char* str;

    for (str = s; *str != '\0' && n--; ++str) {
    fd8000008bc0:	39400002 	ldrb	w2, [x0]
    fd8000008bc4:	34000162 	cbz	w2, fd8000008bf0 <strnlen+0x30>
    fd8000008bc8:	b4000141 	cbz	x1, fd8000008bf0 <strnlen+0x30>
    fd8000008bcc:	8b010003 	add	x3, x0, x1
    fd8000008bd0:	aa0003e1 	mov	x1, x0
    fd8000008bd4:	14000002 	b	fd8000008bdc <strnlen+0x1c>
    fd8000008bd8:	54000080 	b.eq	fd8000008be8 <strnlen+0x28>  // b.none
    fd8000008bdc:	38401c22 	ldrb	w2, [x1, #1]!
    fd8000008be0:	eb03003f 	cmp	x1, x3
    fd8000008be4:	35ffffa2 	cbnz	w2, fd8000008bd8 <strnlen+0x18>
        /* Just iterate */
    }
    return str - s;
    fd8000008be8:	cb000020 	sub	x0, x1, x0
}
    fd8000008bec:	d65f03c0 	ret
    for (str = s; *str != '\0' && n--; ++str) {
    fd8000008bf0:	d2800000 	mov	x0, #0x0                   	// #0
}
    fd8000008bf4:	d65f03c0 	ret
    fd8000008bf8:	d503201f 	nop
    fd8000008bfc:	d503201f 	nop

0000fd8000008c00 <strcpy>:

char* strcpy(char* dest, char* src)
{
    char* tmp = dest;

    while ((*dest++ = *src++) != '\0') {
    fd8000008c00:	d2800002 	mov	x2, #0x0                   	// #0
    fd8000008c04:	d503201f 	nop
    fd8000008c08:	38626823 	ldrb	w3, [x1, x2]
    fd8000008c0c:	38226803 	strb	w3, [x0, x2]
    fd8000008c10:	91000442 	add	x2, x2, #0x1
    fd8000008c14:	35ffffa3 	cbnz	w3, fd8000008c08 <strcpy+0x8>
        /* Just iterate */
    }
    return tmp;
}
    fd8000008c18:	d65f03c0 	ret
    fd8000008c1c:	d503201f 	nop

0000fd8000008c20 <strcmp>:

int strcmp(char* str0, char* str1)
{
    char *tmp0 = str0, *tmp1 = str1;

    while (*tmp0 == *tmp1 && ((*tmp0 != '\0') && (*tmp1 != '\0'))) {
    fd8000008c20:	39400002 	ldrb	w2, [x0]
    fd8000008c24:	39400023 	ldrb	w3, [x1]
    fd8000008c28:	7100005f 	cmp	w2, #0x0
    fd8000008c2c:	7a421060 	ccmp	w3, w2, #0x0, ne	// ne = any
    fd8000008c30:	540000e1 	b.ne	fd8000008c4c <strcmp+0x2c>  // b.any
    fd8000008c34:	d503201f 	nop
    fd8000008c38:	38401c02 	ldrb	w2, [x0, #1]!
    fd8000008c3c:	38401c23 	ldrb	w3, [x1, #1]!
    fd8000008c40:	7100005f 	cmp	w2, #0x0
    fd8000008c44:	7a421060 	ccmp	w3, w2, #0x0, ne	// ne = any
    fd8000008c48:	54ffff80 	b.eq	fd8000008c38 <strcmp+0x18>  // b.none
        tmp0++;
        tmp1++;
    }

    return (int)(tmp0 - tmp1);
}
    fd8000008c4c:	4b010000 	sub	w0, w0, w1
    fd8000008c50:	d65f03c0 	ret
	...

0000fd8000008c60 <vprintd>:
    }
    return char_count;
}

static size_t vprintd(char** buf, unsigned int flags, va_list* args)
{
    fd8000008c60:	aa0003e5 	mov	x5, x0
    size_t char_count = 0;

    if (is_unsigned) {
        u = is_long ? va_arg(*args, unsigned long) : va_arg(*args, unsigned int);
    } else {
        signed long s = is_long ? va_arg(*args, signed long) : va_arg(*args, signed int);
    fd8000008c64:	b9401844 	ldr	w4, [x2, #24]
    fd8000008c68:	f9400040 	ldr	x0, [x2]
    bool is_long = ((flags & F_LONG) != 0U);
    fd8000008c6c:	12000026 	and	w6, w1, #0x1
    size_t base = ((flags & F_BASE16) != 0U) ? (unsigned int)16U : 10U;
    fd8000008c70:	37100201 	tbnz	w1, #2, fd8000008cb0 <vprintd+0x50>
    bool is_unsigned = ((flags & F_UNSIGNED) != 0U) || (base != 10U);
    fd8000008c74:	37080781 	tbnz	w1, #1, fd8000008d64 <vprintd+0x104>
        signed long s = is_long ? va_arg(*args, signed long) : va_arg(*args, signed int);
    fd8000008c78:	34000ae6 	cbz	w6, fd8000008dd4 <vprintd+0x174>
    fd8000008c7c:	37f80b84 	tbnz	w4, #31, fd8000008dec <vprintd+0x18c>
    fd8000008c80:	91003c01 	add	x1, x0, #0xf
    fd8000008c84:	927df021 	and	x1, x1, #0xfffffffffffffff8
    fd8000008c88:	f9000041 	str	x1, [x2]
    fd8000008c8c:	f9400006 	ldr	x6, [x0]
    size_t char_count = 0;
    fd8000008c90:	d2800000 	mov	x0, #0x0                   	// #0
        if (s < 0) {
    fd8000008c94:	b7f806e6 	tbnz	x6, #63, fd8000008d70 <vprintd+0x110>
    size_t base = ((flags & F_BASE16) != 0U) ? (unsigned int)16U : 10U;
    fd8000008c98:	d2800143 	mov	x3, #0xa                   	// #10
        u = (unsigned long)s;
    }

    divisor = 1;
    tmp = u;
    while (tmp >= base) {
    fd8000008c9c:	eb0300df 	cmp	x6, x3
    fd8000008ca0:	540001c2 	b.cs	fd8000008cd8 <vprintd+0x78>  // b.hs, b.nlast
    fd8000008ca4:	d503201f 	nop
    divisor = 1;
    fd8000008ca8:	d2800022 	mov	x2, #0x1                   	// #1
    fd8000008cac:	14000013 	b	fd8000008cf8 <vprintd+0x98>
    size_t base = ((flags & F_BASE16) != 0U) ? (unsigned int)16U : 10U;
    fd8000008cb0:	d2800203 	mov	x3, #0x10                  	// #16
        u = is_long ? va_arg(*args, unsigned long) : va_arg(*args, unsigned int);
    fd8000008cb4:	350004a6 	cbnz	w6, fd8000008d48 <vprintd+0xe8>
    fd8000008cb8:	37f80804 	tbnz	w4, #31, fd8000008db8 <vprintd+0x158>
    fd8000008cbc:	91002c01 	add	x1, x0, #0xb
    fd8000008cc0:	927df021 	and	x1, x1, #0xfffffffffffffff8
    fd8000008cc4:	f9000041 	str	x1, [x2]
    fd8000008cc8:	b9400006 	ldr	w6, [x0]
    size_t char_count = 0;
    fd8000008ccc:	d2800000 	mov	x0, #0x0                   	// #0
    while (tmp >= base) {
    fd8000008cd0:	eb0300df 	cmp	x6, x3
    fd8000008cd4:	54fffea3 	b.cc	fd8000008ca8 <vprintd+0x48>  // b.lo, b.ul, b.last
    tmp = u;
    fd8000008cd8:	aa0603e1 	mov	x1, x6
    divisor = 1;
    fd8000008cdc:	d2800022 	mov	x2, #0x1                   	// #1
        divisor *= base;
        tmp /= base;
    fd8000008ce0:	9ac30821 	udiv	x1, x1, x3
        divisor *= base;
    fd8000008ce4:	9b037c42 	mul	x2, x2, x3
    while (tmp >= base) {
    fd8000008ce8:	eb03003f 	cmp	x1, x3
    fd8000008cec:	54ffffa2 	b.cs	fd8000008ce0 <vprintd+0x80>  // b.hs, b.nlast
    }

    while (divisor > 0U) {
    fd8000008cf0:	b40002a2 	cbz	x2, fd8000008d44 <vprintd+0xe4>
    fd8000008cf4:	d503201f 	nop
        unsigned long digit = u / divisor;
    fd8000008cf8:	9ac208c4 	udiv	x4, x6, x2
        u -= digit * divisor;
    fd8000008cfc:	aa0203e7 	mov	x7, x2
        divisor /= base;
        printc(buf, digit_to_char(digit, base));
        char_count++;
    fd8000008d00:	91000400 	add	x0, x0, #0x1
    unsigned long digit = i % base;
    fd8000008d04:	9ac30881 	udiv	x1, x4, x3
    fd8000008d08:	9b029886 	msub	x6, x4, x2, x6
        c = ((unsigned long)'0') + digit;
    fd8000008d0c:	f100249f 	cmp	x4, #0x9
        divisor /= base;
    fd8000008d10:	9ac30842 	udiv	x2, x2, x3
    unsigned long digit = i % base;
    fd8000008d14:	9b039021 	msub	x1, x1, x3, x4
        c = ((unsigned long)'0') + digit;
    fd8000008d18:	9100c024 	add	x4, x1, #0x30
    fd8000008d1c:	91015c21 	add	x1, x1, #0x57
    fd8000008d20:	9a848021 	csel	x1, x1, x4, hi	// hi = pmore
    if (buf != NULL) {
    fd8000008d24:	b40000c5 	cbz	x5, fd8000008d3c <vprintd+0xdc>
        **buf = c;
    fd8000008d28:	f94000a4 	ldr	x4, [x5]
    return (char)c;
    fd8000008d2c:	39000081 	strb	w1, [x4]
        (*buf)++;
    fd8000008d30:	f94000a1 	ldr	x1, [x5]
    fd8000008d34:	91000421 	add	x1, x1, #0x1
    fd8000008d38:	f90000a1 	str	x1, [x5]
    while (divisor > 0U) {
    fd8000008d3c:	eb07007f 	cmp	x3, x7
    fd8000008d40:	54fffdc9 	b.ls	fd8000008cf8 <vprintd+0x98>  // b.plast
    }

    return char_count;
}
    fd8000008d44:	d65f03c0 	ret
        u = is_long ? va_arg(*args, unsigned long) : va_arg(*args, unsigned int);
    fd8000008d48:	37f802a4 	tbnz	w4, #31, fd8000008d9c <vprintd+0x13c>
    fd8000008d4c:	91003c01 	add	x1, x0, #0xf
    fd8000008d50:	927df021 	and	x1, x1, #0xfffffffffffffff8
    fd8000008d54:	f9000041 	str	x1, [x2]
    fd8000008d58:	f9400006 	ldr	x6, [x0]
    size_t char_count = 0;
    fd8000008d5c:	d2800000 	mov	x0, #0x0                   	// #0
    fd8000008d60:	17ffffdc 	b	fd8000008cd0 <vprintd+0x70>
    size_t base = ((flags & F_BASE16) != 0U) ? (unsigned int)16U : 10U;
    fd8000008d64:	d2800143 	mov	x3, #0xa                   	// #10
        u = is_long ? va_arg(*args, unsigned long) : va_arg(*args, unsigned int);
    fd8000008d68:	34fffa86 	cbz	w6, fd8000008cb8 <vprintd+0x58>
    fd8000008d6c:	17fffff7 	b	fd8000008d48 <vprintd+0xe8>
    if (buf != NULL) {
    fd8000008d70:	b40000e5 	cbz	x5, fd8000008d8c <vprintd+0x12c>
        **buf = c;
    fd8000008d74:	f94000a0 	ldr	x0, [x5]
    fd8000008d78:	528005a1 	mov	w1, #0x2d                  	// #45
    fd8000008d7c:	39000001 	strb	w1, [x0]
        (*buf)++;
    fd8000008d80:	f94000a0 	ldr	x0, [x5]
    fd8000008d84:	91000400 	add	x0, x0, #0x1
    fd8000008d88:	f90000a0 	str	x0, [x5]
            s = -s;
    fd8000008d8c:	cb0603e6 	neg	x6, x6
            char_count++;
    fd8000008d90:	d2800020 	mov	x0, #0x1                   	// #1
    size_t base = ((flags & F_BASE16) != 0U) ? (unsigned int)16U : 10U;
    fd8000008d94:	d2800143 	mov	x3, #0xa                   	// #10
    fd8000008d98:	17ffffc1 	b	fd8000008c9c <vprintd+0x3c>
        u = is_long ? va_arg(*args, unsigned long) : va_arg(*args, unsigned int);
    fd8000008d9c:	11002081 	add	w1, w4, #0x8
    fd8000008da0:	b9001841 	str	w1, [x2, #24]
    fd8000008da4:	7100003f 	cmp	w1, #0x0
    fd8000008da8:	54fffd2c 	b.gt	fd8000008d4c <vprintd+0xec>
    fd8000008dac:	f9400440 	ldr	x0, [x2, #8]
    fd8000008db0:	8b24c000 	add	x0, x0, w4, sxtw
    fd8000008db4:	17ffffe9 	b	fd8000008d58 <vprintd+0xf8>
    fd8000008db8:	11002081 	add	w1, w4, #0x8
    fd8000008dbc:	b9001841 	str	w1, [x2, #24]
    fd8000008dc0:	7100003f 	cmp	w1, #0x0
    fd8000008dc4:	54fff7cc 	b.gt	fd8000008cbc <vprintd+0x5c>
    fd8000008dc8:	f9400440 	ldr	x0, [x2, #8]
    fd8000008dcc:	8b24c000 	add	x0, x0, w4, sxtw
    fd8000008dd0:	17ffffbe 	b	fd8000008cc8 <vprintd+0x68>
        signed long s = is_long ? va_arg(*args, signed long) : va_arg(*args, signed int);
    fd8000008dd4:	37f801a4 	tbnz	w4, #31, fd8000008e08 <vprintd+0x1a8>
    fd8000008dd8:	91002c01 	add	x1, x0, #0xb
    fd8000008ddc:	b9800006 	ldrsw	x6, [x0]
    fd8000008de0:	927df021 	and	x1, x1, #0xfffffffffffffff8
    fd8000008de4:	f9000041 	str	x1, [x2]
    fd8000008de8:	17ffffaa 	b	fd8000008c90 <vprintd+0x30>
    fd8000008dec:	11002081 	add	w1, w4, #0x8
    fd8000008df0:	b9001841 	str	w1, [x2, #24]
    fd8000008df4:	7100003f 	cmp	w1, #0x0
    fd8000008df8:	54fff44c 	b.gt	fd8000008c80 <vprintd+0x20>
    fd8000008dfc:	f9400440 	ldr	x0, [x2, #8]
    fd8000008e00:	8b24c000 	add	x0, x0, w4, sxtw
    fd8000008e04:	17ffffa2 	b	fd8000008c8c <vprintd+0x2c>
    fd8000008e08:	11002081 	add	w1, w4, #0x8
    fd8000008e0c:	b9001841 	str	w1, [x2, #24]
    fd8000008e10:	7100003f 	cmp	w1, #0x0
    fd8000008e14:	54fffe2c 	b.gt	fd8000008dd8 <vprintd+0x178>
    fd8000008e18:	f9400440 	ldr	x0, [x2, #8]
    fd8000008e1c:	8b24c000 	add	x0, x0, w4, sxtw
    fd8000008e20:	b9800006 	ldrsw	x6, [x0]
    fd8000008e24:	17ffff9b 	b	fd8000008c90 <vprintd+0x30>
    fd8000008e28:	d503201f 	nop
    fd8000008e2c:	d503201f 	nop

0000fd8000008e30 <vsnprintk>:
 * Note this does not follow the C lib vsnprintf specification. It returns the numbers of
 * characters written to the buffer, and changes fmt to point to the first character that was not
 * printed.
 */
size_t vsnprintk(char* buf, size_t buf_size, const char** fmt, va_list* args)
{
    fd8000008e30:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    fd8000008e34:	aa0303ea 	mov	x10, x3
    fd8000008e38:	aa0203ee 	mov	x14, x2
    fd8000008e3c:	910003fd 	mov	x29, sp
    char* buf_it = buf;
    size_t buf_left = buf_size;
    const char* fmt_it = *fmt;
    fd8000008e40:	f9400049 	ldr	x9, [x2]
    char* buf_it = buf;
    fd8000008e44:	f9000fe0 	str	x0, [sp, #24]
    va_list args_tmp;

    while ((*fmt_it != '\0') && (buf_left > 0U)) {
    fd8000008e48:	39400123 	ldrb	w3, [x9]
    fd8000008e4c:	340014a3 	cbz	w3, fd80000090e0 <vsnprintk+0x2b0>
    fd8000008e50:	aa0103ed 	mov	x13, x1
    fd8000008e54:	b4001461 	cbz	x1, fd80000090e0 <vsnprintk+0x2b0>
    size_t buf_left = buf_size;
    fd8000008e58:	aa0103eb 	mov	x11, x1
    fd8000008e5c:	14000009 	b	fd8000008e80 <vsnprintk+0x50>
        **buf = c;
    fd8000008e60:	f9400fe4 	ldr	x4, [sp, #24]
        if ((*fmt_it) != '%') {
            printc(&buf_it, *fmt_it);
            buf_left--;
    fd8000008e64:	d100056b 	sub	x11, x11, #0x1
                    fmt_it--;
                }
                break;
            }
        }
        fmt_it++;
    fd8000008e68:	91000529 	add	x9, x9, #0x1
        **buf = c;
    fd8000008e6c:	38001483 	strb	w3, [x4], #1
    while ((*fmt_it != '\0') && (buf_left > 0U)) {
    fd8000008e70:	39400123 	ldrb	w3, [x9]
        (*buf)++;
    fd8000008e74:	f9000fe4 	str	x4, [sp, #24]
    while ((*fmt_it != '\0') && (buf_left > 0U)) {
    fd8000008e78:	34000343 	cbz	w3, fd8000008ee0 <vsnprintk+0xb0>
    fd8000008e7c:	b40012ab 	cbz	x11, fd80000090d0 <vsnprintk+0x2a0>
        if ((*fmt_it) != '%') {
    fd8000008e80:	7100947f 	cmp	w3, #0x25
    fd8000008e84:	54fffee1 	b.ne	fd8000008e60 <vsnprintk+0x30>  // b.any
            if (*fmt_it == 'l') {
    fd8000008e88:	39400523 	ldrb	w3, [x9, #1]
    fd8000008e8c:	7101b07f 	cmp	w3, #0x6c
    fd8000008e90:	540010c0 	b.eq	fd80000090a8 <vsnprintk+0x278>  // b.none
            fmt_it++;
    fd8000008e94:	91000529 	add	x9, x9, #0x1
            flags = 0;
    fd8000008e98:	5280000c 	mov	w12, #0x0                   	// #0
                switch (*fmt_it) {
    fd8000008e9c:	7101a47f 	cmp	w3, #0x69
    fd8000008ea0:	54000880 	b.eq	fd8000008fb0 <vsnprintk+0x180>  // b.none
    fd8000008ea4:	54000268 	b.hi	fd8000008ef0 <vsnprintk+0xc0>  // b.pmore
    fd8000008ea8:	71018c7f 	cmp	w3, #0x63
    fd8000008eac:	54000b00 	b.eq	fd800000900c <vsnprintk+0x1dc>  // b.none
    fd8000008eb0:	71018c7f 	cmp	w3, #0x63
    fd8000008eb4:	54000cc8 	b.hi	fd800000904c <vsnprintk+0x21c>  // b.pmore
    fd8000008eb8:	7100947f 	cmp	w3, #0x25
    fd8000008ebc:	54000721 	b.ne	fd8000008fa0 <vsnprintk+0x170>  // b.any
        **buf = c;
    fd8000008ec0:	f9400fe4 	ldr	x4, [sp, #24]
    fd8000008ec4:	38001483 	strb	w3, [x4], #1
        (*buf)++;
    fd8000008ec8:	d2800028 	mov	x8, #0x1                   	// #1
                buf_left -= arg_char_count;
    fd8000008ecc:	cb08016b 	sub	x11, x11, x8
        (*buf)++;
    fd8000008ed0:	f9000fe4 	str	x4, [sp, #24]
    while ((*fmt_it != '\0') && (buf_left > 0U)) {
    fd8000008ed4:	39400523 	ldrb	w3, [x9, #1]
        fmt_it++;
    fd8000008ed8:	91000529 	add	x9, x9, #0x1
    while ((*fmt_it != '\0') && (buf_left > 0U)) {
    fd8000008edc:	35fffd03 	cbnz	w3, fd8000008e7c <vsnprintk+0x4c>
    }

    *fmt = fmt_it;
    return buf_size - buf_left;
    fd8000008ee0:	cb0b01a0 	sub	x0, x13, x11
    *fmt = fmt_it;
    fd8000008ee4:	f90001c9 	str	x9, [x14]
}
    fd8000008ee8:	a8c47bfd 	ldp	x29, x30, [sp], #64
    fd8000008eec:	d65f03c0 	ret
                switch (*fmt_it) {
    fd8000008ef0:	7101d47f 	cmp	w3, #0x75
    fd8000008ef4:	540005c0 	b.eq	fd8000008fac <vsnprintk+0x17c>  // b.none
    fd8000008ef8:	7101e07f 	cmp	w3, #0x78
    fd8000008efc:	54000560 	b.eq	fd8000008fa8 <vsnprintk+0x178>  // b.none
    fd8000008f00:	7101cc7f 	cmp	w3, #0x73
    fd8000008f04:	54ffff61 	b.ne	fd8000008ef0 <vsnprintk+0xc0>  // b.any
                        va_copy(args_tmp, *args);
    fd8000008f08:	f9400941 	ldr	x1, [x10, #16]
    fd8000008f0c:	f9001be1 	str	x1, [sp, #48]
    fd8000008f10:	f9400d41 	ldr	x1, [x10, #24]
    fd8000008f14:	f9001fe1 	str	x1, [sp, #56]
    fd8000008f18:	a9400940 	ldp	x0, x2, [x10]
    fd8000008f1c:	a9020be0 	stp	x0, x2, [sp, #32]
                        arg_char_count = prints(NULL, va_arg(args_tmp, char*));
    fd8000008f20:	37f809c1 	tbnz	w1, #31, fd8000009058 <vsnprintk+0x228>
    fd8000008f24:	91003c01 	add	x1, x0, #0xf
    fd8000008f28:	927df021 	and	x1, x1, #0xfffffffffffffff8
    fd8000008f2c:	f90013e1 	str	x1, [sp, #32]
    fd8000008f30:	f9400004 	ldr	x4, [x0]
    size_t char_count = 0;
    fd8000008f34:	d2800008 	mov	x8, #0x0                   	// #0
    while (*str_it != '\0') {
    fd8000008f38:	39400080 	ldrb	w0, [x4]
    fd8000008f3c:	340000c0 	cbz	w0, fd8000008f54 <vsnprintk+0x124>
        char_count++;
    fd8000008f40:	91000508 	add	x8, x8, #0x1
    while (*str_it != '\0') {
    fd8000008f44:	38686883 	ldrb	w3, [x4, x8]
    fd8000008f48:	35ffffc3 	cbnz	w3, fd8000008f40 <vsnprintk+0x110>
                        if (arg_char_count <= buf_left) {
    fd8000008f4c:	eb0b011f 	cmp	x8, x11
    fd8000008f50:	54000468 	b.hi	fd8000008fdc <vsnprintk+0x1ac>  // b.pmore
                            (void)prints(&buf_it, va_arg(*args, char*));
    fd8000008f54:	b9401941 	ldr	w1, [x10, #24]
    fd8000008f58:	f9400140 	ldr	x0, [x10]
    fd8000008f5c:	37f80981 	tbnz	w1, #31, fd800000908c <vsnprintk+0x25c>
    fd8000008f60:	91003c01 	add	x1, x0, #0xf
    fd8000008f64:	927df021 	and	x1, x1, #0xfffffffffffffff8
    fd8000008f68:	f9000141 	str	x1, [x10]
    fd8000008f6c:	f9400004 	ldr	x4, [x0]
    while (*str_it != '\0') {
    fd8000008f70:	39400083 	ldrb	w3, [x4]
    fd8000008f74:	340000e3 	cbz	w3, fd8000008f90 <vsnprintk+0x160>
    fd8000008f78:	f9400fe5 	ldr	x5, [sp, #24]
    fd8000008f7c:	d503201f 	nop
        **buf = c;
    fd8000008f80:	380014a3 	strb	w3, [x5], #1
    while (*str_it != '\0') {
    fd8000008f84:	38401c83 	ldrb	w3, [x4, #1]!
    fd8000008f88:	35ffffc3 	cbnz	w3, fd8000008f80 <vsnprintk+0x150>
    fd8000008f8c:	f9000fe5 	str	x5, [sp, #24]
            if (arg_char_count <= buf_left) {
    fd8000008f90:	eb0b011f 	cmp	x8, x11
    fd8000008f94:	54000248 	b.hi	fd8000008fdc <vsnprintk+0x1ac>  // b.pmore
                buf_left -= arg_char_count;
    fd8000008f98:	cb08016b 	sub	x11, x11, x8
    fd8000008f9c:	17ffffce 	b	fd8000008ed4 <vsnprintk+0xa4>
                switch (*fmt_it) {
    fd8000008fa0:	7101607f 	cmp	w3, #0x58
    fd8000008fa4:	54fff861 	b.ne	fd8000008eb0 <vsnprintk+0x80>  // b.any
                        flags = flags | F_BASE16;
    fd8000008fa8:	321e018c 	orr	w12, w12, #0x4
                        flags = flags | F_UNSIGNED;
    fd8000008fac:	321f018c 	orr	w12, w12, #0x2
                        va_copy(args_tmp, *args);
    fd8000008fb0:	a9401546 	ldp	x6, x5, [x10]
                        arg_char_count = vprintd(NULL, flags, &args_tmp);
    fd8000008fb4:	910083e2 	add	x2, sp, #0x20
                        va_copy(args_tmp, *args);
    fd8000008fb8:	a9410d44 	ldp	x4, x3, [x10, #16]
                        arg_char_count = vprintd(NULL, flags, &args_tmp);
    fd8000008fbc:	2a0c03e1 	mov	w1, w12
    fd8000008fc0:	d2800000 	mov	x0, #0x0                   	// #0
                        va_copy(args_tmp, *args);
    fd8000008fc4:	a90217e6 	stp	x6, x5, [sp, #32]
    fd8000008fc8:	a9030fe4 	stp	x4, x3, [sp, #48]
                        arg_char_count = vprintd(NULL, flags, &args_tmp);
    fd8000008fcc:	97ffff25 	bl	fd8000008c60 <vprintd>
    fd8000008fd0:	aa0003e8 	mov	x8, x0
                        if (arg_char_count <= buf_left) {
    fd8000008fd4:	eb0b001f 	cmp	x0, x11
    fd8000008fd8:	540002e9 	b.ls	fd8000009034 <vsnprintk+0x204>  // b.plast
                while (*fmt_it != '%') {
    fd8000008fdc:	39400121 	ldrb	w1, [x9]
    return buf_size - buf_left;
    fd8000008fe0:	cb0b01a0 	sub	x0, x13, x11
                while (*fmt_it != '%') {
    fd8000008fe4:	7100943f 	cmp	w1, #0x25
    fd8000008fe8:	54fff7e0 	b.eq	fd8000008ee4 <vsnprintk+0xb4>  // b.none
    fd8000008fec:	d503201f 	nop
    fd8000008ff0:	385ffd21 	ldrb	w1, [x9, #-1]!
    fd8000008ff4:	7100943f 	cmp	w1, #0x25
    fd8000008ff8:	54fff760 	b.eq	fd8000008ee4 <vsnprintk+0xb4>  // b.none
    fd8000008ffc:	385ffd21 	ldrb	w1, [x9, #-1]!
    fd8000009000:	7100943f 	cmp	w1, #0x25
    fd8000009004:	54ffff61 	b.ne	fd8000008ff0 <vsnprintk+0x1c0>  // b.any
    fd8000009008:	17ffffb7 	b	fd8000008ee4 <vsnprintk+0xb4>
                            printc(&buf_it, (char)va_arg(args_tmp, int));
    fd800000900c:	b9403be1 	ldr	w1, [sp, #56]
    fd8000009010:	f94013e0 	ldr	x0, [sp, #32]
    fd8000009014:	37f802e1 	tbnz	w1, #31, fd8000009070 <vsnprintk+0x240>
    fd8000009018:	91002c01 	add	x1, x0, #0xb
    fd800000901c:	927df021 	and	x1, x1, #0xfffffffffffffff8
    fd8000009020:	f90013e1 	str	x1, [sp, #32]
    fd8000009024:	f9400fe4 	ldr	x4, [sp, #24]
    fd8000009028:	b9400000 	ldr	w0, [x0]
    fd800000902c:	38001480 	strb	w0, [x4], #1
            } while (ignore_char);
    fd8000009030:	17ffffa6 	b	fd8000008ec8 <vsnprintk+0x98>
                            (void)vprintd(&buf_it, flags, args);
    fd8000009034:	2a0c03e1 	mov	w1, w12
    fd8000009038:	aa0a03e2 	mov	x2, x10
    fd800000903c:	910063e0 	add	x0, sp, #0x18
                buf_left -= arg_char_count;
    fd8000009040:	cb08016b 	sub	x11, x11, x8
                            (void)vprintd(&buf_it, flags, args);
    fd8000009044:	97ffff07 	bl	fd8000008c60 <vprintd>
                buf_left -= arg_char_count;
    fd8000009048:	17ffffa3 	b	fd8000008ed4 <vsnprintk+0xa4>
                switch (*fmt_it) {
    fd800000904c:	7101907f 	cmp	w3, #0x64
    fd8000009050:	54fffb00 	b.eq	fd8000008fb0 <vsnprintk+0x180>  // b.none
    fd8000009054:	14000000 	b	fd8000009054 <vsnprintk+0x224>
                        arg_char_count = prints(NULL, va_arg(args_tmp, char*));
    fd8000009058:	11002023 	add	w3, w1, #0x8
    fd800000905c:	b9003be3 	str	w3, [sp, #56]
    fd8000009060:	7100007f 	cmp	w3, #0x0
    fd8000009064:	54fff60c 	b.gt	fd8000008f24 <vsnprintk+0xf4>
    fd8000009068:	8b21c040 	add	x0, x2, w1, sxtw
    fd800000906c:	17ffffb1 	b	fd8000008f30 <vsnprintk+0x100>
                            printc(&buf_it, (char)va_arg(args_tmp, int));
    fd8000009070:	11002022 	add	w2, w1, #0x8
    fd8000009074:	b9003be2 	str	w2, [sp, #56]
    fd8000009078:	7100005f 	cmp	w2, #0x0
    fd800000907c:	54fffcec 	b.gt	fd8000009018 <vsnprintk+0x1e8>
    fd8000009080:	f94017e0 	ldr	x0, [sp, #40]
    fd8000009084:	8b21c000 	add	x0, x0, w1, sxtw
    fd8000009088:	17ffffe7 	b	fd8000009024 <vsnprintk+0x1f4>
                            (void)prints(&buf_it, va_arg(*args, char*));
    fd800000908c:	11002022 	add	w2, w1, #0x8
    fd8000009090:	b9001942 	str	w2, [x10, #24]
    fd8000009094:	7100005f 	cmp	w2, #0x0
    fd8000009098:	54fff64c 	b.gt	fd8000008f60 <vsnprintk+0x130>
    fd800000909c:	f9400540 	ldr	x0, [x10, #8]
    fd80000090a0:	8b21c000 	add	x0, x0, w1, sxtw
    fd80000090a4:	17ffffb2 	b	fd8000008f6c <vsnprintk+0x13c>
                if (*fmt_it == 'l') {
    fd80000090a8:	39400923 	ldrb	w3, [x9, #2]
    fd80000090ac:	7101b07f 	cmp	w3, #0x6c
    fd80000090b0:	54000080 	b.eq	fd80000090c0 <vsnprintk+0x290>  // b.none
                fmt_it++;
    fd80000090b4:	91000929 	add	x9, x9, #0x2
                flags = flags | F_LONG;
    fd80000090b8:	5280002c 	mov	w12, #0x1                   	// #1
    fd80000090bc:	17ffff78 	b	fd8000008e9c <vsnprintk+0x6c>
                switch (*fmt_it) {
    fd80000090c0:	39400d23 	ldrb	w3, [x9, #3]
                flags = flags | F_LONG;
    fd80000090c4:	5280002c 	mov	w12, #0x1                   	// #1
                    fmt_it++;
    fd80000090c8:	91000d29 	add	x9, x9, #0x3
    fd80000090cc:	17ffff74 	b	fd8000008e9c <vsnprintk+0x6c>
    *fmt = fmt_it;
    fd80000090d0:	f90001c9 	str	x9, [x14]
    fd80000090d4:	aa0d03e0 	mov	x0, x13
}
    fd80000090d8:	a8c47bfd 	ldp	x29, x30, [sp], #64
    fd80000090dc:	d65f03c0 	ret
    while ((*fmt_it != '\0') && (buf_left > 0U)) {
    fd80000090e0:	d2800000 	mov	x0, #0x0                   	// #0
    fd80000090e4:	17ffff80 	b	fd8000008ee4 <vsnprintk+0xb4>
	...

0000fd80000090f0 <bitmap_find_nth>:

#include <bitmap.h>

ssize_t bitmap_find_nth(bitmap_t* map, size_t size, size_t nth, size_t start, bool set)
{
    if (size <= 0 || nth <= 0 || start < 0) {
    fd80000090f0:	f100003f 	cmp	x1, #0x0
{
    fd80000090f4:	aa0003e6 	mov	x6, x0
    if (size <= 0 || nth <= 0 || start < 0) {
    fd80000090f8:	fa401844 	ccmp	x2, #0x0, #0x4, ne	// ne = any
{
    fd80000090fc:	12001c84 	and	w4, w4, #0xff
    if (size <= 0 || nth <= 0 || start < 0) {
    fd8000009100:	540002a0 	b.eq	fd8000009154 <bitmap_find_nth+0x64>  // b.none
    }

    size_t count = 0;
    unsigned bit = set ? 1 : 0;

    for (ssize_t i = start; i < size; i++) {
    fd8000009104:	aa0303e0 	mov	x0, x3
    fd8000009108:	eb03003f 	cmp	x1, x3
    fd800000910c:	54000249 	b.ls	fd8000009154 <bitmap_find_nth+0x64>  // b.plast
    size_t count = 0;
    fd8000009110:	d2800007 	mov	x7, #0x0                   	// #0
    fd8000009114:	52800028 	mov	w8, #0x1                   	// #1
    fd8000009118:	14000004 	b	fd8000009128 <bitmap_find_nth+0x38>
    for (ssize_t i = start; i < size; i++) {
    fd800000911c:	91000400 	add	x0, x0, #0x1
    fd8000009120:	eb00003f 	cmp	x1, x0
    fd8000009124:	54000189 	b.ls	fd8000009154 <bitmap_find_nth+0x64>  // b.plast
    fd8000009128:	d345fc05 	lsr	x5, x0, #5
    fd800000912c:	1ac02103 	lsl	w3, w8, w0
    fd8000009130:	b86578c5 	ldr	w5, [x6, x5, lsl #2]
    fd8000009134:	6a05007f 	tst	w3, w5
        if (bitmap_get(map, i) == bit) {
    fd8000009138:	1a9f07e3 	cset	w3, ne	// ne = any
    fd800000913c:	6b04007f 	cmp	w3, w4
    fd8000009140:	54fffee1 	b.ne	fd800000911c <bitmap_find_nth+0x2c>  // b.any
            if (++count == nth) {
    fd8000009144:	910004e7 	add	x7, x7, #0x1
    fd8000009148:	eb07005f 	cmp	x2, x7
    fd800000914c:	54fffe81 	b.ne	fd800000911c <bitmap_find_nth+0x2c>  // b.any
            }
        }
    }

    return -1;
}
    fd8000009150:	d65f03c0 	ret
        return -1;
    fd8000009154:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
}
    fd8000009158:	d65f03c0 	ret
    fd800000915c:	d503201f 	nop

0000fd8000009160 <bitmap_count_consecutive>:

size_t bitmap_count_consecutive(bitmap_t* map, size_t size, size_t start, size_t n)
{
    size_t pos = start;
    size_t count = 0;
    size_t start_offset = start % BITMAP_GRANULE_LEN;
    fd8000009160:	92401049 	and	x9, x2, #0x1f
    size_t first_word_bits = min(BITMAP_GRANULE_LEN - start_offset, n);
    fd8000009164:	d2800404 	mov	x4, #0x20                  	// #32
    fd8000009168:	cb090084 	sub	x4, x4, x9
{
    fd800000916c:	aa0003e8 	mov	x8, x0
    size_t first_word_bits = min(BITMAP_GRANULE_LEN - start_offset, n);
    fd8000009170:	eb03009f 	cmp	x4, x3
    fd8000009174:	d345fc47 	lsr	x7, x2, #5
    fd8000009178:	9a839080 	csel	x0, x4, x3, ls	// ls = plast
    fd800000917c:	52800026 	mov	w6, #0x1                   	// #1
    bool set = !!bitmap_get(map, start);
    bitmap_granule_t init_mask = BITMAP_GRANULE_MASK(start_offset, first_word_bits);
    fd8000009180:	51000404 	sub	w4, w0, #0x1
    fd8000009184:	1ac920c5 	lsl	w5, w6, w9
    fd8000009188:	b8677907 	ldr	w7, [x8, x7, lsl #2]
    fd800000918c:	1ac420c4 	lsl	w4, w6, w4
    fd8000009190:	0b040084 	add	w4, w4, w4
    fd8000009194:	51000484 	sub	w4, w4, #0x1
    fd8000009198:	6a0700a5 	ands	w5, w5, w7
    fd800000919c:	1ac92084 	lsl	w4, w4, w9
    fd80000091a0:	54000660 	b.eq	fd800000926c <bitmap_count_consecutive+0x10c>  // b.none
    bitmap_granule_t mask;

    if (n <= 1) {
    fd80000091a4:	f100047f 	cmp	x3, #0x1
    fd80000091a8:	540005e9 	b.ls	fd8000009264 <bitmap_count_consecutive+0x104>  // b.plast
        return n;
    }

    mask = set ? init_mask : ~init_mask;
    if (!((map[pos / BITMAP_GRANULE_LEN] ^ mask) & init_mask)) {
    fd80000091ac:	6a27009f 	bics	wzr, w4, w7
    fd80000091b0:	540006c1 	b.ne	fd8000009288 <bitmap_count_consecutive+0x128>  // b.any
    fd80000091b4:	12800007 	mov	w7, #0xffffffff            	// #-1
        count += first_word_bits;
        pos += first_word_bits;
    fd80000091b8:	8b000042 	add	x2, x2, x0
    fd80000091bc:	2a0703e5 	mov	w5, w7
    }

    mask = set ? ~0 : 0;
    while ((pos < size) && !(map[pos / BITMAP_GRANULE_LEN] ^ mask) && (count < n)) {
    fd80000091c0:	eb02003f 	cmp	x1, x2
    fd80000091c4:	540004e9 	b.ls	fd8000009260 <bitmap_count_consecutive+0x100>  // b.plast
    fd80000091c8:	d345fc44 	lsr	x4, x2, #5
    fd80000091cc:	eb00007f 	cmp	x3, x0
    fd80000091d0:	1a9f97e9 	cset	w9, hi	// hi = pmore
    fd80000091d4:	7100013f 	cmp	w9, #0x0
    fd80000091d8:	b8647904 	ldr	w4, [x8, x4, lsl #2]
    fd80000091dc:	7a4410a0 	ccmp	w5, w4, #0x0, ne	// ne = any
    fd80000091e0:	540001a1 	b.ne	fd8000009214 <bitmap_count_consecutive+0xb4>  // b.any
    fd80000091e4:	d503201f 	nop
        count += BITMAP_GRANULE_LEN;
        pos += BITMAP_GRANULE_LEN;
    fd80000091e8:	91008042 	add	x2, x2, #0x20
        count += BITMAP_GRANULE_LEN;
    fd80000091ec:	91008000 	add	x0, x0, #0x20
    while ((pos < size) && !(map[pos / BITMAP_GRANULE_LEN] ^ mask) && (count < n)) {
    fd80000091f0:	eb02003f 	cmp	x1, x2
    fd80000091f4:	54000369 	b.ls	fd8000009260 <bitmap_count_consecutive+0x100>  // b.plast
    fd80000091f8:	d345fc44 	lsr	x4, x2, #5
    fd80000091fc:	b8647904 	ldr	w4, [x8, x4, lsl #2]
    fd8000009200:	6b05009f 	cmp	w4, w5
    fd8000009204:	fa400060 	ccmp	x3, x0, #0x0, eq	// eq = none
    fd8000009208:	54ffff08 	b.hi	fd80000091e8 <bitmap_count_consecutive+0x88>  // b.pmore
    fd800000920c:	eb00007f 	cmp	x3, x0
    fd8000009210:	1a9f97e9 	cset	w9, hi	// hi = pmore
    fd8000009214:	52800027 	mov	w7, #0x1                   	// #1
    fd8000009218:	1ac220e5 	lsl	w5, w7, w2
    fd800000921c:	6a0400bf 	tst	w5, w4
    }

    while ((pos < size) && (!!bitmap_get(map, pos) == set) && (count < n)) {
    fd8000009220:	1a9f07e4 	cset	w4, ne	// ne = any
    fd8000009224:	7100013f 	cmp	w9, #0x0
    fd8000009228:	7a461080 	ccmp	w4, w6, #0x0, ne	// ne = any
    fd800000922c:	540001a1 	b.ne	fd8000009260 <bitmap_count_consecutive+0x100>  // b.any
        count++;
        pos += 1;
    fd8000009230:	91000442 	add	x2, x2, #0x1
        count++;
    fd8000009234:	91000400 	add	x0, x0, #0x1
    while ((pos < size) && (!!bitmap_get(map, pos) == set) && (count < n)) {
    fd8000009238:	eb02003f 	cmp	x1, x2
    fd800000923c:	54000129 	b.ls	fd8000009260 <bitmap_count_consecutive+0x100>  // b.plast
    fd8000009240:	d345fc45 	lsr	x5, x2, #5
    fd8000009244:	1ac220e4 	lsl	w4, w7, w2
    fd8000009248:	b8657905 	ldr	w5, [x8, x5, lsl #2]
    fd800000924c:	6a05009f 	tst	w4, w5
    fd8000009250:	1a9f07e4 	cset	w4, ne	// ne = any
    fd8000009254:	6b06009f 	cmp	w4, w6
    fd8000009258:	fa400060 	ccmp	x3, x0, #0x0, eq	// eq = none
    fd800000925c:	54fffea8 	b.hi	fd8000009230 <bitmap_count_consecutive+0xd0>  // b.pmore
    }

    return count;
}
    fd8000009260:	d65f03c0 	ret
        return n;
    fd8000009264:	aa0303e0 	mov	x0, x3
}
    fd8000009268:	d65f03c0 	ret
    if (n <= 1) {
    fd800000926c:	f100047f 	cmp	x3, #0x1
    fd8000009270:	54ffffa9 	b.ls	fd8000009264 <bitmap_count_consecutive+0x104>  // b.plast
    if (!((map[pos / BITMAP_GRANULE_LEN] ^ mask) & init_mask)) {
    fd8000009274:	6a0400e7 	ands	w7, w7, w4
    bool set = !!bitmap_get(map, start);
    fd8000009278:	52800006 	mov	w6, #0x0                   	// #0
    if (!((map[pos / BITMAP_GRANULE_LEN] ^ mask) & init_mask)) {
    fd800000927c:	54fff9e0 	b.eq	fd80000091b8 <bitmap_count_consecutive+0x58>  // b.none
    size_t count = 0;
    fd8000009280:	d2800000 	mov	x0, #0x0                   	// #0
    mask = set ? ~0 : 0;
    fd8000009284:	17ffffcf 	b	fd80000091c0 <bitmap_count_consecutive+0x60>
    fd8000009288:	12800005 	mov	w5, #0xffffffff            	// #-1
    size_t count = 0;
    fd800000928c:	d2800000 	mov	x0, #0x0                   	// #0
    mask = set ? ~0 : 0;
    fd8000009290:	17ffffcc 	b	fd80000091c0 <bitmap_count_consecutive+0x60>
    fd8000009294:	d503201f 	nop
    fd8000009298:	d503201f 	nop
    fd800000929c:	d503201f 	nop

0000fd80000092a0 <bitmap_find_consec>:
    if (size <= 0 || nth <= 0 || start < 0) {
    fd80000092a0:	b40006a1 	cbz	x1, fd8000009374 <bitmap_find_consec+0xd4>
    fd80000092a4:	aa0103eb 	mov	x11, x1
    for (ssize_t i = start; i < size; i++) {
    fd80000092a8:	aa0203ea 	mov	x10, x2
    fd80000092ac:	eb02003f 	cmp	x1, x2
    fd80000092b0:	54000629 	b.ls	fd8000009374 <bitmap_find_consec+0xd4>  // b.plast
        if (bitmap_get(map, i) == bit) {
    fd80000092b4:	aa0003ec 	mov	x12, x0
    fd80000092b8:	d345fc40 	lsr	x0, x2, #5
    fd80000092bc:	52800021 	mov	w1, #0x1                   	// #1
    fd80000092c0:	12001c84 	and	w4, w4, #0xff
    fd80000092c4:	1ac22022 	lsl	w2, w1, w2
    fd80000092c8:	aa0303ee 	mov	x14, x3
    fd80000092cc:	b8607980 	ldr	w0, [x12, x0, lsl #2]
    fd80000092d0:	6a00005f 	tst	w2, w0
    fd80000092d4:	1a9f07e0 	cset	w0, ne	// ne = any
    fd80000092d8:	6b04001f 	cmp	w0, w4
    fd80000092dc:	54000160 	b.eq	fd8000009308 <bitmap_find_consec+0x68>  // b.none
    for (ssize_t i = start; i < size; i++) {
    fd80000092e0:	9100054a 	add	x10, x10, #0x1
    fd80000092e4:	eb0b015f 	cmp	x10, x11
    fd80000092e8:	54000462 	b.cs	fd8000009374 <bitmap_find_consec+0xd4>  // b.hs, b.nlast
    fd80000092ec:	d345fd45 	lsr	x5, x10, #5
    fd80000092f0:	1aca2022 	lsl	w2, w1, w10
    fd80000092f4:	b8657980 	ldr	w0, [x12, x5, lsl #2]
    fd80000092f8:	6a00005f 	tst	w2, w0
        if (bitmap_get(map, i) == bit) {
    fd80000092fc:	1a9f07e0 	cset	w0, ne	// ne = any
    fd8000009300:	6b04001f 	cmp	w0, w4
    fd8000009304:	54fffee1 	b.ne	fd80000092e0 <bitmap_find_consec+0x40>  // b.any
{
    ssize_t count = 0;
    ssize_t i = 0;

    // find first set
    if ((i = bitmap_find_nth(map, size, 1, start, set)) < 0) {
    fd8000009308:	b7f8036a 	tbnz	x10, #63, fd8000009374 <bitmap_find_consec+0xd4>
        return -1;
    }

    while (i < size) {
    fd800000930c:	eb0a017f 	cmp	x11, x10
    fd8000009310:	54000329 	b.ls	fd8000009374 <bitmap_find_consec+0xd4>  // b.plast
{
    fd8000009314:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    fd8000009318:	910003fd 	mov	x29, sp
    fd800000931c:	14000005 	b	fd8000009330 <bitmap_find_consec+0x90>
        // find the last (with n as maximum) contiguous set page
        count = bitmap_count_consecutive(map, size, i, n);
        if (count < n) { // if didn't found enough n contiguous set pages
            i += count;
            // find the last contiguous ~set page
            i += bitmap_count_consecutive(map, size, i, -1);
    fd8000009320:	97ffff90 	bl	fd8000009160 <bitmap_count_consecutive>
    fd8000009324:	8b0001aa 	add	x10, x13, x0
    while (i < size) {
    fd8000009328:	eb0b015f 	cmp	x10, x11
    fd800000932c:	540002a2 	b.cs	fd8000009380 <bitmap_find_consec+0xe0>  // b.hs, b.nlast
        count = bitmap_count_consecutive(map, size, i, n);
    fd8000009330:	aa0a03e2 	mov	x2, x10
    fd8000009334:	aa0e03e3 	mov	x3, x14
    fd8000009338:	aa0b03e1 	mov	x1, x11
    fd800000933c:	aa0c03e0 	mov	x0, x12
    fd8000009340:	97ffff88 	bl	fd8000009160 <bitmap_count_consecutive>
    fd8000009344:	aa0003e2 	mov	x2, x0
            i += count;
    fd8000009348:	8b0a004d 	add	x13, x2, x10
        if (count < n) { // if didn't found enough n contiguous set pages
    fd800000934c:	eb0e005f 	cmp	x2, x14
            i += bitmap_count_consecutive(map, size, i, -1);
    fd8000009350:	aa0c03e0 	mov	x0, x12
    fd8000009354:	aa0d03e2 	mov	x2, x13
    fd8000009358:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
        if (count < n) { // if didn't found enough n contiguous set pages
    fd800000935c:	54fffe23 	b.cc	fd8000009320 <bitmap_find_consec+0x80>  // b.lo, b.ul, b.last
        return -1;
    fd8000009360:	eb0a017f 	cmp	x11, x10
    fd8000009364:	da9f814a 	csinv	x10, x10, xzr, hi	// hi = pmore
    if (i >= size) {
        i = -1;
    }

    return i;
}
    fd8000009368:	aa0a03e0 	mov	x0, x10
    fd800000936c:	a8c17bfd 	ldp	x29, x30, [sp], #16
    fd8000009370:	d65f03c0 	ret
        return -1;
    fd8000009374:	9280000a 	mov	x10, #0xffffffffffffffff    	// #-1
}
    fd8000009378:	aa0a03e0 	mov	x0, x10
    fd800000937c:	d65f03c0 	ret
        return -1;
    fd8000009380:	aa0303ea 	mov	x10, x3
}
    fd8000009384:	aa0a03e0 	mov	x0, x10
    fd8000009388:	a8c17bfd 	ldp	x29, x30, [sp], #16
    fd800000938c:	d65f03c0 	ret

0000fd8000009390 <bitmap_set_consecutive>:

void bitmap_set_consecutive(bitmap_t* map, size_t start, size_t n)
{
    size_t pos = start;
    size_t count = n;
    size_t start_offset = start % BITMAP_GRANULE_LEN;
    fd8000009390:	92401027 	and	x7, x1, #0x1f
    size_t first_word_bits = min(BITMAP_GRANULE_LEN - start_offset, count);
    fd8000009394:	d2800403 	mov	x3, #0x20                  	// #32
    fd8000009398:	cb070063 	sub	x3, x3, x7

    map[pos / BITMAP_GRANULE_LEN] |= BITMAP_GRANULE_MASK(start_offset, first_word_bits);
    fd800000939c:	d345fc26 	lsr	x6, x1, #5
    size_t first_word_bits = min(BITMAP_GRANULE_LEN - start_offset, count);
    fd80000093a0:	eb02007f 	cmp	x3, x2
    map[pos / BITMAP_GRANULE_LEN] |= BITMAP_GRANULE_MASK(start_offset, first_word_bits);
    fd80000093a4:	52800044 	mov	w4, #0x2                   	// #2
    size_t first_word_bits = min(BITMAP_GRANULE_LEN - start_offset, count);
    fd80000093a8:	9a829063 	csel	x3, x3, x2, ls	// ls = plast
    map[pos / BITMAP_GRANULE_LEN] |= BITMAP_GRANULE_MASK(start_offset, first_word_bits);
    fd80000093ac:	51000468 	sub	w8, w3, #0x1
    pos += first_word_bits;
    count -= first_word_bits;
    fd80000093b0:	cb030045 	sub	x5, x2, x3
    pos += first_word_bits;
    fd80000093b4:	8b030022 	add	x2, x1, x3
    map[pos / BITMAP_GRANULE_LEN] |= BITMAP_GRANULE_MASK(start_offset, first_word_bits);
    fd80000093b8:	b8667803 	ldr	w3, [x0, x6, lsl #2]
    fd80000093bc:	1ac82081 	lsl	w1, w4, w8
    fd80000093c0:	51000421 	sub	w1, w1, #0x1

    while (count >= BITMAP_GRANULE_LEN) {
    fd80000093c4:	f1007cbf 	cmp	x5, #0x1f
    map[pos / BITMAP_GRANULE_LEN] |= BITMAP_GRANULE_MASK(start_offset, first_word_bits);
    fd80000093c8:	1ac72021 	lsl	w1, w1, w7
    fd80000093cc:	2a010061 	orr	w1, w3, w1
    fd80000093d0:	b8267801 	str	w1, [x0, x6, lsl #2]
    while (count >= BITMAP_GRANULE_LEN) {
    fd80000093d4:	54000309 	b.ls	fd8000009434 <bitmap_set_consecutive+0xa4>  // b.plast
    fd80000093d8:	d10080a3 	sub	x3, x5, #0x20
    fd80000093dc:	91008041 	add	x1, x2, #0x20
    fd80000093e0:	927be863 	and	x3, x3, #0xffffffffffffffe0
        map[pos / BITMAP_GRANULE_LEN] |= ~0;
    fd80000093e4:	12800006 	mov	w6, #0xffffffff            	// #-1
    fd80000093e8:	8b010063 	add	x3, x3, x1
    fd80000093ec:	d503201f 	nop
    fd80000093f0:	d345fc44 	lsr	x4, x2, #5
    while (count >= BITMAP_GRANULE_LEN) {
    fd80000093f4:	eb03003f 	cmp	x1, x3
        pos += BITMAP_GRANULE_LEN;
    fd80000093f8:	aa0103e2 	mov	x2, x1
    fd80000093fc:	91008021 	add	x1, x1, #0x20
        map[pos / BITMAP_GRANULE_LEN] |= ~0;
    fd8000009400:	b8247806 	str	w6, [x0, x4, lsl #2]
    while (count >= BITMAP_GRANULE_LEN) {
    fd8000009404:	54ffff61 	b.ne	fd80000093f0 <bitmap_set_consecutive+0x60>  // b.any
    fd8000009408:	924010a5 	and	x5, x5, #0x1f
        count -= BITMAP_GRANULE_LEN;
    }

    if (count > 0) {
    fd800000940c:	b4000125 	cbz	x5, fd8000009430 <bitmap_set_consecutive+0xa0>
        map[pos / BITMAP_GRANULE_LEN] |= BITMAP_GRANULE_MASK(0, count);
    fd8000009410:	d345fc63 	lsr	x3, x3, #5
    fd8000009414:	510004a5 	sub	w5, w5, #0x1
    fd8000009418:	52800041 	mov	w1, #0x2                   	// #2
    fd800000941c:	1ac52021 	lsl	w1, w1, w5
    fd8000009420:	51000421 	sub	w1, w1, #0x1
    fd8000009424:	b8637802 	ldr	w2, [x0, x3, lsl #2]
    fd8000009428:	2a010041 	orr	w1, w2, w1
    fd800000942c:	b8237801 	str	w1, [x0, x3, lsl #2]
    }
}
    fd8000009430:	d65f03c0 	ret
    pos += first_word_bits;
    fd8000009434:	aa0203e3 	mov	x3, x2
    fd8000009438:	17fffff5 	b	fd800000940c <bitmap_set_consecutive+0x7c>
    fd800000943c:	00000000 	udf	#0

0000fd8000009440 <init>:
#include <printk.h>
#include <platform.h>
#include <vmm.h>

void init(cpuid_t cpu_id, paddr_t load_addr)    //arguments received from the boot.S
{
    fd8000009440:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    fd8000009444:	910003fd 	mov	x29, sp
    fd8000009448:	f9000bf3 	str	x19, [sp, #16]
    fd800000944c:	aa0103f3 	mov	x19, x1
    /**
     * These initializations must be executed first and in fixed order.
     */

    cpu_init(cpu_id, load_addr);
    fd8000009450:	94000520 	bl	fd800000a8d0 <cpu_init>
    mem_init(load_addr);
    fd8000009454:	aa1303e0 	mov	x0, x19
    fd8000009458:	940003aa 	bl	fd800000a300 <mem_init>

    /* -------------------------------------------------------------- */

    console_init();
    fd800000945c:	94000b2d 	bl	fd800000c110 <console_init>

    if (cpu()->id == CPU_MASTER) {
    fd8000009460:	90000000 	adrp	x0, fd8000009000 <vsnprintk+0x1d0>
    fd8000009464:	f9424c00 	ldr	x0, [x0, #1176]
    fd8000009468:	d2dfc001 	mov	x1, #0xfe0000000000        	// #279275953455104
    fd800000946c:	f9400021 	ldr	x1, [x1]
    fd8000009470:	f9400000 	ldr	x0, [x0]
    fd8000009474:	eb00003f 	cmp	x1, x0
    fd8000009478:	54000080 	b.eq	fd8000009488 <init+0x48>  // b.none
        console_printk("Bao Hypervisor\n\r");
    }
    interrupts_init();
    fd800000947c:	940004f5 	bl	fd800000a850 <interrupts_init>

    vmm_init();
    fd8000009480:	94000628 	bl	fd800000ad20 <vmm_init>

    /* Should never reach here */
    while (1) { }
    fd8000009484:	14000000 	b	fd8000009484 <init+0x44>
        console_printk("Bao Hypervisor\n\r");
    fd8000009488:	90000000 	adrp	x0, fd8000009000 <vsnprintk+0x1d0>
    fd800000948c:	f9425000 	ldr	x0, [x0, #1184]
    fd8000009490:	94000ae4 	bl	fd800000c020 <console_printk>
    fd8000009494:	17fffffa 	b	fd800000947c <init+0x3c>
    fd8000009498:	00012348 	.word	0x00012348
    fd800000949c:	0000fd80 	.word	0x0000fd80
    fd80000094a0:	00010a68 	.word	0x00010a68
    fd80000094a4:	0000fd80 	.word	0x0000fd80
	...

0000fd80000094b0 <cpu_sync_and_clear_msgs.constprop.0>:
    }

    return reserved;
}

bool mem_are_ppages_reserved(struct ppages* ppages)
    fd80000094b0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    fd80000094b4:	910003fd 	mov	x29, sp
    fd80000094b8:	a90153f3 	stp	x19, x20, [sp, #16]
    fd80000094bc:	90000000 	adrp	x0, fd8000009000 <vsnprintk+0x1d0>
    fd80000094c0:	f9430413 	ldr	x19, [x0, #1544]
    fd80000094c4:	f90013f5 	str	x21, [sp, #32]
{
    bool reserved = false;
    list_foreach (page_pool_list, struct page_pool, pool) {
        bool is_in_rgn = range_in_range(ppages->base, ppages->num_pages * PAGE_SIZE, pool->base,
    fd80000094c8:	39404260 	ldrb	w0, [x19, #16]
    fd80000094cc:	3607ffe0 	tbz	w0, #0, fd80000094c8 <cpu_sync_and_clear_msgs.constprop.0+0x18>
    __asm__ volatile(
    fd80000094d0:	91001263 	add	x3, x19, #0x4
    fd80000094d4:	885ffe60 	ldaxr	w0, [x19]
    fd80000094d8:	11000401 	add	w1, w0, #0x1
    fd80000094dc:	88027e61 	stxr	w2, w1, [x19]
    fd80000094e0:	35ffffa2 	cbnz	w2, fd80000094d4 <cpu_sync_and_clear_msgs.constprop.0+0x24>
    fd80000094e4:	88dffc61 	ldar	w1, [x3]
    fd80000094e8:	6b01001f 	cmp	w0, w1
    fd80000094ec:	54000060 	b.eq	fd80000094f8 <cpu_sync_and_clear_msgs.constprop.0+0x48>  // b.none
    fd80000094f0:	d503205f 	wfe
    fd80000094f4:	17fffffc 	b	fd80000094e4 <cpu_sync_and_clear_msgs.constprop.0+0x34>
    token->count++;
    fd80000094f8:	f9400e60 	ldr	x0, [x19, #24]
    fd80000094fc:	91000400 	add	x0, x0, #0x1
    fd8000009500:	f9000e60 	str	x0, [x19, #24]
    next_count = ALIGN(token->count, token->n);
    fd8000009504:	f9400e74 	ldr	x20, [x19, #24]
    fd8000009508:	f9400660 	ldr	x0, [x19, #8]
    fd800000950c:	f9400661 	ldr	x1, [x19, #8]
    fd8000009510:	8b000294 	add	x20, x20, x0
    fd8000009514:	d1000694 	sub	x20, x20, #0x1
    fd8000009518:	f9400660 	ldr	x0, [x19, #8]
    fd800000951c:	9ac10a94 	udiv	x20, x20, x1
    fd8000009520:	9b007e94 	mul	x20, x20, x0
    __asm__ volatile(
    fd8000009524:	b9400060 	ldr	w0, [x3]
    fd8000009528:	11000400 	add	w0, w0, #0x1
    fd800000952c:	889ffc60 	stlr	w0, [x3]
    fd8000009530:	d5033b9f 	dsb	ish
    fd8000009534:	d503209f 	sev
        if (!cpu()->handling_msgs) {
    fd8000009538:	d2dfc015 	mov	x21, #0xfe0000000000        	// #279275953455104
    while (token->count < next_count) {
    fd800000953c:	f9400e61 	ldr	x1, [x19, #24]
        if (!cpu()->handling_msgs) {
    fd8000009540:	394022a0 	ldrb	w0, [x21, #8]
    while (token->count < next_count) {
    fd8000009544:	eb01029f 	cmp	x20, x1
        if (!cpu()->handling_msgs) {
    fd8000009548:	12000001 	and	w1, w0, #0x1
    while (token->count < next_count) {
    fd800000954c:	540000c9 	b.ls	fd8000009564 <cpu_sync_and_clear_msgs.constprop.0+0xb4>  // b.plast
        if (!cpu()->handling_msgs) {
    fd8000009550:	36000520 	tbz	w0, #0, fd80000095f4 <cpu_sync_and_clear_msgs.constprop.0+0x144>
    fd8000009554:	d503201f 	nop
    while (token->count < next_count) {
    fd8000009558:	f9400e60 	ldr	x0, [x19, #24]
    fd800000955c:	eb00029f 	cmp	x20, x0
    fd8000009560:	54ffffc8 	b.hi	fd8000009558 <cpu_sync_and_clear_msgs.constprop.0+0xa8>  // b.pmore
    if (!cpu()->handling_msgs) {
    fd8000009564:	340004c1 	cbz	w1, fd80000095fc <cpu_sync_and_clear_msgs.constprop.0+0x14c>
    while (!token->ready) { }
    fd8000009568:	39404260 	ldrb	w0, [x19, #16]
    fd800000956c:	3607ffe0 	tbz	w0, #0, fd8000009568 <cpu_sync_and_clear_msgs.constprop.0+0xb8>
    __asm__ volatile(
    fd8000009570:	91001263 	add	x3, x19, #0x4
    fd8000009574:	885ffe60 	ldaxr	w0, [x19]
    fd8000009578:	11000401 	add	w1, w0, #0x1
    fd800000957c:	88027e61 	stxr	w2, w1, [x19]
    fd8000009580:	35ffffa2 	cbnz	w2, fd8000009574 <cpu_sync_and_clear_msgs.constprop.0+0xc4>
    fd8000009584:	88dffc61 	ldar	w1, [x3]
    fd8000009588:	6b01001f 	cmp	w0, w1
    fd800000958c:	54000060 	b.eq	fd8000009598 <cpu_sync_and_clear_msgs.constprop.0+0xe8>  // b.none
    fd8000009590:	d503205f 	wfe
    fd8000009594:	17fffffc 	b	fd8000009584 <cpu_sync_and_clear_msgs.constprop.0+0xd4>
    token->count++;
    fd8000009598:	f9400e60 	ldr	x0, [x19, #24]
    fd800000959c:	91000400 	add	x0, x0, #0x1
    fd80000095a0:	f9000e60 	str	x0, [x19, #24]
    next_count = ALIGN(token->count, token->n);
    fd80000095a4:	f9400e61 	ldr	x1, [x19, #24]
    fd80000095a8:	f9400660 	ldr	x0, [x19, #8]
    fd80000095ac:	f9400662 	ldr	x2, [x19, #8]
    fd80000095b0:	8b000021 	add	x1, x1, x0
    fd80000095b4:	d1000421 	sub	x1, x1, #0x1
    fd80000095b8:	f9400660 	ldr	x0, [x19, #8]
    fd80000095bc:	9ac20821 	udiv	x1, x1, x2
    fd80000095c0:	9b007c21 	mul	x1, x1, x0
    __asm__ volatile(
    fd80000095c4:	b9400060 	ldr	w0, [x3]
    fd80000095c8:	11000400 	add	w0, w0, #0x1
    fd80000095cc:	889ffc60 	stlr	w0, [x3]
    fd80000095d0:	d5033b9f 	dsb	ish
    fd80000095d4:	d503209f 	sev
    while (token->count < next_count) { }
    fd80000095d8:	f9400e60 	ldr	x0, [x19, #24]
    fd80000095dc:	eb00003f 	cmp	x1, x0
    fd80000095e0:	54ffffc8 	b.hi	fd80000095d8 <cpu_sync_and_clear_msgs.constprop.0+0x128>  // b.pmore
    }

    cpu_sync_barrier(token);
}
    fd80000095e4:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd80000095e8:	f94013f5 	ldr	x21, [sp, #32]
    fd80000095ec:	a8c37bfd 	ldp	x29, x30, [sp], #48
    fd80000095f0:	d65f03c0 	ret
            cpu_msg_handler();
    fd80000095f4:	9400058b 	bl	fd800000ac20 <cpu_msg_handler>
    fd80000095f8:	17ffffd1 	b	fd800000953c <cpu_sync_and_clear_msgs.constprop.0+0x8c>
        cpu_msg_handler();
    fd80000095fc:	94000589 	bl	fd800000ac20 <cpu_msg_handler>
    while (!token->ready) { }
    fd8000009600:	17ffffda 	b	fd8000009568 <cpu_sync_and_clear_msgs.constprop.0+0xb8>
    fd8000009604:	d503201f 	nop
    fd8000009608:	00016000 	.word	0x00016000
    fd800000960c:	0000fd80 	.word	0x0000fd80

0000fd8000009610 <pp_alloc.part.0.constprop.0>:
bool pp_alloc(struct page_pool* pool, size_t num_pages, bool aligned, struct ppages* ppages)
    fd8000009610:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    fd8000009614:	12001c42 	and	w2, w2, #0xff
    fd8000009618:	910003fd 	mov	x29, sp
    fd800000961c:	a90363f7 	stp	x23, x24, [sp, #48]
    spin_lock(&pool->lock);
    fd8000009620:	9100c018 	add	x24, x0, #0x30
bool pp_alloc(struct page_pool* pool, size_t num_pages, bool aligned, struct ppages* ppages)
    fd8000009624:	aa0303f7 	mov	x23, x3
    __asm__ volatile(
    fd8000009628:	91001304 	add	x4, x24, #0x4
    fd800000962c:	a90153f3 	stp	x19, x20, [sp, #16]
    fd8000009630:	aa0003f4 	mov	x20, x0
    fd8000009634:	a9025bf5 	stp	x21, x22, [sp, #32]
    fd8000009638:	a9046bf9 	stp	x25, x26, [sp, #64]
    fd800000963c:	aa0103fa 	mov	x26, x1
    fd8000009640:	885fff00 	ldaxr	w0, [x24]
    fd8000009644:	11000401 	add	w1, w0, #0x1
    fd8000009648:	88037f01 	stxr	w3, w1, [x24]
    fd800000964c:	35ffffa3 	cbnz	w3, fd8000009640 <pp_alloc.part.0.constprop.0+0x30>
    fd8000009650:	88dffc81 	ldar	w1, [x4]
    fd8000009654:	6b01001f 	cmp	w0, w1
    fd8000009658:	54000060 	b.eq	fd8000009664 <pp_alloc.part.0.constprop.0+0x54>  // b.none
    fd800000965c:	d503205f 	wfe
    fd8000009660:	17fffffc 	b	fd8000009650 <pp_alloc.part.0.constprop.0+0x40>
    size_t start = aligned ? pool->base / PAGE_SIZE % num_pages : 0;
    fd8000009664:	d2800015 	mov	x21, #0x0                   	// #0
    fd8000009668:	12000056 	and	w22, w2, #0x1
    fd800000966c:	360000a2 	tbz	w2, #0, fd8000009680 <pp_alloc.part.0.constprop.0+0x70>
    fd8000009670:	f9400680 	ldr	x0, [x20, #8]
    fd8000009674:	d34cfc00 	lsr	x0, x0, #12
    fd8000009678:	9ada0815 	udiv	x21, x0, x26
    fd800000967c:	9b1a82b5 	msub	x21, x21, x26, x0
    size_t curr = pool->last + ((pool->last + start) % num_pages);
    fd8000009680:	f9401280 	ldr	x0, [x20, #32]
    fd8000009684:	d2800059 	mov	x25, #0x2                   	// #2
    fd8000009688:	8b150001 	add	x1, x0, x21
    fd800000968c:	9ada0822 	udiv	x2, x1, x26
    fd8000009690:	9b1a8442 	msub	x2, x2, x26, x1
    fd8000009694:	8b000042 	add	x2, x2, x0
    for (size_t i = 0; i < 2 && !ok; i++) {
    fd8000009698:	1400000e 	b	fd80000096d0 <pp_alloc.part.0.constprop.0+0xc0>
            ssize_t bit = bitmap_find_consec(pool->bitmap, pool->size, curr, num_pages, false);
    fd800000969c:	f9400a81 	ldr	x1, [x20, #16]
    fd80000096a0:	aa1a03e3 	mov	x3, x26
    fd80000096a4:	f9401680 	ldr	x0, [x20, #40]
    fd80000096a8:	52800004 	mov	w4, #0x0                   	// #0
    fd80000096ac:	97fffefd 	bl	fd80000092a0 <bitmap_find_consec>
    fd80000096b0:	aa0003f3 	mov	x19, x0
            if (bit < 0) {
    fd80000096b4:	b7f804a0 	tbnz	x0, #63, fd8000009748 <pp_alloc.part.0.constprop.0+0x138>
            } else if (aligned && (((bit + start) % num_pages) != 0)) {
    fd80000096b8:	8b0002a0 	add	x0, x21, x0
    fd80000096bc:	34000176 	cbz	w22, fd80000096e8 <pp_alloc.part.0.constprop.0+0xd8>
    fd80000096c0:	9ada0804 	udiv	x4, x0, x26
    fd80000096c4:	9b1a8084 	msub	x4, x4, x26, x0
                curr = bit + ((bit + start) % num_pages);
    fd80000096c8:	8b130082 	add	x2, x4, x19
            } else if (aligned && (((bit + start) % num_pages) != 0)) {
    fd80000096cc:	b40000e4 	cbz	x4, fd80000096e8 <pp_alloc.part.0.constprop.0+0xd8>
        while (pool->free != 0) {
    fd80000096d0:	f9400e80 	ldr	x0, [x20, #24]
    fd80000096d4:	b5fffe40 	cbnz	x0, fd800000969c <pp_alloc.part.0.constprop.0+0x8c>
    for (size_t i = 0; i < 2 && !ok; i++) {
    fd80000096d8:	f100073f 	cmp	x25, #0x1
    fd80000096dc:	540004c0 	b.eq	fd8000009774 <pp_alloc.part.0.constprop.0+0x164>  // b.none
    fd80000096e0:	d2800039 	mov	x25, #0x1                   	// #1
    fd80000096e4:	17fffffb 	b	fd80000096d0 <pp_alloc.part.0.constprop.0+0xc0>
                ppages->base = pool->base + (bit * PAGE_SIZE);
    fd80000096e8:	f9400681 	ldr	x1, [x20, #8]
                bitmap_set_consecutive(pool->bitmap, bit, num_pages);
    fd80000096ec:	aa1a03e2 	mov	x2, x26
    fd80000096f0:	f9401680 	ldr	x0, [x20, #40]
                ppages->base = pool->base + (bit * PAGE_SIZE);
    fd80000096f4:	8b133021 	add	x1, x1, x19, lsl #12
                ppages->num_pages = num_pages;
    fd80000096f8:	a9006ae1 	stp	x1, x26, [x23]
                bitmap_set_consecutive(pool->bitmap, bit, num_pages);
    fd80000096fc:	aa1303e1 	mov	x1, x19
    fd8000009700:	97ffff24 	bl	fd8000009390 <bitmap_set_consecutive>
                pool->last = bit + num_pages;
    fd8000009704:	8b130353 	add	x19, x26, x19
                pool->free -= num_pages;
    fd8000009708:	f9400e81 	ldr	x1, [x20, #24]
                ok = true;
    fd800000970c:	52800020 	mov	w0, #0x1                   	// #1
                pool->free -= num_pages;
    fd8000009710:	cb1a0021 	sub	x1, x1, x26
                pool->last = bit + num_pages;
    fd8000009714:	a901ce81 	stp	x1, x19, [x20, #24]
    __asm__ volatile(
    fd8000009718:	91001302 	add	x2, x24, #0x4
    fd800000971c:	b9400041 	ldr	w1, [x2]
    fd8000009720:	11000421 	add	w1, w1, #0x1
    fd8000009724:	889ffc41 	stlr	w1, [x2]
    fd8000009728:	d5033b9f 	dsb	ish
    fd800000972c:	d503209f 	sev
}
    fd8000009730:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd8000009734:	a9425bf5 	ldp	x21, x22, [sp, #32]
    fd8000009738:	a94363f7 	ldp	x23, x24, [sp, #48]
    fd800000973c:	a9446bf9 	ldp	x25, x26, [sp, #64]
    fd8000009740:	a8c57bfd 	ldp	x29, x30, [sp], #80
    fd8000009744:	d65f03c0 	ret
                curr = aligned ? next_aligned : 0;
    fd8000009748:	d2800002 	mov	x2, #0x0                   	// #0
    fd800000974c:	34fffc76 	cbz	w22, fd80000096d8 <pp_alloc.part.0.constprop.0+0xc8>
                    (num_pages - ((pool->base / PAGE_SIZE) % num_pages)) % num_pages;
    fd8000009750:	f9400681 	ldr	x1, [x20, #8]
    for (size_t i = 0; i < 2 && !ok; i++) {
    fd8000009754:	f100073f 	cmp	x25, #0x1
                    (num_pages - ((pool->base / PAGE_SIZE) % num_pages)) % num_pages;
    fd8000009758:	d34cfc21 	lsr	x1, x1, #12
    fd800000975c:	9ada0820 	udiv	x0, x1, x26
    fd8000009760:	9b1a8400 	msub	x0, x0, x26, x1
    fd8000009764:	cb000340 	sub	x0, x26, x0
                size_t next_aligned =
    fd8000009768:	9ada0802 	udiv	x2, x0, x26
    fd800000976c:	9b1a8042 	msub	x2, x2, x26, x0
    for (size_t i = 0; i < 2 && !ok; i++) {
    fd8000009770:	54fffb81 	b.ne	fd80000096e0 <pp_alloc.part.0.constprop.0+0xd0>  // b.any
    fd8000009774:	52800000 	mov	w0, #0x0                   	// #0
    fd8000009778:	17ffffe8 	b	fd8000009718 <pp_alloc.part.0.constprop.0+0x108>
    fd800000977c:	d503201f 	nop

0000fd8000009780 <pp_alloc>:
    ppages->colors = 0;
    fd8000009780:	a900fc7f 	stp	xzr, xzr, [x3, #8]
{
    fd8000009784:	12001c42 	and	w2, w2, #0xff
    if (num_pages == 0) {
    fd8000009788:	b5000061 	cbnz	x1, fd8000009794 <pp_alloc+0x14>
}
    fd800000978c:	52800020 	mov	w0, #0x1                   	// #1
    fd8000009790:	d65f03c0 	ret
    fd8000009794:	17ffff9f 	b	fd8000009610 <pp_alloc.part.0.constprop.0>
    fd8000009798:	d503201f 	nop
    fd800000979c:	d503201f 	nop

0000fd80000097a0 <mem_are_ppages_reserved_in_pool>:
{
    fd80000097a0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    fd80000097a4:	52800025 	mov	w5, #0x1                   	// #1
    fd80000097a8:	910003fd 	mov	x29, sp
    fd80000097ac:	a90153f3 	stp	x19, x20, [sp, #16]
    fd80000097b0:	aa0103f4 	mov	x20, x1
    bool rgn_found = range_in_range(ppages->base, ppages->num_pages * PAGE_SIZE, ppool->base,
    fd80000097b4:	f9400423 	ldr	x3, [x1, #8]
        ppool->size * PAGE_SIZE);
    fd80000097b8:	f9400801 	ldr	x1, [x0, #16]
    bool rgn_found = range_in_range(ppages->base, ppages->num_pages * PAGE_SIZE, ppool->base,
    fd80000097bc:	f9400282 	ldr	x2, [x20]
    fd80000097c0:	d374cc64 	lsl	x4, x3, #12
    fd80000097c4:	f9400406 	ldr	x6, [x0, #8]
}

static inline bool range_in_range(unsigned long base1, unsigned long size1, unsigned long base2,
    unsigned long size2)
{
    unsigned long limit1 = base1 + size1;
    fd80000097c8:	ab040044 	adds	x4, x2, x4
    fd80000097cc:	d374cc27 	lsl	x7, x1, #12
    fd80000097d0:	9a9f37e9 	cset	x9, cs	// cs = hs, nlast
    unsigned long limit2 = base2 + size2;
    fd80000097d4:	ab0700c7 	adds	x7, x6, x7
    fd80000097d8:	9a9f37e8 	cset	x8, cs	// cs = hs, nlast

    /* Saturate possible overflows */
    if (limit1 < base1) {
        limit1 = ULONG_MAX;
    fd80000097dc:	f100013f 	cmp	x9, #0x0
    fd80000097e0:	da9f0084 	csinv	x4, x4, xzr, eq	// eq = none
    }
    if (limit2 < base2) {
    fd80000097e4:	b5000068 	cbnz	x8, fd80000097f0 <mem_are_ppages_reserved_in_pool+0x50>
        limit2 = ULONG_MAX;
    }

    return (base1 >= base2) && (limit1 <= limit2);
    fd80000097e8:	eb0400ff 	cmp	x7, x4
    fd80000097ec:	1a9f37e5 	cset	w5, cs	// cs = hs, nlast
    fd80000097f0:	eb06005f 	cmp	x2, x6
    fd80000097f4:	1a9f37e4 	cset	w4, cs	// cs = hs, nlast
    if (rgn_found) {
    fd80000097f8:	6a0400bf 	tst	w5, w4
    fd80000097fc:	0a0400b3 	and	w19, w5, w4
    fd8000009800:	54000180 	b.eq	fd8000009830 <mem_are_ppages_reserved_in_pool+0x90>  // b.none
        size_t pageoff = NUM_PAGES(ppages->base - ppool->base);
    fd8000009804:	cb060042 	sub	x2, x2, x6
    fd8000009808:	52800024 	mov	w4, #0x1                   	// #1
    fd800000980c:	913ffc42 	add	x2, x2, #0xfff
        bool is_alloced = bitmap_get(ppool->bitmap, pageoff);
    fd8000009810:	f9401400 	ldr	x0, [x0, #40]
    fd8000009814:	d351fc45 	lsr	x5, x2, #17
        size_t pageoff = NUM_PAGES(ppages->base - ppool->base);
    fd8000009818:	d34cfc42 	lsr	x2, x2, #12
    fd800000981c:	b8657805 	ldr	w5, [x0, x5, lsl #2]
    fd8000009820:	1ac22084 	lsl	w4, w4, w2
    fd8000009824:	6a05009f 	tst	w4, w5
    fd8000009828:	540000c0 	b.eq	fd8000009840 <mem_are_ppages_reserved_in_pool+0xa0>  // b.none
            bitmap_count_consecutive(ppool->bitmap, ppool->size, pageoff, ppages->num_pages);
    fd800000982c:	97fffe4d 	bl	fd8000009160 <bitmap_count_consecutive>
}
    fd8000009830:	2a1303e0 	mov	w0, w19
    fd8000009834:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd8000009838:	a8c27bfd 	ldp	x29, x30, [sp], #32
    fd800000983c:	d65f03c0 	ret
            bitmap_count_consecutive(ppool->bitmap, ppool->size, pageoff, ppages->num_pages);
    fd8000009840:	97fffe48 	bl	fd8000009160 <bitmap_count_consecutive>
        if (is_alloced || avlbl_contig_pp < ppages->num_pages) {
    fd8000009844:	f9400681 	ldr	x1, [x20, #8]
    fd8000009848:	eb00003f 	cmp	x1, x0
    fd800000984c:	1a9f97f3 	cset	w19, hi	// hi = pmore
}
    fd8000009850:	2a1303e0 	mov	w0, w19
    fd8000009854:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd8000009858:	a8c27bfd 	ldp	x29, x30, [sp], #32
    fd800000985c:	d65f03c0 	ret

0000fd8000009860 <mem_are_ppages_reserved>:
    list_foreach (page_pool_list, struct page_pool, pool) {
    fd8000009860:	90000001 	adrp	x1, fd8000009000 <vsnprintk+0x1d0>
    fd8000009864:	f9446c22 	ldr	x2, [x1, #2264]
{
    fd8000009868:	aa0003e1 	mov	x1, x0
    list_foreach (page_pool_list, struct page_pool, pool) {
    fd800000986c:	f9400040 	ldr	x0, [x2]
    fd8000009870:	b4000280 	cbz	x0, fd80000098c0 <mem_are_ppages_reserved+0x60>
        bool is_in_rgn = range_in_range(ppages->base, ppages->num_pages * PAGE_SIZE, pool->base,
    fd8000009874:	a9401426 	ldp	x6, x5, [x1]
    fd8000009878:	d374cca5 	lsl	x5, x5, #12
    fd800000987c:	ab0500c5 	adds	x5, x6, x5
    fd8000009880:	da9f30a5 	csinv	x5, x5, xzr, cc	// cc = lo, ul, last
    fd8000009884:	14000003 	b	fd8000009890 <mem_are_ppages_reserved+0x30>
    list_foreach (page_pool_list, struct page_pool, pool) {
    fd8000009888:	f9400000 	ldr	x0, [x0]
    fd800000988c:	b40001c0 	cbz	x0, fd80000098c4 <mem_are_ppages_reserved+0x64>
        bool is_in_rgn = range_in_range(ppages->base, ppages->num_pages * PAGE_SIZE, pool->base,
    fd8000009890:	a9408804 	ldp	x4, x2, [x0, #8]
    fd8000009894:	d374cc42 	lsl	x2, x2, #12
    fd8000009898:	ab020082 	adds	x2, x4, x2
    fd800000989c:	54000182 	b.cs	fd80000098cc <mem_are_ppages_reserved+0x6c>  // b.hs, b.nlast
    fd80000098a0:	eb05005f 	cmp	x2, x5
    fd80000098a4:	1a9f37e2 	cset	w2, cs	// cs = hs, nlast
    fd80000098a8:	eb0400df 	cmp	x6, x4
    fd80000098ac:	1a9f37e4 	cset	w4, cs	// cs = hs, nlast
            pool->size * PAGE_SIZE);

        if (is_in_rgn) {
    fd80000098b0:	6a04005f 	tst	w2, w4
    fd80000098b4:	0a040042 	and	w2, w2, w4
    fd80000098b8:	54fffe80 	b.eq	fd8000009888 <mem_are_ppages_reserved+0x28>  // b.none
            reserved = mem_are_ppages_reserved_in_pool(pool, ppages);
    fd80000098bc:	17ffffb9 	b	fd80000097a0 <mem_are_ppages_reserved_in_pool>
    bool reserved = false;
    fd80000098c0:	52800002 	mov	w2, #0x0                   	// #0
            break;
        }
    }

    return reserved;
}
    fd80000098c4:	2a0203e0 	mov	w0, w2
    fd80000098c8:	d65f03c0 	ret
    fd80000098cc:	52800022 	mov	w2, #0x1                   	// #1
    fd80000098d0:	17fffff6 	b	fd80000098a8 <mem_are_ppages_reserved+0x48>
    fd80000098d4:	d503201f 	nop
    fd80000098d8:	000130a0 	.word	0x000130a0
    fd80000098dc:	0000fd80 	.word	0x0000fd80

0000fd80000098e0 <mem_reserve_ppool_ppages>:

bool mem_reserve_ppool_ppages(struct page_pool* pool, struct ppages* ppages)
{
    fd80000098e0:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    fd80000098e4:	910003fd 	mov	x29, sp
    fd80000098e8:	a90153f3 	stp	x19, x20, [sp, #16]
    fd80000098ec:	aa0003f4 	mov	x20, x0
    bool is_in_rgn = range_in_range(ppages->base, ppages->num_pages * PAGE_SIZE, pool->base,
    fd80000098f0:	a9400833 	ldp	x19, x2, [x1]
{
    fd80000098f4:	a9025bf5 	stp	x21, x22, [sp, #32]
    fd80000098f8:	aa0103f5 	mov	x21, x1
    bool is_in_rgn = range_in_range(ppages->base, ppages->num_pages * PAGE_SIZE, pool->base,
    fd80000098fc:	f9400800 	ldr	x0, [x0, #16]
    fd8000009900:	52800021 	mov	w1, #0x1                   	// #1
    fd8000009904:	f9400696 	ldr	x22, [x20, #8]
    fd8000009908:	d374cc42 	lsl	x2, x2, #12
    fd800000990c:	ab020262 	adds	x2, x19, x2
    fd8000009910:	d374cc00 	lsl	x0, x0, #12
    fd8000009914:	9a9f37e4 	cset	x4, cs	// cs = hs, nlast
    unsigned long limit2 = base2 + size2;
    fd8000009918:	ab0002c0 	adds	x0, x22, x0
{
    fd800000991c:	f9001bf7 	str	x23, [sp, #48]
    fd8000009920:	9a9f37e3 	cset	x3, cs	// cs = hs, nlast
        limit1 = ULONG_MAX;
    fd8000009924:	f100009f 	cmp	x4, #0x0
    fd8000009928:	da9f0042 	csinv	x2, x2, xzr, eq	// eq = none
    if (limit2 < base2) {
    fd800000992c:	b5000063 	cbnz	x3, fd8000009938 <mem_reserve_ppool_ppages+0x58>
    return (base1 >= base2) && (limit1 <= limit2);
    fd8000009930:	eb02001f 	cmp	x0, x2
    fd8000009934:	1a9f37e1 	cset	w1, cs	// cs = hs, nlast
    fd8000009938:	7100003f 	cmp	w1, #0x0
        pool->size * PAGE_SIZE);
    if (!is_in_rgn) {
        return true;
    fd800000993c:	52800037 	mov	w23, #0x1                   	// #1
    if (!is_in_rgn) {
    fd8000009940:	fa561260 	ccmp	x19, x22, #0x0, ne	// ne = any
    fd8000009944:	54000203 	b.cc	fd8000009984 <mem_reserve_ppool_ppages+0xa4>  // b.lo, b.ul, b.last
    }

    size_t pageoff = NUM_PAGES(ppages->base - pool->base);

    bool was_free = true;
    if (mem_are_ppages_reserved_in_pool(pool, ppages)) {
    fd8000009948:	aa1503e1 	mov	x1, x21
    fd800000994c:	aa1403e0 	mov	x0, x20
    fd8000009950:	97ffff94 	bl	fd80000097a0 <mem_are_ppages_reserved_in_pool>
    fd8000009954:	12001c17 	and	w23, w0, #0xff
        was_free = false;
    }

    bitmap_set_consecutive(pool->bitmap, pageoff, ppages->num_pages);
    fd8000009958:	f94006a2 	ldr	x2, [x21, #8]
    size_t pageoff = NUM_PAGES(ppages->base - pool->base);
    fd800000995c:	cb160273 	sub	x19, x19, x22
    bitmap_set_consecutive(pool->bitmap, pageoff, ppages->num_pages);
    fd8000009960:	f9401680 	ldr	x0, [x20, #40]
    size_t pageoff = NUM_PAGES(ppages->base - pool->base);
    fd8000009964:	913ffe73 	add	x19, x19, #0xfff
    if (mem_are_ppages_reserved_in_pool(pool, ppages)) {
    fd8000009968:	520002f7 	eor	w23, w23, #0x1
    bitmap_set_consecutive(pool->bitmap, pageoff, ppages->num_pages);
    fd800000996c:	d34cfe61 	lsr	x1, x19, #12
    fd8000009970:	97fffe88 	bl	fd8000009390 <bitmap_set_consecutive>
    pool->free -= ppages->num_pages;
    fd8000009974:	f94006a1 	ldr	x1, [x21, #8]
    fd8000009978:	f9400e80 	ldr	x0, [x20, #24]
    fd800000997c:	cb010000 	sub	x0, x0, x1
    fd8000009980:	f9000e80 	str	x0, [x20, #24]

    return is_in_rgn && was_free;
}
    fd8000009984:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd8000009988:	2a1703e0 	mov	w0, w23
    fd800000998c:	a9425bf5 	ldp	x21, x22, [sp, #32]
    fd8000009990:	f9401bf7 	ldr	x23, [sp, #48]
    fd8000009994:	a8c47bfd 	ldp	x29, x30, [sp], #64
    fd8000009998:	d65f03c0 	ret
    fd800000999c:	d503201f 	nop

0000fd80000099a0 <root_pool_set_up_bitmap>:

    return (void*)vpage;
}

bool root_pool_set_up_bitmap(paddr_t load_addr, struct page_pool* root_pool)
{
    fd80000099a0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    fd80000099a4:	910003fd 	mov	x29, sp
    size_t image_size = (size_t)(&_image_end - &_image_start);
    size_t vm_image_size = (size_t)(&_vm_image_end - &_vm_image_start);
    size_t cpu_size = platform.cpu_num * mem_cpu_boot_alloc_size();
    fd80000099a8:	90000002 	adrp	x2, fd8000009000 <vsnprintk+0x1d0>
    fd80000099ac:	f9454442 	ldr	x2, [x2, #2696]
{
    fd80000099b0:	a90153f3 	stp	x19, x20, [sp, #16]
    fd80000099b4:	aa0103f4 	mov	x20, x1
    fd80000099b8:	a9025bf5 	stp	x21, x22, [sp, #32]
    fd80000099bc:	aa0003f5 	mov	x21, x0
    size_t cpu_size = platform.cpu_num * mem_cpu_boot_alloc_size();
    fd80000099c0:	f9400056 	ldr	x22, [x2]
    fd80000099c4:	94000cdf 	bl	fd800000cd40 <mem_cpu_boot_alloc_size>

    size_t bitmap_num_pages =
        root_pool->size / (8 * PAGE_SIZE) + ((root_pool->size % (8 * PAGE_SIZE) != 0) ? 1 : 0);
    fd80000099c8:	f9400a81 	ldr	x1, [x20, #16]
    fd80000099cc:	92403822 	and	x2, x1, #0x7fff
    fd80000099d0:	f100005f 	cmp	x2, #0x0
    fd80000099d4:	d34ffc33 	lsr	x19, x1, #15
    size_t bitmap_num_pages =
    fd80000099d8:	9a930673 	cinc	x19, x19, ne	// ne = any
    if (root_pool->size <= bitmap_num_pages) {
    fd80000099dc:	eb13003f 	cmp	x1, x19
    fd80000099e0:	540000c8 	b.hi	fd80000099f8 <root_pool_set_up_bitmap+0x58>  // b.pmore
        INVALID_VA, bitmap_num_pages, PTE_HYP_FLAGS);
    root_pool->bitmap = root_bitmap;
    memset((void*)root_pool->bitmap, 0, bitmap_num_pages * PAGE_SIZE);

    return mem_reserve_ppool_ppages(root_pool, &bitmap_pp);
}
    fd80000099e4:	a94153f3 	ldp	x19, x20, [sp, #16]
        return false;
    fd80000099e8:	52800000 	mov	w0, #0x0                   	// #0
}
    fd80000099ec:	a9425bf5 	ldp	x21, x22, [sp, #32]
    fd80000099f0:	a8c57bfd 	ldp	x29, x30, [sp], #80
    fd80000099f4:	d65f03c0 	ret
    size_t image_size = (size_t)(&_image_end - &_image_start);
    fd80000099f8:	90000001 	adrp	x1, fd8000009000 <vsnprintk+0x1d0>
    fd80000099fc:	f9454826 	ldr	x6, [x1, #2704]
    fd8000009a00:	90000001 	adrp	x1, fd8000009000 <vsnprintk+0x1d0>
    fd8000009a04:	f9454c23 	ldr	x3, [x1, #2712]
    size_t vm_image_size = (size_t)(&_vm_image_end - &_vm_image_start);
    fd8000009a08:	90000002 	adrp	x2, fd8000009000 <vsnprintk+0x1d0>
    fd8000009a0c:	f9455442 	ldr	x2, [x2, #2728]
    fd8000009a10:	90000001 	adrp	x1, fd8000009000 <vsnprintk+0x1d0>
    fd8000009a14:	f9455021 	ldr	x1, [x1, #2720]
    size_t bitmap_base = load_addr + image_size + vm_image_size + cpu_size;
    fd8000009a18:	9b0056d6 	madd	x22, x22, x0, x21
    size_t image_size = (size_t)(&_image_end - &_image_start);
    fd8000009a1c:	cb0300c6 	sub	x6, x6, x3
    bitmap_t* root_bitmap = (bitmap_t*)mem_alloc_map(&cpu()->as, SEC_HYP_GLOBAL, &bitmap_pp,
    fd8000009a20:	d2800200 	mov	x0, #0x10                  	// #16
    size_t vm_image_size = (size_t)(&_vm_image_end - &_vm_image_start);
    fd8000009a24:	cb020021 	sub	x1, x1, x2
    bitmap_t* root_bitmap = (bitmap_t*)mem_alloc_map(&cpu()->as, SEC_HYP_GLOBAL, &bitmap_pp,
    fd8000009a28:	aa1303e4 	mov	x4, x19
    size_t bitmap_base = load_addr + image_size + vm_image_size + cpu_size;
    fd8000009a2c:	8b0100c6 	add	x6, x6, x1
    bitmap_t* root_bitmap = (bitmap_t*)mem_alloc_map(&cpu()->as, SEC_HYP_GLOBAL, &bitmap_pp,
    fd8000009a30:	d280e885 	mov	x5, #0x744                 	// #1860
    size_t bitmap_base = load_addr + image_size + vm_image_size + cpu_size;
    fd8000009a34:	8b1600c6 	add	x6, x6, x22
    bitmap_t* root_bitmap = (bitmap_t*)mem_alloc_map(&cpu()->as, SEC_HYP_GLOBAL, &bitmap_pp,
    fd8000009a38:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
    fd8000009a3c:	9100e3e2 	add	x2, sp, #0x38
    fd8000009a40:	52800001 	mov	w1, #0x0                   	// #0
    fd8000009a44:	f2dfc000 	movk	x0, #0xfe00, lsl #32
    spinlock_t lock;
};

static inline struct ppages mem_ppages_get(paddr_t base, size_t num_pages)
{
    return (struct ppages){ .colors = 0, .base = base, .num_pages = num_pages };
    fd8000009a48:	a903cfe6 	stp	x6, x19, [sp, #56]
    fd8000009a4c:	f90027ff 	str	xzr, [sp, #72]
    fd8000009a50:	940014ec 	bl	fd800000ee00 <mem_alloc_map>
    memset((void*)root_pool->bitmap, 0, bitmap_num_pages * PAGE_SIZE);
    fd8000009a54:	d374ce62 	lsl	x2, x19, #12
    root_pool->bitmap = root_bitmap;
    fd8000009a58:	f9001680 	str	x0, [x20, #40]
    memset((void*)root_pool->bitmap, 0, bitmap_num_pages * PAGE_SIZE);
    fd8000009a5c:	52800001 	mov	w1, #0x0                   	// #0
    fd8000009a60:	97fffc34 	bl	fd8000008b30 <memset>
    return mem_reserve_ppool_ppages(root_pool, &bitmap_pp);
    fd8000009a64:	9100e3e1 	add	x1, sp, #0x38
    fd8000009a68:	aa1403e0 	mov	x0, x20
    fd8000009a6c:	97ffff9d 	bl	fd80000098e0 <mem_reserve_ppool_ppages>
    fd8000009a70:	12001c00 	and	w0, w0, #0xff
}
    fd8000009a74:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd8000009a78:	a9425bf5 	ldp	x21, x22, [sp, #32]
    fd8000009a7c:	a8c57bfd 	ldp	x29, x30, [sp], #80
    fd8000009a80:	d65f03c0 	ret
    fd8000009a84:	d503201f 	nop
    fd8000009a88:	00012930 	.word	0x00012930
    fd8000009a8c:	0000fd80 	.word	0x0000fd80
    fd8000009a90:	00020000 	.word	0x00020000
    fd8000009a94:	0000fd80 	.word	0x0000fd80
    fd8000009a98:	00000000 	.word	0x00000000
    fd8000009a9c:	0000fd80 	.word	0x0000fd80
    fd8000009aa0:	03562000 	.word	0x03562000
    fd8000009aa4:	0000fd80 	.word	0x0000fd80
    fd8000009aa8:	00013000 	.word	0x00013000
    fd8000009aac:	0000fd80 	.word	0x0000fd80

0000fd8000009ab0 <pp_root_reserve_hyp_mem>:

bool pp_root_reserve_hyp_mem(paddr_t load_addr, struct page_pool* root_pool)
{
    fd8000009ab0:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
    fd8000009ab4:	910003fd 	mov	x29, sp
    size_t image_load_size = (size_t)(&_image_load_end - &_image_start);
    size_t image_noload_size = (size_t)(&_image_end - &_image_load_end);
    size_t vm_image_size = (size_t)(&_vm_image_end - &_vm_image_start);
    size_t cpu_size = platform.cpu_num * mem_cpu_boot_alloc_size();
    fd8000009ab8:	90000002 	adrp	x2, fd8000009000 <vsnprintk+0x1d0>
    fd8000009abc:	f945dc43 	ldr	x3, [x2, #3000]
    size_t image_load_size = (size_t)(&_image_load_end - &_image_start);
    fd8000009ac0:	90000002 	adrp	x2, fd8000009000 <vsnprintk+0x1d0>
    fd8000009ac4:	f945d042 	ldr	x2, [x2, #2976]
{
    fd8000009ac8:	a90153f3 	stp	x19, x20, [sp, #16]
    size_t cpu_size = platform.cpu_num * mem_cpu_boot_alloc_size();
    fd8000009acc:	f9400073 	ldr	x19, [x3]
{
    fd8000009ad0:	f9001bf7 	str	x23, [sp, #48]
    size_t image_load_size = (size_t)(&_image_load_end - &_image_start);
    fd8000009ad4:	90000004 	adrp	x4, fd8000009000 <vsnprintk+0x1d0>
    fd8000009ad8:	f945d497 	ldr	x23, [x4, #2984]
    size_t image_noload_size = (size_t)(&_image_end - &_image_load_end);
    fd8000009adc:	90000004 	adrp	x4, fd8000009000 <vsnprintk+0x1d0>
    fd8000009ae0:	f945d894 	ldr	x20, [x4, #2992]
    size_t image_load_size = (size_t)(&_image_load_end - &_image_start);
    fd8000009ae4:	cb170057 	sub	x23, x2, x23
{
    fd8000009ae8:	a9025bf5 	stp	x21, x22, [sp, #32]
    fd8000009aec:	aa0103f5 	mov	x21, x1
    fd8000009af0:	aa0003f6 	mov	x22, x0
    size_t image_noload_size = (size_t)(&_image_end - &_image_load_end);
    fd8000009af4:	cb020294 	sub	x20, x20, x2
    size_t cpu_size = platform.cpu_num * mem_cpu_boot_alloc_size();
    fd8000009af8:	94000c92 	bl	fd800000cd40 <mem_cpu_boot_alloc_size>
    size_t vm_image_size = (size_t)(&_vm_image_end - &_vm_image_start);
    fd8000009afc:	90000001 	adrp	x1, fd8000009000 <vsnprintk+0x1d0>
    fd8000009b00:	f945e022 	ldr	x2, [x1, #3008]
    fd8000009b04:	90000001 	adrp	x1, fd8000009000 <vsnprintk+0x1d0>
    fd8000009b08:	f945e421 	ldr	x1, [x1, #3016]
    paddr_t image_noload_addr = load_addr + image_load_size + vm_image_size;
    paddr_t cpu_base_addr = image_noload_addr + image_noload_size;

    struct ppages images_load_ppages = mem_ppages_get(load_addr, NUM_PAGES(image_load_size));
    fd8000009b0c:	913ffee4 	add	x4, x23, #0xfff
    struct ppages images_noload_ppages =
        mem_ppages_get(image_noload_addr, NUM_PAGES(image_noload_size));
    fd8000009b10:	913ffe83 	add	x3, x20, #0xfff
    size_t cpu_size = platform.cpu_num * mem_cpu_boot_alloc_size();
    fd8000009b14:	9b007e73 	mul	x19, x19, x0
    size_t vm_image_size = (size_t)(&_vm_image_end - &_vm_image_start);
    fd8000009b18:	cb010042 	sub	x2, x2, x1
    struct ppages images_load_ppages = mem_ppages_get(load_addr, NUM_PAGES(image_load_size));
    fd8000009b1c:	d34cfc84 	lsr	x4, x4, #12
    paddr_t image_noload_addr = load_addr + image_load_size + vm_image_size;
    fd8000009b20:	8b170042 	add	x2, x2, x23
        mem_ppages_get(image_noload_addr, NUM_PAGES(image_noload_size));
    fd8000009b24:	d34cfc63 	lsr	x3, x3, #12
    paddr_t image_noload_addr = load_addr + image_load_size + vm_image_size;
    fd8000009b28:	8b160042 	add	x2, x2, x22
    struct ppages cpu_ppages = mem_ppages_get(cpu_base_addr, NUM_PAGES(cpu_size));
    fd8000009b2c:	913ffe73 	add	x19, x19, #0xfff
    paddr_t cpu_base_addr = image_noload_addr + image_noload_size;
    fd8000009b30:	8b020294 	add	x20, x20, x2

    bool image_load_reserved = mem_reserve_ppool_ppages(root_pool, &images_load_ppages);
    fd8000009b34:	910123e1 	add	x1, sp, #0x48
    struct ppages cpu_ppages = mem_ppages_get(cpu_base_addr, NUM_PAGES(cpu_size));
    fd8000009b38:	d34cfe73 	lsr	x19, x19, #12
    bool image_load_reserved = mem_reserve_ppool_ppages(root_pool, &images_load_ppages);
    fd8000009b3c:	aa1503e0 	mov	x0, x21
    fd8000009b40:	a90493f6 	stp	x22, x4, [sp, #72]
    fd8000009b44:	a9058bff 	stp	xzr, x2, [sp, #88]
    fd8000009b48:	a906ffe3 	stp	x3, xzr, [sp, #104]
    fd8000009b4c:	a907cff4 	stp	x20, x19, [sp, #120]
    fd8000009b50:	f90047ff 	str	xzr, [sp, #136]
    fd8000009b54:	97ffff63 	bl	fd80000098e0 <mem_reserve_ppool_ppages>
    bool image_noload_reserved = mem_reserve_ppool_ppages(root_pool, &images_noload_ppages);
    fd8000009b58:	910183e1 	add	x1, sp, #0x60
    bool image_load_reserved = mem_reserve_ppool_ppages(root_pool, &images_load_ppages);
    fd8000009b5c:	12001c14 	and	w20, w0, #0xff
    bool image_noload_reserved = mem_reserve_ppool_ppages(root_pool, &images_noload_ppages);
    fd8000009b60:	aa1503e0 	mov	x0, x21
    fd8000009b64:	97ffff5f 	bl	fd80000098e0 <mem_reserve_ppool_ppages>
    bool cpu_reserved = mem_reserve_ppool_ppages(root_pool, &cpu_ppages);
    fd8000009b68:	9101e3e1 	add	x1, sp, #0x78
    bool image_noload_reserved = mem_reserve_ppool_ppages(root_pool, &images_noload_ppages);
    fd8000009b6c:	12001c13 	and	w19, w0, #0xff
    bool cpu_reserved = mem_reserve_ppool_ppages(root_pool, &cpu_ppages);
    fd8000009b70:	aa1503e0 	mov	x0, x21
    fd8000009b74:	97ffff5b 	bl	fd80000098e0 <mem_reserve_ppool_ppages>

    return image_load_reserved && image_noload_reserved && cpu_reserved;
    fd8000009b78:	7100029f 	cmp	w20, #0x0
    bool cpu_reserved = mem_reserve_ppool_ppages(root_pool, &cpu_ppages);
    fd8000009b7c:	12001c00 	and	w0, w0, #0xff
    return image_load_reserved && image_noload_reserved && cpu_reserved;
    fd8000009b80:	7a401a64 	ccmp	w19, #0x0, #0x4, ne	// ne = any
    fd8000009b84:	7a401804 	ccmp	w0, #0x0, #0x4, ne	// ne = any
}
    fd8000009b88:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd8000009b8c:	1a9f07e0 	cset	w0, ne	// ne = any
    fd8000009b90:	a9425bf5 	ldp	x21, x22, [sp, #32]
    fd8000009b94:	f9401bf7 	ldr	x23, [sp, #48]
    fd8000009b98:	a8c97bfd 	ldp	x29, x30, [sp], #144
    fd8000009b9c:	d65f03c0 	ret
    fd8000009ba0:	00013000 	.word	0x00013000
    fd8000009ba4:	0000fd80 	.word	0x0000fd80
    fd8000009ba8:	00000000 	.word	0x00000000
    fd8000009bac:	0000fd80 	.word	0x0000fd80
    fd8000009bb0:	00020000 	.word	0x00020000
    fd8000009bb4:	0000fd80 	.word	0x0000fd80
    fd8000009bb8:	00012930 	.word	0x00012930
    fd8000009bbc:	0000fd80 	.word	0x0000fd80
    fd8000009bc0:	03562000 	.word	0x03562000
    fd8000009bc4:	0000fd80 	.word	0x0000fd80
    fd8000009bc8:	00013000 	.word	0x00013000
    fd8000009bcc:	0000fd80 	.word	0x0000fd80

0000fd8000009bd0 <mem_vm_img_in_phys_rgn>:

bool mem_vm_img_in_phys_rgn(struct vm_config* vm_config)
{
    bool img_in_rgn = false;

    for (size_t i = 0; i < vm_config->platform.region_num; i++) {
    fd8000009bd0:	f9402008 	ldr	x8, [x0, #64]
    fd8000009bd4:	b4000388 	cbz	x8, fd8000009c44 <mem_vm_img_in_phys_rgn+0x74>
    fd8000009bd8:	f9402401 	ldr	x1, [x0, #72]
    fd8000009bdc:	d2800004 	mov	x4, #0x0                   	// #0
        limit1 = ULONG_MAX;
    fd8000009be0:	9280000b 	mov	x11, #0xffffffffffffffff    	// #-1
    fd8000009be4:	91002021 	add	x1, x1, #0x8
        if (vm_config->platform.regions[i].place_phys) {
    fd8000009be8:	39404022 	ldrb	w2, [x1, #16]
    for (size_t i = 0; i < vm_config->platform.region_num; i++) {
    fd8000009bec:	91000484 	add	x4, x4, #0x1
        if (vm_config->platform.regions[i].place_phys) {
    fd8000009bf0:	36000242 	tbz	w2, #0, fd8000009c38 <mem_vm_img_in_phys_rgn+0x68>
    fd8000009bf4:	a9408c05 	ldp	x5, x3, [x0, #8]
            vaddr_t rgn_base = vm_config->platform.regions[i].phys;
            size_t rgn_size = vm_config->platform.regions[i].size;
    fd8000009bf8:	f9400027 	ldr	x7, [x1]
            vaddr_t rgn_base = vm_config->platform.regions[i].phys;
    fd8000009bfc:	f9400c26 	ldr	x6, [x1, #24]
    unsigned long limit2 = base2 + size2;
    fd8000009c00:	ab0300a3 	adds	x3, x5, x3
    fd8000009c04:	9a9f37ea 	cset	x10, cs	// cs = hs, nlast
    fd8000009c08:	ab0700c7 	adds	x7, x6, x7
    fd8000009c0c:	9a9f37e9 	cset	x9, cs	// cs = hs, nlast
        limit1 = ULONG_MAX;
    fd8000009c10:	f100015f 	cmp	x10, #0x0
    fd8000009c14:	9a8b0063 	csel	x3, x3, x11, eq	// eq = none
    if (limit2 < base2) {
    fd8000009c18:	b5000069 	cbnz	x9, fd8000009c24 <mem_vm_img_in_phys_rgn+0x54>
    return (base1 >= base2) && (limit1 <= limit2);
    fd8000009c1c:	eb0300ff 	cmp	x7, x3
    fd8000009c20:	1a9f37e2 	cset	w2, cs	// cs = hs, nlast
    fd8000009c24:	eb0500df 	cmp	x6, x5
    fd8000009c28:	1a9f87e3 	cset	w3, ls	// ls = plast
            paddr_t img_base = vm_config->image.load_addr;
            size_t img_size = vm_config->image.size;
            if (range_in_range(img_base, img_size, rgn_base, rgn_size)) {
    fd8000009c2c:	6a03005f 	tst	w2, w3
    fd8000009c30:	0a030042 	and	w2, w2, w3
    fd8000009c34:	540000a1 	b.ne	fd8000009c48 <mem_vm_img_in_phys_rgn+0x78>  // b.any
    for (size_t i = 0; i < vm_config->platform.region_num; i++) {
    fd8000009c38:	9100a021 	add	x1, x1, #0x28
    fd8000009c3c:	eb08009f 	cmp	x4, x8
    fd8000009c40:	54fffd41 	b.ne	fd8000009be8 <mem_vm_img_in_phys_rgn+0x18>  // b.any
    bool img_in_rgn = false;
    fd8000009c44:	52800002 	mov	w2, #0x0                   	// #0
            }
        }
    }

    return img_in_rgn;
}
    fd8000009c48:	2a0203e0 	mov	w0, w2
    fd8000009c4c:	d65f03c0 	ret

0000fd8000009c50 <mem_reserve_physical_memory>:

bool mem_reserve_physical_memory(struct page_pool* pool)
{
    if (pool == NULL) {
    fd8000009c50:	b4000d00 	cbz	x0, fd8000009df0 <mem_reserve_physical_memory+0x1a0>
{
    fd8000009c54:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    fd8000009c58:	910003fd 	mov	x29, sp
    fd8000009c5c:	a9025bf5 	stp	x21, x22, [sp, #32]
    fd8000009c60:	aa0003f5 	mov	x21, x0
        return false;
    }

    for (size_t i = 0; i < config.vmlist_size; i++) {
    fd8000009c64:	90000000 	adrp	x0, fd8000009000 <vsnprintk+0x1d0>
    fd8000009c68:	f946fc16 	ldr	x22, [x0, #3576]
{
    fd8000009c6c:	a90153f3 	stp	x19, x20, [sp, #16]
    for (size_t i = 0; i < config.vmlist_size; i++) {
    fd8000009c70:	f94016c0 	ldr	x0, [x22, #40]
    fd8000009c74:	b4000760 	cbz	x0, fd8000009d60 <mem_reserve_physical_memory+0x110>
    fd8000009c78:	9100c2d3 	add	x19, x22, #0x30
    fd8000009c7c:	d2800014 	mov	x20, #0x0                   	// #0
        struct vm_config* vm_cfg = &config.vmlist[i];
        size_t n_pg = NUM_PAGES(vm_cfg->image.size);
    fd8000009c80:	a9408662 	ldp	x2, x1, [x19, #8]
        // If the vm image is part of a statically allocated region of the same vm, we defer the
        // reservation of this memory to when we reserve the physical region below. Note that this
        // not allow partial overlaps. If the image must be entirely inside a statically allocated
        // region, or completely outside of it. This avoid overcamplicating the reservation logic
        // while still covering all the useful use cases.
        if (mem_vm_img_in_phys_rgn(vm_cfg)) {
    fd8000009c84:	aa1303e0 	mov	x0, x19
    fd8000009c88:	f9002fff 	str	xzr, [sp, #88]
        size_t n_pg = NUM_PAGES(vm_cfg->image.size);
    fd8000009c8c:	913ffc21 	add	x1, x1, #0xfff
    fd8000009c90:	d34cfc21 	lsr	x1, x1, #12
    fd8000009c94:	a90487e2 	stp	x2, x1, [sp, #72]
        if (mem_vm_img_in_phys_rgn(vm_cfg)) {
    fd8000009c98:	97ffffce 	bl	fd8000009bd0 <mem_vm_img_in_phys_rgn>
    fd8000009c9c:	2a0003e2 	mov	w2, w0
            continue;
        }

        if (!mem_reserve_ppool_ppages(pool, &ppages)) {
    fd8000009ca0:	910123e1 	add	x1, sp, #0x48
    fd8000009ca4:	aa1503e0 	mov	x0, x21
        if (mem_vm_img_in_phys_rgn(vm_cfg)) {
    fd8000009ca8:	37000062 	tbnz	w2, #0, fd8000009cb4 <mem_reserve_physical_memory+0x64>
        if (!mem_reserve_ppool_ppages(pool, &ppages)) {
    fd8000009cac:	97ffff0d 	bl	fd80000098e0 <mem_reserve_ppool_ppages>
    fd8000009cb0:	36000900 	tbz	w0, #0, fd8000009dd0 <mem_reserve_physical_memory+0x180>
    for (size_t i = 0; i < config.vmlist_size; i++) {
    fd8000009cb4:	f94016c0 	ldr	x0, [x22, #40]
    fd8000009cb8:	91000694 	add	x20, x20, #0x1
    fd8000009cbc:	9102c273 	add	x19, x19, #0xb0
    fd8000009cc0:	eb14001f 	cmp	x0, x20
    fd8000009cc4:	54fffde8 	b.hi	fd8000009c80 <mem_reserve_physical_memory+0x30>  // b.pmore
            return false;
        }
    }

    /* for every vm config */
    for (size_t i = 0; i < config.vmlist_size; i++) {
    fd8000009cc8:	a90363f7 	stp	x23, x24, [sp, #48]
    fd8000009ccc:	b4000480 	cbz	x0, fd8000009d5c <mem_reserve_physical_memory+0x10c>
    fd8000009cd0:	aa1603f8 	mov	x24, x22
    fd8000009cd4:	d2800017 	mov	x23, #0x0                   	// #0
        struct vm_config* vm_cfg = &config.vmlist[i];
        /* for every mem region */
        for (size_t j = 0; j < vm_cfg->platform.region_num; j++) {
    fd8000009cd8:	f9403b00 	ldr	x0, [x24, #112]
    fd8000009cdc:	d2800013 	mov	x19, #0x0                   	// #0
    fd8000009ce0:	d2800014 	mov	x20, #0x0                   	// #0
    fd8000009ce4:	b50000c0 	cbnz	x0, fd8000009cfc <mem_reserve_physical_memory+0xac>
    fd8000009ce8:	14000018 	b	fd8000009d48 <mem_reserve_physical_memory+0xf8>
    fd8000009cec:	91000694 	add	x20, x20, #0x1
    fd8000009cf0:	9100a273 	add	x19, x19, #0x28
    fd8000009cf4:	eb14001f 	cmp	x0, x20
    fd8000009cf8:	54000289 	b.ls	fd8000009d48 <mem_reserve_physical_memory+0xf8>  // b.plast
            struct vm_mem_region* reg = &vm_cfg->platform.regions[j];
    fd8000009cfc:	f9403f02 	ldr	x2, [x24, #120]
    fd8000009d00:	8b130042 	add	x2, x2, x19
            if (reg->place_phys) {
    fd8000009d04:	39406041 	ldrb	w1, [x2, #24]
    fd8000009d08:	3607ff21 	tbz	w1, #0, fd8000009cec <mem_reserve_physical_memory+0x9c>
                size_t n_pg = NUM_PAGES(reg->size);
    fd8000009d0c:	f9400440 	ldr	x0, [x2, #8]
                struct ppages ppages = mem_ppages_get(reg->phys, n_pg);
                if (!mem_reserve_ppool_ppages(pool, &ppages)) {
    fd8000009d10:	910123e1 	add	x1, sp, #0x48
    fd8000009d14:	f9401043 	ldr	x3, [x2, #32]
                size_t n_pg = NUM_PAGES(reg->size);
    fd8000009d18:	913ffc02 	add	x2, x0, #0xfff
                if (!mem_reserve_ppool_ppages(pool, &ppages)) {
    fd8000009d1c:	aa1503e0 	mov	x0, x21
    fd8000009d20:	f9002fff 	str	xzr, [sp, #88]
                size_t n_pg = NUM_PAGES(reg->size);
    fd8000009d24:	d34cfc42 	lsr	x2, x2, #12
    fd8000009d28:	a9048be3 	stp	x3, x2, [sp, #72]
                if (!mem_reserve_ppool_ppages(pool, &ppages)) {
    fd8000009d2c:	97fffeed 	bl	fd80000098e0 <mem_reserve_ppool_ppages>
    fd8000009d30:	360004e0 	tbz	w0, #0, fd8000009dcc <mem_reserve_physical_memory+0x17c>
    fd8000009d34:	f9403b00 	ldr	x0, [x24, #112]
        for (size_t j = 0; j < vm_cfg->platform.region_num; j++) {
    fd8000009d38:	91000694 	add	x20, x20, #0x1
    fd8000009d3c:	9100a273 	add	x19, x19, #0x28
    fd8000009d40:	eb14001f 	cmp	x0, x20
    fd8000009d44:	54fffdc8 	b.hi	fd8000009cfc <mem_reserve_physical_memory+0xac>  // b.pmore
    for (size_t i = 0; i < config.vmlist_size; i++) {
    fd8000009d48:	f94016c0 	ldr	x0, [x22, #40]
    fd8000009d4c:	910006f7 	add	x23, x23, #0x1
    fd8000009d50:	9102c318 	add	x24, x24, #0xb0
    fd8000009d54:	eb17001f 	cmp	x0, x23
    fd8000009d58:	54fffc08 	b.hi	fd8000009cd8 <mem_reserve_physical_memory+0x88>  // b.pmore
    fd8000009d5c:	a94363f7 	ldp	x23, x24, [sp, #48]
                }
            }
        }
    }

    for (size_t i = 0; i < config.shmemlist_size; i++) {
    fd8000009d60:	d2800013 	mov	x19, #0x0                   	// #0
    fd8000009d64:	f9400ec0 	ldr	x0, [x22, #24]
    fd8000009d68:	d2800014 	mov	x20, #0x0                   	// #0
    fd8000009d6c:	b40003e0 	cbz	x0, fd8000009de8 <mem_reserve_physical_memory+0x198>
    fd8000009d70:	a90363f7 	stp	x23, x24, [sp, #48]
    fd8000009d74:	14000006 	b	fd8000009d8c <mem_reserve_physical_memory+0x13c>
    fd8000009d78:	f9400ec0 	ldr	x0, [x22, #24]
    fd8000009d7c:	91000694 	add	x20, x20, #0x1
    fd8000009d80:	9100c273 	add	x19, x19, #0x30
    fd8000009d84:	eb14001f 	cmp	x0, x20
    fd8000009d88:	540002e9 	b.ls	fd8000009de4 <mem_reserve_physical_memory+0x194>  // b.plast
        struct shmem* shmem = &config.shmemlist[i];
    fd8000009d8c:	f94012c0 	ldr	x0, [x22, #32]
    fd8000009d90:	8b130017 	add	x23, x0, x19
        if (shmem->place_phys) {
    fd8000009d94:	394042e1 	ldrb	w1, [x23, #16]
    fd8000009d98:	3607ff01 	tbz	w1, #0, fd8000009d78 <mem_reserve_physical_memory+0x128>
            size_t n_pg = NUM_PAGES(shmem->size);
    fd8000009d9c:	f8736802 	ldr	x2, [x0, x19]
            struct ppages ppages = mem_ppages_get(shmem->phys, n_pg);
            if (!mem_reserve_ppool_ppages(pool, &ppages)) {
    fd8000009da0:	910123e1 	add	x1, sp, #0x48
            struct ppages ppages = mem_ppages_get(shmem->phys, n_pg);
    fd8000009da4:	f9400ef8 	ldr	x24, [x23, #24]
            size_t n_pg = NUM_PAGES(shmem->size);
    fd8000009da8:	913ffc42 	add	x2, x2, #0xfff
            if (!mem_reserve_ppool_ppages(pool, &ppages)) {
    fd8000009dac:	aa1503e0 	mov	x0, x21
    fd8000009db0:	f9002fff 	str	xzr, [sp, #88]
            size_t n_pg = NUM_PAGES(shmem->size);
    fd8000009db4:	d34cfc42 	lsr	x2, x2, #12
    fd8000009db8:	a9048bf8 	stp	x24, x2, [sp, #72]
            if (!mem_reserve_ppool_ppages(pool, &ppages)) {
    fd8000009dbc:	97fffec9 	bl	fd80000098e0 <mem_reserve_ppool_ppages>
    fd8000009dc0:	36000060 	tbz	w0, #0, fd8000009dcc <mem_reserve_physical_memory+0x17c>
                return false;
            }
            shmem->phys = ppages.base;
    fd8000009dc4:	f9000ef8 	str	x24, [x23, #24]
    fd8000009dc8:	17ffffec 	b	fd8000009d78 <mem_reserve_physical_memory+0x128>
    fd8000009dcc:	a94363f7 	ldp	x23, x24, [sp, #48]
        return false;
    fd8000009dd0:	52800000 	mov	w0, #0x0                   	// #0
        }
    }

    return true;
}
    fd8000009dd4:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd8000009dd8:	a9425bf5 	ldp	x21, x22, [sp, #32]
    fd8000009ddc:	a8c67bfd 	ldp	x29, x30, [sp], #96
    fd8000009de0:	d65f03c0 	ret
    fd8000009de4:	a94363f7 	ldp	x23, x24, [sp, #48]
    return true;
    fd8000009de8:	52800020 	mov	w0, #0x1                   	// #1
    fd8000009dec:	17fffffa 	b	fd8000009dd4 <mem_reserve_physical_memory+0x184>
        return false;
    fd8000009df0:	52800000 	mov	w0, #0x0                   	// #0
}
    fd8000009df4:	d65f03c0 	ret
    fd8000009df8:	00012bf0 	.word	0x00012bf0
    fd8000009dfc:	0000fd80 	.word	0x0000fd80

0000fd8000009e00 <mem_find_root_region>:
{
    size_t image_size = (size_t)(&_image_end - &_image_start);

    /* Find the root memory region in which the hypervisor was loaded. */
    struct mem_region* root_mem_region = NULL;
    for (size_t i = 0; i < platform.region_num; i++) {
    fd8000009e00:	90000001 	adrp	x1, fd8000009000 <vsnprintk+0x1d0>
    fd8000009e04:	f9474c21 	ldr	x1, [x1, #3736]
    size_t image_size = (size_t)(&_image_end - &_image_start);
    fd8000009e08:	90000002 	adrp	x2, fd8000009000 <vsnprintk+0x1d0>
    fd8000009e0c:	f9474445 	ldr	x5, [x2, #3720]
    fd8000009e10:	90000002 	adrp	x2, fd8000009000 <vsnprintk+0x1d0>
    fd8000009e14:	f9474842 	ldr	x2, [x2, #3728]
{
    fd8000009e18:	aa0003e6 	mov	x6, x0
    for (size_t i = 0; i < platform.region_num; i++) {
    fd8000009e1c:	f9400c27 	ldr	x7, [x1, #24]
    size_t image_size = (size_t)(&_image_end - &_image_start);
    fd8000009e20:	cb0200a5 	sub	x5, x5, x2
    for (size_t i = 0; i < platform.region_num; i++) {
    fd8000009e24:	b4000287 	cbz	x7, fd8000009e74 <mem_find_root_region+0x74>
    fd8000009e28:	ab0000a5 	adds	x5, x5, x0
    fd8000009e2c:	d2800004 	mov	x4, #0x0                   	// #0
    fd8000009e30:	f9401023 	ldr	x3, [x1, #32]
    fd8000009e34:	da9f30a5 	csinv	x5, x5, xzr, cc	// cc = lo, ul, last
    fd8000009e38:	14000004 	b	fd8000009e48 <mem_find_root_region+0x48>
    fd8000009e3c:	eb07009f 	cmp	x4, x7
    fd8000009e40:	91012063 	add	x3, x3, #0x48
    fd8000009e44:	54000180 	b.eq	fd8000009e74 <mem_find_root_region+0x74>  // b.none
        struct mem_region* region = &(platform.regions[i]);
    fd8000009e48:	a9400861 	ldp	x1, x2, [x3]
    fd8000009e4c:	aa0303e0 	mov	x0, x3
        bool is_in_rgn = range_in_range(load_addr, image_size, region->base, region->size);
    fd8000009e50:	ab020022 	adds	x2, x1, x2
    fd8000009e54:	54000142 	b.cs	fd8000009e7c <mem_find_root_region+0x7c>  // b.hs, b.nlast
    fd8000009e58:	eb05005f 	cmp	x2, x5
    fd8000009e5c:	1a9f37e2 	cset	w2, cs	// cs = hs, nlast
    fd8000009e60:	7100005f 	cmp	w2, #0x0
    for (size_t i = 0; i < platform.region_num; i++) {
    fd8000009e64:	91000484 	add	x4, x4, #0x1
        if (is_in_rgn) {
    fd8000009e68:	fa461022 	ccmp	x1, x6, #0x2, ne	// ne = any
    fd8000009e6c:	54fffe88 	b.hi	fd8000009e3c <mem_find_root_region+0x3c>  // b.pmore
            break;
        }
    }

    return root_mem_region;
}
    fd8000009e70:	d65f03c0 	ret
    struct mem_region* root_mem_region = NULL;
    fd8000009e74:	d2800000 	mov	x0, #0x0                   	// #0
}
    fd8000009e78:	d65f03c0 	ret
    fd8000009e7c:	52800022 	mov	w2, #0x1                   	// #1
    fd8000009e80:	17fffff8 	b	fd8000009e60 <mem_find_root_region+0x60>
    fd8000009e84:	d503201f 	nop
    fd8000009e88:	00020000 	.word	0x00020000
    fd8000009e8c:	0000fd80 	.word	0x0000fd80
    fd8000009e90:	00000000 	.word	0x00000000
    fd8000009e94:	0000fd80 	.word	0x0000fd80
    fd8000009e98:	00012930 	.word	0x00012930
    fd8000009e9c:	0000fd80 	.word	0x0000fd80

0000fd8000009ea0 <mem_setup_root_pool>:

bool mem_setup_root_pool(paddr_t load_addr, struct mem_region** root_mem_region)
{
    fd8000009ea0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    fd8000009ea4:	aa0103e8 	mov	x8, x1
    fd8000009ea8:	910003fd 	mov	x29, sp
    fd8000009eac:	a90153f3 	stp	x19, x20, [sp, #16]
    fd8000009eb0:	aa0003f4 	mov	x20, x0
    *root_mem_region = mem_find_root_region(load_addr);
    fd8000009eb4:	97ffffd3 	bl	fd8000009e00 <mem_find_root_region>
    fd8000009eb8:	f9000100 	str	x0, [x8]
    if (*root_mem_region == NULL) {
    fd8000009ebc:	b40001a0 	cbz	x0, fd8000009ef0 <mem_setup_root_pool+0x50>
        return false;
    }

    return pp_root_init(load_addr, *root_mem_region);
    fd8000009ec0:	aa0003f3 	mov	x19, x0
    if (!root_pool_set_up_bitmap(load_addr, root_pool)) {
    fd8000009ec4:	aa1403e0 	mov	x0, x20
    root_pool->size = root_region->size / PAGE_SIZE; /* TODO: what if not
    fd8000009ec8:	f9400662 	ldr	x2, [x19, #8]
    root_pool->base = ALIGN(root_region->base, PAGE_SIZE);
    fd8000009ecc:	f8410661 	ldr	x1, [x19], #16
    root_pool->size = root_region->size / PAGE_SIZE; /* TODO: what if not
    fd8000009ed0:	d34cfc42 	lsr	x2, x2, #12
    root_pool->free = root_pool->size;
    fd8000009ed4:	f9000e62 	str	x2, [x19, #24]
    root_pool->base = ALIGN(root_region->base, PAGE_SIZE);
    fd8000009ed8:	913ffc21 	add	x1, x1, #0xfff
    fd8000009edc:	9274cc21 	and	x1, x1, #0xfffffffffffff000
    root_pool->size = root_region->size / PAGE_SIZE; /* TODO: what if not
    fd8000009ee0:	a9008a61 	stp	x1, x2, [x19, #8]
    if (!root_pool_set_up_bitmap(load_addr, root_pool)) {
    fd8000009ee4:	aa1303e1 	mov	x1, x19
    fd8000009ee8:	97fffeae 	bl	fd80000099a0 <root_pool_set_up_bitmap>
    fd8000009eec:	370000a0 	tbnz	w0, #0, fd8000009f00 <mem_setup_root_pool+0x60>
}
    fd8000009ef0:	a94153f3 	ldp	x19, x20, [sp, #16]
        return false;
    fd8000009ef4:	52800000 	mov	w0, #0x0                   	// #0
}
    fd8000009ef8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    fd8000009efc:	d65f03c0 	ret
    if (!pp_root_reserve_hyp_mem(load_addr, root_pool)) {
    fd8000009f00:	aa1303e1 	mov	x1, x19
    fd8000009f04:	aa1403e0 	mov	x0, x20
    fd8000009f08:	97fffeea 	bl	fd8000009ab0 <pp_root_reserve_hyp_mem>
    fd8000009f0c:	2a0003e1 	mov	w1, w0
    fd8000009f10:	12001c00 	and	w0, w0, #0xff
    fd8000009f14:	3607fee1 	tbz	w1, #0, fd8000009ef0 <mem_setup_root_pool+0x50>
    root_pool->last = 0;
    fd8000009f18:	f900127f 	str	xzr, [x19, #32]
}
    fd8000009f1c:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd8000009f20:	a8c27bfd 	ldp	x29, x30, [sp], #32
    fd8000009f24:	d65f03c0 	ret
    fd8000009f28:	d503201f 	nop
    fd8000009f2c:	d503201f 	nop

__attribute__((weak)) void mem_color_hypervisor(const paddr_t load_addr,
    struct mem_region* root_region)
{
    WARNING("Trying to color hypervisor, but implementation does not suuport "
    fd8000009f30:	90000000 	adrp	x0, fd8000009000 <vsnprintk+0x1d0>
    fd8000009f34:	f947a000 	ldr	x0, [x0, #3904]
    fd8000009f38:	1400083a 	b	fd800000c020 <console_printk>
    fd8000009f3c:	d503201f 	nop
    fd8000009f40:	00010a80 	.word	0x00010a80
    fd8000009f44:	0000fd80 	.word	0x0000fd80
    fd8000009f48:	d503201f 	nop
    fd8000009f4c:	d503201f 	nop
            "it");
}

__attribute__((weak)) bool mem_map_reclr(struct addr_space* as, vaddr_t va, struct ppages* ppages,
    size_t num_pages, mem_flags_t flags)
{
    fd8000009f50:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    fd8000009f54:	910003fd 	mov	x29, sp
    ERROR("Trying to recolor section but there is no coloring implementation");
    fd8000009f58:	90000000 	adrp	x0, fd8000009000 <vsnprintk+0x1d0>
    fd8000009f5c:	f947b400 	ldr	x0, [x0, #3944]
    fd8000009f60:	94000830 	bl	fd800000c020 <console_printk>
    fd8000009f64:	14000000 	b	fd8000009f64 <mem_setup_root_pool+0xc4>
    fd8000009f68:	00010ad8 	.word	0x00010ad8
    fd8000009f6c:	0000fd80 	.word	0x0000fd80
}

__attribute__((weak)) bool pp_alloc_clr(struct page_pool* pool, size_t num_pages, colormap_t colors,
    struct ppages* ppages)
{
    fd8000009f70:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    fd8000009f74:	910003fd 	mov	x29, sp
    ERROR("Trying to allocate colored pages but there is no coloring "
    fd8000009f78:	90000000 	adrp	x0, fd8000009000 <vsnprintk+0x1d0>
    fd8000009f7c:	f947c400 	ldr	x0, [x0, #3976]
    fd8000009f80:	94000828 	bl	fd800000c020 <console_printk>
    fd8000009f84:	14000000 	b	fd8000009f84 <mem_setup_root_pool+0xe4>
    fd8000009f88:	00010b28 	.word	0x00010b28
    fd8000009f8c:	0000fd80 	.word	0x0000fd80

0000fd8000009f90 <mem_alloc_ppages>:
          "implementation");
}

struct ppages mem_alloc_ppages(colormap_t colors, size_t num_pages, bool aligned)
{
    fd8000009f90:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
    fd8000009f94:	910003fd 	mov	x29, sp
    struct ppages pages = { .num_pages = 0 };

    list_foreach (page_pool_list, struct page_pool, pool) {
    fd8000009f98:	b0000003 	adrp	x3, fd800000a000 <mem_alloc_ppages+0x70>
    fd8000009f9c:	f9403463 	ldr	x3, [x3, #104]
{
    fd8000009fa0:	a90153f3 	stp	x19, x20, [sp, #16]
    fd8000009fa4:	a9025bf5 	stp	x21, x22, [sp, #32]
    fd8000009fa8:	aa0803f6 	mov	x22, x8
    list_foreach (page_pool_list, struct page_pool, pool) {
    fd8000009fac:	f9400073 	ldr	x19, [x3]
    struct ppages pages = { .num_pages = 0 };
    fd8000009fb0:	a905ffff 	stp	xzr, xzr, [sp, #88]
    fd8000009fb4:	f90037ff 	str	xzr, [sp, #104]
    list_foreach (page_pool_list, struct page_pool, pool) {
    fd8000009fb8:	b40003d3 	cbz	x19, fd800000a030 <mem_alloc_ppages+0xa0>
    fd8000009fbc:	aa0003f4 	mov	x20, x0
    fd8000009fc0:	f90023f9 	str	x25, [sp, #64]
    fd8000009fc4:	b0000000 	adrp	x0, fd800000a000 <mem_alloc_ppages+0x70>
    fd8000009fc8:	f9403819 	ldr	x25, [x0, #112]
    fd8000009fcc:	aa0103f5 	mov	x21, x1
    fd8000009fd0:	a90363f7 	stp	x23, x24, [sp, #48]
    fd8000009fd4:	12001c57 	and	w23, w2, #0xff
}

static inline bool all_clrs(colormap_t clrs)
{
    colormap_t mask = (((colormap_t)1) << COLOR_NUM) - 1;
    fd8000009fd8:	d2800038 	mov	x24, #0x1                   	// #1
    fd8000009fdc:	f9400324 	ldr	x4, [x25]
    fd8000009fe0:	910163e3 	add	x3, sp, #0x58
    fd8000009fe4:	2a1703e2 	mov	w2, w23
    fd8000009fe8:	aa1503e1 	mov	x1, x21
    fd8000009fec:	aa1303e0 	mov	x0, x19
    fd8000009ff0:	9ac42304 	lsl	x4, x24, x4
    fd8000009ff4:	d1000484 	sub	x4, x4, #0x1
        bool ok = (!all_clrs(colors) && !aligned) ? pp_alloc_clr(pool, num_pages, colors, &pages) :
    fd8000009ff8:	ea040285 	ands	x5, x20, x4
    fd8000009ffc:	fa451084 	ccmp	x4, x5, #0x4, ne	// ne = any
    fd800000a000:	7a401ae0 	ccmp	w23, #0x0, #0x0, ne	// ne = any
    fd800000a004:	540002a0 	b.eq	fd800000a058 <mem_alloc_ppages+0xc8>  // b.none
    ppages->colors = 0;
    fd800000a008:	a9067fff 	stp	xzr, xzr, [sp, #96]
    if (num_pages == 0) {
    fd800000a00c:	b40000f5 	cbz	x21, fd800000a028 <mem_alloc_ppages+0x98>
    fd800000a010:	97fffd80 	bl	fd8000009610 <pp_alloc.part.0.constprop.0>
    fd800000a014:	12001c00 	and	w0, w0, #0xff
                                                    pp_alloc(pool, num_pages, aligned, &pages);
        if (ok) {
    fd800000a018:	37000080 	tbnz	w0, #0, fd800000a028 <mem_alloc_ppages+0x98>
    list_foreach (page_pool_list, struct page_pool, pool) {
    fd800000a01c:	f9400273 	ldr	x19, [x19]
    fd800000a020:	b5fffdf3 	cbnz	x19, fd8000009fdc <mem_alloc_ppages+0x4c>
    fd800000a024:	d503201f 	nop
    fd800000a028:	a94363f7 	ldp	x23, x24, [sp, #48]
    fd800000a02c:	f94023f9 	ldr	x25, [sp, #64]
            break;
        }
    }

    return pages;
    fd800000a030:	f9402fe0 	ldr	x0, [sp, #88]
}
    fd800000a034:	a94153f3 	ldp	x19, x20, [sp, #16]
    return pages;
    fd800000a038:	f90002c0 	str	x0, [x22]
    fd800000a03c:	f94033e0 	ldr	x0, [sp, #96]
    fd800000a040:	f90006c0 	str	x0, [x22, #8]
    fd800000a044:	f94037e0 	ldr	x0, [sp, #104]
    fd800000a048:	f9000ac0 	str	x0, [x22, #16]
}
    fd800000a04c:	a9425bf5 	ldp	x21, x22, [sp, #32]
    fd800000a050:	a8c77bfd 	ldp	x29, x30, [sp], #112
    fd800000a054:	d65f03c0 	ret
        bool ok = (!all_clrs(colors) && !aligned) ? pp_alloc_clr(pool, num_pages, colors, &pages) :
    fd800000a058:	aa1403e2 	mov	x2, x20
    fd800000a05c:	94000b51 	bl	fd800000cda0 <pp_alloc_clr>
    fd800000a060:	12001c00 	and	w0, w0, #0xff
    fd800000a064:	17ffffed 	b	fd800000a018 <mem_alloc_ppages+0x88>
    fd800000a068:	000130a0 	.word	0x000130a0
    fd800000a06c:	0000fd80 	.word	0x0000fd80
    fd800000a070:	00012828 	.word	0x00012828
    fd800000a074:	0000fd80 	.word	0x0000fd80
    fd800000a078:	d503201f 	nop
    fd800000a07c:	d503201f 	nop

0000fd800000a080 <mem_alloc_page>:
{
    fd800000a080:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    fd800000a084:	910003fd 	mov	x29, sp
    fd800000a088:	f90013f5 	str	x21, [sp, #32]
    struct ppages ppages = mem_alloc_ppages(cpu()->as.colors, num_pages, phys_aligned);
    fd800000a08c:	d2dfc015 	mov	x21, #0xfe0000000000        	// #279275953455104
{
    fd800000a090:	a90153f3 	stp	x19, x20, [sp, #16]
    fd800000a094:	aa0003f3 	mov	x19, x0
    fd800000a098:	2a0103f4 	mov	w20, w1
    struct ppages ppages = mem_alloc_ppages(cpu()->as.colors, num_pages, phys_aligned);
    fd800000a09c:	aa0003e1 	mov	x1, x0
    fd800000a0a0:	9100e3e8 	add	x8, sp, #0x38
    fd800000a0a4:	f9401ea0 	ldr	x0, [x21, #56]
    fd800000a0a8:	97ffffba 	bl	fd8000009f90 <mem_alloc_ppages>
    if (ppages.num_pages == num_pages) {
    fd800000a0ac:	f94023e4 	ldr	x4, [sp, #64]
    fd800000a0b0:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    fd800000a0b4:	eb13009f 	cmp	x4, x19
    fd800000a0b8:	540000a0 	b.eq	fd800000a0cc <mem_alloc_page+0x4c>  // b.none
}
    fd800000a0bc:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd800000a0c0:	f94013f5 	ldr	x21, [sp, #32]
    fd800000a0c4:	a8c57bfd 	ldp	x29, x30, [sp], #80
    fd800000a0c8:	d65f03c0 	ret
        vpage = mem_alloc_map(&cpu()->as, sec, &ppages, INVALID_VA, num_pages, PTE_HYP_FLAGS);
    fd800000a0cc:	9100e3e2 	add	x2, sp, #0x38
    fd800000a0d0:	2a1403e1 	mov	w1, w20
    fd800000a0d4:	910042a0 	add	x0, x21, #0x10
    fd800000a0d8:	d280e885 	mov	x5, #0x744                 	// #1860
    fd800000a0dc:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
    fd800000a0e0:	94001348 	bl	fd800000ee00 <mem_alloc_map>
}
    fd800000a0e4:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd800000a0e8:	f94013f5 	ldr	x21, [sp, #32]
    fd800000a0ec:	a8c57bfd 	ldp	x29, x30, [sp], #80
    fd800000a0f0:	d65f03c0 	ret
    fd800000a0f4:	d503201f 	nop
    fd800000a0f8:	d503201f 	nop
    fd800000a0fc:	d503201f 	nop

0000fd800000a100 <mem_create_ppools>:
{
    fd800000a100:	a9b67bfd 	stp	x29, x30, [sp, #-160]!
    fd800000a104:	910003fd 	mov	x29, sp
    fd800000a108:	a90573fb 	stp	x27, x28, [sp, #80]
    for (size_t i = 0; i < platform.region_num; i++) {
    fd800000a10c:	90000001 	adrp	x1, fd800000a000 <mem_alloc_ppages+0x70>
    fd800000a110:	f941783b 	ldr	x27, [x1, #752]
{
    fd800000a114:	a9025bf5 	stp	x21, x22, [sp, #32]
    fd800000a118:	aa0003f6 	mov	x22, x0
    for (size_t i = 0; i < platform.region_num; i++) {
    fd800000a11c:	f9400f60 	ldr	x0, [x27, #24]
    fd800000a120:	b4000d80 	cbz	x0, fd800000a2d0 <mem_create_ppools+0x1d0>
    fd800000a124:	d2800015 	mov	x21, #0x0                   	// #0
    fd800000a128:	a90153f3 	stp	x19, x20, [sp, #16]
    fd800000a12c:	a90363f7 	stp	x23, x24, [sp, #48]
    __asm__ volatile(
    fd800000a130:	90000017 	adrp	x23, fd800000a000 <mem_alloc_ppages+0x70>
    pages = mem_alloc_ppages(cpu()->as.colors, bitmap_size, false);
    fd800000a134:	d2dfc018 	mov	x24, #0xfe0000000000        	// #279275953455104
    fd800000a138:	a9046bf9 	stp	x25, x26, [sp, #64]
    for (size_t i = 0; i < platform.region_num; i++) {
    fd800000a13c:	d280001a 	mov	x26, #0x0                   	// #0
    fd800000a140:	14000023 	b	fd800000a1cc <mem_create_ppools+0xcc>
                if (!mem_reserve_physical_memory(pool)) {
    fd800000a144:	aa1903e0 	mov	x0, x25
    fd800000a148:	97fffec2 	bl	fd8000009c50 <mem_reserve_physical_memory>
    fd800000a14c:	12001c01 	and	w1, w0, #0xff
    fd800000a150:	36000aa0 	tbz	w0, #0, fd800000a2a4 <mem_create_ppools+0x1a4>
    fd800000a154:	f9417ee1 	ldr	x1, [x23, #760]
        *node = NULL;
    fd800000a158:	f9000a9f 	str	xzr, [x20, #16]
    fd800000a15c:	91004024 	add	x4, x1, #0x10
    fd800000a160:	91005025 	add	x5, x1, #0x14
    fd800000a164:	885ffc80 	ldaxr	w0, [x4]
    fd800000a168:	11000402 	add	w2, w0, #0x1
    fd800000a16c:	88037c82 	stxr	w3, w2, [x4]
    fd800000a170:	35ffffa3 	cbnz	w3, fd800000a164 <mem_create_ppools+0x64>
    fd800000a174:	88dffca2 	ldar	w2, [x5]
    fd800000a178:	6b02001f 	cmp	w0, w2
    fd800000a17c:	54000060 	b.eq	fd800000a188 <mem_create_ppools+0x88>  // b.none
    fd800000a180:	d503205f 	wfe
    fd800000a184:	17fffffc 	b	fd800000a174 <mem_create_ppools+0x74>
        if (list->tail != NULL) {
    fd800000a188:	f9400420 	ldr	x0, [x1, #8]
    fd800000a18c:	b4000040 	cbz	x0, fd800000a194 <mem_create_ppools+0x94>
            *list->tail = node;
    fd800000a190:	f9000019 	str	x25, [x0]
        if (list->head == NULL) {
    fd800000a194:	f9400020 	ldr	x0, [x1]
        list->tail = node;
    fd800000a198:	f9000439 	str	x25, [x1, #8]
        if (list->head == NULL) {
    fd800000a19c:	b4000a60 	cbz	x0, fd800000a2e8 <mem_create_ppools+0x1e8>
    __asm__ volatile(
    fd800000a1a0:	91005021 	add	x1, x1, #0x14
    fd800000a1a4:	b9400020 	ldr	w0, [x1]
    fd800000a1a8:	11000400 	add	w0, w0, #0x1
    fd800000a1ac:	889ffc20 	stlr	w0, [x1]
    fd800000a1b0:	d5033b9f 	dsb	ish
    fd800000a1b4:	d503209f 	sev
    for (size_t i = 0; i < platform.region_num; i++) {
    fd800000a1b8:	f9400f60 	ldr	x0, [x27, #24]
    fd800000a1bc:	9100075a 	add	x26, x26, #0x1
    fd800000a1c0:	910122b5 	add	x21, x21, #0x48
    fd800000a1c4:	eb1a001f 	cmp	x0, x26
    fd800000a1c8:	540007e9 	b.ls	fd800000a2c4 <mem_create_ppools+0x1c4>  // b.plast
        if (&platform.regions[i] != root_mem_region) {
    fd800000a1cc:	f9401360 	ldr	x0, [x27, #32]
    fd800000a1d0:	8b150014 	add	x20, x0, x21
    fd800000a1d4:	eb16029f 	cmp	x20, x22
    fd800000a1d8:	54ffff00 	b.eq	fd800000a1b8 <mem_create_ppools+0xb8>  // b.none
                pp_init(pool, reg->base, reg->size);
    fd800000a1dc:	f940069c 	ldr	x28, [x20, #8]
            struct page_pool* pool = &reg->page_pool;
    fd800000a1e0:	91004299 	add	x25, x20, #0x10
                pp_init(pool, reg->base, reg->size);
    fd800000a1e4:	f8756813 	ldr	x19, [x0, x21]
    memset((void*)pool, 0, sizeof(struct page_pool));
    fd800000a1e8:	52800001 	mov	w1, #0x0                   	// #0
    fd800000a1ec:	aa1903e0 	mov	x0, x25
    fd800000a1f0:	d2800702 	mov	x2, #0x38                  	// #56
    fd800000a1f4:	97fffa4f 	bl	fd8000008b30 <memset>
    pool->base = ALIGN(base, PAGE_SIZE);
    fd800000a1f8:	913ffe73 	add	x19, x19, #0xfff
    pool->size = NUM_PAGES(size);
    fd800000a1fc:	913fff84 	add	x4, x28, #0xfff
    pool->base = ALIGN(base, PAGE_SIZE);
    fd800000a200:	9274ce73 	and	x19, x19, #0xfffffffffffff000
    pool->size = NUM_PAGES(size);
    fd800000a204:	d34cfc80 	lsr	x0, x4, #12
    size_t bitmap_size = pool->size / (8 * PAGE_SIZE) + !!(pool->size % (8 * PAGE_SIZE) != 0);
    fd800000a208:	d35bfc84 	lsr	x4, x4, #27
    fd800000a20c:	92403801 	and	x1, x0, #0x7fff
    pool->size = NUM_PAGES(size);
    fd800000a210:	a9008333 	stp	x19, x0, [x25, #8]
    size_t bitmap_size = pool->size / (8 * PAGE_SIZE) + !!(pool->size % (8 * PAGE_SIZE) != 0);
    fd800000a214:	f100003f 	cmp	x1, #0x0
    fd800000a218:	9a840493 	cinc	x19, x4, ne	// ne = any
    if (size <= bitmap_size) {
    fd800000a21c:	eb1c027f 	cmp	x19, x28
    fd800000a220:	54fff922 	b.cs	fd800000a144 <mem_create_ppools+0x44>  // b.hs, b.nlast
    pages = mem_alloc_ppages(cpu()->as.colors, bitmap_size, false);
    fd800000a224:	f9401f00 	ldr	x0, [x24, #56]
    fd800000a228:	aa1303e1 	mov	x1, x19
    fd800000a22c:	910183e8 	add	x8, sp, #0x60
    fd800000a230:	52800002 	mov	w2, #0x0                   	// #0
    fd800000a234:	97ffff57 	bl	fd8000009f90 <mem_alloc_ppages>
    fd800000a238:	f94033e0 	ldr	x0, [sp, #96]
    fd800000a23c:	f90047e0 	str	x0, [sp, #136]
    fd800000a240:	f94037e0 	ldr	x0, [sp, #104]
    fd800000a244:	f9004be0 	str	x0, [sp, #144]
    fd800000a248:	f9403be1 	ldr	x1, [sp, #112]
    fd800000a24c:	f9004fe1 	str	x1, [sp, #152]
    if (pages.num_pages != bitmap_size) {
    fd800000a250:	eb00027f 	cmp	x19, x0
    fd800000a254:	54fff781 	b.ne	fd800000a144 <mem_create_ppools+0x44>  // b.any
    if ((pool->bitmap = (bitmap_t*)mem_alloc_map(&cpu()->as, SEC_HYP_GLOBAL, &pages, INVALID_VA,
    fd800000a258:	d2800200 	mov	x0, #0x10                  	// #16
    fd800000a25c:	aa1303e4 	mov	x4, x19
    fd800000a260:	910223e2 	add	x2, sp, #0x88
    fd800000a264:	d280e885 	mov	x5, #0x744                 	// #1860
    fd800000a268:	f2dfc000 	movk	x0, #0xfe00, lsl #32
    fd800000a26c:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
    fd800000a270:	52800001 	mov	w1, #0x0                   	// #0
    fd800000a274:	940012e3 	bl	fd800000ee00 <mem_alloc_map>
    fd800000a278:	f9001720 	str	x0, [x25, #40]
    fd800000a27c:	b4fff640 	cbz	x0, fd800000a144 <mem_create_ppools+0x44>
    memset((void*)pool->bitmap, 0, bitmap_size * PAGE_SIZE);
    fd800000a280:	52800001 	mov	w1, #0x0                   	// #0
    fd800000a284:	d374ce62 	lsl	x2, x19, #12
    fd800000a288:	97fffa2a 	bl	fd8000008b30 <memset>
    pool->free = pool->size;
    fd800000a28c:	f9400b20 	ldr	x0, [x25, #16]
    pool->last = 0;
    fd800000a290:	a901ff20 	stp	x0, xzr, [x25, #24]
                if (!mem_reserve_physical_memory(pool)) {
    fd800000a294:	aa1903e0 	mov	x0, x25
    fd800000a298:	97fffe6e 	bl	fd8000009c50 <mem_reserve_physical_memory>
    fd800000a29c:	12001c01 	and	w1, w0, #0xff
    fd800000a2a0:	3707f5a0 	tbnz	w0, #0, fd800000a154 <mem_create_ppools+0x54>
    fd800000a2a4:	a94153f3 	ldp	x19, x20, [sp, #16]
}
    fd800000a2a8:	2a0103e0 	mov	w0, w1
    fd800000a2ac:	a9425bf5 	ldp	x21, x22, [sp, #32]
    fd800000a2b0:	a94363f7 	ldp	x23, x24, [sp, #48]
    fd800000a2b4:	a9446bf9 	ldp	x25, x26, [sp, #64]
    fd800000a2b8:	a94573fb 	ldp	x27, x28, [sp, #80]
    fd800000a2bc:	a8ca7bfd 	ldp	x29, x30, [sp], #160
    fd800000a2c0:	d65f03c0 	ret
    fd800000a2c4:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd800000a2c8:	a94363f7 	ldp	x23, x24, [sp, #48]
    fd800000a2cc:	a9446bf9 	ldp	x25, x26, [sp, #64]
    return true;
    fd800000a2d0:	52800021 	mov	w1, #0x1                   	// #1
}
    fd800000a2d4:	a9425bf5 	ldp	x21, x22, [sp, #32]
    fd800000a2d8:	2a0103e0 	mov	w0, w1
    fd800000a2dc:	a94573fb 	ldp	x27, x28, [sp, #80]
    fd800000a2e0:	a8ca7bfd 	ldp	x29, x30, [sp], #160
    fd800000a2e4:	d65f03c0 	ret
            list->head = node;
    fd800000a2e8:	f9000039 	str	x25, [x1]
    fd800000a2ec:	17ffffad 	b	fd800000a1a0 <mem_create_ppools+0xa0>
    fd800000a2f0:	00012930 	.word	0x00012930
    fd800000a2f4:	0000fd80 	.word	0x0000fd80
    fd800000a2f8:	000130a0 	.word	0x000130a0
    fd800000a2fc:	0000fd80 	.word	0x0000fd80

0000fd800000a300 <mem_init>:

void mem_init(paddr_t load_addr)
{
    fd800000a300:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    fd800000a304:	910003fd 	mov	x29, sp
    fd800000a308:	a90153f3 	stp	x19, x20, [sp, #16]
    fd800000a30c:	aa0003f3 	mov	x19, x0
    fd800000a310:	f90013f5 	str	x21, [sp, #32]
    mem_prot_init();
    fd800000a314:	940012a7 	bl	fd800000edb0 <mem_prot_init>

    static struct mem_region* root_mem_region = NULL;

    if (cpu()->id == CPU_MASTER) {
    fd800000a318:	90000000 	adrp	x0, fd800000a000 <mem_alloc_ppages+0x70>
    fd800000a31c:	f9424c15 	ldr	x21, [x0, #1176]
    fd800000a320:	d2dfc000 	mov	x0, #0xfe0000000000        	// #279275953455104
    fd800000a324:	f9400001 	ldr	x1, [x0]
    fd800000a328:	f94002a0 	ldr	x0, [x21]
    fd800000a32c:	eb00003f 	cmp	x1, x0
    fd800000a330:	540002e0 	b.eq	fd800000a38c <mem_init+0x8c>  // b.none
        if (!mem_reserve_physical_memory(&root_mem_region->page_pool)) {
            ERROR("failed reserving memory in root pool");
        }
    }

    cpu_sync_and_clear_msgs(&cpu_glb_sync);
    fd800000a334:	97fffc5f 	bl	fd80000094b0 <cpu_sync_and_clear_msgs.constprop.0>
    fd800000a338:	90000000 	adrp	x0, fd800000a000 <mem_alloc_ppages+0x70>
    fd800000a33c:	f9425c00 	ldr	x0, [x0, #1208]

    if (!all_clrs(config.hyp.colors)) {
    fd800000a340:	90000001 	adrp	x1, fd800000a000 <mem_alloc_ppages+0x70>
    fd800000a344:	f9426022 	ldr	x2, [x1, #1216]
    fd800000a348:	d2800021 	mov	x1, #0x1                   	// #1
    fd800000a34c:	f9400000 	ldr	x0, [x0]
    colormap_t masked_colors = clrs & mask;
    fd800000a350:	f9400842 	ldr	x2, [x2, #16]
    colormap_t mask = (((colormap_t)1) << COLOR_NUM) - 1;
    fd800000a354:	9ac02021 	lsl	x1, x1, x0
    fd800000a358:	d1000421 	sub	x1, x1, #0x1
    return (masked_colors == 0) || (masked_colors == mask);
    fd800000a35c:	ea020022 	ands	x2, x1, x2
    fd800000a360:	fa421024 	ccmp	x1, x2, #0x4, ne	// ne = any
    fd800000a364:	54000801 	b.ne	fd800000a464 <mem_init+0x164>  // b.any
        mem_color_hypervisor(load_addr, root_mem_region);
    }

    if (cpu()->id == CPU_MASTER) {
    fd800000a368:	d2dfc001 	mov	x1, #0xfe0000000000        	// #279275953455104
    fd800000a36c:	f94002a0 	ldr	x0, [x21]
    fd800000a370:	f9400021 	ldr	x1, [x1]
    fd800000a374:	eb00003f 	cmp	x1, x0
    fd800000a378:	54000640 	b.eq	fd800000a440 <mem_init+0x140>  // b.none
        }
    }

    /* Wait for master core to initialize memory management */
    cpu_sync_and_clear_msgs(&cpu_glb_sync);
}
    fd800000a37c:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd800000a380:	f94013f5 	ldr	x21, [sp, #32]
    fd800000a384:	a8c37bfd 	ldp	x29, x30, [sp], #48
    cpu_sync_and_clear_msgs(&cpu_glb_sync);
    fd800000a388:	17fffc4a 	b	fd80000094b0 <cpu_sync_and_clear_msgs.constprop.0>
        cache_enumerate();
    fd800000a38c:	94000051 	bl	fd800000a4d0 <cache_enumerate>
        if (!mem_setup_root_pool(load_addr, &root_mem_region)) {
    fd800000a390:	90000001 	adrp	x1, fd800000a000 <mem_alloc_ppages+0x70>
    fd800000a394:	f9425034 	ldr	x20, [x1, #1184]
    fd800000a398:	aa1303e0 	mov	x0, x19
    fd800000a39c:	91006281 	add	x1, x20, #0x18
    fd800000a3a0:	97fffec0 	bl	fd8000009ea0 <mem_setup_root_pool>
    fd800000a3a4:	360006c0 	tbz	w0, #0, fd800000a47c <mem_init+0x17c>
        list_push(&page_pool_list, &(root_mem_region->page_pool.node));
    fd800000a3a8:	f9400e80 	ldr	x0, [x20, #24]
        list->lock = SPINLOCK_INITVAL;
    fd800000a3ac:	f9000a9f 	str	xzr, [x20, #16]
    __asm__ volatile(
    fd800000a3b0:	91004284 	add	x4, x20, #0x10
    fd800000a3b4:	91005285 	add	x5, x20, #0x14
    fd800000a3b8:	91004001 	add	x1, x0, #0x10
        list->tail = NULL;
    fd800000a3bc:	a9007e9f 	stp	xzr, xzr, [x20]
        *node = NULL;
    fd800000a3c0:	f900081f 	str	xzr, [x0, #16]
    fd800000a3c4:	885ffc80 	ldaxr	w0, [x4]
    fd800000a3c8:	11000402 	add	w2, w0, #0x1
    fd800000a3cc:	88037c82 	stxr	w3, w2, [x4]
    fd800000a3d0:	35ffffa3 	cbnz	w3, fd800000a3c4 <mem_init+0xc4>
    fd800000a3d4:	88dffca2 	ldar	w2, [x5]
    fd800000a3d8:	6b02001f 	cmp	w0, w2
    fd800000a3dc:	54000060 	b.eq	fd800000a3e8 <mem_init+0xe8>  // b.none
    fd800000a3e0:	d503205f 	wfe
    fd800000a3e4:	17fffffc 	b	fd800000a3d4 <mem_init+0xd4>
        if (list->tail != NULL) {
    fd800000a3e8:	f9400680 	ldr	x0, [x20, #8]
    fd800000a3ec:	b4000040 	cbz	x0, fd800000a3f4 <mem_init+0xf4>
            *list->tail = node;
    fd800000a3f0:	f9000001 	str	x1, [x0]
        if (list->head == NULL) {
    fd800000a3f4:	f9400280 	ldr	x0, [x20]
        list->tail = node;
    fd800000a3f8:	f9000681 	str	x1, [x20, #8]
        if (list->head == NULL) {
    fd800000a3fc:	b4000480 	cbz	x0, fd800000a48c <mem_init+0x18c>
    __asm__ volatile(
    fd800000a400:	91005281 	add	x1, x20, #0x14
    fd800000a404:	b9400020 	ldr	w0, [x1]
    fd800000a408:	11000400 	add	w0, w0, #0x1
    fd800000a40c:	889ffc20 	stlr	w0, [x1]
    fd800000a410:	d5033b9f 	dsb	ish
    fd800000a414:	d503209f 	sev
        config_init(load_addr);
    fd800000a418:	aa1303e0 	mov	x0, x19
    fd800000a41c:	940006c9 	bl	fd800000bf40 <config_init>
        if (!mem_reserve_physical_memory(&root_mem_region->page_pool)) {
    fd800000a420:	f9400e80 	ldr	x0, [x20, #24]
    fd800000a424:	91004000 	add	x0, x0, #0x10
    fd800000a428:	97fffe0a 	bl	fd8000009c50 <mem_reserve_physical_memory>
    fd800000a42c:	3707f840 	tbnz	w0, #0, fd800000a334 <mem_init+0x34>
            ERROR("failed reserving memory in root pool");
    fd800000a430:	90000000 	adrp	x0, fd800000a000 <mem_alloc_ppages+0x70>
    fd800000a434:	f9425800 	ldr	x0, [x0, #1200]
    fd800000a438:	940006fa 	bl	fd800000c020 <console_printk>
    fd800000a43c:	14000000 	b	fd800000a43c <mem_init+0x13c>
        if (!mem_create_ppools(root_mem_region)) {
    fd800000a440:	90000000 	adrp	x0, fd800000a000 <mem_alloc_ppages+0x70>
    fd800000a444:	f9425000 	ldr	x0, [x0, #1184]
    fd800000a448:	f9400c00 	ldr	x0, [x0, #24]
    fd800000a44c:	97ffff2d 	bl	fd800000a100 <mem_create_ppools>
    fd800000a450:	3707f960 	tbnz	w0, #0, fd800000a37c <mem_init+0x7c>
            ERROR("couldn't create additional page pools");
    fd800000a454:	90000000 	adrp	x0, fd800000a000 <mem_alloc_ppages+0x70>
    fd800000a458:	f9426400 	ldr	x0, [x0, #1224]
    fd800000a45c:	940006f1 	bl	fd800000c020 <console_printk>
    fd800000a460:	14000000 	b	fd800000a460 <mem_init+0x160>
        mem_color_hypervisor(load_addr, root_mem_region);
    fd800000a464:	90000000 	adrp	x0, fd800000a000 <mem_alloc_ppages+0x70>
    fd800000a468:	f9425001 	ldr	x1, [x0, #1184]
    fd800000a46c:	aa1303e0 	mov	x0, x19
    fd800000a470:	f9400c21 	ldr	x1, [x1, #24]
    fd800000a474:	9400108f 	bl	fd800000e6b0 <mem_color_hypervisor>
    fd800000a478:	17ffffbc 	b	fd800000a368 <mem_init+0x68>
            ERROR("couldn't not initialize root pool");
    fd800000a47c:	90000000 	adrp	x0, fd800000a000 <mem_alloc_ppages+0x70>
    fd800000a480:	f9425400 	ldr	x0, [x0, #1192]
    fd800000a484:	940006e7 	bl	fd800000c020 <console_printk>
    fd800000a488:	14000000 	b	fd800000a488 <mem_init+0x188>
            list->head = node;
    fd800000a48c:	f9000281 	str	x1, [x20]
    fd800000a490:	17ffffdc 	b	fd800000a400 <mem_init+0x100>
    fd800000a494:	d503201f 	nop
    fd800000a498:	00012348 	.word	0x00012348
    fd800000a49c:	0000fd80 	.word	0x0000fd80
    fd800000a4a0:	000130a0 	.word	0x000130a0
    fd800000a4a4:	0000fd80 	.word	0x0000fd80
    fd800000a4a8:	00010b80 	.word	0x00010b80
    fd800000a4ac:	0000fd80 	.word	0x0000fd80
    fd800000a4b0:	00010bb0 	.word	0x00010bb0
    fd800000a4b4:	0000fd80 	.word	0x0000fd80
    fd800000a4b8:	00012828 	.word	0x00012828
    fd800000a4bc:	0000fd80 	.word	0x0000fd80
    fd800000a4c0:	00012bf0 	.word	0x00012bf0
    fd800000a4c4:	0000fd80 	.word	0x0000fd80
    fd800000a4c8:	00010be8 	.word	0x00010be8
    fd800000a4cc:	0000fd80 	.word	0x0000fd80

0000fd800000a4d0 <cache_enumerate>:
    COLOR_SIZE = flc_num_colors;
    COLOR_NUM = llc_num_colors / COLOR_SIZE;
}

void cache_enumerate()
{
    fd800000a4d0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    fd800000a4d4:	910003fd 	mov	x29, sp
    fd800000a4d8:	f9000bf3 	str	x19, [sp, #16]
    cache_arch_enumerate(&cache_dscr);
    fd800000a4dc:	90000000 	adrp	x0, fd800000a000 <mem_alloc_ppages+0x70>
    fd800000a4e0:	f942c013 	ldr	x19, [x0, #1408]
    fd800000a4e4:	aa1303e0 	mov	x0, x19
    fd800000a4e8:	97ffe2ba 	bl	fd8000002fd0 <cache_arch_enumerate>
    if (dscrp->lvls == 0) {
    fd800000a4ec:	f9400260 	ldr	x0, [x19]
    fd800000a4f0:	b40003e0 	cbz	x0, fd800000a56c <cache_enumerate+0x9c>
    size_t llc = dscrp->min_shared_lvl;
    fd800000a4f4:	f9400660 	ldr	x0, [x19, #8]
    if ((dscrp->type[llc] != UNIFIED) || (dscrp->indexed[llc][0] != PIPT)) {
    fd800000a4f8:	91001001 	add	x1, x0, #0x4
    fd800000a4fc:	b8617a61 	ldr	w1, [x19, x1, lsl #2]
    fd800000a500:	35000361 	cbnz	w1, fd800000a56c <cache_enumerate+0x9c>
    fd800000a504:	8b000e61 	add	x1, x19, x0, lsl #3
    fd800000a508:	b9403021 	ldr	w1, [x1, #48]
    fd800000a50c:	35000301 	cbnz	w1, fd800000a56c <cache_enumerate+0x9c>
    size_t llc_way_size = dscrp->numset[llc][UNIFIED] * dscrp->line_size[llc][UNIFIED];
    fd800000a510:	8b001264 	add	x4, x19, x0, lsl #4
    if (dscrp->type[0] != UNIFIED) {
    fd800000a514:	b9401262 	ldr	w2, [x19, #16]
    fd800000a518:	d2800001 	mov	x1, #0x0                   	// #0
    size_t llc_way_size = dscrp->numset[llc][UNIFIED] * dscrp->line_size[llc][UNIFIED];
    fd800000a51c:	f9403883 	ldr	x3, [x4, #112]
    fd800000a520:	f940b880 	ldr	x0, [x4, #368]
    fd800000a524:	9b037c00 	mul	x0, x0, x3
    if (dscrp->type[0] != UNIFIED) {
    fd800000a528:	34000182 	cbz	w2, fd800000a558 <cache_enumerate+0x88>
        size_t flc_i_way_size = dscrp->numset[0][1] * dscrp->line_size[0][1];
    fd800000a52c:	a9471265 	ldp	x5, x4, [x19, #112]
    fd800000a530:	a9570a61 	ldp	x1, x2, [x19, #368]
        if (((dscrp->indexed[0][0] == PIPT) || (flc_i_way_size < flc_way_size)) &&
    fd800000a534:	b9403263 	ldr	w3, [x19, #48]
    fd800000a538:	7100007f 	cmp	w3, #0x0
        flc_way_size = dscrp->numset[0][0] * dscrp->line_size[0][0];
    fd800000a53c:	9b057c21 	mul	x1, x1, x5
        size_t flc_i_way_size = dscrp->numset[0][1] * dscrp->line_size[0][1];
    fd800000a540:	9b047c42 	mul	x2, x2, x4
        if (((dscrp->indexed[0][0] == PIPT) || (flc_i_way_size < flc_way_size)) &&
    fd800000a544:	fa421022 	ccmp	x1, x2, #0x2, ne	// ne = any
    fd800000a548:	54000189 	b.ls	fd800000a578 <cache_enumerate+0xa8>  // b.plast
    fd800000a54c:	b9403663 	ldr	w3, [x19, #52]
    fd800000a550:	35000143 	cbnz	w3, fd800000a578 <cache_enumerate+0xa8>
    size_t flc_num_colors = flc_way_size / page_size;
    fd800000a554:	d34cfc41 	lsr	x1, x2, #12
    size_t llc_num_colors = llc_way_size / page_size;
    fd800000a558:	d34cfc00 	lsr	x0, x0, #12
    COLOR_SIZE = flc_num_colors;
    fd800000a55c:	90000002 	adrp	x2, fd800000a000 <mem_alloc_ppages+0x70>
    fd800000a560:	f942c442 	ldr	x2, [x2, #1416]
    COLOR_NUM = llc_num_colors / COLOR_SIZE;
    fd800000a564:	9ac10800 	udiv	x0, x0, x1
    fd800000a568:	a9000041 	stp	x1, x0, [x2]
    cache_calc_colors(&cache_dscr, PAGE_SIZE);
}
    fd800000a56c:	f9400bf3 	ldr	x19, [sp, #16]
    fd800000a570:	a8c27bfd 	ldp	x29, x30, [sp], #32
    fd800000a574:	d65f03c0 	ret
    size_t flc_num_colors = flc_way_size / page_size;
    fd800000a578:	d34cfc21 	lsr	x1, x1, #12
    fd800000a57c:	17fffff7 	b	fd800000a558 <cache_enumerate+0x88>
    fd800000a580:	000130c0 	.word	0x000130c0
    fd800000a584:	0000fd80 	.word	0x0000fd80
    fd800000a588:	00012820 	.word	0x00012820
    fd800000a58c:	0000fd80 	.word	0x0000fd80

0000fd800000a590 <interrupts_cpu_sendipi>:

irq_handler_t interrupt_handlers[MAX_INTERRUPTS];

inline void interrupts_cpu_sendipi(cpuid_t target_cpu, irqid_t ipi_id)
{
    interrupts_arch_ipi_send(target_cpu, ipi_id);
    fd800000a590:	17ffe318 	b	fd80000031f0 <interrupts_arch_ipi_send>
    fd800000a594:	d503201f 	nop
    fd800000a598:	d503201f 	nop
    fd800000a59c:	d503201f 	nop

0000fd800000a5a0 <interrupts_cpu_enable>:
}

inline void interrupts_cpu_enable(irqid_t int_id, bool en)
{
    interrupts_arch_enable(int_id, en);
    fd800000a5a0:	17ffe318 	b	fd8000003200 <interrupts_arch_enable>
    fd800000a5a4:	d503201f 	nop
    fd800000a5a8:	d503201f 	nop
    fd800000a5ac:	d503201f 	nop

0000fd800000a5b0 <interrupts_check>:
}

inline bool interrupts_check(irqid_t int_id)
{
    return interrupts_arch_check(int_id);
    fd800000a5b0:	17ffe324 	b	fd8000003240 <interrupts_arch_check>
    fd800000a5b4:	d503201f 	nop
    fd800000a5b8:	d503201f 	nop
    fd800000a5bc:	d503201f 	nop

0000fd800000a5c0 <interrupts_clear>:
}

inline void interrupts_clear(irqid_t int_id)
{
    interrupts_arch_clear(int_id);
    fd800000a5c0:	17ffe330 	b	fd8000003280 <interrupts_arch_clear>
    fd800000a5c4:	d503201f 	nop
    fd800000a5c8:	d503201f 	nop
    fd800000a5cc:	d503201f 	nop

0000fd800000a5d0 <interrupts_handle>:
{
    return bitmap_get(global_interrupt_bitmap, int_id);
}

enum irq_res interrupts_handle(irqid_t int_id)
{
    fd800000a5d0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    if (vm_has_interrupt(cpu()->vcpu->vm, int_id)) {
    fd800000a5d4:	d2dfc002 	mov	x2, #0xfe0000000000        	// #279275953455104
{
    fd800000a5d8:	2a0003e6 	mov	w6, w0
    fd800000a5dc:	910003fd 	mov	x29, sp
    if (vm_has_interrupt(cpu()->vcpu->vm, int_id)) {
    fd800000a5e0:	f9402845 	ldr	x5, [x2, #80]
    fd800000a5e4:	53057cc4 	lsr	w4, w6, #5
{
    fd800000a5e8:	a90153f3 	stp	x19, x20, [sp, #16]
    fd800000a5ec:	52800034 	mov	w20, #0x1                   	// #1
    fd800000a5f0:	1ac62283 	lsl	w3, w20, w6
    fd800000a5f4:	f944c8a2 	ldr	x2, [x5, #2448]
    fd800000a5f8:	aa0603e1 	mov	x1, x6
    fd800000a5fc:	8b040842 	add	x2, x2, x4, lsl #2
    fd800000a600:	b9419842 	ldr	w2, [x2, #408]
    fd800000a604:	6a020073 	ands	w19, w3, w2
    fd800000a608:	54000100 	b.eq	fd800000a628 <interrupts_handle+0x58>  // b.none
void vcpu_arch_profile_init(struct vcpu* vcpu, struct vm* vm);
void vcpu_subarch_reset(struct vcpu* vcpu);

static inline void vcpu_arch_inject_hw_irq(struct vcpu* vcpu, irqid_t id)
{
    vgic_inject_hw(vcpu, id);
    fd800000a60c:	aa0503e0 	mov	x0, x5
        vcpu_inject_hw_irq(cpu()->vcpu, int_id);

        return FORWARD_TO_VM;
    fd800000a610:	2a1403f3 	mov	w19, w20
    fd800000a614:	97ffed9b 	bl	fd8000005c80 <vgic_inject_hw>
        return HANDLED_BY_HYP;

    } else {
        ERROR("received unknown interrupt id = %d", int_id);
    }
}
    fd800000a618:	2a1303e0 	mov	w0, w19
    fd800000a61c:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd800000a620:	a8c27bfd 	ldp	x29, x30, [sp], #32
    fd800000a624:	d65f03c0 	ret
    fd800000a628:	90000002 	adrp	x2, fd800000a000 <mem_alloc_ppages+0x70>
    fd800000a62c:	f9433842 	ldr	x2, [x2, #1648]
    fd800000a630:	b8647842 	ldr	w2, [x2, x4, lsl #2]
    fd800000a634:	6a02007f 	tst	w3, w2
    fd800000a638:	54000120 	b.eq	fd800000a65c <interrupts_handle+0x8c>  // b.none
        interrupt_handlers[int_id](int_id);
    fd800000a63c:	90000001 	adrp	x1, fd800000a000 <mem_alloc_ppages+0x70>
    fd800000a640:	f9434021 	ldr	x1, [x1, #1664]
    fd800000a644:	f8667821 	ldr	x1, [x1, x6, lsl #3]
    fd800000a648:	d63f0020 	blr	x1
}
    fd800000a64c:	2a1303e0 	mov	w0, w19
    fd800000a650:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd800000a654:	a8c27bfd 	ldp	x29, x30, [sp], #32
    fd800000a658:	d65f03c0 	ret
        ERROR("received unknown interrupt id = %d", int_id);
    fd800000a65c:	90000000 	adrp	x0, fd800000a000 <mem_alloc_ppages+0x70>
    fd800000a660:	f9433c00 	ldr	x0, [x0, #1656]
    fd800000a664:	9400066f 	bl	fd800000c020 <console_printk>
    fd800000a668:	14000000 	b	fd800000a668 <interrupts_handle+0x98>
    fd800000a66c:	d503201f 	nop
    fd800000a670:	000132b0 	.word	0x000132b0
    fd800000a674:	0000fd80 	.word	0x0000fd80
    fd800000a678:	00010c20 	.word	0x00010c20
    fd800000a67c:	0000fd80 	.word	0x0000fd80
    fd800000a680:	000133b8 	.word	0x000133b8
    fd800000a684:	0000fd80 	.word	0x0000fd80
    fd800000a688:	d503201f 	nop
    fd800000a68c:	d503201f 	nop

0000fd800000a690 <interrupts_vm_assign>:

bool interrupts_vm_assign(struct vm* vm, irqid_t id)
{
    fd800000a690:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    fd800000a694:	910003fd 	mov	x29, sp
    fd800000a698:	a90153f3 	stp	x19, x20, [sp, #16]
    fd800000a69c:	aa0003f4 	mov	x20, x0
    __asm__ volatile(
    fd800000a6a0:	90000000 	adrp	x0, fd800000a000 <mem_alloc_ppages+0x70>
    fd800000a6a4:	f943a813 	ldr	x19, [x0, #1872]
    fd800000a6a8:	a9025bf5 	stp	x21, x22, [sp, #32]
    fd800000a6ac:	2a0103f6 	mov	w22, w1
    fd800000a6b0:	91020264 	add	x4, x19, #0x80
    fd800000a6b4:	91021265 	add	x5, x19, #0x84
    fd800000a6b8:	885ffc80 	ldaxr	w0, [x4]
    fd800000a6bc:	11000402 	add	w2, w0, #0x1
    fd800000a6c0:	88037c82 	stxr	w3, w2, [x4]
    fd800000a6c4:	35ffffa3 	cbnz	w3, fd800000a6b8 <interrupts_vm_assign+0x28>
    fd800000a6c8:	88dffca2 	ldar	w2, [x5]
    fd800000a6cc:	6b02001f 	cmp	w0, w2
    fd800000a6d0:	54000060 	b.eq	fd800000a6dc <interrupts_vm_assign+0x4c>  // b.none
    fd800000a6d4:	d503205f 	wfe
    fd800000a6d8:	17fffffc 	b	fd800000a6c8 <interrupts_vm_assign+0x38>
    bool ret = false;

    spin_lock(&irq_reserve_lock);
    if (!interrupts_arch_conflict(global_interrupt_bitmap, id)) {
    fd800000a6dc:	91022275 	add	x21, x19, #0x88
    fd800000a6e0:	aa1503e0 	mov	x0, x21
    fd800000a6e4:	97ffe2db 	bl	fd8000003250 <interrupts_arch_conflict>
    fd800000a6e8:	36000180 	tbz	w0, #0, fd800000a718 <interrupts_vm_assign+0x88>
    bool ret = false;
    fd800000a6ec:	52800000 	mov	w0, #0x0                   	// #0
    __asm__ volatile(
    fd800000a6f0:	91021262 	add	x2, x19, #0x84
    fd800000a6f4:	b9400041 	ldr	w1, [x2]
    fd800000a6f8:	11000421 	add	w1, w1, #0x1
    fd800000a6fc:	889ffc41 	stlr	w1, [x2]
    fd800000a700:	d5033b9f 	dsb	ish
    fd800000a704:	d503209f 	sev
        bitmap_set(global_interrupt_bitmap, id);
    }
    spin_unlock(&irq_reserve_lock);

    return ret;
}
    fd800000a708:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd800000a70c:	a9425bf5 	ldp	x21, x22, [sp, #32]
    fd800000a710:	a8c37bfd 	ldp	x29, x30, [sp], #48
    fd800000a714:	d65f03c0 	ret
        interrupts_arch_vm_assign(vm, id);
    fd800000a718:	aa1403e0 	mov	x0, x20
    fd800000a71c:	2a1603e1 	mov	w1, w22
    fd800000a720:	97ffe2e4 	bl	fd80000032b0 <interrupts_arch_vm_assign>
        bitmap_set(vm->interrupt_bitmap, id);
    fd800000a724:	91066294 	add	x20, x20, #0x198
    map[bit / BITMAP_GRANULE_LEN] |= ONE << (bit % BITMAP_GRANULE_LEN);
    fd800000a728:	53057ec2 	lsr	w2, w22, #5
    fd800000a72c:	52800020 	mov	w0, #0x1                   	// #1
    fd800000a730:	1ad62001 	lsl	w1, w0, w22
    fd800000a734:	b8627a83 	ldr	w3, [x20, x2, lsl #2]
    fd800000a738:	2a010063 	orr	w3, w3, w1
    fd800000a73c:	b8227a83 	str	w3, [x20, x2, lsl #2]
    fd800000a740:	b8627aa3 	ldr	w3, [x21, x2, lsl #2]
    fd800000a744:	2a010061 	orr	w1, w3, w1
    fd800000a748:	b8227aa1 	str	w1, [x21, x2, lsl #2]
}
    fd800000a74c:	17ffffe9 	b	fd800000a6f0 <interrupts_vm_assign+0x60>
    fd800000a750:	000132b0 	.word	0x000132b0
    fd800000a754:	0000fd80 	.word	0x0000fd80
    fd800000a758:	d503201f 	nop
    fd800000a75c:	d503201f 	nop

0000fd800000a760 <interrupts_reserve>:
    __asm__ volatile(
    fd800000a760:	90000002 	adrp	x2, fd800000a000 <mem_alloc_ppages+0x70>
    fd800000a764:	f9442042 	ldr	x2, [x2, #2112]
    fd800000a768:	91020046 	add	x6, x2, #0x80
    fd800000a76c:	91021047 	add	x7, x2, #0x84
    fd800000a770:	885ffcc3 	ldaxr	w3, [x6]
    fd800000a774:	11000464 	add	w4, w3, #0x1
    fd800000a778:	88057cc4 	stxr	w5, w4, [x6]
    fd800000a77c:	35ffffa5 	cbnz	w5, fd800000a770 <interrupts_reserve+0x10>
    fd800000a780:	88dffce4 	ldar	w4, [x7]
    fd800000a784:	6b04007f 	cmp	w3, w4
    fd800000a788:	54000060 	b.eq	fd800000a794 <interrupts_reserve+0x34>  // b.none
    fd800000a78c:	d503205f 	wfe
    fd800000a790:	17fffffc 	b	fd800000a780 <interrupts_reserve+0x20>
bool interrupts_reserve(irqid_t int_id, irq_handler_t handler)
{
    bool ret = false;

    spin_lock(&irq_reserve_lock);
    if ((int_id < MAX_INTERRUPTS) && !interrupt_assigned(int_id)) {
    fd800000a794:	710ffc1f 	cmp	w0, #0x3ff
    fd800000a798:	54000228 	b.hi	fd800000a7dc <interrupts_reserve+0x7c>  // b.pmore
    return (map[bit / BITMAP_GRANULE_LEN] & (ONE << (bit % BITMAP_GRANULE_LEN))) ? 1U : 0U;
    fd800000a79c:	53057c04 	lsr	w4, w0, #5
    fd800000a7a0:	91022046 	add	x6, x2, #0x88
    fd800000a7a4:	52800027 	mov	w7, #0x1                   	// #1
    return bitmap_get(global_interrupt_bitmap, int_id);
    fd800000a7a8:	2a0003e9 	mov	w9, w0
    fd800000a7ac:	1ac020e3 	lsl	w3, w7, w0
    bool ret = false;
    fd800000a7b0:	52800000 	mov	w0, #0x0                   	// #0
    fd800000a7b4:	b86478c5 	ldr	w5, [x6, x4, lsl #2]
    fd800000a7b8:	6a0300bf 	tst	w5, w3
    fd800000a7bc:	54000200 	b.eq	fd800000a7fc <interrupts_reserve+0x9c>  // b.none
    __asm__ volatile(
    fd800000a7c0:	91021042 	add	x2, x2, #0x84
    fd800000a7c4:	b9400041 	ldr	w1, [x2]
    fd800000a7c8:	11000421 	add	w1, w1, #0x1
    fd800000a7cc:	889ffc41 	stlr	w1, [x2]
    fd800000a7d0:	d5033b9f 	dsb	ish
    fd800000a7d4:	d503209f 	sev
        bitmap_set(global_interrupt_bitmap, int_id);
    }
    spin_unlock(&irq_reserve_lock);

    return ret;
}
    fd800000a7d8:	d65f03c0 	ret
    bool ret = false;
    fd800000a7dc:	52800000 	mov	w0, #0x0                   	// #0
    fd800000a7e0:	91021042 	add	x2, x2, #0x84
    fd800000a7e4:	b9400041 	ldr	w1, [x2]
    fd800000a7e8:	11000421 	add	w1, w1, #0x1
    fd800000a7ec:	889ffc41 	stlr	w1, [x2]
    fd800000a7f0:	d5033b9f 	dsb	ish
    fd800000a7f4:	d503209f 	sev
}
    fd800000a7f8:	d65f03c0 	ret
        interrupt_handlers[int_id] = handler;
    fd800000a7fc:	90000000 	adrp	x0, fd800000a000 <mem_alloc_ppages+0x70>
    fd800000a800:	f944240a 	ldr	x10, [x0, #2120]
    map[bit / BITMAP_GRANULE_LEN] |= ONE << (bit % BITMAP_GRANULE_LEN);
    fd800000a804:	2a0300a5 	orr	w5, w5, w3
    fd800000a808:	b8647848 	ldr	w8, [x2, x4, lsl #2]
        ret = true;
    fd800000a80c:	2a0703e0 	mov	w0, w7
    fd800000a810:	b82478c5 	str	w5, [x6, x4, lsl #2]
    fd800000a814:	2a030103 	orr	w3, w8, w3
        interrupt_handlers[int_id] = handler;
    fd800000a818:	f8297941 	str	x1, [x10, x9, lsl #3]
    fd800000a81c:	b8247843 	str	w3, [x2, x4, lsl #2]
    fd800000a820:	91021042 	add	x2, x2, #0x84
    fd800000a824:	b9400041 	ldr	w1, [x2]
    fd800000a828:	11000421 	add	w1, w1, #0x1
    fd800000a82c:	889ffc41 	stlr	w1, [x2]
    fd800000a830:	d5033b9f 	dsb	ish
    fd800000a834:	d503209f 	sev
}
    fd800000a838:	d65f03c0 	ret
    fd800000a83c:	d503201f 	nop
    fd800000a840:	000132b0 	.word	0x000132b0
    fd800000a844:	0000fd80 	.word	0x0000fd80
    fd800000a848:	000133b8 	.word	0x000133b8
    fd800000a84c:	0000fd80 	.word	0x0000fd80

0000fd800000a850 <interrupts_init>:
{
    fd800000a850:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    fd800000a854:	910003fd 	mov	x29, sp
    interrupts_arch_init();
    fd800000a858:	97ffe25a 	bl	fd80000031c0 <interrupts_arch_init>
    if (cpu()->id == CPU_MASTER) {
    fd800000a85c:	90000000 	adrp	x0, fd800000a000 <mem_alloc_ppages+0x70>
    fd800000a860:	f9445800 	ldr	x0, [x0, #2224]
    fd800000a864:	d2dfc001 	mov	x1, #0xfe0000000000        	// #279275953455104
    fd800000a868:	f9400021 	ldr	x1, [x1]
    fd800000a86c:	f9400000 	ldr	x0, [x0]
    fd800000a870:	eb00003f 	cmp	x1, x0
    fd800000a874:	540000a0 	b.eq	fd800000a888 <interrupts_init+0x38>  // b.none
}
    fd800000a878:	a8c17bfd 	ldp	x29, x30, [sp], #16
    interrupts_arch_enable(int_id, en);
    fd800000a87c:	52800021 	mov	w1, #0x1                   	// #1
    fd800000a880:	52800020 	mov	w0, #0x1                   	// #1
    fd800000a884:	17ffe25f 	b	fd8000003200 <interrupts_arch_enable>
        if (!interrupts_reserve(IPI_CPU_MSG, cpu_msg_handler)) {
    fd800000a888:	90000000 	adrp	x0, fd800000a000 <mem_alloc_ppages+0x70>
    fd800000a88c:	f9445c01 	ldr	x1, [x0, #2232]
    fd800000a890:	52800020 	mov	w0, #0x1                   	// #1
    fd800000a894:	97ffffb3 	bl	fd800000a760 <interrupts_reserve>
    fd800000a898:	3707ff00 	tbnz	w0, #0, fd800000a878 <interrupts_init+0x28>
            ERROR("Failed to reserve IPI_CPU_MSG interrupt");
    fd800000a89c:	90000000 	adrp	x0, fd800000a000 <mem_alloc_ppages+0x70>
    fd800000a8a0:	f9446000 	ldr	x0, [x0, #2240]
    fd800000a8a4:	940005df 	bl	fd800000c020 <console_printk>
    fd800000a8a8:	14000000 	b	fd800000a8a8 <interrupts_init+0x58>
    fd800000a8ac:	d503201f 	nop
    fd800000a8b0:	00012348 	.word	0x00012348
    fd800000a8b4:	0000fd80 	.word	0x0000fd80
    fd800000a8b8:	0000ac20 	.word	0x0000ac20
    fd800000a8bc:	0000fd80 	.word	0x0000fd80
    fd800000a8c0:	00010c50 	.word	0x00010c50
    fd800000a8c4:	0000fd80 	.word	0x0000fd80
	...

0000fd800000a8d0 <cpu_init>:
size_t ipi_cpumsg_handler_num;

struct cpuif cpu_interfaces[PLAT_CPU_NUM];

void cpu_init(cpuid_t cpu_id, paddr_t load_addr)
{
    fd800000a8d0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    fd800000a8d4:	910003fd 	mov	x29, sp
    return &cpu_interfaces[cpu_id];
    fd800000a8d8:	90000002 	adrp	x2, fd800000a000 <mem_alloc_ppages+0x70>
    fd800000a8dc:	f9450c43 	ldr	x3, [x2, #2584]
    fd800000a8e0:	f9000bf3 	str	x19, [sp, #16]
    cpu()->id = cpu_id;
    fd800000a8e4:	d2dfc013 	mov	x19, #0xfe0000000000        	// #279275953455104
    fd800000a8e8:	8b003063 	add	x3, x3, x0, lsl #12
    fd800000a8ec:	f9000260 	str	x0, [x19]
    cpu()->handling_msgs = false;
    fd800000a8f0:	3900227f 	strb	wzr, [x19, #8]
    cpu()->interface = cpu_if(cpu()->id);
    fd800000a8f4:	f9017e63 	str	x3, [x19, #760]

    cpu_arch_init(cpu_id, load_addr);
    fd800000a8f8:	97ffe472 	bl	fd8000003ac0 <cpu_arch_init>

    list_init(&cpu()->interface->event_list);
    fd800000a8fc:	f9417e60 	ldr	x0, [x19, #760]
    if (list != NULL) {
    fd800000a900:	b4000060 	cbz	x0, fd800000a90c <cpu_init+0x3c>
        list->tail = NULL;
    fd800000a904:	a9007c1f 	stp	xzr, xzr, [x0]
        list->lock = SPINLOCK_INITVAL;
    fd800000a908:	f900081f 	str	xzr, [x0, #16]

    if (cpu()->id == CPU_MASTER) {
    fd800000a90c:	90000000 	adrp	x0, fd800000a000 <mem_alloc_ppages+0x70>
    fd800000a910:	f9451000 	ldr	x0, [x0, #2592]
    fd800000a914:	d2dfc001 	mov	x1, #0xfe0000000000        	// #279275953455104
    fd800000a918:	f9400021 	ldr	x1, [x1]
    fd800000a91c:	f9400000 	ldr	x0, [x0]
    fd800000a920:	eb00003f 	cmp	x1, x0
    fd800000a924:	540004a0 	b.eq	fd800000a9b8 <cpu_init+0xe8>  // b.none
    fd800000a928:	90000000 	adrp	x0, fd800000a000 <mem_alloc_ppages+0x70>
    fd800000a92c:	f9451800 	ldr	x0, [x0, #2608]
    while (!token->ready) { }
    fd800000a930:	39404001 	ldrb	w1, [x0, #16]
    fd800000a934:	3607ffe1 	tbz	w1, #0, fd800000a930 <cpu_init+0x60>
    __asm__ volatile(
    fd800000a938:	91001004 	add	x4, x0, #0x4
    fd800000a93c:	885ffc01 	ldaxr	w1, [x0]
    fd800000a940:	11000422 	add	w2, w1, #0x1
    fd800000a944:	88037c02 	stxr	w3, w2, [x0]
    fd800000a948:	35ffffa3 	cbnz	w3, fd800000a93c <cpu_init+0x6c>
    fd800000a94c:	88dffc82 	ldar	w2, [x4]
    fd800000a950:	6b02003f 	cmp	w1, w2
    fd800000a954:	54000060 	b.eq	fd800000a960 <cpu_init+0x90>  // b.none
    fd800000a958:	d503205f 	wfe
    fd800000a95c:	17fffffc 	b	fd800000a94c <cpu_init+0x7c>
    token->count++;
    fd800000a960:	f9400c01 	ldr	x1, [x0, #24]
    fd800000a964:	91000421 	add	x1, x1, #0x1
    fd800000a968:	f9000c01 	str	x1, [x0, #24]
    next_count = ALIGN(token->count, token->n);
    fd800000a96c:	f9400c02 	ldr	x2, [x0, #24]
    fd800000a970:	f9400401 	ldr	x1, [x0, #8]
    fd800000a974:	f9400403 	ldr	x3, [x0, #8]
    fd800000a978:	8b010042 	add	x2, x2, x1
    fd800000a97c:	d1000442 	sub	x2, x2, #0x1
    fd800000a980:	f9400401 	ldr	x1, [x0, #8]
    fd800000a984:	9ac30842 	udiv	x2, x2, x3
    fd800000a988:	9b017c42 	mul	x2, x2, x1
    __asm__ volatile(
    fd800000a98c:	b9400081 	ldr	w1, [x4]
    fd800000a990:	11000421 	add	w1, w1, #0x1
    fd800000a994:	889ffc81 	stlr	w1, [x4]
    fd800000a998:	d5033b9f 	dsb	ish
    fd800000a99c:	d503209f 	sev
    while (token->count < next_count) { }
    fd800000a9a0:	f9400c01 	ldr	x1, [x0, #24]
    fd800000a9a4:	eb01005f 	cmp	x2, x1
    fd800000a9a8:	54ffffc8 	b.hi	fd800000a9a0 <cpu_init+0xd0>  // b.pmore
            ((size_t*)_ipi_cpumsg_handlers_id_start)[i] = i;
        }
    }

    cpu_sync_barrier(&cpu_glb_sync);
}
    fd800000a9ac:	f9400bf3 	ldr	x19, [sp, #16]
    fd800000a9b0:	a8c27bfd 	ldp	x29, x30, [sp], #32
    fd800000a9b4:	d65f03c0 	ret
        cpu_sync_init(&cpu_glb_sync, platform.cpu_num);
    fd800000a9b8:	90000000 	adrp	x0, fd800000a000 <mem_alloc_ppages+0x70>
    fd800000a9bc:	f9451403 	ldr	x3, [x0, #2600]
    token->lock = SPINLOCK_INITVAL;
    fd800000a9c0:	90000000 	adrp	x0, fd800000a000 <mem_alloc_ppages+0x70>
    fd800000a9c4:	f9451800 	ldr	x0, [x0, #2608]
        ipi_cpumsg_handler_num = ((size_t)&_ipi_cpumsg_handlers_size) / sizeof(cpu_msg_handler_t);
    fd800000a9c8:	90000001 	adrp	x1, fd800000a000 <mem_alloc_ppages+0x70>
    fd800000a9cc:	f9451c22 	ldr	x2, [x1, #2616]
    token->ready = true;
    fd800000a9d0:	52800021 	mov	w1, #0x1                   	// #1
        cpu_sync_init(&cpu_glb_sync, platform.cpu_num);
    fd800000a9d4:	f9400063 	ldr	x3, [x3]
    token->n = n;
    fd800000a9d8:	f9000403 	str	x3, [x0, #8]
    token->count = 0;
    fd800000a9dc:	f9000c1f 	str	xzr, [x0, #24]
        ipi_cpumsg_handler_num = ((size_t)&_ipi_cpumsg_handlers_size) / sizeof(cpu_msg_handler_t);
    fd800000a9e0:	d343fc42 	lsr	x2, x2, #3
    token->lock = SPINLOCK_INITVAL;
    fd800000a9e4:	f900001f 	str	xzr, [x0]
    token->ready = true;
    fd800000a9e8:	39004001 	strb	w1, [x0, #16]
    fd800000a9ec:	f9001002 	str	x2, [x0, #32]
        for (size_t i = 0; i < ipi_cpumsg_handler_num; i++) {
    fd800000a9f0:	b4fffa02 	cbz	x2, fd800000a930 <cpu_init+0x60>
    fd800000a9f4:	90000001 	adrp	x1, fd800000a000 <mem_alloc_ppages+0x70>
    fd800000a9f8:	f9452023 	ldr	x3, [x1, #2624]
    fd800000a9fc:	d2800001 	mov	x1, #0x0                   	// #0
            ((size_t*)_ipi_cpumsg_handlers_id_start)[i] = i;
    fd800000aa00:	f8217861 	str	x1, [x3, x1, lsl #3]
        for (size_t i = 0; i < ipi_cpumsg_handler_num; i++) {
    fd800000aa04:	91000421 	add	x1, x1, #0x1
    fd800000aa08:	eb01005f 	cmp	x2, x1
    fd800000aa0c:	54ffffa1 	b.ne	fd800000aa00 <cpu_init+0x130>  // b.any
    fd800000aa10:	17ffffc8 	b	fd800000a930 <cpu_init+0x60>
    fd800000aa14:	d503201f 	nop
    fd800000aa18:	00017000 	.word	0x00017000
    fd800000aa1c:	0000fd80 	.word	0x0000fd80
    fd800000aa20:	00012348 	.word	0x00012348
    fd800000aa24:	0000fd80 	.word	0x0000fd80
    fd800000aa28:	00012930 	.word	0x00012930
    fd800000aa2c:	0000fd80 	.word	0x0000fd80
    fd800000aa30:	00016000 	.word	0x00016000
    fd800000aa34:	0000fd80 	.word	0x0000fd80
    fd800000aa38:	00000018 	.word	0x00000018
    fd800000aa3c:	00000000 	.word	0x00000000
    fd800000aa40:	00012e78 	.word	0x00012e78
    fd800000aa44:	0000fd80 	.word	0x0000fd80
    fd800000aa48:	d503201f 	nop
    fd800000aa4c:	d503201f 	nop

0000fd800000aa50 <cpu_send_msg>:

void cpu_send_msg(cpuid_t trgtcpu, struct cpu_msg* msg)
{
    fd800000aa50:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    fd800000aa54:	910003fd 	mov	x29, sp
    fd800000aa58:	a90153f3 	stp	x19, x20, [sp, #16]
    fd800000aa5c:	aa0003f3 	mov	x19, x0
    struct cpu_msg_node* node = objpool_alloc(&msg_pool);
    fd800000aa60:	90000000 	adrp	x0, fd800000a000 <mem_alloc_ppages+0x70>
    fd800000aa64:	f9459800 	ldr	x0, [x0, #2864]
{
    fd800000aa68:	aa0103f4 	mov	x20, x1
    struct cpu_msg_node* node = objpool_alloc(&msg_pool);
    fd800000aa6c:	94000701 	bl	fd800000c670 <objpool_alloc>
    if (node == NULL) {
    fd800000aa70:	b4000520 	cbz	x0, fd800000ab14 <cpu_send_msg+0xc4>
        ERROR("cant allocate msg node");
    }
    node->msg = *msg;
    fd800000aa74:	f9400281 	ldr	x1, [x20]
        spin_lock(&list->lock);
    fd800000aa78:	90000002 	adrp	x2, fd800000a000 <mem_alloc_ppages+0x70>
    fd800000aa7c:	f945a043 	ldr	x3, [x2, #2880]
    fd800000aa80:	d374ce62 	lsl	x2, x19, #12
    fd800000aa84:	f9000401 	str	x1, [x0, #8]
    fd800000aa88:	91004041 	add	x1, x2, #0x10
    fd800000aa8c:	8b010061 	add	x1, x3, x1
    fd800000aa90:	f9400684 	ldr	x4, [x20, #8]
    __asm__ volatile(
    fd800000aa94:	91001027 	add	x7, x1, #0x4
        *node = NULL;
    fd800000aa98:	f900001f 	str	xzr, [x0]
    fd800000aa9c:	f9000804 	str	x4, [x0, #16]
    fd800000aaa0:	885ffc24 	ldaxr	w4, [x1]
    fd800000aaa4:	11000485 	add	w5, w4, #0x1
    fd800000aaa8:	88067c25 	stxr	w6, w5, [x1]
    fd800000aaac:	35ffffa6 	cbnz	w6, fd800000aaa0 <cpu_send_msg+0x50>
    fd800000aab0:	88dffce5 	ldar	w5, [x7]
    fd800000aab4:	6b05009f 	cmp	w4, w5
    fd800000aab8:	54000060 	b.eq	fd800000aac4 <cpu_send_msg+0x74>  // b.none
    fd800000aabc:	d503205f 	wfe
    fd800000aac0:	17fffffc 	b	fd800000aab0 <cpu_send_msg+0x60>
        if (list->tail != NULL) {
    fd800000aac4:	8b020064 	add	x4, x3, x2
    fd800000aac8:	f9400484 	ldr	x4, [x4, #8]
    fd800000aacc:	b4000044 	cbz	x4, fd800000aad4 <cpu_send_msg+0x84>
            *list->tail = node;
    fd800000aad0:	f9000080 	str	x0, [x4]
        list->tail = node;
    fd800000aad4:	8b020064 	add	x4, x3, x2
        if (list->head == NULL) {
    fd800000aad8:	f8626865 	ldr	x5, [x3, x2]
        list->tail = node;
    fd800000aadc:	f9000480 	str	x0, [x4, #8]
        if (list->head == NULL) {
    fd800000aae0:	b4000225 	cbz	x5, fd800000ab24 <cpu_send_msg+0xd4>
    __asm__ volatile(
    fd800000aae4:	91001021 	add	x1, x1, #0x4
    fd800000aae8:	b9400020 	ldr	w0, [x1]
    fd800000aaec:	11000400 	add	w0, w0, #0x1
    fd800000aaf0:	889ffc20 	stlr	w0, [x1]
    fd800000aaf4:	d5033b9f 	dsb	ish
    fd800000aaf8:	d503209f 	sev
    fd800000aafc:	d5033a9f 	dsb	ishst
    list_push(&cpu_if(trgtcpu)->event_list, (node_t*)node);
    fence_sync_write();
    interrupts_cpu_sendipi(trgtcpu, IPI_CPU_MSG);
    fd800000ab00:	aa1303e0 	mov	x0, x19
    fd800000ab04:	52800021 	mov	w1, #0x1                   	// #1
}
    fd800000ab08:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd800000ab0c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    interrupts_cpu_sendipi(trgtcpu, IPI_CPU_MSG);
    fd800000ab10:	17fffea0 	b	fd800000a590 <interrupts_cpu_sendipi>
        ERROR("cant allocate msg node");
    fd800000ab14:	90000000 	adrp	x0, fd800000a000 <mem_alloc_ppages+0x70>
    fd800000ab18:	f9459c00 	ldr	x0, [x0, #2872]
    fd800000ab1c:	94000541 	bl	fd800000c020 <console_printk>
    fd800000ab20:	14000000 	b	fd800000ab20 <cpu_send_msg+0xd0>
            list->head = node;
    fd800000ab24:	f8226860 	str	x0, [x3, x2]
    fd800000ab28:	17ffffef 	b	fd800000aae4 <cpu_send_msg+0x94>
    fd800000ab2c:	d503201f 	nop
    fd800000ab30:	00012830 	.word	0x00012830
    fd800000ab34:	0000fd80 	.word	0x0000fd80
    fd800000ab38:	00010c88 	.word	0x00010c88
    fd800000ab3c:	0000fd80 	.word	0x0000fd80
    fd800000ab40:	00017000 	.word	0x00017000
    fd800000ab44:	0000fd80 	.word	0x0000fd80
    fd800000ab48:	d503201f 	nop
    fd800000ab4c:	d503201f 	nop

0000fd800000ab50 <cpu_get_msg>:

bool cpu_get_msg(struct cpu_msg* msg)
{
    struct cpu_msg_node* node = NULL;
    if ((node = (struct cpu_msg_node*)list_pop(&cpu()->interface->event_list)) != NULL) {
    fd800000ab50:	d2dfc001 	mov	x1, #0xfe0000000000        	// #279275953455104
    fd800000ab54:	f9417c23 	ldr	x3, [x1, #760]
    if (list != NULL) {
    fd800000ab58:	b4000583 	cbz	x3, fd800000ac08 <cpu_get_msg+0xb8>
        spin_lock(&list->lock);
    fd800000ab5c:	91004062 	add	x2, x3, #0x10
    __asm__ volatile(
    fd800000ab60:	aa0003e4 	mov	x4, x0
    fd800000ab64:	91001046 	add	x6, x2, #0x4
    fd800000ab68:	885ffc40 	ldaxr	w0, [x2]
    fd800000ab6c:	11000401 	add	w1, w0, #0x1
    fd800000ab70:	88057c41 	stxr	w5, w1, [x2]
    fd800000ab74:	35ffffa5 	cbnz	w5, fd800000ab68 <cpu_get_msg+0x18>
    fd800000ab78:	88dffcc1 	ldar	w1, [x6]
    fd800000ab7c:	6b01001f 	cmp	w0, w1
    fd800000ab80:	54000060 	b.eq	fd800000ab8c <cpu_get_msg+0x3c>  // b.none
    fd800000ab84:	d503205f 	wfe
    fd800000ab88:	17fffffc 	b	fd800000ab78 <cpu_get_msg+0x28>
        if (list->head != NULL) {
    fd800000ab8c:	f9400061 	ldr	x1, [x3]
    fd800000ab90:	b4000301 	cbz	x1, fd800000abf0 <cpu_get_msg+0xa0>
{
    fd800000ab94:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    fd800000ab98:	910003fd 	mov	x29, sp
            list->head = *list->head;
    fd800000ab9c:	f9400020 	ldr	x0, [x1]
    fd800000aba0:	f9000060 	str	x0, [x3]
            if (list->head == NULL) {
    fd800000aba4:	b4000360 	cbz	x0, fd800000ac10 <cpu_get_msg+0xc0>
            *temp = NULL;
    fd800000aba8:	aa0103e3 	mov	x3, x1
    __asm__ volatile(
    fd800000abac:	91001042 	add	x2, x2, #0x4
    fd800000abb0:	f800847f 	str	xzr, [x3], #8
    fd800000abb4:	b9400040 	ldr	w0, [x2]
    fd800000abb8:	11000400 	add	w0, w0, #0x1
    fd800000abbc:	889ffc40 	stlr	w0, [x2]
    fd800000abc0:	d5033b9f 	dsb	ish
    fd800000abc4:	d503209f 	sev
        *msg = node->msg;
    fd800000abc8:	f9400422 	ldr	x2, [x1, #8]
    fd800000abcc:	f9000082 	str	x2, [x4]
        objpool_free(&msg_pool, node);
    fd800000abd0:	90000000 	adrp	x0, fd800000a000 <mem_alloc_ppages+0x70>
    fd800000abd4:	f9460c00 	ldr	x0, [x0, #3096]
        *msg = node->msg;
    fd800000abd8:	f9400462 	ldr	x2, [x3, #8]
    fd800000abdc:	f9000482 	str	x2, [x4, #8]
        objpool_free(&msg_pool, node);
    fd800000abe0:	940006d0 	bl	fd800000c720 <objpool_free>
        return true;
    fd800000abe4:	52800020 	mov	w0, #0x1                   	// #1
    }
    return false;
}
    fd800000abe8:	a8c17bfd 	ldp	x29, x30, [sp], #16
    fd800000abec:	d65f03c0 	ret
    fd800000abf0:	91001041 	add	x1, x2, #0x4
    fd800000abf4:	b9400020 	ldr	w0, [x1]
    fd800000abf8:	11000400 	add	w0, w0, #0x1
    fd800000abfc:	889ffc20 	stlr	w0, [x1]
    fd800000ac00:	d5033b9f 	dsb	ish
    fd800000ac04:	d503209f 	sev
    return false;
    fd800000ac08:	52800000 	mov	w0, #0x0                   	// #0
}
    fd800000ac0c:	d65f03c0 	ret
                list->tail = NULL;
    fd800000ac10:	f900047f 	str	xzr, [x3, #8]
    fd800000ac14:	17ffffe5 	b	fd800000aba8 <cpu_get_msg+0x58>
    fd800000ac18:	00012830 	.word	0x00012830
    fd800000ac1c:	0000fd80 	.word	0x0000fd80

0000fd800000ac20 <cpu_msg_handler>:

void cpu_msg_handler()
{
    fd800000ac20:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    cpu()->handling_msgs = true;
    fd800000ac24:	d2dfc000 	mov	x0, #0xfe0000000000        	// #279275953455104
    fd800000ac28:	52800021 	mov	w1, #0x1                   	// #1
{
    fd800000ac2c:	910003fd 	mov	x29, sp
    fd800000ac30:	a90153f3 	stp	x19, x20, [sp, #16]
    struct cpu_msg msg;
    while (cpu_get_msg(&msg)) {
        if (msg.handler < ipi_cpumsg_handler_num && ipi_cpumsg_handlers[msg.handler]) {
    fd800000ac34:	90000013 	adrp	x19, fd800000a000 <mem_alloc_ppages+0x70>
    fd800000ac38:	90000014 	adrp	x20, fd800000a000 <mem_alloc_ppages+0x70>
    cpu()->handling_msgs = true;
    fd800000ac3c:	39002001 	strb	w1, [x0, #8]
    while (cpu_get_msg(&msg)) {
    fd800000ac40:	910083e0 	add	x0, sp, #0x20
    fd800000ac44:	97ffffc3 	bl	fd800000ab50 <cpu_get_msg>
    fd800000ac48:	360001e0 	tbz	w0, #0, fd800000ac84 <cpu_msg_handler+0x64>
        if (msg.handler < ipi_cpumsg_handler_num && ipi_cpumsg_handlers[msg.handler]) {
    fd800000ac4c:	f9464e61 	ldr	x1, [x19, #3224]
    fd800000ac50:	b94023e0 	ldr	w0, [sp, #32]
    fd800000ac54:	f9401021 	ldr	x1, [x1, #32]
    fd800000ac58:	eb01001f 	cmp	x0, x1
    fd800000ac5c:	54ffff22 	b.cs	fd800000ac40 <cpu_msg_handler+0x20>  // b.hs, b.nlast
    fd800000ac60:	f9465281 	ldr	x1, [x20, #3232]
    fd800000ac64:	f8607822 	ldr	x2, [x1, x0, lsl #3]
    fd800000ac68:	b4fffec2 	cbz	x2, fd800000ac40 <cpu_msg_handler+0x20>
            ipi_cpumsg_handlers[msg.handler](msg.event, msg.data);
    fd800000ac6c:	f94017e1 	ldr	x1, [sp, #40]
    fd800000ac70:	b94027e0 	ldr	w0, [sp, #36]
    fd800000ac74:	d63f0040 	blr	x2
    while (cpu_get_msg(&msg)) {
    fd800000ac78:	910083e0 	add	x0, sp, #0x20
    fd800000ac7c:	97ffffb5 	bl	fd800000ab50 <cpu_get_msg>
    fd800000ac80:	3707fe60 	tbnz	w0, #0, fd800000ac4c <cpu_msg_handler+0x2c>
        }
    }
    cpu()->handling_msgs = false;
    fd800000ac84:	d2dfc000 	mov	x0, #0xfe0000000000        	// #279275953455104
}
    fd800000ac88:	a94153f3 	ldp	x19, x20, [sp, #16]
    cpu()->handling_msgs = false;
    fd800000ac8c:	3900201f 	strb	wzr, [x0, #8]
}
    fd800000ac90:	a8c37bfd 	ldp	x29, x30, [sp], #48
    fd800000ac94:	d65f03c0 	ret
    fd800000ac98:	00016000 	.word	0x00016000
    fd800000ac9c:	0000fd80 	.word	0x0000fd80
    fd800000aca0:	00012e60 	.word	0x00012e60
    fd800000aca4:	0000fd80 	.word	0x0000fd80
    fd800000aca8:	d503201f 	nop
    fd800000acac:	d503201f 	nop

0000fd800000acb0 <cpu_idle>:

void cpu_idle()
{
    fd800000acb0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    fd800000acb4:	910003fd 	mov	x29, sp
    cpu_arch_idle();
    fd800000acb8:	97ffe38e 	bl	fd8000003af0 <cpu_arch_idle>

    /**
     * Should not return here. cpu should "wake up" from idle in cpu_idle_wakeup with a rewinded
     * stack.
     */
    ERROR("Spurious idle wake up");
    fd800000acbc:	90000000 	adrp	x0, fd800000a000 <mem_alloc_ppages+0x70>
    fd800000acc0:	f9466800 	ldr	x0, [x0, #3280]
    fd800000acc4:	940004d7 	bl	fd800000c020 <console_printk>
    fd800000acc8:	14000000 	b	fd800000acc8 <cpu_idle+0x18>
    fd800000accc:	d503201f 	nop
    fd800000acd0:	00010cb0 	.word	0x00010cb0
    fd800000acd4:	0000fd80 	.word	0x0000fd80
    fd800000acd8:	d503201f 	nop
    fd800000acdc:	d503201f 	nop

0000fd800000ace0 <cpu_idle_wakeup>:
}

void cpu_idle_wakeup()
{
    fd800000ace0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    if (interrupts_check(IPI_CPU_MSG)) {
    fd800000ace4:	52800020 	mov	w0, #0x1                   	// #1
{
    fd800000ace8:	910003fd 	mov	x29, sp
    if (interrupts_check(IPI_CPU_MSG)) {
    fd800000acec:	97fffe31 	bl	fd800000a5b0 <interrupts_check>
    fd800000acf0:	370000c0 	tbnz	w0, #0, fd800000ad08 <cpu_idle_wakeup+0x28>
        interrupts_clear(IPI_CPU_MSG);
        cpu_msg_handler();
    }

    if (cpu()->vcpu != NULL) {
    fd800000acf4:	d2dfc000 	mov	x0, #0xfe0000000000        	// #279275953455104
    fd800000acf8:	f9402800 	ldr	x0, [x0, #80]
    fd800000acfc:	b40000e0 	cbz	x0, fd800000ad18 <cpu_idle_wakeup+0x38>
        vcpu_run(cpu()->vcpu);
    } else {
        cpu_idle();
    }
}
    fd800000ad00:	a8c17bfd 	ldp	x29, x30, [sp], #16
        vcpu_run(cpu()->vcpu);
    fd800000ad04:	1400046f 	b	fd800000bec0 <vcpu_run>
        interrupts_clear(IPI_CPU_MSG);
    fd800000ad08:	52800020 	mov	w0, #0x1                   	// #1
    fd800000ad0c:	97fffe2d 	bl	fd800000a5c0 <interrupts_clear>
        cpu_msg_handler();
    fd800000ad10:	97ffffc4 	bl	fd800000ac20 <cpu_msg_handler>
    fd800000ad14:	17fffff8 	b	fd800000acf4 <cpu_idle_wakeup+0x14>
        cpu_idle();
    fd800000ad18:	97ffffe6 	bl	fd800000acb0 <cpu_idle>
    fd800000ad1c:	00000000 	udf	#0

0000fd800000ad20 <vmm_init>:
}

//Assign the vcpus to VMs
//Initialize the VMs
void vmm_init()     //this is done for each cpu
{
    fd800000ad20:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    fd800000ad24:	910003fd 	mov	x29, sp
    fd800000ad28:	a90153f3 	stp	x19, x20, [sp, #16]
    fd800000ad2c:	a9025bf5 	stp	x21, x22, [sp, #32]
    vmm_arch_init();
    fd800000ad30:	97ffefe8 	bl	fd8000006cd0 <vmm_arch_init>
    vmm_io_init();
    fd800000ad34:	9400107b 	bl	fd800000ef20 <vmm_io_init>
    ipc_init();
    fd800000ad38:	940005ea 	bl	fd800000c4e0 <ipc_init>
    while (!token->ready) { }
    fd800000ad3c:	b0000000 	adrp	x0, fd800000b000 <vmm_init+0x2e0>
    fd800000ad40:	f9412000 	ldr	x0, [x0, #576]
    fd800000ad44:	d503201f 	nop
    fd800000ad48:	39404001 	ldrb	w1, [x0, #16]
    fd800000ad4c:	12001c28 	and	w8, w1, #0xff
    fd800000ad50:	3607ffc1 	tbz	w1, #0, fd800000ad48 <vmm_init+0x28>
    __asm__ volatile(
    fd800000ad54:	91001004 	add	x4, x0, #0x4
    fd800000ad58:	885ffc01 	ldaxr	w1, [x0]
    fd800000ad5c:	11000422 	add	w2, w1, #0x1
    fd800000ad60:	88037c02 	stxr	w3, w2, [x0]
    fd800000ad64:	35ffffa3 	cbnz	w3, fd800000ad58 <vmm_init+0x38>
    fd800000ad68:	88dffc82 	ldar	w2, [x4]
    fd800000ad6c:	6b02003f 	cmp	w1, w2
    fd800000ad70:	54000060 	b.eq	fd800000ad7c <vmm_init+0x5c>  // b.none
    fd800000ad74:	d503205f 	wfe
    fd800000ad78:	17fffffc 	b	fd800000ad68 <vmm_init+0x48>
    token->count++;
    fd800000ad7c:	f9400c01 	ldr	x1, [x0, #24]
    fd800000ad80:	91000421 	add	x1, x1, #0x1
    fd800000ad84:	f9000c01 	str	x1, [x0, #24]
    next_count = ALIGN(token->count, token->n);
    fd800000ad88:	f9400c02 	ldr	x2, [x0, #24]
    fd800000ad8c:	f9400401 	ldr	x1, [x0, #8]
    fd800000ad90:	f9400403 	ldr	x3, [x0, #8]
    fd800000ad94:	8b010042 	add	x2, x2, x1
    fd800000ad98:	d1000442 	sub	x2, x2, #0x1
    fd800000ad9c:	f9400401 	ldr	x1, [x0, #8]
    fd800000ada0:	9ac30842 	udiv	x2, x2, x3
    fd800000ada4:	9b017c42 	mul	x2, x2, x1
    __asm__ volatile(
    fd800000ada8:	b9400081 	ldr	w1, [x4]
    fd800000adac:	11000421 	add	w1, w1, #0x1
    fd800000adb0:	889ffc81 	stlr	w1, [x4]
    fd800000adb4:	d5033b9f 	dsb	ish
    fd800000adb8:	d503209f 	sev
    while (token->count < next_count) { }
    fd800000adbc:	d503201f 	nop
    fd800000adc0:	f9400c01 	ldr	x1, [x0, #24]
    fd800000adc4:	eb01005f 	cmp	x2, x1
    fd800000adc8:	54ffffc8 	b.hi	fd800000adc0 <vmm_init+0xa0>  // b.pmore
    for (size_t i = 0; i < config.vmlist_size && !assigned; i++) {
    fd800000adcc:	b0000001 	adrp	x1, fd800000b000 <vmm_init+0x2e0>
    fd800000add0:	f9412426 	ldr	x6, [x1, #584]
    fd800000add4:	f94014c1 	ldr	x1, [x6, #40]
    fd800000add8:	b40022c1 	cbz	x1, fd800000b230 <vmm_init+0x510>
    fd800000addc:	b0000001 	adrp	x1, fd800000b000 <vmm_init+0x2e0>
    fd800000ade0:	f9412821 	ldr	x1, [x1, #592]
    fd800000ade4:	aa0603e5 	mov	x5, x6
    fd800000ade8:	1200010e 	and	w14, w8, #0x1

    cpu_sync_barrier(&cpu_glb_sync);
    

    bool master = false;
    vmid_t vm_id = -1;
    fd800000adec:	92800014 	mov	x20, #0xffffffffffffffff    	// #-1
    *master = false;
    fd800000adf0:	52800013 	mov	w19, #0x0                   	// #0
    for (size_t i = 0; i < config.vmlist_size && !assigned; i++) {
    fd800000adf4:	d2800004 	mov	x4, #0x0                   	// #0
        if (config.vmlist[i].cpu_affinity & (1UL << cpu()->id)) {
    fd800000adf8:	d2dfc009 	mov	x9, #0xfe0000000000        	// #279275953455104
                vm_assign[i].master = true;
    fd800000adfc:	5280002d 	mov	w13, #0x1                   	// #1
                vm_assign[i].cpus |= (1UL << cpu()->id);
    fd800000ae00:	d280002c 	mov	x12, #0x1                   	// #1
    fd800000ae04:	d503201f 	nop
        if (config.vmlist[i].cpu_affinity & (1UL << cpu()->id)) {
    fd800000ae08:	f9400127 	ldr	x7, [x9]
    fd800000ae0c:	f9402ca2 	ldr	x2, [x5, #88]
    fd800000ae10:	9ac72442 	lsr	x2, x2, x7
    fd800000ae14:	37000d22 	tbnz	w2, #0, fd800000afb8 <vmm_init+0x298>
    for (size_t i = 0; i < config.vmlist_size && !assigned; i++) {
    fd800000ae18:	f94014c2 	ldr	x2, [x6, #40]
    fd800000ae1c:	91000484 	add	x4, x4, #0x1
    fd800000ae20:	9102c0a5 	add	x5, x5, #0xb0
    fd800000ae24:	91016021 	add	x1, x1, #0x58
    fd800000ae28:	eb02009f 	cmp	x4, x2
    fd800000ae2c:	54fffee3 	b.cc	fd800000ae08 <vmm_init+0xe8>  // b.lo, b.ul, b.last
    bool assigned = false;
    fd800000ae30:	52800003 	mov	w3, #0x0                   	// #0
    fd800000ae34:	5280000a 	mov	w10, #0x0                   	// #0
    while (!token->ready) { }
    fd800000ae38:	39404001 	ldrb	w1, [x0, #16]
    fd800000ae3c:	12001c27 	and	w7, w1, #0xff
    fd800000ae40:	3607ffc1 	tbz	w1, #0, fd800000ae38 <vmm_init+0x118>
    __asm__ volatile(
    fd800000ae44:	91001005 	add	x5, x0, #0x4
    fd800000ae48:	885ffc01 	ldaxr	w1, [x0]
    fd800000ae4c:	11000422 	add	w2, w1, #0x1
    fd800000ae50:	88047c02 	stxr	w4, w2, [x0]
    fd800000ae54:	35ffffa4 	cbnz	w4, fd800000ae48 <vmm_init+0x128>
    fd800000ae58:	88dffca2 	ldar	w2, [x5]
    fd800000ae5c:	6b02003f 	cmp	w1, w2
    fd800000ae60:	54000060 	b.eq	fd800000ae6c <vmm_init+0x14c>  // b.none
    fd800000ae64:	d503205f 	wfe
    fd800000ae68:	17fffffc 	b	fd800000ae58 <vmm_init+0x138>
    token->count++;
    fd800000ae6c:	f9400c01 	ldr	x1, [x0, #24]
    fd800000ae70:	91000421 	add	x1, x1, #0x1
    fd800000ae74:	f9000c01 	str	x1, [x0, #24]
    next_count = ALIGN(token->count, token->n);
    fd800000ae78:	f9400c02 	ldr	x2, [x0, #24]
    fd800000ae7c:	f9400401 	ldr	x1, [x0, #8]
    fd800000ae80:	f9400404 	ldr	x4, [x0, #8]
    fd800000ae84:	8b010042 	add	x2, x2, x1
    fd800000ae88:	d1000442 	sub	x2, x2, #0x1
    fd800000ae8c:	f9400401 	ldr	x1, [x0, #8]
    fd800000ae90:	9ac40842 	udiv	x2, x2, x4
    fd800000ae94:	9b017c42 	mul	x2, x2, x1
    __asm__ volatile(
    fd800000ae98:	b94000a1 	ldr	w1, [x5]
    fd800000ae9c:	11000421 	add	w1, w1, #0x1
    fd800000aea0:	889ffca1 	stlr	w1, [x5]
    fd800000aea4:	d5033b9f 	dsb	ish
    fd800000aea8:	d503209f 	sev
    while (token->count < next_count) { }
    fd800000aeac:	d503201f 	nop
    fd800000aeb0:	f9400c01 	ldr	x1, [x0, #24]
    fd800000aeb4:	eb01005f 	cmp	x2, x1
    fd800000aeb8:	54ffffc8 	b.hi	fd800000aeb0 <vmm_init+0x190>  // b.pmore
    if (assigned == false) {
    fd800000aebc:	34000f4a 	cbz	w10, fd800000b0a4 <vmm_init+0x384>
    fd800000aec0:	b0000001 	adrp	x1, fd800000b000 <vmm_init+0x2e0>
    fd800000aec4:	f9412836 	ldr	x22, [x1, #592]
    fd800000aec8:	a90363f7 	stp	x23, x24, [sp, #48]
    struct vm_allocation* vm_alloc = &vm_assign[vm_id].vm_alloc;
    fd800000aecc:	d2800b15 	mov	x21, #0x58                  	// #88
    struct vm_config* vm_config = &config.vmlist[vm_id];
    fd800000aed0:	d2801617 	mov	x23, #0xb0                  	// #176
    fd800000aed4:	9b157e95 	mul	x21, x20, x21
    fd800000aed8:	9b171a97 	madd	x23, x20, x23, x6
    struct vm_allocation* vm_alloc = &vm_assign[vm_id].vm_alloc;
    fd800000aedc:	910082b8 	add	x24, x21, #0x20
        while (!vm_assign[vm_id].install_info_ready) { }
    fd800000aee0:	8b1502c2 	add	x2, x22, x21
    struct vm_allocation* vm_alloc = &vm_assign[vm_id].vm_alloc;
    fd800000aee4:	8b1802d8 	add	x24, x22, x24
    struct vm_config* vm_config = &config.vmlist[vm_id];
    fd800000aee8:	9100c2f7 	add	x23, x23, #0x30
    if (master) {
    fd800000aeec:	37001653 	tbnz	w19, #0, fd800000b1b4 <vmm_init+0x494>
        while (!vm_assign[vm_id].install_info_ready) { }
    fd800000aef0:	39414040 	ldrb	w0, [x2, #80]
    fd800000aef4:	3607ffe0 	tbz	w0, #0, fd800000aef0 <vmm_init+0x1d0>
        vmm_vm_install(&vm_assign[vm_id].vm_install_info);
    fd800000aef8:	910102a0 	add	x0, x21, #0x40
    fd800000aefc:	8b0002c0 	add	x0, x22, x0
    fd800000af00:	9400101c 	bl	fd800000ef70 <vmm_vm_install>
    fd800000af04:	d5033a9f 	dsb	ishst
    if (vmm_assign_vcpu(&master, &vm_id)) { //if cpu has been assigned to vm_assign struct
        struct vm_allocation* vm_alloc = vmm_alloc_install_vm(vm_id, master);
        struct vm_config* vm_config = &config.vmlist[vm_id];
        struct vm* vm = vm_init(vm_alloc, vm_config, master, vm_id);
    fd800000af08:	aa1403e3 	mov	x3, x20
    fd800000af0c:	2a1303e2 	mov	w2, w19
    fd800000af10:	aa1703e1 	mov	x1, x23
    fd800000af14:	aa1803e0 	mov	x0, x24
    fd800000af18:	94000136 	bl	fd800000b3f0 <vm_init>
    while (!token->ready) { }
    fd800000af1c:	91006000 	add	x0, x0, #0x18
    fd800000af20:	39404001 	ldrb	w1, [x0, #16]
    fd800000af24:	3607ffe1 	tbz	w1, #0, fd800000af20 <vmm_init+0x200>
    __asm__ volatile(
    fd800000af28:	91001004 	add	x4, x0, #0x4
    fd800000af2c:	885ffc01 	ldaxr	w1, [x0]
    fd800000af30:	11000422 	add	w2, w1, #0x1
    fd800000af34:	88037c02 	stxr	w3, w2, [x0]
    fd800000af38:	35ffffa3 	cbnz	w3, fd800000af2c <vmm_init+0x20c>
    fd800000af3c:	88dffc82 	ldar	w2, [x4]
    fd800000af40:	6b02003f 	cmp	w1, w2
    fd800000af44:	54000060 	b.eq	fd800000af50 <vmm_init+0x230>  // b.none
    fd800000af48:	d503205f 	wfe
    fd800000af4c:	17fffffc 	b	fd800000af3c <vmm_init+0x21c>
    token->count++;
    fd800000af50:	f9400c01 	ldr	x1, [x0, #24]
    fd800000af54:	91000421 	add	x1, x1, #0x1
    fd800000af58:	f9000c01 	str	x1, [x0, #24]
    next_count = ALIGN(token->count, token->n);
    fd800000af5c:	f9400c02 	ldr	x2, [x0, #24]
    fd800000af60:	f9400401 	ldr	x1, [x0, #8]
    fd800000af64:	f9400403 	ldr	x3, [x0, #8]
    fd800000af68:	8b010042 	add	x2, x2, x1
    fd800000af6c:	d1000442 	sub	x2, x2, #0x1
    fd800000af70:	f9400401 	ldr	x1, [x0, #8]
    fd800000af74:	9ac30842 	udiv	x2, x2, x3
    fd800000af78:	9b017c42 	mul	x2, x2, x1
    __asm__ volatile(
    fd800000af7c:	b9400081 	ldr	w1, [x4]
    fd800000af80:	11000421 	add	w1, w1, #0x1
    fd800000af84:	889ffc81 	stlr	w1, [x4]
    fd800000af88:	d5033b9f 	dsb	ish
    fd800000af8c:	d503209f 	sev
    while (token->count < next_count) { }
    fd800000af90:	f9400c01 	ldr	x1, [x0, #24]
    fd800000af94:	eb01005f 	cmp	x2, x1
    fd800000af98:	54ffffc8 	b.hi	fd800000af90 <vmm_init+0x270>  // b.pmore
        cpu_sync_barrier(&vm->sync);
        vcpu_run(cpu()->vcpu);
    } else {
        cpu_idle();
    }
}
    fd800000af9c:	a94153f3 	ldp	x19, x20, [sp, #16]
        vcpu_run(cpu()->vcpu);
    fd800000afa0:	d2dfc000 	mov	x0, #0xfe0000000000        	// #279275953455104
}
    fd800000afa4:	a9425bf5 	ldp	x21, x22, [sp, #32]
        vcpu_run(cpu()->vcpu);
    fd800000afa8:	a94363f7 	ldp	x23, x24, [sp, #48]
}
    fd800000afac:	a8c57bfd 	ldp	x29, x30, [sp], #80
        vcpu_run(cpu()->vcpu);
    fd800000afb0:	f9402800 	ldr	x0, [x0, #80]
    fd800000afb4:	140003c3 	b	fd800000bec0 <vcpu_run>
    __asm__ volatile(
    fd800000afb8:	9100102a 	add	x10, x1, #0x4
    fd800000afbc:	885ffc22 	ldaxr	w2, [x1]
    fd800000afc0:	11000443 	add	w3, w2, #0x1
    fd800000afc4:	88077c23 	stxr	w7, w3, [x1]
    fd800000afc8:	35ffffa7 	cbnz	w7, fd800000afbc <vmm_init+0x29c>
    fd800000afcc:	88dffd43 	ldar	w3, [x10]
    fd800000afd0:	6b03005f 	cmp	w2, w3
    fd800000afd4:	54000060 	b.eq	fd800000afe0 <vmm_init+0x2c0>  // b.none
    fd800000afd8:	d503205f 	wfe
    fd800000afdc:	17fffffc 	b	fd800000afcc <vmm_init+0x2ac>
            if (!vm_assign[i].master) {
    fd800000afe0:	39402023 	ldrb	w3, [x1, #8]
    fd800000afe4:	1200006a 	and	w10, w3, #0x1
    fd800000afe8:	370003c3 	tbnz	w3, #0, fd800000b060 <vmm_init+0x340>
                vm_assign[i].cpus |= (1UL << cpu()->id);
    fd800000afec:	a9410823 	ldp	x3, x2, [x1, #16]
    fd800000aff0:	aa0403f4 	mov	x20, x4
                *master = true;
    fd800000aff4:	2a0803f3 	mov	w19, w8
    fd800000aff8:	2a0e03ea 	mov	w10, w14
                vm_assign[i].ncpus++;
    fd800000affc:	91000463 	add	x3, x3, #0x1
    fd800000b000:	f9000823 	str	x3, [x1, #16]
                assigned = true;
    fd800000b004:	2a0803e3 	mov	w3, w8
                vm_assign[i].cpus |= (1UL << cpu()->id);
    fd800000b008:	f9400127 	ldr	x7, [x9]
                vm_assign[i].master = true;
    fd800000b00c:	3900202d 	strb	w13, [x1, #8]
                vm_assign[i].cpus |= (1UL << cpu()->id);
    fd800000b010:	9ac72187 	lsl	x7, x12, x7
    fd800000b014:	aa070042 	orr	x2, x2, x7
    fd800000b018:	f9000c22 	str	x2, [x1, #24]
    __asm__ volatile(
    fd800000b01c:	91001027 	add	x7, x1, #0x4
    fd800000b020:	b94000e2 	ldr	w2, [x7]
    fd800000b024:	11000442 	add	w2, w2, #0x1
    fd800000b028:	889ffce2 	stlr	w2, [x7]
    fd800000b02c:	d5033b9f 	dsb	ish
    fd800000b030:	d503209f 	sev
    for (size_t i = 0; i < config.vmlist_size && !assigned; i++) {
    fd800000b034:	f94014c2 	ldr	x2, [x6, #40]
    fd800000b038:	91000484 	add	x4, x4, #0x1
    fd800000b03c:	9102c0a5 	add	x5, x5, #0xb0
    fd800000b040:	91016021 	add	x1, x1, #0x58
    fd800000b044:	eb02009f 	cmp	x4, x2
    fd800000b048:	54ffef82 	b.cs	fd800000ae38 <vmm_init+0x118>  // b.hs, b.nlast
    fd800000b04c:	34ffedea 	cbz	w10, fd800000ae08 <vmm_init+0xe8>
    while (!token->ready) { }
    fd800000b050:	39404001 	ldrb	w1, [x0, #16]
    fd800000b054:	12001c27 	and	w7, w1, #0xff
    fd800000b058:	3607ef01 	tbz	w1, #0, fd800000ae38 <vmm_init+0x118>
    fd800000b05c:	17ffff7a 	b	fd800000ae44 <vmm_init+0x124>
            } else if (vm_assign[i].ncpus < config.vmlist[i].platform.cpu_num) {
    fd800000b060:	f9400822 	ldr	x2, [x1, #16]
                vm_assign[i].cpus |= (1UL << cpu()->id);
    fd800000b064:	d2800027 	mov	x7, #0x1                   	// #1
            } else if (vm_assign[i].ncpus < config.vmlist[i].platform.cpu_num) {
    fd800000b068:	f94034ab 	ldr	x11, [x5, #104]
                vm_assign[i].ncpus++;
    fd800000b06c:	8b07004f 	add	x15, x2, x7
            } else if (vm_assign[i].ncpus < config.vmlist[i].platform.cpu_num) {
    fd800000b070:	eb0b005f 	cmp	x2, x11
    fd800000b074:	54000122 	b.cs	fd800000b098 <vmm_init+0x378>  // b.hs, b.nlast
                vm_assign[i].ncpus++;
    fd800000b078:	f900082f 	str	x15, [x1, #16]
                vm_assign[i].cpus |= (1UL << cpu()->id);
    fd800000b07c:	aa0403f4 	mov	x20, x4
    fd800000b080:	f9400c22 	ldr	x2, [x1, #24]
    fd800000b084:	f940012b 	ldr	x11, [x9]
    fd800000b088:	9acb20e7 	lsl	x7, x7, x11
    fd800000b08c:	aa070042 	orr	x2, x2, x7
    fd800000b090:	f9000c22 	str	x2, [x1, #24]
                *vm_id = i;
    fd800000b094:	17ffffe2 	b	fd800000b01c <vmm_init+0x2fc>
    fd800000b098:	52800003 	mov	w3, #0x0                   	// #0
    fd800000b09c:	5280000a 	mov	w10, #0x0                   	// #0
    fd800000b0a0:	17ffffdf 	b	fd800000b01c <vmm_init+0x2fc>
        for (size_t i = 0; i < config.vmlist_size && !assigned; i++) {
    fd800000b0a4:	f94014c0 	ldr	x0, [x6, #40]
    fd800000b0a8:	b40007a0 	cbz	x0, fd800000b19c <vmm_init+0x47c>
    fd800000b0ac:	90000001 	adrp	x1, fd800000b000 <vmm_init+0x2e0>
    fd800000b0b0:	f9412836 	ldr	x22, [x1, #592]
                    vm_assign[i].cpus |= (1UL << cpu()->id);
    fd800000b0b4:	d280002a 	mov	x10, #0x1                   	// #1
    fd800000b0b8:	12000063 	and	w3, w3, #0x1
    fd800000b0bc:	aa0603e2 	mov	x2, x6
    fd800000b0c0:	aa1603e0 	mov	x0, x22
                    vm_assign[i].master = true;
    fd800000b0c4:	2a0a03ed 	mov	w13, w10
    fd800000b0c8:	120000ec 	and	w12, w7, #0x1
        for (size_t i = 0; i < config.vmlist_size && !assigned; i++) {
    fd800000b0cc:	d2800001 	mov	x1, #0x0                   	// #0
                    vm_assign[i].cpus |= (1UL << cpu()->id);
    fd800000b0d0:	d2dfc00b 	mov	x11, #0xfe0000000000        	// #279275953455104
    fd800000b0d4:	14000016 	b	fd800000b12c <vmm_init+0x40c>
                    vm_assign[i].cpus |= (1UL << cpu()->id);
    fd800000b0d8:	f9400168 	ldr	x8, [x11]
                    *master = true;
    fd800000b0dc:	2a0703f3 	mov	w19, w7
                    vm_assign[i].cpus |= (1UL << cpu()->id);
    fd800000b0e0:	f9400c04 	ldr	x4, [x0, #24]
    fd800000b0e4:	2a0c03e5 	mov	w5, w12
    fd800000b0e8:	9ac82148 	lsl	x8, x10, x8
                    vm_assign[i].master = true;
    fd800000b0ec:	3900200d 	strb	w13, [x0, #8]
                    vm_assign[i].cpus |= (1UL << cpu()->id);
    fd800000b0f0:	aa080084 	orr	x4, x4, x8
    fd800000b0f4:	f9000c04 	str	x4, [x0, #24]
    fd800000b0f8:	91001008 	add	x8, x0, #0x4
    fd800000b0fc:	b9400104 	ldr	w4, [x8]
    fd800000b100:	11000484 	add	w4, w4, #0x1
    fd800000b104:	889ffd04 	stlr	w4, [x8]
    fd800000b108:	d5033b9f 	dsb	ish
    fd800000b10c:	d503209f 	sev
        for (size_t i = 0; i < config.vmlist_size && !assigned; i++) {
    fd800000b110:	f94014c4 	ldr	x4, [x6, #40]
    fd800000b114:	91000421 	add	x1, x1, #0x1
    fd800000b118:	91016000 	add	x0, x0, #0x58
    fd800000b11c:	9102c042 	add	x2, x2, #0xb0
    fd800000b120:	eb04003f 	cmp	x1, x4
    fd800000b124:	540003a2 	b.cs	fd800000b198 <vmm_init+0x478>  // b.hs, b.nlast
    fd800000b128:	35000425 	cbnz	w5, fd800000b1ac <vmm_init+0x48c>
    __asm__ volatile(
    fd800000b12c:	91001009 	add	x9, x0, #0x4
    fd800000b130:	885ffc04 	ldaxr	w4, [x0]
    fd800000b134:	11000485 	add	w5, w4, #0x1
    fd800000b138:	88087c05 	stxr	w8, w5, [x0]
    fd800000b13c:	35ffffa8 	cbnz	w8, fd800000b130 <vmm_init+0x410>
    fd800000b140:	88dffd25 	ldar	w5, [x9]
    fd800000b144:	6b05009f 	cmp	w4, w5
    fd800000b148:	54000060 	b.eq	fd800000b154 <vmm_init+0x434>  // b.none
    fd800000b14c:	d503205f 	wfe
    fd800000b150:	17fffffc 	b	fd800000b140 <vmm_init+0x420>
            if (vm_assign[i].ncpus < config.vmlist[i].platform.cpu_num) {
    fd800000b154:	f9400804 	ldr	x4, [x0, #16]
    fd800000b158:	2a0303e5 	mov	w5, w3
    fd800000b15c:	f9403448 	ldr	x8, [x2, #104]
                    vm_assign[i].ncpus++;
    fd800000b160:	91000489 	add	x9, x4, #0x1
            if (vm_assign[i].ncpus < config.vmlist[i].platform.cpu_num) {
    fd800000b164:	eb08009f 	cmp	x4, x8
    fd800000b168:	54fffc82 	b.cs	fd800000b0f8 <vmm_init+0x3d8>  // b.hs, b.nlast
                if (!vm_assign[i].master) {
    fd800000b16c:	39402004 	ldrb	w4, [x0, #8]
                    vm_assign[i].cpus |= (1UL << cpu()->id);
    fd800000b170:	aa0103f4 	mov	x20, x1
                    vm_assign[i].ncpus++;
    fd800000b174:	f9000809 	str	x9, [x0, #16]
                if (!vm_assign[i].master) {
    fd800000b178:	12000085 	and	w5, w4, #0x1
    fd800000b17c:	3607fae4 	tbz	w4, #0, fd800000b0d8 <vmm_init+0x3b8>
                    vm_assign[i].cpus |= (1UL << cpu()->id);
    fd800000b180:	f9400168 	ldr	x8, [x11]
    fd800000b184:	f9400c04 	ldr	x4, [x0, #24]
    fd800000b188:	9ac82148 	lsl	x8, x10, x8
    fd800000b18c:	aa080084 	orr	x4, x4, x8
    fd800000b190:	f9000c04 	str	x4, [x0, #24]
                    *vm_id = i;
    fd800000b194:	17ffffd9 	b	fd800000b0f8 <vmm_init+0x3d8>
    if (vmm_assign_vcpu(&master, &vm_id)) { //if cpu has been assigned to vm_assign struct
    fd800000b198:	350000a5 	cbnz	w5, fd800000b1ac <vmm_init+0x48c>
}
    fd800000b19c:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd800000b1a0:	a9425bf5 	ldp	x21, x22, [sp, #32]
    fd800000b1a4:	a8c57bfd 	ldp	x29, x30, [sp], #80
        cpu_idle();
    fd800000b1a8:	17fffec2 	b	fd800000acb0 <cpu_idle>
    fd800000b1ac:	a90363f7 	stp	x23, x24, [sp, #48]
    fd800000b1b0:	17ffff47 	b	fd800000aecc <vmm_init+0x1ac>
    total_size = vcpus_offset + (config->platform.cpu_num * sizeof(struct vcpu));
    fd800000b1b4:	f9401ee0 	ldr	x0, [x23, #56]
    fd800000b1b8:	d2813404 	mov	x4, #0x9a0                 	// #2464
    total_size = ALIGN(total_size, PAGE_SIZE);
    fd800000b1bc:	d28245e3 	mov	x3, #0x122f                	// #4655
    void* allocation = mem_alloc_page(NUM_PAGES(total_size), SEC_HYP_VM, false);
    fd800000b1c0:	52800002 	mov	w2, #0x0                   	// #0
    fd800000b1c4:	52800061 	mov	w1, #0x3                   	// #3
    fd800000b1c8:	a9046bf9 	stp	x25, x26, [sp, #64]
    total_size = ALIGN(total_size, PAGE_SIZE);
    fd800000b1cc:	9b040c00 	madd	x0, x0, x4, x3
    fd800000b1d0:	9274cc1a 	and	x26, x0, #0xfffffffffffff000
    void* allocation = mem_alloc_page(NUM_PAGES(total_size), SEC_HYP_VM, false);
    fd800000b1d4:	d34cfc00 	lsr	x0, x0, #12
    fd800000b1d8:	97fffbaa 	bl	fd800000a080 <mem_alloc_page>
    fd800000b1dc:	aa0003f9 	mov	x25, x0
    if (allocation == NULL) {
    fd800000b1e0:	b4000200 	cbz	x0, fd800000b220 <vmm_init+0x500>
    memset((void*)allocation, 0, total_size);   //clear all memory?
    fd800000b1e4:	aa1a03e2 	mov	x2, x26
    fd800000b1e8:	52800001 	mov	w1, #0x0                   	// #0
    fd800000b1ec:	97fff651 	bl	fd8000008b30 <memset>
    vm_alloc->base = (vaddr_t)allocation;
    fd800000b1f0:	8b1502d5 	add	x21, x22, x21
    vm_alloc->vcpus = (struct vcpu*)(vm_alloc->base + vcpus_offset);
    fd800000b1f4:	9108c321 	add	x1, x25, #0x230
        vm_assign[vm_id].vm_install_info = vmm_get_vm_install_info(vm_alloc);
    fd800000b1f8:	aa1803e0 	mov	x0, x24
    vm_alloc->size = total_size;
    fd800000b1fc:	a9026ab9 	stp	x25, x26, [x21, #32]
    vm_alloc->vcpus = (struct vcpu*)(vm_alloc->base + vcpus_offset);
    fd800000b200:	a90306b9 	stp	x25, x1, [x21, #48]
        vm_assign[vm_id].vm_install_info = vmm_get_vm_install_info(vm_alloc);
    fd800000b204:	94000f4b 	bl	fd800000ef30 <vmm_get_vm_install_info>
    fd800000b208:	a90406a0 	stp	x0, x1, [x21, #64]
    DMB(ishst);
    fd800000b20c:	d5033abf 	dmb	ishst
        vm_assign[vm_id].install_info_ready = true;
    fd800000b210:	a9446bf9 	ldp	x25, x26, [sp, #64]
    fd800000b214:	52800020 	mov	w0, #0x1                   	// #1
    fd800000b218:	390142a0 	strb	w0, [x21, #80]
    fd800000b21c:	17ffff3b 	b	fd800000af08 <vmm_init+0x1e8>
            ERROR("Failed to allocate vm internal structures");
    fd800000b220:	90000000 	adrp	x0, fd800000b000 <vmm_init+0x2e0>
    fd800000b224:	f9412c00 	ldr	x0, [x0, #600]
    fd800000b228:	9400037e 	bl	fd800000c020 <console_printk>
    fd800000b22c:	14000000 	b	fd800000b22c <vmm_init+0x50c>
    vmid_t vm_id = -1;
    fd800000b230:	92800014 	mov	x20, #0xffffffffffffffff    	// #-1
    *master = false;
    fd800000b234:	52800013 	mov	w19, #0x0                   	// #0
    fd800000b238:	17fffefe 	b	fd800000ae30 <vmm_init+0x110>
    fd800000b23c:	d503201f 	nop
    fd800000b240:	00016000 	.word	0x00016000
    fd800000b244:	0000fd80 	.word	0x0000fd80
    fd800000b248:	00012bf0 	.word	0x00012bf0
    fd800000b24c:	0000fd80 	.word	0x0000fd80
    fd800000b250:	0001bc10 	.word	0x0001bc10
    fd800000b254:	0000fd80 	.word	0x0000fd80
    fd800000b258:	00010cd8 	.word	0x00010cd8
    fd800000b25c:	0000fd80 	.word	0x0000fd80

0000fd800000b260 <vm_cpu_init>:
    vm_mem_prot_init(vm, config);
}

void vm_cpu_init(struct vm* vm)
{
    spin_lock(&vm->lock);
    fd800000b260:	91004001 	add	x1, x0, #0x10
    fd800000b264:	91005005 	add	x5, x0, #0x14
    fd800000b268:	885ffc22 	ldaxr	w2, [x1]
    fd800000b26c:	11000443 	add	w3, w2, #0x1
    fd800000b270:	88047c23 	stxr	w4, w3, [x1]
    fd800000b274:	35ffffa4 	cbnz	w4, fd800000b268 <vm_cpu_init+0x8>
    fd800000b278:	88dffca3 	ldar	w3, [x5]
    fd800000b27c:	6b03005f 	cmp	w2, w3
    fd800000b280:	54000060 	b.eq	fd800000b28c <vm_cpu_init+0x2c>  // b.none
    fd800000b284:	d503205f 	wfe
    fd800000b288:	17fffffc 	b	fd800000b278 <vm_cpu_init+0x18>
    vm->cpus |= (1UL << cpu()->id);
    fd800000b28c:	d2dfc004 	mov	x4, #0xfe0000000000        	// #279275953455104
    fd800000b290:	d2800023 	mov	x3, #0x1                   	// #1
    fd800000b294:	f9402802 	ldr	x2, [x0, #80]
    fd800000b298:	f9400084 	ldr	x4, [x4]
    fd800000b29c:	9ac42063 	lsl	x3, x3, x4
    fd800000b2a0:	aa030042 	orr	x2, x2, x3
    fd800000b2a4:	f9002802 	str	x2, [x0, #80]
    __asm__ volatile(
    fd800000b2a8:	b94000a0 	ldr	w0, [x5]
    fd800000b2ac:	11000400 	add	w0, w0, #0x1
    fd800000b2b0:	889ffca0 	stlr	w0, [x5]
    fd800000b2b4:	d5033b9f 	dsb	ish
    fd800000b2b8:	d503209f 	sev
    spin_unlock(&vm->lock);
}
    fd800000b2bc:	d65f03c0 	ret

0000fd800000b2c0 <vm_vcpu_init>:
    }
    return vcpu_id;
}

void vm_vcpu_init(struct vm* vm, const struct vm_config* config)
{
    fd800000b2c0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    for (size_t i = 0; i < cpu()->id; i++) {
    fd800000b2c4:	d2dfc002 	mov	x2, #0xfe0000000000        	// #279275953455104
{
    fd800000b2c8:	aa0003e8 	mov	x8, x0
    fd800000b2cc:	910003fd 	mov	x29, sp
    for (size_t i = 0; i < cpu()->id; i++) {
    fd800000b2d0:	f9400045 	ldr	x5, [x2]
{
    fd800000b2d4:	a90153f3 	stp	x19, x20, [sp, #16]
    fd800000b2d8:	aa0103f4 	mov	x20, x1
    for (size_t i = 0; i < cpu()->id; i++) {
    fd800000b2dc:	b40003c5 	cbz	x5, fd800000b354 <vm_vcpu_init+0x94>
        if (!!bit_get(vm->cpus, i)) {
    fd800000b2e0:	f9402807 	ldr	x7, [x0, #80]
    vcpuid_t vcpu_id = 0;
    fd800000b2e4:	d2800003 	mov	x3, #0x0                   	// #0
    for (size_t i = 0; i < cpu()->id; i++) {
    fd800000b2e8:	d2800002 	mov	x2, #0x0                   	// #0
BIT_OPS_GEN(bit, unsigned long, (1UL), BIT_MASK);
    fd800000b2ec:	d2800026 	mov	x6, #0x1                   	// #1
    fd800000b2f0:	9ac220c4 	lsl	x4, x6, x2
    fd800000b2f4:	91000442 	add	x2, x2, #0x1
            vcpu_id++;
    fd800000b2f8:	ea07009f 	tst	x4, x7
    fd800000b2fc:	9a830463 	cinc	x3, x3, ne	// ne = any
    for (size_t i = 0; i < cpu()->id; i++) {
    fd800000b300:	eb0200bf 	cmp	x5, x2
    fd800000b304:	54ffff61 	b.ne	fd800000b2f0 <vm_vcpu_init+0x30>  // b.any
    if (vcpuid < vm->cpu_num) {
    fd800000b308:	f9402500 	ldr	x0, [x8, #72]
    fd800000b30c:	eb03001f 	cmp	x0, x3
    fd800000b310:	54000269 	b.ls	fd800000b35c <vm_vcpu_init+0x9c>  // b.plast
        return &vm->vcpus[vcpuid];
    fd800000b314:	f9402100 	ldr	x0, [x8, #64]
    fd800000b318:	d2813413 	mov	x19, #0x9a0                 	// #2464
    struct vcpu* vcpu = vm_get_vcpu(vm, vcpu_id);

    vcpu->id = vcpu_id;
    vcpu->phys_id = cpu()->id;
    vcpu->vm = vm;
    cpu()->vcpu = vcpu;
    fd800000b31c:	d2dfc002 	mov	x2, #0xfe0000000000        	// #279275953455104

    vcpu_arch_init(vcpu, vm);
    fd800000b320:	aa0803e1 	mov	x1, x8
    fd800000b324:	9b130073 	madd	x19, x3, x19, x0
    fd800000b328:	aa1303e0 	mov	x0, x19
    vcpu->id = vcpu_id;
    fd800000b32c:	f904be63 	str	x3, [x19, #2424]
    vcpu->phys_id = cpu()->id;
    fd800000b330:	f904c265 	str	x5, [x19, #2432]
    vcpu->vm = vm;
    fd800000b334:	f904ca68 	str	x8, [x19, #2448]
    cpu()->vcpu = vcpu;
    fd800000b338:	f9002853 	str	x19, [x2, #80]
    vcpu_arch_init(vcpu, vm);
    fd800000b33c:	97ffe055 	bl	fd8000003490 <vcpu_arch_init>
    vcpu_arch_reset(vcpu, config->entry);
    fd800000b340:	f9401281 	ldr	x1, [x20, #32]
    fd800000b344:	aa1303e0 	mov	x0, x19
}
    fd800000b348:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd800000b34c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    vcpu_arch_reset(vcpu, config->entry);
    fd800000b350:	17ffe06c 	b	fd8000003500 <vcpu_arch_reset>
    vcpuid_t vcpu_id = 0;
    fd800000b354:	d2800003 	mov	x3, #0x0                   	// #0
    fd800000b358:	17ffffec 	b	fd800000b308 <vm_vcpu_init+0x48>
    vcpu->id = vcpu_id;
    fd800000b35c:	d2800000 	mov	x0, #0x0                   	// #0
    fd800000b360:	f904bc1f 	str	xzr, [x0, #2424]
    fd800000b364:	d4207d00 	brk	#0x3e8
    fd800000b368:	d503201f 	nop
    fd800000b36c:	d503201f 	nop

0000fd800000b370 <vm_map_mem_region>:

void vm_map_mem_region(struct vm* vm, struct vm_mem_region* reg)
{
    fd800000b370:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    fd800000b374:	d2800002 	mov	x2, #0x0                   	// #0
    fd800000b378:	910003fd 	mov	x29, sp
    size_t n = NUM_PAGES(reg->size);
    fd800000b37c:	f9400424 	ldr	x4, [x1, #8]
{
    fd800000b380:	f9000bf3 	str	x19, [sp, #16]
    fd800000b384:	aa0103f3 	mov	x19, x1

    struct ppages pa_reg;
    struct ppages* pa_ptr = NULL;
    if (reg->place_phys) {
    fd800000b388:	39406021 	ldrb	w1, [x1, #24]
    size_t n = NUM_PAGES(reg->size);
    fd800000b38c:	913ffc84 	add	x4, x4, #0xfff
    fd800000b390:	d34cfc84 	lsr	x4, x4, #12
    if (reg->place_phys) {
    fd800000b394:	360000c1 	tbz	w1, #0, fd800000b3ac <vm_map_mem_region+0x3c>
        pa_reg = mem_ppages_get(reg->phys, n);
        pa_reg.colors = reg->colors;
    fd800000b398:	f9400a61 	ldr	x1, [x19, #16]
        pa_ptr = &pa_reg;
    fd800000b39c:	9100a3e2 	add	x2, sp, #0x28
        pa_reg = mem_ppages_get(reg->phys, n);
    fd800000b3a0:	f9401263 	ldr	x3, [x19, #32]
    fd800000b3a4:	a90293e3 	stp	x3, x4, [sp, #40]
        pa_reg.colors = reg->colors;
    fd800000b3a8:	f9001fe1 	str	x1, [sp, #56]
    } else {
        pa_ptr = NULL;
    }

    vaddr_t va = mem_alloc_map(&vm->as, SEC_VM_ANY, pa_ptr, (vaddr_t)reg->base, n, PTE_VM_FLAGS);
    fd800000b3ac:	f9400263 	ldr	x3, [x19]
    fd800000b3b0:	52800001 	mov	w1, #0x0                   	// #0
    fd800000b3b4:	91016000 	add	x0, x0, #0x58
    fd800000b3b8:	d2809f85 	mov	x5, #0x4fc                 	// #1276
    fd800000b3bc:	94000e91 	bl	fd800000ee00 <mem_alloc_map>
    if (va != (vaddr_t)reg->base) {
    fd800000b3c0:	f9400261 	ldr	x1, [x19]
    fd800000b3c4:	eb00003f 	cmp	x1, x0
    fd800000b3c8:	54000081 	b.ne	fd800000b3d8 <vm_map_mem_region+0x68>  // b.any
        ERROR("failed to allocate vm's region at 0x%lx", reg->base);
    }
}
    fd800000b3cc:	f9400bf3 	ldr	x19, [sp, #16]
    fd800000b3d0:	a8c47bfd 	ldp	x29, x30, [sp], #64
    fd800000b3d4:	d65f03c0 	ret
        ERROR("failed to allocate vm's region at 0x%lx", reg->base);
    fd800000b3d8:	90000000 	adrp	x0, fd800000b000 <vmm_init+0x2e0>
    fd800000b3dc:	f941f400 	ldr	x0, [x0, #1000]
    fd800000b3e0:	94000310 	bl	fd800000c020 <console_printk>
    fd800000b3e4:	14000000 	b	fd800000b3e4 <vm_map_mem_region+0x74>
    fd800000b3e8:	00010d10 	.word	0x00010d10
    fd800000b3ec:	0000fd80 	.word	0x0000fd80

0000fd800000b3f0 <vm_init>:
    return vm;
}

struct vm* vm_init(struct vm_allocation* vm_alloc, const struct vm_config* config, bool master,
    vmid_t vm_id)
{
    fd800000b3f0:	a9b67bfd 	stp	x29, x30, [sp, #-160]!
    fd800000b3f4:	910003fd 	mov	x29, sp
    fd800000b3f8:	a9025bf5 	stp	x21, x22, [sp, #32]
    fd800000b3fc:	12001c56 	and	w22, w2, #0xff
    vm->vcpus = vm_alloc->vcpus;
    fd800000b400:	a9410015 	ldp	x21, x0, [x0, #16]
{
    fd800000b404:	a90153f3 	stp	x19, x20, [sp, #16]
    fd800000b408:	aa0103f4 	mov	x20, x1
    fd800000b40c:	a90363f7 	stp	x23, x24, [sp, #48]
    struct vm* vm = vm_allocation_init(vm_alloc);

    /**
     * Before anything else, initialize vm structure.
     */
    if (master) {
    fd800000b410:	12000057 	and	w23, w2, #0x1
    vm->vcpus = vm_alloc->vcpus;
    fd800000b414:	f90022a0 	str	x0, [x21, #64]
    if (master) {
    fd800000b418:	910062b3 	add	x19, x21, #0x18
    fd800000b41c:	37001f62 	tbnz	w2, #0, fd800000b808 <vm_init+0x418>
    }

    /*
     *  Initialize each core.
     */
    vm_cpu_init(vm);
    fd800000b420:	aa1503e0 	mov	x0, x21
    fd800000b424:	97ffff8f 	bl	fd800000b260 <vm_cpu_init>
    fd800000b428:	39404260 	ldrb	w0, [x19, #16]
    fd800000b42c:	3607ffe0 	tbz	w0, #0, fd800000b428 <vm_init+0x38>
    __asm__ volatile(
    fd800000b430:	91001263 	add	x3, x19, #0x4
    fd800000b434:	885ffe60 	ldaxr	w0, [x19]
    fd800000b438:	11000401 	add	w1, w0, #0x1
    fd800000b43c:	88027e61 	stxr	w2, w1, [x19]
    fd800000b440:	35ffffa2 	cbnz	w2, fd800000b434 <vm_init+0x44>
    fd800000b444:	88dffc61 	ldar	w1, [x3]
    fd800000b448:	6b01001f 	cmp	w0, w1
    fd800000b44c:	54000060 	b.eq	fd800000b458 <vm_init+0x68>  // b.none
    fd800000b450:	d503205f 	wfe
    fd800000b454:	17fffffc 	b	fd800000b444 <vm_init+0x54>
    token->count++;
    fd800000b458:	f9400e60 	ldr	x0, [x19, #24]
    fd800000b45c:	91000400 	add	x0, x0, #0x1
    fd800000b460:	f9000e60 	str	x0, [x19, #24]
    next_count = ALIGN(token->count, token->n);
    fd800000b464:	f9400e61 	ldr	x1, [x19, #24]
    fd800000b468:	f9400660 	ldr	x0, [x19, #8]
    fd800000b46c:	f9400662 	ldr	x2, [x19, #8]
    fd800000b470:	8b000021 	add	x1, x1, x0
    fd800000b474:	d1000421 	sub	x1, x1, #0x1
    fd800000b478:	f9400660 	ldr	x0, [x19, #8]
    fd800000b47c:	9ac20821 	udiv	x1, x1, x2
    fd800000b480:	9b007c21 	mul	x1, x1, x0
    __asm__ volatile(
    fd800000b484:	b9400060 	ldr	w0, [x3]
    fd800000b488:	11000400 	add	w0, w0, #0x1
    fd800000b48c:	889ffc60 	stlr	w0, [x3]
    fd800000b490:	d5033b9f 	dsb	ish
    fd800000b494:	d503209f 	sev
    while (token->count < next_count) { }
    fd800000b498:	f9400e60 	ldr	x0, [x19, #24]
    fd800000b49c:	eb00003f 	cmp	x1, x0
    fd800000b4a0:	54ffffc8 	b.hi	fd800000b498 <vm_init+0xa8>  // b.pmore
    cpu_sync_barrier(&vm->sync);

    /*
     *  Initialize each virtual core.
     */
    vm_vcpu_init(vm, config);
    fd800000b4a4:	aa1403e1 	mov	x1, x20
    fd800000b4a8:	aa1503e0 	mov	x0, x21
    fd800000b4ac:	97ffff85 	bl	fd800000b2c0 <vm_vcpu_init>
    while (!token->ready) { }
    fd800000b4b0:	39404260 	ldrb	w0, [x19, #16]
    fd800000b4b4:	3607ffe0 	tbz	w0, #0, fd800000b4b0 <vm_init+0xc0>
    __asm__ volatile(
    fd800000b4b8:	91001263 	add	x3, x19, #0x4
    fd800000b4bc:	885ffe60 	ldaxr	w0, [x19]
    fd800000b4c0:	11000401 	add	w1, w0, #0x1
    fd800000b4c4:	88027e61 	stxr	w2, w1, [x19]
    fd800000b4c8:	35ffffa2 	cbnz	w2, fd800000b4bc <vm_init+0xcc>
    fd800000b4cc:	88dffc61 	ldar	w1, [x3]
    fd800000b4d0:	6b01001f 	cmp	w0, w1
    fd800000b4d4:	54000060 	b.eq	fd800000b4e0 <vm_init+0xf0>  // b.none
    fd800000b4d8:	d503205f 	wfe
    fd800000b4dc:	17fffffc 	b	fd800000b4cc <vm_init+0xdc>
    token->count++;
    fd800000b4e0:	f9400e60 	ldr	x0, [x19, #24]
    fd800000b4e4:	91000400 	add	x0, x0, #0x1
    fd800000b4e8:	f9000e60 	str	x0, [x19, #24]
    next_count = ALIGN(token->count, token->n);
    fd800000b4ec:	f9400e62 	ldr	x2, [x19, #24]
    fd800000b4f0:	f9400660 	ldr	x0, [x19, #8]
    fd800000b4f4:	f9400661 	ldr	x1, [x19, #8]
    fd800000b4f8:	8b000042 	add	x2, x2, x0
    fd800000b4fc:	d1000442 	sub	x2, x2, #0x1
    fd800000b500:	f9400660 	ldr	x0, [x19, #8]
    fd800000b504:	9ac10842 	udiv	x2, x2, x1
    fd800000b508:	9b007c42 	mul	x2, x2, x0
    __asm__ volatile(
    fd800000b50c:	b9400060 	ldr	w0, [x3]
    fd800000b510:	11000400 	add	w0, w0, #0x1
    fd800000b514:	889ffc60 	stlr	w0, [x3]
    fd800000b518:	d5033b9f 	dsb	ish
    fd800000b51c:	d503209f 	sev
    while (token->count < next_count) { }
    fd800000b520:	f9400e60 	ldr	x0, [x19, #24]
    fd800000b524:	eb00005f 	cmp	x2, x0
    fd800000b528:	54ffffc8 	b.hi	fd800000b520 <vm_init+0x130>  // b.pmore

    /**
     * Perform architecture dependent initializations. This includes, for example, setting the page
     * table pointer and other virtualization extensions specifics.
     */
    vm_arch_init(vm, config);
    fd800000b52c:	aa1403e1 	mov	x1, x20
    fd800000b530:	aa1503e0 	mov	x0, x21
    fd800000b534:	97ffdf63 	bl	fd80000032c0 <vm_arch_init>

    /**
     * Create the VM's address space according to configuration and where its image was loaded.
     */
    if (master) {
    fd800000b538:	35000ab7 	cbnz	w23, fd800000b68c <vm_init+0x29c>
    fd800000b53c:	d503201f 	nop
    while (!token->ready) { }
    fd800000b540:	39404260 	ldrb	w0, [x19, #16]
    fd800000b544:	3607ffe0 	tbz	w0, #0, fd800000b540 <vm_init+0x150>
    __asm__ volatile(
    fd800000b548:	91001263 	add	x3, x19, #0x4
    fd800000b54c:	885ffe60 	ldaxr	w0, [x19]
    fd800000b550:	11000401 	add	w1, w0, #0x1
    fd800000b554:	88027e61 	stxr	w2, w1, [x19]
    fd800000b558:	35ffffa2 	cbnz	w2, fd800000b54c <vm_init+0x15c>
    fd800000b55c:	88dffc61 	ldar	w1, [x3]
    fd800000b560:	6b01001f 	cmp	w0, w1
    fd800000b564:	54000060 	b.eq	fd800000b570 <vm_init+0x180>  // b.none
    fd800000b568:	d503205f 	wfe
    fd800000b56c:	17fffffc 	b	fd800000b55c <vm_init+0x16c>
    token->count++;
    fd800000b570:	f9400e60 	ldr	x0, [x19, #24]
    fd800000b574:	91000400 	add	x0, x0, #0x1
    fd800000b578:	f9000e60 	str	x0, [x19, #24]
    next_count = ALIGN(token->count, token->n);
    fd800000b57c:	f9400e74 	ldr	x20, [x19, #24]
    fd800000b580:	f9400660 	ldr	x0, [x19, #8]
    fd800000b584:	f9400661 	ldr	x1, [x19, #8]
    fd800000b588:	8b000294 	add	x20, x20, x0
    fd800000b58c:	d1000694 	sub	x20, x20, #0x1
    fd800000b590:	f9400660 	ldr	x0, [x19, #8]
    fd800000b594:	9ac10a94 	udiv	x20, x20, x1
    fd800000b598:	9b007e94 	mul	x20, x20, x0
    __asm__ volatile(
    fd800000b59c:	b9400060 	ldr	w0, [x3]
    fd800000b5a0:	11000400 	add	w0, w0, #0x1
    fd800000b5a4:	889ffc60 	stlr	w0, [x3]
    fd800000b5a8:	d5033b9f 	dsb	ish
    fd800000b5ac:	d503209f 	sev
        if (!cpu()->handling_msgs) {
    fd800000b5b0:	d2dfc016 	mov	x22, #0xfe0000000000        	// #279275953455104
    while (token->count < next_count) {
    fd800000b5b4:	f9400e61 	ldr	x1, [x19, #24]
        if (!cpu()->handling_msgs) {
    fd800000b5b8:	394022c0 	ldrb	w0, [x22, #8]
    while (token->count < next_count) {
    fd800000b5bc:	eb01029f 	cmp	x20, x1
        if (!cpu()->handling_msgs) {
    fd800000b5c0:	12000001 	and	w1, w0, #0x1
    while (token->count < next_count) {
    fd800000b5c4:	540000c9 	b.ls	fd800000b5dc <vm_init+0x1ec>  // b.plast
        if (!cpu()->handling_msgs) {
    fd800000b5c8:	36000560 	tbz	w0, #0, fd800000b674 <vm_init+0x284>
    fd800000b5cc:	d503201f 	nop
    while (token->count < next_count) {
    fd800000b5d0:	f9400e60 	ldr	x0, [x19, #24]
    fd800000b5d4:	eb14001f 	cmp	x0, x20
    fd800000b5d8:	54ffffc3 	b.cc	fd800000b5d0 <vm_init+0x1e0>  // b.lo, b.ul, b.last
    if (!cpu()->handling_msgs) {
    fd800000b5dc:	34000501 	cbz	w1, fd800000b67c <vm_init+0x28c>
    while (!token->ready) { }
    fd800000b5e0:	39404260 	ldrb	w0, [x19, #16]
    fd800000b5e4:	3607ffe0 	tbz	w0, #0, fd800000b5e0 <vm_init+0x1f0>
    __asm__ volatile(
    fd800000b5e8:	91001263 	add	x3, x19, #0x4
    fd800000b5ec:	885ffe60 	ldaxr	w0, [x19]
    fd800000b5f0:	11000401 	add	w1, w0, #0x1
    fd800000b5f4:	88027e61 	stxr	w2, w1, [x19]
    fd800000b5f8:	35ffffa2 	cbnz	w2, fd800000b5ec <vm_init+0x1fc>
    fd800000b5fc:	88dffc61 	ldar	w1, [x3]
    fd800000b600:	6b01001f 	cmp	w0, w1
    fd800000b604:	54000060 	b.eq	fd800000b610 <vm_init+0x220>  // b.none
    fd800000b608:	d503205f 	wfe
    fd800000b60c:	17fffffc 	b	fd800000b5fc <vm_init+0x20c>
    token->count++;
    fd800000b610:	f9400e60 	ldr	x0, [x19, #24]
    fd800000b614:	91000400 	add	x0, x0, #0x1
    fd800000b618:	f9000e60 	str	x0, [x19, #24]
    next_count = ALIGN(token->count, token->n);
    fd800000b61c:	f9400e61 	ldr	x1, [x19, #24]
    fd800000b620:	f9400660 	ldr	x0, [x19, #8]
    fd800000b624:	f9400662 	ldr	x2, [x19, #8]
    fd800000b628:	8b000021 	add	x1, x1, x0
    fd800000b62c:	d1000421 	sub	x1, x1, #0x1
    fd800000b630:	f9400660 	ldr	x0, [x19, #8]
    fd800000b634:	9ac20821 	udiv	x1, x1, x2
    fd800000b638:	9b007c21 	mul	x1, x1, x0
    __asm__ volatile(
    fd800000b63c:	b9400060 	ldr	w0, [x3]
    fd800000b640:	11000400 	add	w0, w0, #0x1
    fd800000b644:	889ffc60 	stlr	w0, [x3]
    fd800000b648:	d5033b9f 	dsb	ish
    fd800000b64c:	d503209f 	sev
    while (token->count < next_count) { }
    fd800000b650:	f9400e60 	ldr	x0, [x19, #24]
    fd800000b654:	eb00003f 	cmp	x1, x0
    fd800000b658:	54ffffc8 	b.hi	fd800000b650 <vm_init+0x260>  // b.pmore
    }

    cpu_sync_and_clear_msgs(&vm->sync);

    return vm;
}
    fd800000b65c:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd800000b660:	aa1503e0 	mov	x0, x21
    fd800000b664:	a9425bf5 	ldp	x21, x22, [sp, #32]
    fd800000b668:	a94363f7 	ldp	x23, x24, [sp, #48]
    fd800000b66c:	a8ca7bfd 	ldp	x29, x30, [sp], #160
    fd800000b670:	d65f03c0 	ret
            cpu_msg_handler();
    fd800000b674:	97fffd6b 	bl	fd800000ac20 <cpu_msg_handler>
    fd800000b678:	17ffffcf 	b	fd800000b5b4 <vm_init+0x1c4>
        cpu_msg_handler();
    fd800000b67c:	97fffd69 	bl	fd800000ac20 <cpu_msg_handler>
    while (!token->ready) { }
    fd800000b680:	39404260 	ldrb	w0, [x19, #16]
    fd800000b684:	3607fae0 	tbz	w0, #0, fd800000b5e0 <vm_init+0x1f0>
    fd800000b688:	17ffffd8 	b	fd800000b5e8 <vm_init+0x1f8>
    for (size_t i = 0; i < config->platform.region_num; i++) {
    fd800000b68c:	f9402280 	ldr	x0, [x20, #64]
    fd800000b690:	a9046bf9 	stp	x25, x26, [sp, #64]
    fd800000b694:	d280001a 	mov	x26, #0x0                   	// #0
    fd800000b698:	a90573fb 	stp	x27, x28, [sp, #80]
    fd800000b69c:	d280001c 	mov	x28, #0x0                   	// #0
    fd800000b6a0:	b4000780 	cbz	x0, fd800000b790 <vm_init+0x3a0>
    unsigned long limit1 = base1 + size1;
    fd800000b6a4:	9280001b 	mov	x27, #0xffffffffffffffff    	// #-1
        struct vm_mem_region* reg = &config->platform.regions[i];
    fd800000b6a8:	f9402680 	ldr	x0, [x20, #72]
    fd800000b6ac:	2a1603e2 	mov	w2, w22
            range_in_range(config->image.base_addr, config->image.size, reg->base, reg->size);
    fd800000b6b0:	f9400297 	ldr	x23, [x20]
        struct vm_mem_region* reg = &config->platform.regions[i];
    fd800000b6b4:	8b1a0018 	add	x24, x0, x26
            range_in_range(config->image.base_addr, config->image.size, reg->base, reg->size);
    fd800000b6b8:	f9400a81 	ldr	x1, [x20, #16]
    fd800000b6bc:	f87a6803 	ldr	x3, [x0, x26]
    fd800000b6c0:	ab0102e4 	adds	x4, x23, x1
    fd800000b6c4:	f9400700 	ldr	x0, [x24, #8]
    unsigned long limit2 = base2 + size2;
    fd800000b6c8:	9a9f37e8 	cset	x8, cs	// cs = hs, nlast
    fd800000b6cc:	ab000060 	adds	x0, x3, x0
    fd800000b6d0:	9a9f37e5 	cset	x5, cs	// cs = hs, nlast
    unsigned long limit1 = base1 + size1;
    fd800000b6d4:	f100011f 	cmp	x8, #0x0
    fd800000b6d8:	9a9b0088 	csel	x8, x4, x27, eq	// eq = none
    if (limit2 < base2) {
    fd800000b6dc:	b5000065 	cbnz	x5, fd800000b6e8 <vm_init+0x2f8>
    return (base1 >= base2) && (limit1 <= limit2);
    fd800000b6e0:	eb08001f 	cmp	x0, x8
    fd800000b6e4:	1a9f37e2 	cset	w2, cs	// cs = hs, nlast
    fd800000b6e8:	7100005f 	cmp	w2, #0x0
        if (img_is_in_rgn) {
    fd800000b6ec:	fa4312e0 	ccmp	x23, x3, #0x0, ne	// ne = any
    fd800000b6f0:	54000403 	b.cc	fd800000b770 <vm_init+0x380>  // b.lo, b.ul, b.last
    if (!reg->place_phys && config->image.inplace) {
    fd800000b6f4:	39406302 	ldrb	w2, [x24, #24]
    fd800000b6f8:	37000062 	tbnz	w2, #0, fd800000b704 <vm_init+0x314>
    fd800000b6fc:	39406682 	ldrb	w2, [x20, #25]
    fd800000b700:	370014a2 	tbnz	w2, #0, fd800000b994 <vm_init+0x5a4>
        vm_map_mem_region(vm, reg);
    fd800000b704:	aa1503e0 	mov	x0, x21
    fd800000b708:	aa1803e1 	mov	x1, x24
    fd800000b70c:	97ffff19 	bl	fd800000b370 <vm_map_mem_region>
    if (reg->place_phys) {
    fd800000b710:	39406300 	ldrb	w0, [x24, #24]
    fd800000b714:	36000960 	tbz	w0, #0, fd800000b840 <vm_init+0x450>
        paddr_t img_base = (paddr_t)vm->config->image.base_addr;
    fd800000b718:	f94006a0 	ldr	x0, [x21, #8]
        paddr_t img_load_pa = vm->config->image.load_addr;
    fd800000b71c:	a9402002 	ldp	x2, x8, [x0]
        size_t img_sz = vm->config->image.size;
    fd800000b720:	f9400800 	ldr	x0, [x0, #16]
        if (img_base == img_load_pa) {
    fd800000b724:	eb08005f 	cmp	x2, x8
    fd800000b728:	540002a0 	b.eq	fd800000b77c <vm_init+0x38c>  // b.none
    vaddr_t reg2_lim = base2 + size2 - 1;
    fd800000b72c:	8b000101 	add	x1, x8, x0
    fd800000b730:	d1000421 	sub	x1, x1, #0x1
    return (base1 >= base2 && base1 <= reg2_lim) || (reg1_lim >= base2 && reg1_lim <= reg2_lim) ||
    fd800000b734:	fa412042 	ccmp	x2, x1, #0x2, cs	// cs = hs, nlast
    fd800000b738:	54000149 	b.ls	fd800000b760 <vm_init+0x370>  // b.plast
    vaddr_t reg1_lim = base1 + size1 - 1;
    fd800000b73c:	8b000043 	add	x3, x2, x0
    fd800000b740:	d1000463 	sub	x3, x3, #0x1
    return (base1 >= base2 && base1 <= reg2_lim) || (reg1_lim >= base2 && reg1_lim <= reg2_lim) ||
    fd800000b744:	eb03011f 	cmp	x8, x3
    fd800000b748:	fa419062 	ccmp	x3, x1, #0x2, ls	// ls = plast
    fd800000b74c:	540000a9 	b.ls	fd800000b760 <vm_init+0x370>  // b.plast
        (base1 <= base2 && reg1_lim >= reg2_lim);
    fd800000b750:	eb08005f 	cmp	x2, x8
    return (base1 >= base2 && base1 <= reg2_lim) || (reg1_lim >= base2 && reg1_lim <= reg2_lim) ||
    fd800000b754:	fa419060 	ccmp	x3, x1, #0x0, ls	// ls = plast
    fd800000b758:	54000783 	b.cc	fd800000b848 <vm_init+0x458>  // b.lo, b.ul, b.last
    fd800000b75c:	d503201f 	nop
            ERROR("failed installing vm image. Image load region overlaps with"
    fd800000b760:	90000000 	adrp	x0, fd800000b000 <vmm_init+0x2e0>
    fd800000b764:	f945c800 	ldr	x0, [x0, #2960]
    fd800000b768:	9400022e 	bl	fd800000c020 <console_printk>
    fd800000b76c:	14000000 	b	fd800000b76c <vm_init+0x37c>
            vm_map_mem_region(vm, reg);
    fd800000b770:	aa1803e1 	mov	x1, x24
    fd800000b774:	aa1503e0 	mov	x0, x21
    fd800000b778:	97fffefe 	bl	fd800000b370 <vm_map_mem_region>
    for (size_t i = 0; i < config->platform.region_num; i++) {
    fd800000b77c:	f9402280 	ldr	x0, [x20, #64]
    fd800000b780:	9100079c 	add	x28, x28, #0x1
    fd800000b784:	9100a35a 	add	x26, x26, #0x28
    fd800000b788:	eb00039f 	cmp	x28, x0
    fd800000b78c:	54fff8e3 	b.cc	fd800000b6a8 <vm_init+0x2b8>  // b.lo, b.ul, b.last
    for (size_t i = 0; i < config->platform.dev_num; i++) {
    fd800000b790:	f9403280 	ldr	x0, [x20, #96]
    fd800000b794:	d2800019 	mov	x25, #0x0                   	// #0
    fd800000b798:	d280001a 	mov	x26, #0x0                   	// #0
    fd800000b79c:	b4000c00 	cbz	x0, fd800000b91c <vm_init+0x52c>
        struct vm_dev_region* dev = &config->platform.devs[i];
    fd800000b7a0:	f9403680 	ldr	x0, [x20, #104]
    fd800000b7a4:	8b190018 	add	x24, x0, x25
        if (dev->va != INVALID_VA) {
    fd800000b7a8:	f9400702 	ldr	x2, [x24, #8]
    fd800000b7ac:	b100045f 	cmn	x2, #0x1
    fd800000b7b0:	54000e21 	b.ne	fd800000b974 <vm_init+0x584>  // b.any
        for (size_t j = 0; j < dev->interrupt_num; j++) {
    fd800000b7b4:	f9400f00 	ldr	x0, [x24, #24]
    fd800000b7b8:	d2800017 	mov	x23, #0x0                   	// #0
    fd800000b7bc:	d2800016 	mov	x22, #0x0                   	// #0
    fd800000b7c0:	b50000c0 	cbnz	x0, fd800000b7d8 <vm_init+0x3e8>
    fd800000b7c4:	14000051 	b	fd800000b908 <vm_init+0x518>
    fd800000b7c8:	f9400f00 	ldr	x0, [x24, #24]
    fd800000b7cc:	910012f7 	add	x23, x23, #0x4
    fd800000b7d0:	eb0002df 	cmp	x22, x0
    fd800000b7d4:	540009a2 	b.cs	fd800000b908 <vm_init+0x518>  // b.hs, b.nlast
            if (!interrupts_vm_assign(vm, dev->interrupts[j])) {
    fd800000b7d8:	f9401301 	ldr	x1, [x24, #32]
    fd800000b7dc:	aa1503e0 	mov	x0, x21
        for (size_t j = 0; j < dev->interrupt_num; j++) {
    fd800000b7e0:	910006d6 	add	x22, x22, #0x1
            if (!interrupts_vm_assign(vm, dev->interrupts[j])) {
    fd800000b7e4:	b8776821 	ldr	w1, [x1, x23]
    fd800000b7e8:	97fffbaa 	bl	fd800000a690 <interrupts_vm_assign>
    fd800000b7ec:	3707fee0 	tbnz	w0, #0, fd800000b7c8 <vm_init+0x3d8>
                ERROR("Failed to assign interrupt id %d", dev->interrupts[j]);
    fd800000b7f0:	f9401301 	ldr	x1, [x24, #32]
    fd800000b7f4:	90000000 	adrp	x0, fd800000b000 <vmm_init+0x2e0>
    fd800000b7f8:	f945cc00 	ldr	x0, [x0, #2968]
    fd800000b7fc:	b8776821 	ldr	w1, [x1, x23]
    fd800000b800:	94000208 	bl	fd800000c020 <console_printk>
    fd800000b804:	14000000 	b	fd800000b804 <vm_init+0x414>
    vm->master = cpu()->id;
    fd800000b808:	d2dfc005 	mov	x5, #0xfe0000000000        	// #279275953455104
    token->ready = true;
    fd800000b80c:	52800024 	mov	w4, #0x1                   	// #1
    vm->cpu_num = config->platform.cpu_num;
    fd800000b810:	f9401c22 	ldr	x2, [x1, #56]
    vm_mem_prot_init(vm, config);
    fd800000b814:	aa1503e0 	mov	x0, x21
    vm->master = cpu()->id;
    fd800000b818:	f94000a5 	ldr	x5, [x5]
    vm->config = config;
    fd800000b81c:	a90006a3 	stp	x3, x1, [x21]
    token->lock = SPINLOCK_INITVAL;
    fd800000b820:	f9000ebf 	str	xzr, [x21, #24]
    vm->master = cpu()->id;
    fd800000b824:	f9001ea5 	str	x5, [x21, #56]
    vm->cpu_num = config->platform.cpu_num;
    fd800000b828:	f90026a2 	str	x2, [x21, #72]
    token->n = n;
    fd800000b82c:	f9000662 	str	x2, [x19, #8]
    token->count = 0;
    fd800000b830:	f9000e7f 	str	xzr, [x19, #24]
    token->ready = true;
    fd800000b834:	39004264 	strb	w4, [x19, #16]
    vm_mem_prot_init(vm, config);
    fd800000b838:	94000dde 	bl	fd800000efb0 <vm_mem_prot_init>
}
    fd800000b83c:	17fffef9 	b	fd800000b420 <vm_init+0x30>
        paddr_t img_base = (paddr_t)vm->config->image.base_addr;
    fd800000b840:	f94006a0 	ldr	x0, [x21, #8]
        size_t img_sz = vm->config->image.size;
    fd800000b844:	a9408008 	ldp	x8, x0, [x0, #8]
    size_t img_num_pages = NUM_PAGES(vm->config->image.size);
    fd800000b848:	913ffc00 	add	x0, x0, #0xfff
    vaddr_t src_va = mem_alloc_map(&cpu()->as, SEC_HYP_GLOBAL, &img_ppages, INVALID_VA,
    fd800000b84c:	d280e885 	mov	x5, #0x744                 	// #1860
    fd800000b850:	9101e3e2 	add	x2, sp, #0x78
    size_t img_num_pages = NUM_PAGES(vm->config->image.size);
    fd800000b854:	d34cfc17 	lsr	x23, x0, #12
    vaddr_t src_va = mem_alloc_map(&cpu()->as, SEC_HYP_GLOBAL, &img_ppages, INVALID_VA,
    fd800000b858:	d2800200 	mov	x0, #0x10                  	// #16
    fd800000b85c:	aa1703e4 	mov	x4, x23
    fd800000b860:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
    fd800000b864:	52800001 	mov	w1, #0x0                   	// #0
    fd800000b868:	f2dfc000 	movk	x0, #0xfe00, lsl #32
    return (struct ppages){ .colors = 0, .base = base, .num_pages = num_pages };
    fd800000b86c:	a907dfe8 	stp	x8, x23, [sp, #120]
    for (size_t i = 0; i < config->platform.region_num; i++) {
    fd800000b870:	9100079c 	add	x28, x28, #0x1
    fd800000b874:	9100a35a 	add	x26, x26, #0x28
    fd800000b878:	f90047ff 	str	xzr, [sp, #136]
    vaddr_t src_va = mem_alloc_map(&cpu()->as, SEC_HYP_GLOBAL, &img_ppages, INVALID_VA,
    fd800000b87c:	94000d61 	bl	fd800000ee00 <mem_alloc_map>
        mem_map_cpy(&vm->as, &cpu()->as, vm->config->image.base_addr, INVALID_VA, img_num_pages);
    fd800000b880:	f94006a2 	ldr	x2, [x21, #8]
    fd800000b884:	d2800201 	mov	x1, #0x10                  	// #16
    fd800000b888:	aa1703e4 	mov	x4, x23
    fd800000b88c:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
    vaddr_t src_va = mem_alloc_map(&cpu()->as, SEC_HYP_GLOBAL, &img_ppages, INVALID_VA,
    fd800000b890:	aa0003f9 	mov	x25, x0
        mem_map_cpy(&vm->as, &cpu()->as, vm->config->image.base_addr, INVALID_VA, img_num_pages);
    fd800000b894:	f2dfc001 	movk	x1, #0xfe00, lsl #32
    fd800000b898:	f9400042 	ldr	x2, [x2]
    fd800000b89c:	910162a0 	add	x0, x21, #0x58
    fd800000b8a0:	94000ad0 	bl	fd800000e3e0 <mem_map_cpy>
    fd800000b8a4:	aa0003f8 	mov	x24, x0
    memcpy((void*)dst_va, (void*)src_va, vm->config->image.size);
    fd800000b8a8:	f94006a2 	ldr	x2, [x21, #8]
    fd800000b8ac:	aa1903e1 	mov	x1, x25
    fd800000b8b0:	f9400842 	ldr	x2, [x2, #16]
    fd800000b8b4:	97fff477 	bl	fd8000008a90 <memcpy>
    cache_flush_range((vaddr_t)dst_va, vm->config->image.size);
    fd800000b8b8:	f94006a1 	ldr	x1, [x21, #8]
    fd800000b8bc:	aa1803e0 	mov	x0, x24
    fd800000b8c0:	f9400821 	ldr	x1, [x1, #16]
    fd800000b8c4:	97ffde2f 	bl	fd8000003180 <cache_flush_range>
    mem_unmap(&cpu()->as, src_va, img_num_pages, false);
    fd800000b8c8:	d2800200 	mov	x0, #0x10                  	// #16
    fd800000b8cc:	aa1903e1 	mov	x1, x25
    fd800000b8d0:	aa1703e2 	mov	x2, x23
    fd800000b8d4:	f2dfc000 	movk	x0, #0xfe00, lsl #32
    fd800000b8d8:	52800003 	mov	w3, #0x0                   	// #0
    fd800000b8dc:	94000719 	bl	fd800000d540 <mem_unmap>
    mem_unmap(&cpu()->as, dst_va, img_num_pages, false);
    fd800000b8e0:	d2800200 	mov	x0, #0x10                  	// #16
    fd800000b8e4:	aa1703e2 	mov	x2, x23
    fd800000b8e8:	f2dfc000 	movk	x0, #0xfe00, lsl #32
    fd800000b8ec:	aa1803e1 	mov	x1, x24
    fd800000b8f0:	52800003 	mov	w3, #0x0                   	// #0
    fd800000b8f4:	94000713 	bl	fd800000d540 <mem_unmap>
    for (size_t i = 0; i < config->platform.region_num; i++) {
    fd800000b8f8:	f9402280 	ldr	x0, [x20, #64]
    fd800000b8fc:	eb00039f 	cmp	x28, x0
    fd800000b900:	54ffed43 	b.cc	fd800000b6a8 <vm_init+0x2b8>  // b.lo, b.ul, b.last
    fd800000b904:	17ffffa3 	b	fd800000b790 <vm_init+0x3a0>
    for (size_t i = 0; i < config->platform.dev_num; i++) {
    fd800000b908:	f9403280 	ldr	x0, [x20, #96]
    fd800000b90c:	9100075a 	add	x26, x26, #0x1
    fd800000b910:	9100c339 	add	x25, x25, #0x30
    fd800000b914:	eb00035f 	cmp	x26, x0
    fd800000b918:	54fff443 	b.cc	fd800000b7a0 <vm_init+0x3b0>  // b.lo, b.ul, b.last
    if (io_vm_init(vm, config)) {
    fd800000b91c:	aa1403e1 	mov	x1, x20
    fd800000b920:	aa1503e0 	mov	x0, x21
    fd800000b924:	94000d77 	bl	fd800000ef00 <io_vm_init>
    fd800000b928:	36000a20 	tbz	w0, #0, fd800000ba6c <vm_init+0x67c>
        for (size_t i = 0; i < config->platform.dev_num; i++) {
    fd800000b92c:	f9403282 	ldr	x2, [x20, #96]
    fd800000b930:	b40009e2 	cbz	x2, fd800000ba6c <vm_init+0x67c>
    fd800000b934:	d2800017 	mov	x23, #0x0                   	// #0
    fd800000b938:	d2800016 	mov	x22, #0x0                   	// #0
    fd800000b93c:	14000005 	b	fd800000b950 <vm_init+0x560>
    fd800000b940:	910006d6 	add	x22, x22, #0x1
    fd800000b944:	9100c2f7 	add	x23, x23, #0x30
    fd800000b948:	eb0202df 	cmp	x22, x2
    fd800000b94c:	54000902 	b.cs	fd800000ba6c <vm_init+0x67c>  // b.hs, b.nlast
            if (dev->id) {
    fd800000b950:	f9403680 	ldr	x0, [x20, #104]
    fd800000b954:	8b170000 	add	x0, x0, x23
    fd800000b958:	b9402801 	ldr	w1, [x0, #40]
    fd800000b95c:	34ffff21 	cbz	w1, fd800000b940 <vm_init+0x550>
                if (!io_vm_add_device(vm, dev->id)) {
    fd800000b960:	aa1503e0 	mov	x0, x21
    fd800000b964:	94000d6b 	bl	fd800000ef10 <io_vm_add_device>
    fd800000b968:	36001080 	tbz	w0, #0, fd800000bb78 <vm_init+0x788>
    fd800000b96c:	f9403282 	ldr	x2, [x20, #96]
    fd800000b970:	17fffff4 	b	fd800000b940 <vm_init+0x550>
        size_t n = ALIGN(dev->size, PAGE_SIZE) / PAGE_SIZE;
    fd800000b974:	f9400b04 	ldr	x4, [x24, #16]
            mem_alloc_map_dev(&vm->as, SEC_VM_ANY, (vaddr_t)dev->va, dev->pa, n);
    fd800000b978:	52800001 	mov	w1, #0x0                   	// #0
    fd800000b97c:	f8796803 	ldr	x3, [x0, x25]
        size_t n = ALIGN(dev->size, PAGE_SIZE) / PAGE_SIZE;
    fd800000b980:	913ffc84 	add	x4, x4, #0xfff
            mem_alloc_map_dev(&vm->as, SEC_VM_ANY, (vaddr_t)dev->va, dev->pa, n);
    fd800000b984:	910162a0 	add	x0, x21, #0x58
    fd800000b988:	d34cfc84 	lsr	x4, x4, #12
    fd800000b98c:	94000d39 	bl	fd800000ee70 <mem_alloc_map_dev>
    fd800000b990:	17ffff89 	b	fd800000b7b4 <vm_init+0x3c4>
    fd800000b994:	f9400688 	ldr	x8, [x20, #8]
    size_t n_aft = NUM_PAGES((reg->base + reg->size) - (img_base + img_size));
    fd800000b998:	cb040000 	sub	x0, x0, x4
    size_t n_before = NUM_PAGES(img_base - reg->base);
    fd800000b99c:	913ffee4 	add	x4, x23, #0xfff
    size_t n_img = NUM_PAGES(img_size);
    fd800000b9a0:	913ffc21 	add	x1, x1, #0xfff
    size_t n_before = NUM_PAGES(img_base - reg->base);
    fd800000b9a4:	cb030084 	sub	x4, x4, x3
    size_t n_aft = NUM_PAGES((reg->base + reg->size) - (img_base + img_size));
    fd800000b9a8:	913ffc18 	add	x24, x0, #0xfff
    size_t n_img = NUM_PAGES(img_size);
    fd800000b9ac:	d34cfc39 	lsr	x25, x1, #12
    mem_alloc_map(&vm->as, SEC_VM_ANY, NULL, (vaddr_t)reg->base, n_before, PTE_VM_FLAGS);
    fd800000b9b0:	910162a0 	add	x0, x21, #0x58
    fd800000b9b4:	d2800002 	mov	x2, #0x0                   	// #0
    fd800000b9b8:	52800001 	mov	w1, #0x0                   	// #0
    fd800000b9bc:	d34cfc84 	lsr	x4, x4, #12
    fd800000b9c0:	d2809f85 	mov	x5, #0x4fc                 	// #1276
    fd800000b9c4:	f90037e0 	str	x0, [sp, #104]
    size_t n_aft = NUM_PAGES((reg->base + reg->size) - (img_base + img_size));
    fd800000b9c8:	d34cff18 	lsr	x24, x24, #12
    fd800000b9cc:	a907e7e8 	stp	x8, x25, [sp, #120]
    fd800000b9d0:	f90047ff 	str	xzr, [sp, #136]
    mem_alloc_map(&vm->as, SEC_VM_ANY, NULL, (vaddr_t)reg->base, n_before, PTE_VM_FLAGS);
    fd800000b9d4:	94000d0b 	bl	fd800000ee00 <mem_alloc_map>
    colormap_t mask = (((colormap_t)1) << COLOR_NUM) - 1;
    fd800000b9d8:	90000000 	adrp	x0, fd800000b000 <vmm_init+0x2e0>
    fd800000b9dc:	f945c402 	ldr	x2, [x0, #2952]
    fd800000b9e0:	d2800020 	mov	x0, #0x1                   	// #1
    colormap_t masked_colors = clrs & mask;
    fd800000b9e4:	f94042a1 	ldr	x1, [x21, #128]
    colormap_t mask = (((colormap_t)1) << COLOR_NUM) - 1;
    fd800000b9e8:	f9400042 	ldr	x2, [x2]
    fd800000b9ec:	9ac22000 	lsl	x0, x0, x2
    fd800000b9f0:	d1000400 	sub	x0, x0, #0x1
    return (masked_colors == 0) || (masked_colors == mask);
    fd800000b9f4:	ea010001 	ands	x1, x0, x1
    if (all_clrs(vm->as.colors)) {
    fd800000b9f8:	fa411004 	ccmp	x0, x1, #0x4, ne	// ne = any
    fd800000b9fc:	540002a1 	b.ne	fd800000ba50 <vm_init+0x660>  // b.any
        mem_alloc_map(&vm->as, SEC_VM_ANY, &pa_img, img_base, n_img, PTE_VM_FLAGS);
    fd800000ba00:	f94037e0 	ldr	x0, [sp, #104]
    fd800000ba04:	aa1903e4 	mov	x4, x25
    fd800000ba08:	aa1703e3 	mov	x3, x23
    fd800000ba0c:	9101e3e2 	add	x2, sp, #0x78
    fd800000ba10:	d2809f85 	mov	x5, #0x4fc                 	// #1276
    fd800000ba14:	52800001 	mov	w1, #0x0                   	// #0
    fd800000ba18:	94000cfa 	bl	fd800000ee00 <mem_alloc_map>
    mem_alloc_map(&vm->as, SEC_VM_ANY, NULL, img_base + NUM_PAGES(img_size) * PAGE_SIZE, n_aft,
    fd800000ba1c:	f94037e0 	ldr	x0, [sp, #104]
    fd800000ba20:	aa1803e4 	mov	x4, x24
    fd800000ba24:	8b1932e3 	add	x3, x23, x25, lsl #12
    fd800000ba28:	d2809f85 	mov	x5, #0x4fc                 	// #1276
    fd800000ba2c:	d2800002 	mov	x2, #0x0                   	// #0
    fd800000ba30:	52800001 	mov	w1, #0x0                   	// #0
    fd800000ba34:	94000cf3 	bl	fd800000ee00 <mem_alloc_map>
    for (size_t i = 0; i < config->platform.region_num; i++) {
    fd800000ba38:	9100079c 	add	x28, x28, #0x1
    fd800000ba3c:	f9402280 	ldr	x0, [x20, #64]
    fd800000ba40:	9100a35a 	add	x26, x26, #0x28
    fd800000ba44:	eb00039f 	cmp	x28, x0
    fd800000ba48:	54ffe303 	b.cc	fd800000b6a8 <vm_init+0x2b8>  // b.lo, b.ul, b.last
    fd800000ba4c:	17ffff51 	b	fd800000b790 <vm_init+0x3a0>
        mem_map_reclr(&vm->as, img_base, &pa_img, n_img, PTE_VM_FLAGS);
    fd800000ba50:	f94037e0 	ldr	x0, [sp, #104]
    fd800000ba54:	aa1903e3 	mov	x3, x25
    fd800000ba58:	9101e3e2 	add	x2, sp, #0x78
    fd800000ba5c:	aa1703e1 	mov	x1, x23
    fd800000ba60:	d2809f84 	mov	x4, #0x4fc                 	// #1276
    fd800000ba64:	9400096f 	bl	fd800000e020 <mem_map_reclr>
    fd800000ba68:	17ffffed 	b	fd800000ba1c <vm_init+0x62c>
    vm->ipcs = config->platform.ipcs;
    fd800000ba6c:	a9457280 	ldp	x0, x28, [x20, #80]
    vm->ipc_num = config->platform.ipc_num;
    fd800000ba70:	f9010ea0 	str	x0, [x21, #536]
    vm->ipcs = config->platform.ipcs;
    fd800000ba74:	f90112bc 	str	x28, [x21, #544]
    for (size_t i = 0; i < config->platform.ipc_num; i++) {
    fd800000ba78:	d2800018 	mov	x24, #0x0                   	// #0
    fd800000ba7c:	d2800017 	mov	x23, #0x0                   	// #0
    fd800000ba80:	b40006e0 	cbz	x0, fd800000bb5c <vm_init+0x76c>
        shmem->cpu_masters |= (1ULL << cpu()->id);
    fd800000ba84:	d2dfc01a 	mov	x26, #0xfe0000000000        	// #279275953455104
    fd800000ba88:	d2800039 	mov	x25, #0x1                   	// #1
    fd800000ba8c:	14000026 	b	fd800000bb24 <vm_init+0x734>
        spin_lock(&shmem->lock);
    fd800000ba90:	9100a2c0 	add	x0, x22, #0x28
    __asm__ volatile(
    fd800000ba94:	9100b2c5 	add	x5, x22, #0x2c
    fd800000ba98:	885ffc01 	ldaxr	w1, [x0]
    fd800000ba9c:	11000422 	add	w2, w1, #0x1
    fd800000baa0:	88047c02 	stxr	w4, w2, [x0]
    fd800000baa4:	35ffffa4 	cbnz	w4, fd800000ba98 <vm_init+0x6a8>
    fd800000baa8:	88dffca2 	ldar	w2, [x5]
    fd800000baac:	6b02003f 	cmp	w1, w2
    fd800000bab0:	54000060 	b.eq	fd800000babc <vm_init+0x6cc>  // b.none
    fd800000bab4:	d503205f 	wfe
    fd800000bab8:	17fffffc 	b	fd800000baa8 <vm_init+0x6b8>
        shmem->cpu_masters |= (1ULL << cpu()->id);
    fd800000babc:	f9400342 	ldr	x2, [x26]
    fd800000bac0:	f94012c1 	ldr	x1, [x22, #32]
    fd800000bac4:	9ac22322 	lsl	x2, x25, x2
    fd800000bac8:	aa020021 	orr	x1, x1, x2
    fd800000bacc:	f90012c1 	str	x1, [x22, #32]
    __asm__ volatile(
    fd800000bad0:	b94000a0 	ldr	w0, [x5]
    fd800000bad4:	11000400 	add	w0, w0, #0x1
    fd800000bad8:	889ffca0 	stlr	w0, [x5]
    fd800000badc:	d5033b9f 	dsb	ish
    fd800000bae0:	d503209f 	sev
        struct vm_mem_region reg = {
    fd800000bae4:	f9400385 	ldr	x5, [x28]
        vm_map_mem_region(vm, &reg);
    fd800000bae8:	9101e3e1 	add	x1, sp, #0x78
        struct vm_mem_region reg = {
    fd800000baec:	f94006c4 	ldr	x4, [x22, #8]
        vm_map_mem_region(vm, &reg);
    fd800000baf0:	aa1503e0 	mov	x0, x21
        struct vm_mem_region reg = {
    fd800000baf4:	f9400ec2 	ldr	x2, [x22, #24]
    fd800000baf8:	a9078fe5 	stp	x5, x3, [sp, #120]
    fd800000bafc:	f90047e4 	str	x4, [sp, #136]
    fd800000bb00:	390243f9 	strb	w25, [sp, #144]
    fd800000bb04:	f9004fe2 	str	x2, [sp, #152]
        vm_map_mem_region(vm, &reg);
    fd800000bb08:	97fffe1a 	bl	fd800000b370 <vm_map_mem_region>
    for (size_t i = 0; i < config->platform.ipc_num; i++) {
    fd800000bb0c:	f9402a80 	ldr	x0, [x20, #80]
    fd800000bb10:	910006f7 	add	x23, x23, #0x1
    fd800000bb14:	9100a318 	add	x24, x24, #0x28
    fd800000bb18:	eb0002ff 	cmp	x23, x0
    fd800000bb1c:	54000202 	b.cs	fd800000bb5c <vm_init+0x76c>  // b.hs, b.nlast
        struct ipc* ipc = &config->platform.ipcs[i];
    fd800000bb20:	f9402e9c 	ldr	x28, [x20, #88]
    fd800000bb24:	8b18039c 	add	x28, x28, x24
        struct shmem* shmem = ipc_get_shmem(ipc->shmem_id);
    fd800000bb28:	f9400b80 	ldr	x0, [x28, #16]
    fd800000bb2c:	94000219 	bl	fd800000c390 <ipc_get_shmem>
    fd800000bb30:	aa0003f6 	mov	x22, x0
        if (shmem == NULL) {
    fd800000bb34:	b40001a0 	cbz	x0, fd800000bb68 <vm_init+0x778>
        if (ipc->size > shmem->size) {
    fd800000bb38:	f940001b 	ldr	x27, [x0]
        size_t size = ipc->size;
    fd800000bb3c:	f9400783 	ldr	x3, [x28, #8]
        if (ipc->size > shmem->size) {
    fd800000bb40:	eb1b007f 	cmp	x3, x27
    fd800000bb44:	54fffa69 	b.ls	fd800000ba90 <vm_init+0x6a0>  // b.plast
            WARNING("Trying to map region to smaller shared memory. Truncated");
    fd800000bb48:	90000000 	adrp	x0, fd800000b000 <vmm_init+0x2e0>
    fd800000bb4c:	f945d800 	ldr	x0, [x0, #2992]
    fd800000bb50:	94000134 	bl	fd800000c020 <console_printk>
            size = shmem->size;
    fd800000bb54:	aa1b03e3 	mov	x3, x27
    fd800000bb58:	17ffffce 	b	fd800000ba90 <vm_init+0x6a0>
    fd800000bb5c:	a9446bf9 	ldp	x25, x26, [sp, #64]
    fd800000bb60:	a94573fb 	ldp	x27, x28, [sp, #80]
    fd800000bb64:	17fffe77 	b	fd800000b540 <vm_init+0x150>
            WARNING("Invalid shmem id in configuration. Ignored.");
    fd800000bb68:	90000000 	adrp	x0, fd800000b000 <vmm_init+0x2e0>
    fd800000bb6c:	f945d400 	ldr	x0, [x0, #2984]
    fd800000bb70:	9400012c 	bl	fd800000c020 <console_printk>
            continue;
    fd800000bb74:	17ffffe6 	b	fd800000bb0c <vm_init+0x71c>
                    ERROR("Failed to add device to iommu");
    fd800000bb78:	90000000 	adrp	x0, fd800000b000 <vmm_init+0x2e0>
    fd800000bb7c:	f945d000 	ldr	x0, [x0, #2976]
    fd800000bb80:	94000128 	bl	fd800000c020 <console_printk>
    fd800000bb84:	14000000 	b	fd800000bb84 <vm_init+0x794>
    fd800000bb88:	00012828 	.word	0x00012828
    fd800000bb8c:	0000fd80 	.word	0x0000fd80
    fd800000bb90:	00010d48 	.word	0x00010d48
    fd800000bb94:	0000fd80 	.word	0x0000fd80
    fd800000bb98:	00010da8 	.word	0x00010da8
    fd800000bb9c:	0000fd80 	.word	0x0000fd80
    fd800000bba0:	00010dd8 	.word	0x00010dd8
    fd800000bba4:	0000fd80 	.word	0x0000fd80
    fd800000bba8:	00010e08 	.word	0x00010e08
    fd800000bbac:	0000fd80 	.word	0x0000fd80
    fd800000bbb0:	00010e48 	.word	0x00010e48
    fd800000bbb4:	0000fd80 	.word	0x0000fd80
    fd800000bbb8:	d503201f 	nop
    fd800000bbbc:	d503201f 	nop

0000fd800000bbc0 <vm_emul_add_mem>:
    if (list != NULL && node != NULL) {
    fd800000bbc0:	b5000041 	cbnz	x1, fd800000bbc8 <vm_emul_add_mem+0x8>

void vm_emul_add_mem(struct vm* vm, struct emul_mem* emu)
{
    list_push(&vm->emul_mem_list, &emu->node);
}
    fd800000bbc4:	d65f03c0 	ret
        spin_lock(&list->lock);
    fd800000bbc8:	9105a002 	add	x2, x0, #0x168
    fd800000bbcc:	91056003 	add	x3, x0, #0x158
    __asm__ volatile(
    fd800000bbd0:	91001047 	add	x7, x2, #0x4
        *node = NULL;
    fd800000bbd4:	f900003f 	str	xzr, [x1]
    fd800000bbd8:	885ffc44 	ldaxr	w4, [x2]
    fd800000bbdc:	11000485 	add	w5, w4, #0x1
    fd800000bbe0:	88067c45 	stxr	w6, w5, [x2]
    fd800000bbe4:	35ffffa6 	cbnz	w6, fd800000bbd8 <vm_emul_add_mem+0x18>
    fd800000bbe8:	88dffce5 	ldar	w5, [x7]
    fd800000bbec:	6b05009f 	cmp	w4, w5
    fd800000bbf0:	54000060 	b.eq	fd800000bbfc <vm_emul_add_mem+0x3c>  // b.none
    fd800000bbf4:	d503205f 	wfe
    fd800000bbf8:	17fffffc 	b	fd800000bbe8 <vm_emul_add_mem+0x28>
        if (list->tail != NULL) {
    fd800000bbfc:	f9400464 	ldr	x4, [x3, #8]
    fd800000bc00:	b4000044 	cbz	x4, fd800000bc08 <vm_emul_add_mem+0x48>
            *list->tail = node;
    fd800000bc04:	f9000081 	str	x1, [x4]
        if (list->head == NULL) {
    fd800000bc08:	f940ac04 	ldr	x4, [x0, #344]
        list->tail = node;
    fd800000bc0c:	f9000461 	str	x1, [x3, #8]
        if (list->head == NULL) {
    fd800000bc10:	b4000104 	cbz	x4, fd800000bc30 <vm_emul_add_mem+0x70>
    __asm__ volatile(
    fd800000bc14:	91001041 	add	x1, x2, #0x4
    fd800000bc18:	b9400020 	ldr	w0, [x1]
    fd800000bc1c:	11000400 	add	w0, w0, #0x1
    fd800000bc20:	889ffc20 	stlr	w0, [x1]
    fd800000bc24:	d5033b9f 	dsb	ish
    fd800000bc28:	d503209f 	sev
    fd800000bc2c:	d65f03c0 	ret
            list->head = node;
    fd800000bc30:	f900ac01 	str	x1, [x0, #344]
    fd800000bc34:	17fffff8 	b	fd800000bc14 <vm_emul_add_mem+0x54>
    fd800000bc38:	d503201f 	nop
    fd800000bc3c:	d503201f 	nop

0000fd800000bc40 <vm_emul_add_reg>:
    if (list != NULL && node != NULL) {
    fd800000bc40:	b5000041 	cbnz	x1, fd800000bc48 <vm_emul_add_reg+0x8>

void vm_emul_add_reg(struct vm* vm, struct emul_reg* emu)
{
    list_push(&vm->emul_reg_list, &emu->node);
}
    fd800000bc44:	d65f03c0 	ret
        spin_lock(&list->lock);
    fd800000bc48:	91060002 	add	x2, x0, #0x180
    fd800000bc4c:	9105c003 	add	x3, x0, #0x170
    __asm__ volatile(
    fd800000bc50:	91001047 	add	x7, x2, #0x4
        *node = NULL;
    fd800000bc54:	f900003f 	str	xzr, [x1]
    fd800000bc58:	885ffc44 	ldaxr	w4, [x2]
    fd800000bc5c:	11000485 	add	w5, w4, #0x1
    fd800000bc60:	88067c45 	stxr	w6, w5, [x2]
    fd800000bc64:	35ffffa6 	cbnz	w6, fd800000bc58 <vm_emul_add_reg+0x18>
    fd800000bc68:	88dffce5 	ldar	w5, [x7]
    fd800000bc6c:	6b05009f 	cmp	w4, w5
    fd800000bc70:	54000060 	b.eq	fd800000bc7c <vm_emul_add_reg+0x3c>  // b.none
    fd800000bc74:	d503205f 	wfe
    fd800000bc78:	17fffffc 	b	fd800000bc68 <vm_emul_add_reg+0x28>
        if (list->tail != NULL) {
    fd800000bc7c:	f9400464 	ldr	x4, [x3, #8]
    fd800000bc80:	b4000044 	cbz	x4, fd800000bc88 <vm_emul_add_reg+0x48>
            *list->tail = node;
    fd800000bc84:	f9000081 	str	x1, [x4]
        if (list->head == NULL) {
    fd800000bc88:	f940b804 	ldr	x4, [x0, #368]
        list->tail = node;
    fd800000bc8c:	f9000461 	str	x1, [x3, #8]
        if (list->head == NULL) {
    fd800000bc90:	b4000104 	cbz	x4, fd800000bcb0 <vm_emul_add_reg+0x70>
    __asm__ volatile(
    fd800000bc94:	91001041 	add	x1, x2, #0x4
    fd800000bc98:	b9400020 	ldr	w0, [x1]
    fd800000bc9c:	11000400 	add	w0, w0, #0x1
    fd800000bca0:	889ffc20 	stlr	w0, [x1]
    fd800000bca4:	d5033b9f 	dsb	ish
    fd800000bca8:	d503209f 	sev
    fd800000bcac:	d65f03c0 	ret
            list->head = node;
    fd800000bcb0:	f900b801 	str	x1, [x0, #368]
    fd800000bcb4:	17fffff8 	b	fd800000bc94 <vm_emul_add_reg+0x54>
    fd800000bcb8:	d503201f 	nop
    fd800000bcbc:	d503201f 	nop

0000fd800000bcc0 <vm_emul_get_mem>:

emul_handler_t vm_emul_get_mem(struct vm* vm, vaddr_t addr)
{
    emul_handler_t handler = NULL;
    list_foreach (vm->emul_mem_list, struct emul_mem, emu) {
    fd800000bcc0:	f940ac00 	ldr	x0, [x0, #344]
    fd800000bcc4:	b40001a0 	cbz	x0, fd800000bcf8 <vm_emul_get_mem+0x38>
        if (addr >= emu->va_base && (addr < (emu->va_base + emu->size))) {
    fd800000bcc8:	f9400402 	ldr	x2, [x0, #8]
    fd800000bccc:	eb01005f 	cmp	x2, x1
    fd800000bcd0:	540000a8 	b.hi	fd800000bce4 <vm_emul_get_mem+0x24>  // b.pmore
    fd800000bcd4:	f9400803 	ldr	x3, [x0, #16]
    fd800000bcd8:	8b030042 	add	x2, x2, x3
    fd800000bcdc:	eb01005f 	cmp	x2, x1
    fd800000bce0:	54000088 	b.hi	fd800000bcf0 <vm_emul_get_mem+0x30>  // b.pmore
    list_foreach (vm->emul_mem_list, struct emul_mem, emu) {
    fd800000bce4:	f9400000 	ldr	x0, [x0]
    fd800000bce8:	b5ffff00 	cbnz	x0, fd800000bcc8 <vm_emul_get_mem+0x8>
            break;
        }
    }

    return handler;
}
    fd800000bcec:	d65f03c0 	ret
            handler = emu->handler;
    fd800000bcf0:	f9400c00 	ldr	x0, [x0, #24]
}
    fd800000bcf4:	d65f03c0 	ret
    emul_handler_t handler = NULL;
    fd800000bcf8:	d2800000 	mov	x0, #0x0                   	// #0
}
    fd800000bcfc:	d65f03c0 	ret

0000fd800000bd00 <vm_emul_get_reg>:

emul_handler_t vm_emul_get_reg(struct vm* vm, vaddr_t addr)
{
    emul_handler_t handler = NULL;
    list_foreach (vm->emul_reg_list, struct emul_reg, emu) {
    fd800000bd00:	f940b800 	ldr	x0, [x0, #368]
    fd800000bd04:	b5000080 	cbnz	x0, fd800000bd14 <vm_emul_get_reg+0x14>
    fd800000bd08:	14000008 	b	fd800000bd28 <vm_emul_get_reg+0x28>
    fd800000bd0c:	f9400000 	ldr	x0, [x0]
    fd800000bd10:	b40000a0 	cbz	x0, fd800000bd24 <vm_emul_get_reg+0x24>
        if (emu->addr == addr) {
    fd800000bd14:	f9400402 	ldr	x2, [x0, #8]
    fd800000bd18:	eb01005f 	cmp	x2, x1
    fd800000bd1c:	54ffff81 	b.ne	fd800000bd0c <vm_emul_get_reg+0xc>  // b.any
            handler = emu->handler;
    fd800000bd20:	f9400800 	ldr	x0, [x0, #16]
            break;
        }
    }

    return handler;
}
    fd800000bd24:	d65f03c0 	ret
    emul_handler_t handler = NULL;
    fd800000bd28:	d2800000 	mov	x0, #0x0                   	// #0
}
    fd800000bd2c:	d65f03c0 	ret

0000fd800000bd30 <vm_msg_broadcast>:

void vm_msg_broadcast(struct vm* vm, struct cpu_msg* msg)
{
    for (size_t i = 0, n = 0; n < vm->cpu_num - 1; i++) {
    fd800000bd30:	f9402404 	ldr	x4, [x0, #72]
    fd800000bd34:	f100049f 	cmp	x4, #0x1
    fd800000bd38:	54000420 	b.eq	fd800000bdbc <vm_msg_broadcast+0x8c>  // b.none
{
    fd800000bd3c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    fd800000bd40:	910003fd 	mov	x29, sp
    fd800000bd44:	a90153f3 	stp	x19, x20, [sp, #16]
    fd800000bd48:	aa0003f4 	mov	x20, x0
    for (size_t i = 0, n = 0; n < vm->cpu_num - 1; i++) {
    fd800000bd4c:	d2800013 	mov	x19, #0x0                   	// #0
{
    fd800000bd50:	a90363f7 	stp	x23, x24, [sp, #48]
    fd800000bd54:	aa0103f7 	mov	x23, x1
        if (((1U << i) & vm->cpus) && (i != cpu()->id)) {
    fd800000bd58:	d2dfc018 	mov	x24, #0xfe0000000000        	// #279275953455104
{
    fd800000bd5c:	a9025bf5 	stp	x21, x22, [sp, #32]
    for (size_t i = 0, n = 0; n < vm->cpu_num - 1; i++) {
    fd800000bd60:	d2800015 	mov	x21, #0x0                   	// #0
        if (((1U << i) & vm->cpus) && (i != cpu()->id)) {
    fd800000bd64:	52800036 	mov	w22, #0x1                   	// #1
    fd800000bd68:	f9402a82 	ldr	x2, [x20, #80]
    fd800000bd6c:	1ad322c3 	lsl	w3, w22, w19
    fd800000bd70:	ea02007f 	tst	x3, x2
    fd800000bd74:	54000120 	b.eq	fd800000bd98 <vm_msg_broadcast+0x68>  // b.none
    fd800000bd78:	f9400302 	ldr	x2, [x24]
            n++;
            cpu_send_msg(i, msg);
    fd800000bd7c:	aa1703e1 	mov	x1, x23
    fd800000bd80:	aa1303e0 	mov	x0, x19
        if (((1U << i) & vm->cpus) && (i != cpu()->id)) {
    fd800000bd84:	eb13005f 	cmp	x2, x19
    fd800000bd88:	54000080 	b.eq	fd800000bd98 <vm_msg_broadcast+0x68>  // b.none
            cpu_send_msg(i, msg);
    fd800000bd8c:	97fffb31 	bl	fd800000aa50 <cpu_send_msg>
            n++;
    fd800000bd90:	910006b5 	add	x21, x21, #0x1
            cpu_send_msg(i, msg);
    fd800000bd94:	f9402684 	ldr	x4, [x20, #72]
    for (size_t i = 0, n = 0; n < vm->cpu_num - 1; i++) {
    fd800000bd98:	d1000482 	sub	x2, x4, #0x1
    fd800000bd9c:	91000673 	add	x19, x19, #0x1
    fd800000bda0:	eb15005f 	cmp	x2, x21
    fd800000bda4:	54fffe28 	b.hi	fd800000bd68 <vm_msg_broadcast+0x38>  // b.pmore
        }
    }
}
    fd800000bda8:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd800000bdac:	a9425bf5 	ldp	x21, x22, [sp, #32]
    fd800000bdb0:	a94363f7 	ldp	x23, x24, [sp, #48]
    fd800000bdb4:	a8c47bfd 	ldp	x29, x30, [sp], #64
    fd800000bdb8:	d65f03c0 	ret
    fd800000bdbc:	d65f03c0 	ret

0000fd800000bdc0 <vm_translate_to_pcpu_mask>:

__attribute__((weak)) cpumap_t vm_translate_to_pcpu_mask(struct vm* vm, cpumap_t mask, size_t len)
{
    fd800000bdc0:	aa0003e6 	mov	x6, x0
    cpumap_t pmask = 0;
    cpuid_t shift;
    for (size_t i = 0; i < len; i++) {
    fd800000bdc4:	b40002e2 	cbz	x2, fd800000be20 <vm_translate_to_pcpu_mask+0x60>
    fd800000bdc8:	d2800004 	mov	x4, #0x0                   	// #0
    fd800000bdcc:	d2800003 	mov	x3, #0x0                   	// #0
    cpumap_t pmask = 0;
    fd800000bdd0:	d2800000 	mov	x0, #0x0                   	// #0
        if ((mask & (1ULL << i)) && ((shift = vm_translate_to_pcpuid(vm, i)) != INVALID_CPUID)) {
            pmask |= (1ULL << shift);
    fd800000bdd4:	d2800027 	mov	x7, #0x1                   	// #1
        if ((mask & (1ULL << i)) && ((shift = vm_translate_to_pcpuid(vm, i)) != INVALID_CPUID)) {
    fd800000bdd8:	9ac32425 	lsr	x5, x1, x3
    fd800000bddc:	36000185 	tbz	w5, #0, fd800000be0c <vm_translate_to_pcpu_mask+0x4c>
    if (vcpuid < vm->cpu_num) {
    fd800000bde0:	f94024c5 	ldr	x5, [x6, #72]
    fd800000bde4:	eb0300bf 	cmp	x5, x3
    fd800000bde8:	54000129 	b.ls	fd800000be0c <vm_translate_to_pcpu_mask+0x4c>  // b.plast
        return &vm->vcpus[vcpuid];
    fd800000bdec:	f94020c5 	ldr	x5, [x6, #64]
    if (vcpu == NULL) {
    fd800000bdf0:	ab0400a5 	adds	x5, x5, x4
    fd800000bdf4:	540000c0 	b.eq	fd800000be0c <vm_translate_to_pcpu_mask+0x4c>  // b.none
        return vcpu->phys_id;
    fd800000bdf8:	f944c0a5 	ldr	x5, [x5, #2432]
            pmask |= (1ULL << shift);
    fd800000bdfc:	b10004bf 	cmn	x5, #0x1
    fd800000be00:	9ac520e5 	lsl	x5, x7, x5
    fd800000be04:	aa050005 	orr	x5, x0, x5
    fd800000be08:	9a8010a0 	csel	x0, x5, x0, ne	// ne = any
    for (size_t i = 0; i < len; i++) {
    fd800000be0c:	91000463 	add	x3, x3, #0x1
    fd800000be10:	91268084 	add	x4, x4, #0x9a0
    fd800000be14:	eb03005f 	cmp	x2, x3
    fd800000be18:	54fffe01 	b.ne	fd800000bdd8 <vm_translate_to_pcpu_mask+0x18>  // b.any
        }
    }
    return pmask;
}
    fd800000be1c:	d65f03c0 	ret
    cpumap_t pmask = 0;
    fd800000be20:	d2800000 	mov	x0, #0x0                   	// #0
}
    fd800000be24:	d65f03c0 	ret
    fd800000be28:	d503201f 	nop
    fd800000be2c:	d503201f 	nop

0000fd800000be30 <vm_translate_to_vcpu_mask>:

__attribute__((weak)) cpumap_t vm_translate_to_vcpu_mask(struct vm* vm, cpumap_t mask, size_t len)
{
    fd800000be30:	aa0003e9 	mov	x9, x0
    cpumap_t pmask = 0;
    vcpuid_t shift;
    for (size_t i = 0; i < len; i++) {
    fd800000be34:	b4000402 	cbz	x2, fd800000beb4 <vm_translate_to_vcpu_mask+0x84>
    fd800000be38:	d2800007 	mov	x7, #0x0                   	// #0
    cpumap_t pmask = 0;
    fd800000be3c:	d2800000 	mov	x0, #0x0                   	// #0
}

static inline vcpuid_t vm_translate_to_vcpuid(struct vm* vm, cpuid_t pcpuid)
{
    if (vm->cpus & (1UL << pcpuid)) {
        return (cpuid_t)bit_count(vm->cpus & BIT_MASK(0, pcpuid));
    fd800000be40:	d280002a 	mov	x10, #0x1                   	// #1
    fd800000be44:	d503201f 	nop
        if ((mask & (1ULL << i)) && ((shift = vm_translate_to_vcpuid(vm, i)) != INVALID_CPUID)) {
    fd800000be48:	9ac72423 	lsr	x3, x1, x7
    fd800000be4c:	360002c3 	tbz	w3, #0, fd800000bea4 <vm_translate_to_vcpu_mask+0x74>
    if (vm->cpus & (1UL << pcpuid)) {
    fd800000be50:	f9402928 	ldr	x8, [x9, #80]
    fd800000be54:	9ac72505 	lsr	x5, x8, x7
    fd800000be58:	924000a3 	and	x3, x5, #0x1
    fd800000be5c:	36000245 	tbz	w5, #0, fd800000bea4 <vm_translate_to_vcpu_mask+0x74>
        return (cpuid_t)bit_count(vm->cpus & BIT_MASK(0, pcpuid));
    fd800000be60:	510004e6 	sub	w6, w7, #0x1
    fd800000be64:	52800804 	mov	w4, #0x40                  	// #64
    fd800000be68:	d2800005 	mov	x5, #0x0                   	// #0
    fd800000be6c:	9ac62146 	lsl	x6, x10, x6
    fd800000be70:	8b0600c6 	add	x6, x6, x6
    fd800000be74:	d10004c6 	sub	x6, x6, #0x1
    fd800000be78:	8a0800c6 	and	x6, x6, x8
    fd800000be7c:	d503201f 	nop
    fd800000be80:	ea0300df 	tst	x6, x3
    fd800000be84:	8b030063 	add	x3, x3, x3
    fd800000be88:	9a8504a5 	cinc	x5, x5, ne	// ne = any
    fd800000be8c:	71000484 	subs	w4, w4, #0x1
    fd800000be90:	54ffff81 	b.ne	fd800000be80 <vm_translate_to_vcpu_mask+0x50>  // b.any
            pmask |= (1ULL << shift);
    fd800000be94:	b10004bf 	cmn	x5, #0x1
    fd800000be98:	9ac52143 	lsl	x3, x10, x5
    fd800000be9c:	aa030003 	orr	x3, x0, x3
    fd800000bea0:	9a801060 	csel	x0, x3, x0, ne	// ne = any
    for (size_t i = 0; i < len; i++) {
    fd800000bea4:	910004e7 	add	x7, x7, #0x1
    fd800000bea8:	eb07005f 	cmp	x2, x7
    fd800000beac:	54fffce1 	b.ne	fd800000be48 <vm_translate_to_vcpu_mask+0x18>  // b.any
        }
    }
    return pmask;
}
    fd800000beb0:	d65f03c0 	ret
    cpumap_t pmask = 0;
    fd800000beb4:	d2800000 	mov	x0, #0x0                   	// #0
}
    fd800000beb8:	d65f03c0 	ret
    fd800000bebc:	d503201f 	nop

0000fd800000bec0 <vcpu_run>:

void vcpu_run(struct vcpu* vcpu)
{
    cpu()->vcpu->active = true;
    fd800000bec0:	d2dfc001 	mov	x1, #0xfe0000000000        	// #279275953455104
    fd800000bec4:	52800022 	mov	w2, #0x1                   	// #1
    fd800000bec8:	f9402821 	ldr	x1, [x1, #80]
    fd800000becc:	39262022 	strb	w2, [x1, #2440]
    vcpu_arch_run(vcpu);
    fd800000bed0:	17ffdda4 	b	fd8000003560 <vcpu_arch_run>
	...

0000fd800000bee0 <config_adjust_vm_image_addr>:

#include <config.h>

void config_adjust_vm_image_addr(paddr_t load_addr)
{
    for (size_t i = 0; i < config.vmlist_size; i++) {
    fd800000bee0:	90000001 	adrp	x1, fd800000b000 <vmm_init+0x2e0>
    fd800000bee4:	f9479421 	ldr	x1, [x1, #3880]
    fd800000bee8:	f9401423 	ldr	x3, [x1, #40]
    fd800000beec:	b40001c3 	cbz	x3, fd800000bf24 <config_adjust_vm_image_addr+0x44>
        struct vm_config* vm_config = &config.vmlist[i];
        if (!vm_config->image.separately_loaded) {
            vm_config->image.load_addr = (vm_config->image.load_addr - BAO_VAS_BASE) + load_addr;
    fd800000bef0:	d2c05002 	mov	x2, #0x28000000000         	// #2748779069440
    fd800000bef4:	f2ffffe2 	movk	x2, #0xffff, lsl #48
    fd800000bef8:	8b020004 	add	x4, x0, x2
    for (size_t i = 0; i < config.vmlist_size; i++) {
    fd800000befc:	d2800000 	mov	x0, #0x0                   	// #0
        if (!vm_config->image.separately_loaded) {
    fd800000bf00:	39412022 	ldrb	w2, [x1, #72]
    for (size_t i = 0; i < config.vmlist_size; i++) {
    fd800000bf04:	91000400 	add	x0, x0, #0x1
        if (!vm_config->image.separately_loaded) {
    fd800000bf08:	37000082 	tbnz	w2, #0, fd800000bf18 <config_adjust_vm_image_addr+0x38>
            vm_config->image.load_addr = (vm_config->image.load_addr - BAO_VAS_BASE) + load_addr;
    fd800000bf0c:	f9401c22 	ldr	x2, [x1, #56]
    fd800000bf10:	8b040042 	add	x2, x2, x4
    fd800000bf14:	f9001c22 	str	x2, [x1, #56]
    for (size_t i = 0; i < config.vmlist_size; i++) {
    fd800000bf18:	9102c021 	add	x1, x1, #0xb0
    fd800000bf1c:	eb03001f 	cmp	x0, x3
    fd800000bf20:	54ffff01 	b.ne	fd800000bf00 <config_adjust_vm_image_addr+0x20>  // b.any
        }
    }
}
    fd800000bf24:	d65f03c0 	ret
    fd800000bf28:	00012bf0 	.word	0x00012bf0
    fd800000bf2c:	0000fd80 	.word	0x0000fd80

0000fd800000bf30 <config_mem_prot_init>:

__attribute__((weak)) void config_mem_prot_init(paddr_t load_addr) { }
    fd800000bf30:	d65f03c0 	ret
    fd800000bf34:	d503201f 	nop
    fd800000bf38:	d503201f 	nop
    fd800000bf3c:	d503201f 	nop

0000fd800000bf40 <config_init>:
    for (size_t i = 0; i < config.vmlist_size; i++) {
    fd800000bf40:	90000001 	adrp	x1, fd800000b000 <vmm_init+0x2e0>
    fd800000bf44:	f947c421 	ldr	x1, [x1, #3976]
    fd800000bf48:	f9401424 	ldr	x4, [x1, #40]
    fd800000bf4c:	b40001c4 	cbz	x4, fd800000bf84 <config_init+0x44>
            vm_config->image.load_addr = (vm_config->image.load_addr - BAO_VAS_BASE) + load_addr;
    fd800000bf50:	d2c05005 	mov	x5, #0x28000000000         	// #2748779069440
    for (size_t i = 0; i < config.vmlist_size; i++) {
    fd800000bf54:	d2800002 	mov	x2, #0x0                   	// #0
            vm_config->image.load_addr = (vm_config->image.load_addr - BAO_VAS_BASE) + load_addr;
    fd800000bf58:	f2ffffe5 	movk	x5, #0xffff, lsl #48
    fd800000bf5c:	8b050005 	add	x5, x0, x5
        if (!vm_config->image.separately_loaded) {
    fd800000bf60:	39412023 	ldrb	w3, [x1, #72]
    for (size_t i = 0; i < config.vmlist_size; i++) {
    fd800000bf64:	91000442 	add	x2, x2, #0x1
        if (!vm_config->image.separately_loaded) {
    fd800000bf68:	37000083 	tbnz	w3, #0, fd800000bf78 <config_init+0x38>
            vm_config->image.load_addr = (vm_config->image.load_addr - BAO_VAS_BASE) + load_addr;
    fd800000bf6c:	f9401c23 	ldr	x3, [x1, #56]
    fd800000bf70:	8b050063 	add	x3, x3, x5
    fd800000bf74:	f9001c23 	str	x3, [x1, #56]
    for (size_t i = 0; i < config.vmlist_size; i++) {
    fd800000bf78:	9102c021 	add	x1, x1, #0xb0
    fd800000bf7c:	eb04005f 	cmp	x2, x4
    fd800000bf80:	54ffff01 	b.ne	fd800000bf60 <config_init+0x20>  // b.any

void config_init(paddr_t load_addr)
{
    config_adjust_vm_image_addr(load_addr);
    config_mem_prot_init(load_addr);
    fd800000bf84:	17ffffeb 	b	fd800000bf30 <config_mem_prot_init>
    fd800000bf88:	00012bf0 	.word	0x00012bf0
    fd800000bf8c:	0000fd80 	.word	0x0000fd80

0000fd800000bf90 <console_write>:

    cpu_sync_and_clear_msgs(&cpu_glb_sync);
}

void console_write(const char* buf, size_t n)
{
    fd800000bf90:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    fd800000bf94:	910003fd 	mov	x29, sp
    fd800000bf98:	a90153f3 	stp	x19, x20, [sp, #16]
    while (!console_ready)
    fd800000bf9c:	b0000002 	adrp	x2, fd800000c000 <console_write+0x70>
    fd800000bfa0:	f9400c54 	ldr	x20, [x2, #24]
    fd800000bfa4:	39400282 	ldrb	w2, [x20]
{
    fd800000bfa8:	f90013f5 	str	x21, [sp, #32]
    while (!console_ready)
    fd800000bfac:	37000042 	tbnz	w2, #0, fd800000bfb4 <console_write+0x24>
    fd800000bfb0:	14000000 	b	fd800000bfb0 <console_write+0x20>
        ;
    for (size_t i = 0; i < n; i++) {
    fd800000bfb4:	aa0003f3 	mov	x19, x0
    fd800000bfb8:	8b010015 	add	x21, x0, x1
    fd800000bfbc:	b50000e1 	cbnz	x1, fd800000bfd8 <console_write+0x48>
    fd800000bfc0:	14000012 	b	fd800000c008 <console_write+0x78>
        if (buf[i] == '\n') {
            uart_putc(uart, '\r');
        }
        uart_putc(uart, buf[i]);
    fd800000bfc4:	f9400680 	ldr	x0, [x20, #8]
    for (size_t i = 0; i < n; i++) {
    fd800000bfc8:	91000673 	add	x19, x19, #0x1
        uart_putc(uart, buf[i]);
    fd800000bfcc:	94000c3d 	bl	fd800000f0c0 <uart_putc>
    for (size_t i = 0; i < n; i++) {
    fd800000bfd0:	eb15027f 	cmp	x19, x21
    fd800000bfd4:	540001a0 	b.eq	fd800000c008 <console_write+0x78>  // b.none
        if (buf[i] == '\n') {
    fd800000bfd8:	39400261 	ldrb	w1, [x19]
    fd800000bfdc:	7100283f 	cmp	w1, #0xa
    fd800000bfe0:	54ffff21 	b.ne	fd800000bfc4 <console_write+0x34>  // b.any
            uart_putc(uart, '\r');
    fd800000bfe4:	f9400680 	ldr	x0, [x20, #8]
    fd800000bfe8:	528001a1 	mov	w1, #0xd                   	// #13
    for (size_t i = 0; i < n; i++) {
    fd800000bfec:	91000673 	add	x19, x19, #0x1
            uart_putc(uart, '\r');
    fd800000bff0:	94000c34 	bl	fd800000f0c0 <uart_putc>
        uart_putc(uart, buf[i]);
    fd800000bff4:	f9400680 	ldr	x0, [x20, #8]
    fd800000bff8:	385ff261 	ldurb	w1, [x19, #-1]
    fd800000bffc:	94000c31 	bl	fd800000f0c0 <uart_putc>
    for (size_t i = 0; i < n; i++) {
    fd800000c000:	eb15027f 	cmp	x19, x21
    fd800000c004:	54fffea1 	b.ne	fd800000bfd8 <console_write+0x48>  // b.any
    }
}
    fd800000c008:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd800000c00c:	f94013f5 	ldr	x21, [sp, #32]
    fd800000c010:	a8c37bfd 	ldp	x29, x30, [sp], #48
    fd800000c014:	d65f03c0 	ret
    fd800000c018:	0001bc68 	.word	0x0001bc68
    fd800000c01c:	0000fd80 	.word	0x0000fd80

0000fd800000c020 <console_printk>:

#define PRINTF_BUFFER_LEN (256)
static char console_bufffer[PRINTF_BUFFER_LEN];

__attribute__((format(printf, 1, 2))) void console_printk(const char* fmt, ...)
{
    fd800000c020:	a9b67bfd 	stp	x29, x30, [sp, #-160]!
    va_list args;
    size_t chars_writen;
    const char* fmt_it = fmt;

    va_start(args, fmt);
    fd800000c024:	128006e8 	mov	w8, #0xffffffc8            	// #-56
{
    fd800000c028:	910003fd 	mov	x29, sp
    fd800000c02c:	f90013f5 	str	x21, [sp, #32]
    __asm__ volatile(
    fd800000c030:	9000000a 	adrp	x10, fd800000c000 <console_write+0x70>
    fd800000c034:	f9408555 	ldr	x21, [x10, #264]
    va_start(args, fmt);
    fd800000c038:	910183e9 	add	x9, sp, #0x60
    const char* fmt_it = fmt;
    fd800000c03c:	f9001fe0 	str	x0, [sp, #56]
    va_start(args, fmt);
    fd800000c040:	910283e0 	add	x0, sp, #0xa0
    fd800000c044:	a90403e0 	stp	x0, x0, [sp, #64]
    fd800000c048:	f9002be9 	str	x9, [sp, #80]
    fd800000c04c:	290b7fe8 	stp	w8, wzr, [sp, #88]
{
    fd800000c050:	a9068be1 	stp	x1, x2, [sp, #104]
    fd800000c054:	a90793e3 	stp	x3, x4, [sp, #120]
    fd800000c058:	910042a3 	add	x3, x21, #0x10
    fd800000c05c:	910052a4 	add	x4, x21, #0x14
    fd800000c060:	a9089be5 	stp	x5, x6, [sp, #136]
    fd800000c064:	f9004fe7 	str	x7, [sp, #152]
    fd800000c068:	885ffc60 	ldaxr	w0, [x3]
    fd800000c06c:	11000401 	add	w1, w0, #0x1
    fd800000c070:	88027c61 	stxr	w2, w1, [x3]
    fd800000c074:	35ffffa2 	cbnz	w2, fd800000c068 <console_printk+0x48>
    fd800000c078:	88dffc81 	ldar	w1, [x4]
    fd800000c07c:	6b01001f 	cmp	w0, w1
    fd800000c080:	54000060 	b.eq	fd800000c08c <console_printk+0x6c>  // b.none
    fd800000c084:	d503205f 	wfe
    fd800000c088:	17fffffc 	b	fd800000c078 <console_printk+0x58>
    spin_lock(&console_lock);
    while (*fmt_it != '\0') {
    fd800000c08c:	f9401fe0 	ldr	x0, [sp, #56]
    fd800000c090:	39400000 	ldrb	w0, [x0]
    fd800000c094:	34000260 	cbz	w0, fd800000c0e0 <console_printk+0xc0>
    fd800000c098:	a90153f3 	stp	x19, x20, [sp, #16]
        chars_writen = vsnprintk(console_bufffer, PRINTF_BUFFER_LEN, &fmt_it, &args);
    fd800000c09c:	910062b3 	add	x19, x21, #0x18
    fd800000c0a0:	d2802014 	mov	x20, #0x100                 	// #256
    fd800000c0a4:	d503201f 	nop
    fd800000c0a8:	d2802001 	mov	x1, #0x100                 	// #256
    fd800000c0ac:	910103e3 	add	x3, sp, #0x40
    fd800000c0b0:	9100e3e2 	add	x2, sp, #0x38
    fd800000c0b4:	aa1303e0 	mov	x0, x19
    fd800000c0b8:	97fff35e 	bl	fd8000008e30 <vsnprintk>
    fd800000c0bc:	aa0003e1 	mov	x1, x0
        console_write(console_bufffer, min(PRINTF_BUFFER_LEN, chars_writen));
    fd800000c0c0:	f104003f 	cmp	x1, #0x100
    fd800000c0c4:	aa1303e0 	mov	x0, x19
    fd800000c0c8:	9a949021 	csel	x1, x1, x20, ls	// ls = plast
    fd800000c0cc:	97ffffb1 	bl	fd800000bf90 <console_write>
    while (*fmt_it != '\0') {
    fd800000c0d0:	f9401fe0 	ldr	x0, [sp, #56]
    fd800000c0d4:	39400000 	ldrb	w0, [x0]
    fd800000c0d8:	35fffe80 	cbnz	w0, fd800000c0a8 <console_printk+0x88>
    fd800000c0dc:	a94153f3 	ldp	x19, x20, [sp, #16]
    __asm__ volatile(
    fd800000c0e0:	910052a1 	add	x1, x21, #0x14
    fd800000c0e4:	b9400020 	ldr	w0, [x1]
    fd800000c0e8:	11000400 	add	w0, w0, #0x1
    fd800000c0ec:	889ffc20 	stlr	w0, [x1]
    fd800000c0f0:	d5033b9f 	dsb	ish
    fd800000c0f4:	d503209f 	sev
    }
    spin_unlock(&console_lock);
    va_end(args);
}
    fd800000c0f8:	f94013f5 	ldr	x21, [sp, #32]
    fd800000c0fc:	a8ca7bfd 	ldp	x29, x30, [sp], #160
    fd800000c100:	d65f03c0 	ret
    fd800000c104:	d503201f 	nop
    fd800000c108:	0001bc68 	.word	0x0001bc68
    fd800000c10c:	0000fd80 	.word	0x0000fd80

0000fd800000c110 <console_init>:
{
    fd800000c110:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    if (cpu()->id == CPU_MASTER) {
    fd800000c114:	d2dfc001 	mov	x1, #0xfe0000000000        	// #279275953455104
{
    fd800000c118:	910003fd 	mov	x29, sp
    if (cpu()->id == CPU_MASTER) {
    fd800000c11c:	90000000 	adrp	x0, fd800000c000 <console_write+0x70>
    fd800000c120:	f9417800 	ldr	x0, [x0, #752]
{
    fd800000c124:	a90153f3 	stp	x19, x20, [sp, #16]
    if (cpu()->id == CPU_MASTER) {
    fd800000c128:	f9400021 	ldr	x1, [x1]
    fd800000c12c:	f9400000 	ldr	x0, [x0]
{
    fd800000c130:	f90013f5 	str	x21, [sp, #32]
    if (cpu()->id == CPU_MASTER) {
    fd800000c134:	eb00003f 	cmp	x1, x0
    fd800000c138:	54000a20 	b.eq	fd800000c27c <console_init+0x16c>  // b.none
    while (!token->ready) { }
    fd800000c13c:	90000000 	adrp	x0, fd800000c000 <console_write+0x70>
    fd800000c140:	f9418813 	ldr	x19, [x0, #784]
    fd800000c144:	d503201f 	nop
    fd800000c148:	39404260 	ldrb	w0, [x19, #16]
    fd800000c14c:	3607ffe0 	tbz	w0, #0, fd800000c148 <console_init+0x38>
    __asm__ volatile(
    fd800000c150:	91001263 	add	x3, x19, #0x4
    fd800000c154:	885ffe60 	ldaxr	w0, [x19]
    fd800000c158:	11000401 	add	w1, w0, #0x1
    fd800000c15c:	88027e61 	stxr	w2, w1, [x19]
    fd800000c160:	35ffffa2 	cbnz	w2, fd800000c154 <console_init+0x44>
    fd800000c164:	88dffc61 	ldar	w1, [x3]
    fd800000c168:	6b01001f 	cmp	w0, w1
    fd800000c16c:	54000060 	b.eq	fd800000c178 <console_init+0x68>  // b.none
    fd800000c170:	d503205f 	wfe
    fd800000c174:	17fffffc 	b	fd800000c164 <console_init+0x54>
    token->count++;
    fd800000c178:	f9400e60 	ldr	x0, [x19, #24]
    fd800000c17c:	91000400 	add	x0, x0, #0x1
    fd800000c180:	f9000e60 	str	x0, [x19, #24]
    next_count = ALIGN(token->count, token->n);
    fd800000c184:	f9400e74 	ldr	x20, [x19, #24]
    fd800000c188:	f9400660 	ldr	x0, [x19, #8]
    fd800000c18c:	f9400661 	ldr	x1, [x19, #8]
    fd800000c190:	8b000294 	add	x20, x20, x0
    fd800000c194:	d1000694 	sub	x20, x20, #0x1
    fd800000c198:	f9400660 	ldr	x0, [x19, #8]
    fd800000c19c:	9ac10a94 	udiv	x20, x20, x1
    fd800000c1a0:	9b007e94 	mul	x20, x20, x0
    __asm__ volatile(
    fd800000c1a4:	b9400060 	ldr	w0, [x3]
    fd800000c1a8:	11000400 	add	w0, w0, #0x1
    fd800000c1ac:	889ffc60 	stlr	w0, [x3]
    fd800000c1b0:	d5033b9f 	dsb	ish
    fd800000c1b4:	d503209f 	sev
        if (!cpu()->handling_msgs) {
    fd800000c1b8:	d2dfc015 	mov	x21, #0xfe0000000000        	// #279275953455104
    while (token->count < next_count) {
    fd800000c1bc:	f9400e61 	ldr	x1, [x19, #24]
        if (!cpu()->handling_msgs) {
    fd800000c1c0:	394022a0 	ldrb	w0, [x21, #8]
    while (token->count < next_count) {
    fd800000c1c4:	eb01029f 	cmp	x20, x1
        if (!cpu()->handling_msgs) {
    fd800000c1c8:	12000001 	and	w1, w0, #0x1
    while (token->count < next_count) {
    fd800000c1cc:	540000c9 	b.ls	fd800000c1e4 <console_init+0xd4>  // b.plast
        if (!cpu()->handling_msgs) {
    fd800000c1d0:	36000520 	tbz	w0, #0, fd800000c274 <console_init+0x164>
    fd800000c1d4:	d503201f 	nop
    while (token->count < next_count) {
    fd800000c1d8:	f9400e60 	ldr	x0, [x19, #24]
    fd800000c1dc:	eb00029f 	cmp	x20, x0
    fd800000c1e0:	54ffffc8 	b.hi	fd800000c1d8 <console_init+0xc8>  // b.pmore
    if (!cpu()->handling_msgs) {
    fd800000c1e4:	34000781 	cbz	w1, fd800000c2d4 <console_init+0x1c4>
    while (!token->ready) { }
    fd800000c1e8:	39404260 	ldrb	w0, [x19, #16]
    fd800000c1ec:	3607ffe0 	tbz	w0, #0, fd800000c1e8 <console_init+0xd8>
    __asm__ volatile(
    fd800000c1f0:	91001263 	add	x3, x19, #0x4
    fd800000c1f4:	885ffe60 	ldaxr	w0, [x19]
    fd800000c1f8:	11000401 	add	w1, w0, #0x1
    fd800000c1fc:	88027e61 	stxr	w2, w1, [x19]
    fd800000c200:	35ffffa2 	cbnz	w2, fd800000c1f4 <console_init+0xe4>
    fd800000c204:	88dffc61 	ldar	w1, [x3]
    fd800000c208:	6b01001f 	cmp	w0, w1
    fd800000c20c:	54000060 	b.eq	fd800000c218 <console_init+0x108>  // b.none
    fd800000c210:	d503205f 	wfe
    fd800000c214:	17fffffc 	b	fd800000c204 <console_init+0xf4>
    token->count++;
    fd800000c218:	f9400e60 	ldr	x0, [x19, #24]
    fd800000c21c:	91000400 	add	x0, x0, #0x1
    fd800000c220:	f9000e60 	str	x0, [x19, #24]
    next_count = ALIGN(token->count, token->n);
    fd800000c224:	f9400e61 	ldr	x1, [x19, #24]
    fd800000c228:	f9400660 	ldr	x0, [x19, #8]
    fd800000c22c:	f9400662 	ldr	x2, [x19, #8]
    fd800000c230:	8b000021 	add	x1, x1, x0
    fd800000c234:	d1000421 	sub	x1, x1, #0x1
    fd800000c238:	f9400660 	ldr	x0, [x19, #8]
    fd800000c23c:	9ac20821 	udiv	x1, x1, x2
    fd800000c240:	9b007c21 	mul	x1, x1, x0
    __asm__ volatile(
    fd800000c244:	b9400060 	ldr	w0, [x3]
    fd800000c248:	11000400 	add	w0, w0, #0x1
    fd800000c24c:	889ffc60 	stlr	w0, [x3]
    fd800000c250:	d5033b9f 	dsb	ish
    fd800000c254:	d503209f 	sev
    while (token->count < next_count) { }
    fd800000c258:	f9400e60 	ldr	x0, [x19, #24]
    fd800000c25c:	eb00003f 	cmp	x1, x0
    fd800000c260:	54ffffc8 	b.hi	fd800000c258 <console_init+0x148>  // b.pmore
}
    fd800000c264:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd800000c268:	f94013f5 	ldr	x21, [sp, #32]
    fd800000c26c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    fd800000c270:	d65f03c0 	ret
            cpu_msg_handler();
    fd800000c274:	97fffa6b 	bl	fd800000ac20 <cpu_msg_handler>
    fd800000c278:	17ffffd1 	b	fd800000c1bc <console_init+0xac>
        if ((platform.console.base & PAGE_OFFSET_MASK) != 0) {
    fd800000c27c:	90000000 	adrp	x0, fd800000c000 <console_write+0x70>
    fd800000c280:	f9417c13 	ldr	x19, [x0, #760]
    fd800000c284:	f9401663 	ldr	x3, [x19, #40]
    fd800000c288:	92402c60 	and	x0, x3, #0xfff
    fd800000c28c:	b5000280 	cbnz	x0, fd800000c2dc <console_init+0x1cc>
        uart = (void*)mem_alloc_map_dev(&cpu()->as, SEC_HYP_GLOBAL, INVALID_VA,
    fd800000c290:	d2800200 	mov	x0, #0x10                  	// #16
    fd800000c294:	d2800024 	mov	x4, #0x1                   	// #1
    fd800000c298:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
    fd800000c29c:	52800001 	mov	w1, #0x0                   	// #0
    fd800000c2a0:	f2dfc000 	movk	x0, #0xfe00, lsl #32
    fd800000c2a4:	94000af3 	bl	fd800000ee70 <mem_alloc_map_dev>
    fd800000c2a8:	90000001 	adrp	x1, fd800000c000 <console_write+0x70>
    fd800000c2ac:	f9418433 	ldr	x19, [x1, #776]
    fd800000c2b0:	f9000660 	str	x0, [x19, #8]
    DSB(ishst);
    fd800000c2b4:	d5033a9f 	dsb	ishst
        uart_init(uart);
    fd800000c2b8:	f9400660 	ldr	x0, [x19, #8]
    fd800000c2bc:	94000b61 	bl	fd800000f040 <uart_init>
        uart_enable(uart);
    fd800000c2c0:	f9400660 	ldr	x0, [x19, #8]
    fd800000c2c4:	94000b47 	bl	fd800000efe0 <uart_enable>
        console_ready = true;
    fd800000c2c8:	52800020 	mov	w0, #0x1                   	// #1
    fd800000c2cc:	39000260 	strb	w0, [x19]
    fd800000c2d0:	17ffff9b 	b	fd800000c13c <console_init+0x2c>
        cpu_msg_handler();
    fd800000c2d4:	97fffa53 	bl	fd800000ac20 <cpu_msg_handler>
    while (!token->ready) { }
    fd800000c2d8:	17ffffc4 	b	fd800000c1e8 <console_init+0xd8>
            WARNING("console base must be page aligned");
    fd800000c2dc:	90000000 	adrp	x0, fd800000c000 <console_write+0x70>
    fd800000c2e0:	f9418000 	ldr	x0, [x0, #768]
    fd800000c2e4:	97ffff4f 	bl	fd800000c020 <console_printk>
        uart = (void*)mem_alloc_map_dev(&cpu()->as, SEC_HYP_GLOBAL, INVALID_VA,
    fd800000c2e8:	f9401663 	ldr	x3, [x19, #40]
    fd800000c2ec:	17ffffe9 	b	fd800000c290 <console_init+0x180>
    fd800000c2f0:	00012348 	.word	0x00012348
    fd800000c2f4:	0000fd80 	.word	0x0000fd80
    fd800000c2f8:	00012930 	.word	0x00012930
    fd800000c2fc:	0000fd80 	.word	0x0000fd80
    fd800000c300:	00010e90 	.word	0x00010e90
    fd800000c304:	0000fd80 	.word	0x0000fd80
    fd800000c308:	0001bc68 	.word	0x0001bc68
    fd800000c30c:	0000fd80 	.word	0x0000fd80
    fd800000c310:	00016000 	.word	0x00016000
    fd800000c314:	0000fd80 	.word	0x0000fd80
	...

0000fd800000c320 <ipc_handler>:
}

static void ipc_handler(uint32_t event, uint64_t data)
{
    union ipc_msg_data ipc_data = { .raw = data };
    switch (event) {
    fd800000c320:	34000040 	cbz	w0, fd800000c328 <ipc_handler+0x8>
        case IPC_NOTIFY:
            ipc_notify(ipc_data.shmem_id, ipc_data.event_id);
            break;
    }
}
    fd800000c324:	d65f03c0 	ret
    struct ipc* ipc_obj = ipc_find_by_shmemid(cpu()->vcpu->vm, shmem_id);
    fd800000c328:	d2dfc000 	mov	x0, #0xfe0000000000        	// #279275953455104
    fd800000c32c:	92401c26 	and	x6, x1, #0xff
    fd800000c330:	f9402800 	ldr	x0, [x0, #80]
    fd800000c334:	f944c802 	ldr	x2, [x0, #2448]
    for (size_t i = 0; i < vm->ipc_num; i++) {
    fd800000c338:	f9410c45 	ldr	x5, [x2, #536]
    fd800000c33c:	b4ffff45 	cbz	x5, fd800000c324 <ipc_handler+0x4>
    fd800000c340:	f9411042 	ldr	x2, [x2, #544]
    fd800000c344:	d2800003 	mov	x3, #0x0                   	// #0
    fd800000c348:	14000004 	b	fd800000c358 <ipc_handler+0x38>
    fd800000c34c:	9100a042 	add	x2, x2, #0x28
    fd800000c350:	eb05007f 	cmp	x3, x5
    fd800000c354:	54fffe80 	b.eq	fd800000c324 <ipc_handler+0x4>  // b.none
        if (vm->ipcs[i].shmem_id == shmem_id) {
    fd800000c358:	f9400844 	ldr	x4, [x2, #16]
    for (size_t i = 0; i < vm->ipc_num; i++) {
    fd800000c35c:	91000463 	add	x3, x3, #0x1
        if (vm->ipcs[i].shmem_id == shmem_id) {
    fd800000c360:	eb06009f 	cmp	x4, x6
    fd800000c364:	54ffff41 	b.ne	fd800000c34c <ipc_handler+0x2c>  // b.any
    if (ipc_obj != NULL && event_id < ipc_obj->interrupt_num) {
    fd800000c368:	f9400c43 	ldr	x3, [x2, #24]
            ipc_notify(ipc_data.shmem_id, ipc_data.event_id);
    fd800000c36c:	d3483c21 	ubfx	x1, x1, #8, #8
    if (ipc_obj != NULL && event_id < ipc_obj->interrupt_num) {
    fd800000c370:	eb03003f 	cmp	x1, x3
    fd800000c374:	54fffd82 	b.cs	fd800000c324 <ipc_handler+0x4>  // b.hs, b.nlast
        irqid_t irq_id = ipc_obj->interrupts[event_id];
    fd800000c378:	f9401042 	ldr	x2, [x2, #32]
    fd800000c37c:	b8617841 	ldr	w1, [x2, x1, lsl #2]
    fd800000c380:	17ffe640 	b	fd8000005c80 <vgic_inject_hw>
    fd800000c384:	d503201f 	nop
    fd800000c388:	d503201f 	nop
    fd800000c38c:	d503201f 	nop

0000fd800000c390 <ipc_get_shmem>:
    if (shmem_id < shmem_table_size) {
    fd800000c390:	90000001 	adrp	x1, fd800000c000 <console_write+0x70>
    fd800000c394:	f941e021 	ldr	x1, [x1, #960]
    fd800000c398:	f9400022 	ldr	x2, [x1]
    fd800000c39c:	eb00005f 	cmp	x2, x0
    fd800000c3a0:	540000a9 	b.ls	fd800000c3b4 <ipc_get_shmem+0x24>  // b.plast
        return &shmem_table[shmem_id];
    fd800000c3a4:	f9400421 	ldr	x1, [x1, #8]
    fd800000c3a8:	d2800602 	mov	x2, #0x30                  	// #48
    fd800000c3ac:	9b020400 	madd	x0, x0, x2, x1
}
    fd800000c3b0:	d65f03c0 	ret
        return NULL;
    fd800000c3b4:	d2800000 	mov	x0, #0x0                   	// #0
}
    fd800000c3b8:	d65f03c0 	ret
    fd800000c3bc:	d503201f 	nop
    fd800000c3c0:	0001bd80 	.word	0x0001bd80
    fd800000c3c4:	0000fd80 	.word	0x0000fd80
    fd800000c3c8:	d503201f 	nop
    fd800000c3cc:	d503201f 	nop

0000fd800000c3d0 <ipc_hypercall>:
unsigned long ipc_hypercall(unsigned long ipc_id, unsigned long ipc_event, unsigned long arg2)
{
    unsigned long ret = -HC_E_SUCCESS;

    struct shmem* shmem = NULL;
    bool valid_ipc_obj = ipc_id < cpu()->vcpu->vm->ipc_num;
    fd800000c3d0:	d2dfc002 	mov	x2, #0xfe0000000000        	// #279275953455104
    fd800000c3d4:	f9402842 	ldr	x2, [x2, #80]
    fd800000c3d8:	f944c843 	ldr	x3, [x2, #2448]
    if (valid_ipc_obj) {
    fd800000c3dc:	f9410c62 	ldr	x2, [x3, #536]
    fd800000c3e0:	eb00005f 	cmp	x2, x0
    fd800000c3e4:	540006c9 	b.ls	fd800000c4bc <ipc_hypercall+0xec>  // b.plast
        shmem = ipc_get_shmem(cpu()->vcpu->vm->ipcs[ipc_id].shmem_id);
    fd800000c3e8:	f9411062 	ldr	x2, [x3, #544]
    fd800000c3ec:	d2800504 	mov	x4, #0x28                  	// #40
    if (shmem_id < shmem_table_size) {
    fd800000c3f0:	90000005 	adrp	x5, fd800000c000 <console_write+0x70>
    fd800000c3f4:	f94264a5 	ldr	x5, [x5, #1224]
        shmem = ipc_get_shmem(cpu()->vcpu->vm->ipcs[ipc_id].shmem_id);
    fd800000c3f8:	9b040802 	madd	x2, x0, x4, x2
                cpu_send_msg(i, &msg);
            }
        }

    } else {
        ret = -HC_E_INVAL_ARGS;
    fd800000c3fc:	92800040 	mov	x0, #0xfffffffffffffffd    	// #-3
    if (shmem_id < shmem_table_size) {
    fd800000c400:	f94000a6 	ldr	x6, [x5]
        shmem = ipc_get_shmem(cpu()->vcpu->vm->ipcs[ipc_id].shmem_id);
    fd800000c404:	f9400844 	ldr	x4, [x2, #16]
    if (shmem_id < shmem_table_size) {
    fd800000c408:	eb06009f 	cmp	x4, x6
    fd800000c40c:	540005c2 	b.cs	fd800000c4c4 <ipc_hypercall+0xf4>  // b.hs, b.nlast
        return &shmem_table[shmem_id];
    fd800000c410:	f94004a5 	ldr	x5, [x5, #8]
    fd800000c414:	d2800602 	mov	x2, #0x30                  	// #48
    fd800000c418:	9b021482 	madd	x2, x4, x2, x5
    if (valid_ipc_obj && valid_shmem) {
    fd800000c41c:	b4000542 	cbz	x2, fd800000c4c4 <ipc_hypercall+0xf4>
{
    fd800000c420:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    fd800000c424:	910003fd 	mov	x29, sp
        struct cpu_msg msg = { IPC_CPUMSG_ID, IPC_NOTIFY, data.raw };
    fd800000c428:	90000000 	adrp	x0, fd800000c000 <console_write+0x70>
    fd800000c42c:	f9426805 	ldr	x5, [x0, #1232]
{
    fd800000c430:	a90153f3 	stp	x19, x20, [sp, #16]
        cpumap_t ipc_cpu_masters = shmem->cpu_masters & ~cpu()->vcpu->vm->cpus;
    fd800000c434:	f9402874 	ldr	x20, [x3, #80]
        struct cpu_msg msg = { IPC_CPUMSG_ID, IPC_NOTIFY, data.raw };
    fd800000c438:	f94000a5 	ldr	x5, [x5]
{
    fd800000c43c:	f90013f5 	str	x21, [sp, #32]
        for (size_t i = 0; i < platform.cpu_num; i++) {
    fd800000c440:	90000000 	adrp	x0, fd800000c000 <console_write+0x70>
    fd800000c444:	f9426c15 	ldr	x21, [x0, #1240]
        union ipc_msg_data data = {
    fd800000c448:	d2800000 	mov	x0, #0x0                   	// #0
    fd800000c44c:	b3401c80 	bfxil	x0, x4, #0, #8
        struct cpu_msg msg = { IPC_CPUMSG_ID, IPC_NOTIFY, data.raw };
    fd800000c450:	29067fe5 	stp	w5, wzr, [sp, #48]
        for (size_t i = 0; i < platform.cpu_num; i++) {
    fd800000c454:	f94002a4 	ldr	x4, [x21]
        union ipc_msg_data data = {
    fd800000c458:	b3781c20 	bfi	x0, x1, #8, #8
        cpumap_t ipc_cpu_masters = shmem->cpu_masters & ~cpu()->vcpu->vm->cpus;
    fd800000c45c:	f9401041 	ldr	x1, [x2, #32]
        struct cpu_msg msg = { IPC_CPUMSG_ID, IPC_NOTIFY, data.raw };
    fd800000c460:	f9001fe0 	str	x0, [sp, #56]
        cpumap_t ipc_cpu_masters = shmem->cpu_masters & ~cpu()->vcpu->vm->cpus;
    fd800000c464:	8a340034 	bic	x20, x1, x20
        for (size_t i = 0; i < platform.cpu_num; i++) {
    fd800000c468:	b4000204 	cbz	x4, fd800000c4a8 <ipc_hypercall+0xd8>
    fd800000c46c:	d2800013 	mov	x19, #0x0                   	// #0
    fd800000c470:	14000005 	b	fd800000c484 <ipc_hypercall+0xb4>
    fd800000c474:	f94002a0 	ldr	x0, [x21]
    fd800000c478:	91000673 	add	x19, x19, #0x1
    fd800000c47c:	eb13001f 	cmp	x0, x19
    fd800000c480:	54000149 	b.ls	fd800000c4a8 <ipc_hypercall+0xd8>  // b.plast
            if (ipc_cpu_masters & (1ULL << i)) {
    fd800000c484:	9ad32680 	lsr	x0, x20, x19
    fd800000c488:	3607ff60 	tbz	w0, #0, fd800000c474 <ipc_hypercall+0xa4>
                cpu_send_msg(i, &msg);
    fd800000c48c:	aa1303e0 	mov	x0, x19
    fd800000c490:	9100c3e1 	add	x1, sp, #0x30
    fd800000c494:	97fff96f 	bl	fd800000aa50 <cpu_send_msg>
        for (size_t i = 0; i < platform.cpu_num; i++) {
    fd800000c498:	91000673 	add	x19, x19, #0x1
    fd800000c49c:	f94002a0 	ldr	x0, [x21]
    fd800000c4a0:	eb13001f 	cmp	x0, x19
    fd800000c4a4:	54ffff08 	b.hi	fd800000c484 <ipc_hypercall+0xb4>  // b.pmore
    }

    return ret;
}
    fd800000c4a8:	a94153f3 	ldp	x19, x20, [sp, #16]
    unsigned long ret = -HC_E_SUCCESS;
    fd800000c4ac:	d2800000 	mov	x0, #0x0                   	// #0
}
    fd800000c4b0:	f94013f5 	ldr	x21, [sp, #32]
    fd800000c4b4:	a8c47bfd 	ldp	x29, x30, [sp], #64
    fd800000c4b8:	d65f03c0 	ret
        ret = -HC_E_INVAL_ARGS;
    fd800000c4bc:	92800040 	mov	x0, #0xfffffffffffffffd    	// #-3
    fd800000c4c0:	d65f03c0 	ret
}
    fd800000c4c4:	d65f03c0 	ret
    fd800000c4c8:	0001bd80 	.word	0x0001bd80
    fd800000c4cc:	0000fd80 	.word	0x0000fd80
    fd800000c4d0:	00012e88 	.word	0x00012e88
    fd800000c4d4:	0000fd80 	.word	0x0000fd80
    fd800000c4d8:	00012930 	.word	0x00012930
    fd800000c4dc:	0000fd80 	.word	0x0000fd80

0000fd800000c4e0 <ipc_init>:
    }
}

void ipc_init()
{
    if (cpu()->id == CPU_MASTER) {
    fd800000c4e0:	90000000 	adrp	x0, fd800000c000 <console_write+0x70>
    fd800000c4e4:	f942fc00 	ldr	x0, [x0, #1528]
    fd800000c4e8:	d2dfc001 	mov	x1, #0xfe0000000000        	// #279275953455104
    fd800000c4ec:	f9400021 	ldr	x1, [x1]
    fd800000c4f0:	f9400000 	ldr	x0, [x0]
    fd800000c4f4:	eb00003f 	cmp	x1, x0
    fd800000c4f8:	54000040 	b.eq	fd800000c500 <ipc_init+0x20>  // b.none
    fd800000c4fc:	d65f03c0 	ret
{
    fd800000c500:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    fd800000c504:	910003fd 	mov	x29, sp
    fd800000c508:	a90363f7 	stp	x23, x24, [sp, #48]
        shmem_table_size = config.shmemlist_size;
    fd800000c50c:	90000000 	adrp	x0, fd800000c000 <console_write+0x70>
    fd800000c510:	f9430018 	ldr	x24, [x0, #1536]
    fd800000c514:	90000000 	adrp	x0, fd800000c000 <console_write+0x70>
    fd800000c518:	f9430417 	ldr	x23, [x0, #1544]
        shmem_table = config.shmemlist;
    fd800000c51c:	a9418301 	ldp	x1, x0, [x24, #24]
    fd800000c520:	a90002e1 	stp	x1, x0, [x23]
    for (size_t i = 0; i < shmem_table_size; i++) {
    fd800000c524:	b40005a1 	cbz	x1, fd800000c5d8 <ipc_init+0xf8>
    fd800000c528:	a90153f3 	stp	x19, x20, [sp, #16]
    fd800000c52c:	d2800013 	mov	x19, #0x0                   	// #0
    fd800000c530:	d2800014 	mov	x20, #0x0                   	// #0
    fd800000c534:	a9025bf5 	stp	x21, x22, [sp, #32]
    fd800000c538:	14000007 	b	fd800000c554 <ipc_init+0x74>
    fd800000c53c:	f94002e0 	ldr	x0, [x23]
    fd800000c540:	91000694 	add	x20, x20, #0x1
    fd800000c544:	9100c273 	add	x19, x19, #0x30
    fd800000c548:	eb00029f 	cmp	x20, x0
    fd800000c54c:	540002e2 	b.cs	fd800000c5a8 <ipc_init+0xc8>  // b.hs, b.nlast
        struct shmem* shmem = &shmem_table[i];
    fd800000c550:	f94006e0 	ldr	x0, [x23, #8]
    fd800000c554:	8b130015 	add	x21, x0, x19
        if (!shmem->place_phys) {
    fd800000c558:	394042a1 	ldrb	w1, [x21, #16]
    fd800000c55c:	3707ff01 	tbnz	w1, #0, fd800000c53c <ipc_init+0x5c>
            size_t n_pg = NUM_PAGES(shmem->size);
    fd800000c560:	f8736816 	ldr	x22, [x0, x19]
            struct ppages ppages = mem_alloc_ppages(shmem->colors, n_pg, false);
    fd800000c564:	910123e8 	add	x8, sp, #0x48
    fd800000c568:	f94006a0 	ldr	x0, [x21, #8]
            size_t n_pg = NUM_PAGES(shmem->size);
    fd800000c56c:	913ffed6 	add	x22, x22, #0xfff
            struct ppages ppages = mem_alloc_ppages(shmem->colors, n_pg, false);
    fd800000c570:	52800002 	mov	w2, #0x0                   	// #0
            size_t n_pg = NUM_PAGES(shmem->size);
    fd800000c574:	d34cfed6 	lsr	x22, x22, #12
            struct ppages ppages = mem_alloc_ppages(shmem->colors, n_pg, false);
    fd800000c578:	aa1603e1 	mov	x1, x22
    fd800000c57c:	97fff685 	bl	fd8000009f90 <mem_alloc_ppages>
            if (ppages.num_pages < n_pg) {
    fd800000c580:	f9402be0 	ldr	x0, [sp, #80]
    fd800000c584:	eb0002df 	cmp	x22, x0
    fd800000c588:	540002e8 	b.hi	fd800000c5e4 <ipc_init+0x104>  // b.pmore
            shmem->phys = ppages.base;
    fd800000c58c:	f94027e0 	ldr	x0, [sp, #72]
    fd800000c590:	f9000ea0 	str	x0, [x21, #24]
    for (size_t i = 0; i < shmem_table_size; i++) {
    fd800000c594:	f94002e0 	ldr	x0, [x23]
    fd800000c598:	91000694 	add	x20, x20, #0x1
    fd800000c59c:	9100c273 	add	x19, x19, #0x30
    fd800000c5a0:	eb00029f 	cmp	x20, x0
    fd800000c5a4:	54fffd63 	b.cc	fd800000c550 <ipc_init+0x70>  // b.lo, b.ul, b.last
        ipc_alloc_shmem();

        for (size_t i = 0; i < config.shmemlist_size; i++) {
    fd800000c5a8:	f9400f01 	ldr	x1, [x24, #24]
    fd800000c5ac:	b4000121 	cbz	x1, fd800000c5d0 <ipc_init+0xf0>
    fd800000c5b0:	f9401300 	ldr	x0, [x24, #32]
    fd800000c5b4:	d2800602 	mov	x2, #0x30                  	// #48
    fd800000c5b8:	9b020021 	madd	x1, x1, x2, x0
    fd800000c5bc:	d503201f 	nop
            config.shmemlist[i].cpu_masters = 0;
    fd800000c5c0:	f900101f 	str	xzr, [x0, #32]
        for (size_t i = 0; i < config.shmemlist_size; i++) {
    fd800000c5c4:	9100c000 	add	x0, x0, #0x30
    fd800000c5c8:	eb01001f 	cmp	x0, x1
    fd800000c5cc:	54ffffa1 	b.ne	fd800000c5c0 <ipc_init+0xe0>  // b.any
    fd800000c5d0:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd800000c5d4:	a9425bf5 	ldp	x21, x22, [sp, #32]
        }
    }
}
    fd800000c5d8:	a94363f7 	ldp	x23, x24, [sp, #48]
    fd800000c5dc:	a8c67bfd 	ldp	x29, x30, [sp], #96
    fd800000c5e0:	d65f03c0 	ret
                ERROR("failed to allocate shared memory");
    fd800000c5e4:	90000000 	adrp	x0, fd800000c000 <console_write+0x70>
    fd800000c5e8:	f9430800 	ldr	x0, [x0, #1552]
    fd800000c5ec:	97fffe8d 	bl	fd800000c020 <console_printk>
    fd800000c5f0:	14000000 	b	fd800000c5f0 <ipc_init+0x110>
    fd800000c5f4:	d503201f 	nop
    fd800000c5f8:	00012348 	.word	0x00012348
    fd800000c5fc:	0000fd80 	.word	0x0000fd80
    fd800000c600:	00012bf0 	.word	0x00012bf0
    fd800000c604:	0000fd80 	.word	0x0000fd80
    fd800000c608:	0001bd80 	.word	0x0001bd80
    fd800000c60c:	0000fd80 	.word	0x0000fd80
    fd800000c610:	00010ec0 	.word	0x00010ec0
    fd800000c614:	0000fd80 	.word	0x0000fd80
	...

0000fd800000c620 <objpool_init>:

#include <objpool.h>
#include <string.h>

void objpool_init(struct objpool* objpool)
{
    fd800000c620:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    memset(objpool->pool, 0, objpool->objsize * objpool->num);
    fd800000c624:	52800001 	mov	w1, #0x0                   	// #0
{
    fd800000c628:	910003fd 	mov	x29, sp
    fd800000c62c:	f9000bf3 	str	x19, [sp, #16]
    fd800000c630:	aa0003f3 	mov	x19, x0
    memset(objpool->pool, 0, objpool->objsize * objpool->num);
    fd800000c634:	f9400000 	ldr	x0, [x0]
    fd800000c638:	a9410a63 	ldp	x3, x2, [x19, #16]
    fd800000c63c:	9b027c62 	mul	x2, x3, x2
    fd800000c640:	97fff13c 	bl	fd8000008b30 <memset>
    memset(objpool->bitmap, 0, BITMAP_SIZE(objpool->num));
    fd800000c644:	f9400660 	ldr	x0, [x19, #8]
    fd800000c648:	52800001 	mov	w1, #0x0                   	// #0
    fd800000c64c:	f9400e62 	ldr	x2, [x19, #24]
}
    fd800000c650:	f9400bf3 	ldr	x19, [sp, #16]
    memset(objpool->bitmap, 0, BITMAP_SIZE(objpool->num));
    fd800000c654:	92401043 	and	x3, x2, #0x1f
}
    fd800000c658:	a8c27bfd 	ldp	x29, x30, [sp], #32
    memset(objpool->bitmap, 0, BITMAP_SIZE(objpool->num));
    fd800000c65c:	f100007f 	cmp	x3, #0x0
    fd800000c660:	d345fc42 	lsr	x2, x2, #5
    fd800000c664:	9a820442 	cinc	x2, x2, ne	// ne = any
    fd800000c668:	17fff132 	b	fd8000008b30 <memset>
    fd800000c66c:	d503201f 	nop

0000fd800000c670 <objpool_alloc>:

void* objpool_alloc(struct objpool* objpool)
{
    fd800000c670:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    fd800000c674:	910003fd 	mov	x29, sp
    fd800000c678:	a90153f3 	stp	x19, x20, [sp, #16]
    void* obj = NULL;
    spin_lock(&objpool->lock);
    fd800000c67c:	9100a014 	add	x20, x0, #0x28
{
    fd800000c680:	aa0003f3 	mov	x19, x0
    __asm__ volatile(
    fd800000c684:	91001283 	add	x3, x20, #0x4
    fd800000c688:	885ffe80 	ldaxr	w0, [x20]
    fd800000c68c:	11000401 	add	w1, w0, #0x1
    fd800000c690:	88027e81 	stxr	w2, w1, [x20]
    fd800000c694:	35ffffa2 	cbnz	w2, fd800000c688 <objpool_alloc+0x18>
    fd800000c698:	88dffc61 	ldar	w1, [x3]
    fd800000c69c:	6b01001f 	cmp	w0, w1
    fd800000c6a0:	54000060 	b.eq	fd800000c6ac <objpool_alloc+0x3c>  // b.none
    fd800000c6a4:	d503205f 	wfe
    fd800000c6a8:	17fffffc 	b	fd800000c698 <objpool_alloc+0x28>
    ssize_t n = bitmap_find_nth(objpool->bitmap, objpool->num, 1, 0, false);
    fd800000c6ac:	f9400660 	ldr	x0, [x19, #8]
    fd800000c6b0:	52800004 	mov	w4, #0x0                   	// #0
    fd800000c6b4:	f9400e61 	ldr	x1, [x19, #24]
    fd800000c6b8:	d2800003 	mov	x3, #0x0                   	// #0
    fd800000c6bc:	d2800022 	mov	x2, #0x1                   	// #1
    fd800000c6c0:	97fff28c 	bl	fd80000090f0 <bitmap_find_nth>
    if (n >= 0) {
    fd800000c6c4:	b7f80260 	tbnz	x0, #63, fd800000c710 <objpool_alloc+0xa0>
    fd800000c6c8:	a9400e65 	ldp	x5, x3, [x19]
    fd800000c6cc:	d345fc04 	lsr	x4, x0, #5
        bitmap_set(objpool->bitmap, n);
        obj = objpool->pool + (objpool->objsize * n);
    fd800000c6d0:	f9400a66 	ldr	x6, [x19, #16]
    fd800000c6d4:	52800022 	mov	w2, #0x1                   	// #1
    fd800000c6d8:	1ac02042 	lsl	w2, w2, w0
    fd800000c6dc:	b8647861 	ldr	w1, [x3, x4, lsl #2]
    fd800000c6e0:	9b061400 	madd	x0, x0, x6, x5
    fd800000c6e4:	2a020021 	orr	w1, w1, w2
    fd800000c6e8:	b8247861 	str	w1, [x3, x4, lsl #2]
    __asm__ volatile(
    fd800000c6ec:	91001282 	add	x2, x20, #0x4
    fd800000c6f0:	b9400041 	ldr	w1, [x2]
    fd800000c6f4:	11000421 	add	w1, w1, #0x1
    fd800000c6f8:	889ffc41 	stlr	w1, [x2]
    fd800000c6fc:	d5033b9f 	dsb	ish
    fd800000c700:	d503209f 	sev
    }
    spin_unlock(&objpool->lock);
    return obj;
}
    fd800000c704:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd800000c708:	a8c27bfd 	ldp	x29, x30, [sp], #32
    fd800000c70c:	d65f03c0 	ret
    void* obj = NULL;
    fd800000c710:	d2800000 	mov	x0, #0x0                   	// #0
    fd800000c714:	17fffff6 	b	fd800000c6ec <objpool_alloc+0x7c>
    fd800000c718:	d503201f 	nop
    fd800000c71c:	d503201f 	nop

0000fd800000c720 <objpool_free>:

void objpool_free(struct objpool* objpool, void* obj)
{
    vaddr_t obj_addr = (vaddr_t)obj;
    vaddr_t pool_addr = (vaddr_t)objpool->pool;
    bool in_pool = in_range(obj_addr, pool_addr, objpool->objsize * objpool->num);
    fd800000c720:	a9410803 	ldp	x3, x2, [x0, #16]
    vaddr_t pool_addr = (vaddr_t)objpool->pool;
    fd800000c724:	f9400004 	ldr	x4, [x0]
    bool in_pool = in_range(obj_addr, pool_addr, objpool->objsize * objpool->num);
    fd800000c728:	9b027c62 	mul	x2, x3, x2
    fd800000c72c:	ab040042 	adds	x2, x2, x4
    fd800000c730:	540004a2 	b.cs	fd800000c7c4 <objpool_free+0xa4>  // b.hs, b.nlast
    return (base1 >= base2) && (limit1 <= limit2);
    fd800000c734:	eb02003f 	cmp	x1, x2
    fd800000c738:	1a9f87e6 	cset	w6, ls	// ls = plast
    bool aligned = IS_ALIGNED(obj_addr - pool_addr, objpool->objsize);
    fd800000c73c:	cb040025 	sub	x5, x1, x4
    fd800000c740:	9ac308a2 	udiv	x2, x5, x3
    fd800000c744:	9b039443 	msub	x3, x2, x3, x5
    if (in_pool && aligned) {
    fd800000c748:	f100007f 	cmp	x3, #0x0
    fd800000c74c:	fa440020 	ccmp	x1, x4, #0x0, eq	// eq = none
    fd800000c750:	7a4028c4 	ccmp	w6, #0x0, #0x4, cs	// cs = hs, nlast
    fd800000c754:	54000320 	b.eq	fd800000c7b8 <objpool_free+0x98>  // b.none
        size_t n = (obj_addr - pool_addr) / objpool->objsize;
        spin_lock(&objpool->lock);
    fd800000c758:	9100a001 	add	x1, x0, #0x28
    __asm__ volatile(
    fd800000c75c:	9100b006 	add	x6, x0, #0x2c
    fd800000c760:	885ffc23 	ldaxr	w3, [x1]
    fd800000c764:	11000464 	add	w4, w3, #0x1
    fd800000c768:	88057c24 	stxr	w5, w4, [x1]
    fd800000c76c:	35ffffa5 	cbnz	w5, fd800000c760 <objpool_free+0x40>
    fd800000c770:	88dffcc4 	ldar	w4, [x6]
    fd800000c774:	6b04007f 	cmp	w3, w4
    fd800000c778:	54000060 	b.eq	fd800000c784 <objpool_free+0x64>  // b.none
    fd800000c77c:	d503205f 	wfe
    fd800000c780:	17fffffc 	b	fd800000c770 <objpool_free+0x50>
    map[bit / BITMAP_GRANULE_LEN] &= ~(ONE << (bit % BITMAP_GRANULE_LEN));
    fd800000c784:	f9400403 	ldr	x3, [x0, #8]
    fd800000c788:	d345fc44 	lsr	x4, x2, #5
    fd800000c78c:	52800020 	mov	w0, #0x1                   	// #1
    fd800000c790:	1ac22000 	lsl	w0, w0, w2
    fd800000c794:	b8647862 	ldr	w2, [x3, x4, lsl #2]
    fd800000c798:	0a200040 	bic	w0, w2, w0
    fd800000c79c:	b8247860 	str	w0, [x3, x4, lsl #2]
    __asm__ volatile(
    fd800000c7a0:	b94000c0 	ldr	w0, [x6]
    fd800000c7a4:	11000400 	add	w0, w0, #0x1
    fd800000c7a8:	889ffcc0 	stlr	w0, [x6]
    fd800000c7ac:	d5033b9f 	dsb	ish
    fd800000c7b0:	d503209f 	sev
        bitmap_clear(objpool->bitmap, n);
        spin_unlock(&objpool->lock);
    } else {
        WARNING("leaked while trying to free stray object");
    }
}
    fd800000c7b4:	d65f03c0 	ret
        WARNING("leaked while trying to free stray object");
    fd800000c7b8:	90000000 	adrp	x0, fd800000c000 <console_write+0x70>
    fd800000c7bc:	f943e800 	ldr	x0, [x0, #2000]
    fd800000c7c0:	17fffe18 	b	fd800000c020 <console_printk>
    fd800000c7c4:	52800026 	mov	w6, #0x1                   	// #1
    fd800000c7c8:	17ffffdd 	b	fd800000c73c <objpool_free+0x1c>
    fd800000c7cc:	d503201f 	nop
    fd800000c7d0:	00010ef0 	.word	0x00010ef0
    fd800000c7d4:	0000fd80 	.word	0x0000fd80
	...

0000fd800000c7e0 <hypercall>:
#include <cpu.h>
#include <vm.h>
#include <ipc.h>

long int hypercall(unsigned long id)
{
    fd800000c7e0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    long int ret = -HC_E_INVAL_ID;

    unsigned long ipc_id = vcpu_readreg(cpu()->vcpu, HYPCALL_ARG_REG(0));
    fd800000c7e4:	d2800021 	mov	x1, #0x1                   	// #1
{
    fd800000c7e8:	910003fd 	mov	x29, sp
    fd800000c7ec:	a90153f3 	stp	x19, x20, [sp, #16]
    unsigned long ipc_id = vcpu_readreg(cpu()->vcpu, HYPCALL_ARG_REG(0));
    fd800000c7f0:	d2dfc014 	mov	x20, #0xfe0000000000        	// #279275953455104
{
    fd800000c7f4:	aa0003f3 	mov	x19, x0
    unsigned long ipc_id = vcpu_readreg(cpu()->vcpu, HYPCALL_ARG_REG(0));
    fd800000c7f8:	f9402a80 	ldr	x0, [x20, #80]
{
    fd800000c7fc:	f90013f5 	str	x21, [sp, #32]
    unsigned long ipc_id = vcpu_readreg(cpu()->vcpu, HYPCALL_ARG_REG(0));
    fd800000c800:	97ffd404 	bl	fd8000001810 <vcpu_readreg>
    fd800000c804:	aa0003f5 	mov	x21, x0
    unsigned long arg1 = vcpu_readreg(cpu()->vcpu, HYPCALL_ARG_REG(1));
    fd800000c808:	f9402a80 	ldr	x0, [x20, #80]
    fd800000c80c:	d2800041 	mov	x1, #0x2                   	// #2
    fd800000c810:	97ffd400 	bl	fd8000001810 <vcpu_readreg>
    fd800000c814:	aa0003e1 	mov	x1, x0
    unsigned long arg2 = vcpu_readreg(cpu()->vcpu, HYPCALL_ARG_REG(2));
    fd800000c818:	f9402a80 	ldr	x0, [x20, #80]
    unsigned long arg1 = vcpu_readreg(cpu()->vcpu, HYPCALL_ARG_REG(1));
    fd800000c81c:	aa0103f4 	mov	x20, x1
    unsigned long arg2 = vcpu_readreg(cpu()->vcpu, HYPCALL_ARG_REG(2));
    fd800000c820:	d2800061 	mov	x1, #0x3                   	// #3
    fd800000c824:	97ffd3fb 	bl	fd8000001810 <vcpu_readreg>

    switch (id) {
    fd800000c828:	f100067f 	cmp	x19, #0x1
    fd800000c82c:	54000101 	b.ne	fd800000c84c <hypercall+0x6c>  // b.any
    fd800000c830:	aa0003e2 	mov	x2, x0
        case HC_IPC:
            ret = ipc_hypercall(ipc_id, arg1, arg2);
    fd800000c834:	aa1403e1 	mov	x1, x20
        default:
            WARNING("Unknown hypercall id %d", id);
    }

    return ret;
}
    fd800000c838:	a94153f3 	ldp	x19, x20, [sp, #16]
            ret = ipc_hypercall(ipc_id, arg1, arg2);
    fd800000c83c:	aa1503e0 	mov	x0, x21
}
    fd800000c840:	f94013f5 	ldr	x21, [sp, #32]
    fd800000c844:	a8c37bfd 	ldp	x29, x30, [sp], #48
            ret = ipc_hypercall(ipc_id, arg1, arg2);
    fd800000c848:	17fffee2 	b	fd800000c3d0 <ipc_hypercall>
            WARNING("Unknown hypercall id %d", id);
    fd800000c84c:	90000000 	adrp	x0, fd800000c000 <console_write+0x70>
    fd800000c850:	aa1303e1 	mov	x1, x19
    fd800000c854:	f9443800 	ldr	x0, [x0, #2160]
    fd800000c858:	97fffdf2 	bl	fd800000c020 <console_printk>
}
    fd800000c85c:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd800000c860:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
    fd800000c864:	f94013f5 	ldr	x21, [sp, #32]
    fd800000c868:	a8c37bfd 	ldp	x29, x30, [sp], #48
    fd800000c86c:	d65f03c0 	ret
    fd800000c870:	00010f28 	.word	0x00010f28
    fd800000c874:	0000fd80 	.word	0x0000fd80
	...

0000fd800000c880 <mem_free_ppages>:
    return index;
}

static void mem_free_ppages(struct ppages* ppages)
{
    list_foreach (page_pool_list, struct page_pool, pool) {
    fd800000c880:	90000001 	adrp	x1, fd800000c000 <console_write+0x70>
    fd800000c884:	f944f021 	ldr	x1, [x1, #2528]
    fd800000c888:	f9400029 	ldr	x9, [x1]
    fd800000c88c:	b40006e9 	cbz	x9, fd800000c968 <mem_free_ppages+0xe8>
    colormap_t mask = (((colormap_t)1) << COLOR_NUM) - 1;
    fd800000c890:	d280002b 	mov	x11, #0x1                   	// #1
    fd800000c894:	2a0b03ea 	mov	w10, w11
    fd800000c898:	9000000c 	adrp	x12, fd800000c000 <console_write+0x70>
    size_t clr_offset = (base / PAGE_SIZE) % (COLOR_NUM * COLOR_SIZE);
    fd800000c89c:	9000000d 	adrp	x13, fd800000c000 <console_write+0x70>
        spin_lock(&pool->lock);
    fd800000c8a0:	9100c128 	add	x8, x9, #0x30
    __asm__ volatile(
    fd800000c8a4:	91001104 	add	x4, x8, #0x4
    fd800000c8a8:	885ffd01 	ldaxr	w1, [x8]
    fd800000c8ac:	11000422 	add	w2, w1, #0x1
    fd800000c8b0:	88037d02 	stxr	w3, w2, [x8]
    fd800000c8b4:	35ffffa3 	cbnz	w3, fd800000c8a8 <mem_free_ppages+0x28>
    fd800000c8b8:	88dffc82 	ldar	w2, [x4]
    fd800000c8bc:	6b02003f 	cmp	w1, w2
    fd800000c8c0:	54000060 	b.eq	fd800000c8cc <mem_free_ppages+0x4c>  // b.none
    fd800000c8c4:	d503205f 	wfe
    fd800000c8c8:	17fffffc 	b	fd800000c8b8 <mem_free_ppages+0x38>
        if (in_range(ppages->base, pool->base, pool->size * PAGE_SIZE)) {
    fd800000c8cc:	a9408522 	ldp	x2, x1, [x9, #8]
    fd800000c8d0:	f9400003 	ldr	x3, [x0]
    fd800000c8d4:	d374cc21 	lsl	x1, x1, #12
    fd800000c8d8:	ab010041 	adds	x1, x2, x1
    fd800000c8dc:	540007e2 	b.cs	fd800000c9d8 <mem_free_ppages+0x158>  // b.hs, b.nlast
    fd800000c8e0:	eb01007f 	cmp	x3, x1
    fd800000c8e4:	1a9f87e1 	cset	w1, ls	// ls = plast
    fd800000c8e8:	7100003f 	cmp	w1, #0x0
    fd800000c8ec:	fa421060 	ccmp	x3, x2, #0x0, ne	// ne = any
    fd800000c8f0:	540002c3 	b.cc	fd800000c948 <mem_free_ppages+0xc8>  // b.lo, b.ul, b.last
    fd800000c8f4:	f944f581 	ldr	x1, [x12, #2536]
            size_t index = (ppages->base - pool->base) / PAGE_SIZE;
    fd800000c8f8:	cb020063 	sub	x3, x3, x2
            if (!all_clrs(ppages->colors)) {
    fd800000c8fc:	a940940e 	ldp	x14, x5, [x0, #8]
            size_t index = (ppages->base - pool->base) / PAGE_SIZE;
    fd800000c900:	d34cfc63 	lsr	x3, x3, #12
    fd800000c904:	f9400024 	ldr	x4, [x1]
    fd800000c908:	9ac42161 	lsl	x1, x11, x4
    fd800000c90c:	d1000421 	sub	x1, x1, #0x1
    return (masked_colors == 0) || (masked_colors == mask);
    fd800000c910:	ea0100a6 	ands	x6, x5, x1
            if (!all_clrs(ppages->colors)) {
    fd800000c914:	fa461024 	ccmp	x1, x6, #0x4, ne	// ne = any
    fd800000c918:	540002a1 	b.ne	fd800000c96c <mem_free_ppages+0xec>  // b.any
                for (size_t i = 0; i < ppages->num_pages; i++) {
                    index = pp_next_clr(pool->base, index, ppages->colors);
                    bitmap_clear(pool->bitmap, index++);
                }
            } else {
                bitmap_clear_consecutive(pool->bitmap, index, ppages->num_pages);
    fd800000c91c:	f9401524 	ldr	x4, [x9, #40]
    for (size_t i = 0; i < n; i++) {
    fd800000c920:	b400014e 	cbz	x14, fd800000c948 <mem_free_ppages+0xc8>
    fd800000c924:	8b0e006e 	add	x14, x3, x14
    map[bit / BITMAP_GRANULE_LEN] &= ~(ONE << (bit % BITMAP_GRANULE_LEN));
    fd800000c928:	d345fc62 	lsr	x2, x3, #5
    fd800000c92c:	1ac32141 	lsl	w1, w10, w3
    for (size_t i = 0; i < n; i++) {
    fd800000c930:	91000463 	add	x3, x3, #0x1
    fd800000c934:	eb0e007f 	cmp	x3, x14
    map[bit / BITMAP_GRANULE_LEN] &= ~(ONE << (bit % BITMAP_GRANULE_LEN));
    fd800000c938:	b8627885 	ldr	w5, [x4, x2, lsl #2]
    fd800000c93c:	0a2100a1 	bic	w1, w5, w1
    fd800000c940:	b8227881 	str	w1, [x4, x2, lsl #2]
    for (size_t i = 0; i < n; i++) {
    fd800000c944:	54ffff21 	b.ne	fd800000c928 <mem_free_ppages+0xa8>  // b.any
    __asm__ volatile(
    fd800000c948:	91001102 	add	x2, x8, #0x4
    fd800000c94c:	b9400041 	ldr	w1, [x2]
    fd800000c950:	11000421 	add	w1, w1, #0x1
    fd800000c954:	889ffc41 	stlr	w1, [x2]
    fd800000c958:	d5033b9f 	dsb	ish
    fd800000c95c:	d503209f 	sev
    list_foreach (page_pool_list, struct page_pool, pool) {
    fd800000c960:	f9400129 	ldr	x9, [x9]
    fd800000c964:	b5fff9e9 	cbnz	x9, fd800000c8a0 <mem_free_ppages+0x20>
            }
        }
        spin_unlock(&pool->lock);
    }
}
    fd800000c968:	d65f03c0 	ret
                for (size_t i = 0; i < ppages->num_pages; i++) {
    fd800000c96c:	b4fffeee 	cbz	x14, fd800000c948 <mem_free_ppages+0xc8>
    size_t clr_offset = (base / PAGE_SIZE) % (COLOR_NUM * COLOR_SIZE);
    fd800000c970:	f944f9a1 	ldr	x1, [x13, #2544]
    fd800000c974:	d34cfc42 	lsr	x2, x2, #12
                    bitmap_clear(pool->bitmap, index++);
    fd800000c978:	f9401530 	ldr	x16, [x9, #40]
                for (size_t i = 0; i < ppages->num_pages; i++) {
    fd800000c97c:	d280000f 	mov	x15, #0x0                   	// #0
    size_t clr_offset = (base / PAGE_SIZE) % (COLOR_NUM * COLOR_SIZE);
    fd800000c980:	f9400027 	ldr	x7, [x1]
    fd800000c984:	9b077c81 	mul	x1, x4, x7
    fd800000c988:	9ac10846 	udiv	x6, x2, x1
    fd800000c98c:	9b0188c6 	msub	x6, x6, x1, x2
    fd800000c990:	14000002 	b	fd800000c998 <mem_free_ppages+0x118>
        index++;
    fd800000c994:	91000463 	add	x3, x3, #0x1
    while (!((colors >> ((index + clr_offset) / COLOR_SIZE % COLOR_NUM)) & 1)) {
    fd800000c998:	8b0300c2 	add	x2, x6, x3
    fd800000c99c:	9ac70842 	udiv	x2, x2, x7
    fd800000c9a0:	9ac40841 	udiv	x1, x2, x4
    fd800000c9a4:	9b048821 	msub	x1, x1, x4, x2
    fd800000c9a8:	9ac124a1 	lsr	x1, x5, x1
    fd800000c9ac:	3607ff41 	tbz	w1, #0, fd800000c994 <mem_free_ppages+0x114>
    map[bit / BITMAP_GRANULE_LEN] &= ~(ONE << (bit % BITMAP_GRANULE_LEN));
    fd800000c9b0:	d345fc62 	lsr	x2, x3, #5
    fd800000c9b4:	1ac32141 	lsl	w1, w10, w3
                for (size_t i = 0; i < ppages->num_pages; i++) {
    fd800000c9b8:	910005ef 	add	x15, x15, #0x1
                    bitmap_clear(pool->bitmap, index++);
    fd800000c9bc:	91000463 	add	x3, x3, #0x1
                for (size_t i = 0; i < ppages->num_pages; i++) {
    fd800000c9c0:	eb0e01ff 	cmp	x15, x14
    fd800000c9c4:	b8627a11 	ldr	w17, [x16, x2, lsl #2]
    fd800000c9c8:	0a210221 	bic	w1, w17, w1
    fd800000c9cc:	b8227a01 	str	w1, [x16, x2, lsl #2]
    fd800000c9d0:	54fffe41 	b.ne	fd800000c998 <mem_free_ppages+0x118>  // b.any
    fd800000c9d4:	17ffffdd 	b	fd800000c948 <mem_free_ppages+0xc8>
    fd800000c9d8:	52800021 	mov	w1, #0x1                   	// #1
    fd800000c9dc:	17ffffc3 	b	fd800000c8e8 <mem_free_ppages+0x68>
    fd800000c9e0:	000130a0 	.word	0x000130a0
    fd800000c9e4:	0000fd80 	.word	0x0000fd80
    fd800000c9e8:	00012828 	.word	0x00012828
    fd800000c9ec:	0000fd80 	.word	0x0000fd80
    fd800000c9f0:	00012820 	.word	0x00012820
    fd800000c9f4:	0000fd80 	.word	0x0000fd80
    fd800000c9f8:	d503201f 	nop
    fd800000c9fc:	d503201f 	nop

0000fd800000ca00 <mem_expand_pte.part.0>:
static inline pte_type_t pt_page_type(struct page_table* pt, size_t lvl)
{
    return (lvl == pt->dscr->lvls - 1) ? PTE_PAGE : PTE_SUPERPAGE;
}

static void mem_expand_pte(struct addr_space* as, vaddr_t va, size_t lvl)
    fd800000ca00:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
    fd800000ca04:	910003fd 	mov	x29, sp
    fd800000ca08:	a90153f3 	stp	x19, x20, [sp, #16]
    fd800000ca0c:	aa0203f4 	mov	x20, x2
    if (as->pt.dscr->lvls - 1 <= lvl) {
        /* no more levels to expand */
        return;
    }

    pte_t* pte = pt_get_pte(&as->pt, lvl, va);
    fd800000ca10:	aa0103e2 	mov	x2, x1
static void mem_expand_pte(struct addr_space* as, vaddr_t va, size_t lvl)
    fd800000ca14:	a9025bf5 	stp	x21, x22, [sp, #32]
    fd800000ca18:	aa0103f6 	mov	x22, x1
    fd800000ca1c:	aa0003f5 	mov	x21, x0
    pte_t* pte = pt_get_pte(&as->pt, lvl, va);
    fd800000ca20:	aa1403e1 	mov	x1, x20
    fd800000ca24:	97ffd3ef 	bl	fd80000019e0 <pt_get_pte>

    /**
     * only can expand if the pte exists and it isnt pointing to a next level table already.
     */
    if (pte != NULL && !pte_table(&as->pt, pte, lvl)) {
    fd800000ca28:	b40000e0 	cbz	x0, fd800000ca44 <mem_expand_pte.part.0+0x44>
    fd800000ca2c:	aa0003f3 	mov	x19, x0
    fd800000ca30:	aa0003e1 	mov	x1, x0
    fd800000ca34:	aa1403e2 	mov	x2, x20
    fd800000ca38:	aa1503e0 	mov	x0, x21
    fd800000ca3c:	97ffd431 	bl	fd8000001b00 <pte_table>
    fd800000ca40:	360000a0 	tbz	w0, #0, fd800000ca54 <mem_expand_pte.part.0+0x54>
            }

            fence_sync_write();
        }
    }
}
    fd800000ca44:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd800000ca48:	a9425bf5 	ldp	x21, x22, [sp, #32]
    fd800000ca4c:	a8c87bfd 	ldp	x29, x30, [sp], #128
    fd800000ca50:	d65f03c0 	ret
        pte_t pte_val = *pte; // save the original pte
    fd800000ca54:	f94006a0 	ldr	x0, [x21, #8]
    size_t ptsize = NUM_PAGES(pt_size(&as->pt, lvl + 1));
    fd800000ca58:	91000694 	add	x20, x20, #0x1
    fd800000ca5c:	a90363f7 	stp	x23, x24, [sp, #48]
    struct ppages ppage = mem_alloc_ppages(as->colors, ptsize, ptsize > 1 ? true : false);
    fd800000ca60:	9101a3e8 	add	x8, sp, #0x68
    fd800000ca64:	a9408400 	ldp	x0, x1, [x0, #8]
    fd800000ca68:	a9046bf9 	stp	x25, x26, [sp, #64]
    fd800000ca6c:	d37df29a 	lsl	x26, x20, #3
        pte_t pte_val = *pte; // save the original pte
    fd800000ca70:	f9400277 	ldr	x23, [x19]
    fd800000ca74:	f8747821 	ldr	x1, [x1, x20, lsl #3]
    *pte = (*pte & ~PTE_RSW_MSK) | (flag & PTE_RSW_MSK);
}

static inline bool pte_check_rsw(pte_t* pte, pte_flags_t flag)
{
    return (*pte & PTE_RSW_MSK) == (flag & PTE_RSW_MSK);
    fd800000ca78:	d24906e2 	eor	x2, x23, #0x180000000000000
    fd800000ca7c:	f2490c5f 	tst	x2, #0x780000000000000
    return (*pte & PTE_VALID);
    fd800000ca80:	120002f8 	and	w24, w23, #0x1
    fd800000ca84:	f8747802 	ldr	x2, [x0, x20, lsl #3]
    return (*pte & PTE_RSW_MSK) == (flag & PTE_RSW_MSK);
    fd800000ca88:	1a9f17f9 	cset	w25, eq	// eq = none
    struct ppages ppage = mem_alloc_ppages(as->colors, ptsize, ptsize > 1 ? true : false);
    fd800000ca8c:	f94016a0 	ldr	x0, [x21, #40]
    fd800000ca90:	f9002bfb 	str	x27, [sp, #80]
    fd800000ca94:	d280003b 	mov	x27, #0x1                   	// #1
    fd800000ca98:	9ac12361 	lsl	x1, x27, x1
    fd800000ca9c:	9ac22421 	lsr	x1, x1, x2
    return pt_nentries(pt, lvl) * sizeof(pte_t);
    fd800000caa0:	d37df021 	lsl	x1, x1, #3
    size_t ptsize = NUM_PAGES(pt_size(&as->pt, lvl + 1));
    fd800000caa4:	913ffc21 	add	x1, x1, #0xfff
    fd800000caa8:	d34cfc21 	lsr	x1, x1, #12
    struct ppages ppage = mem_alloc_ppages(as->colors, ptsize, ptsize > 1 ? true : false);
    fd800000caac:	eb1b003f 	cmp	x1, x27
    fd800000cab0:	1a9f97e2 	cset	w2, hi	// hi = pmore
    fd800000cab4:	97fff537 	bl	fd8000009f90 <mem_alloc_ppages>
    if (ppage.num_pages == 0) {
    fd800000cab8:	f9403be1 	ldr	x1, [sp, #112]
        return NULL;
    fd800000cabc:	d2800000 	mov	x0, #0x0                   	// #0
    if (ppage.num_pages == 0) {
    fd800000cac0:	b4000401 	cbz	x1, fd800000cb40 <mem_expand_pte.part.0+0x140>
    *pte = (addr & PTE_ADDR_MSK) | ((type | flags) & PTE_FLAGS_MSK);
    fd800000cac4:	f94037e0 	ldr	x0, [sp, #104]
    fd800000cac8:	d280e8e2 	mov	x2, #0x747                 	// #1863
    pte_t pte_dflt_val = PTE_INVALID | (*parent & PTE_RSW_MSK);
    fd800000cacc:	f9400261 	ldr	x1, [x19]
    fd800000cad0:	92748c00 	and	x0, x0, #0xfffffffff000
    fd800000cad4:	aa020000 	orr	x0, x0, x2
    fd800000cad8:	f9000260 	str	x0, [x19]
    fd800000cadc:	92490c33 	and	x19, x1, #0x780000000000000
    fd800000cae0:	d5033a9f 	dsb	ishst
    pte_t* temp_pt = pt_get(&as->pt, lvl + 1, addr);
    fd800000cae4:	aa1603e2 	mov	x2, x22
    fd800000cae8:	aa1403e1 	mov	x1, x20
    fd800000caec:	aa1503e0 	mov	x0, x21
    fd800000caf0:	97ffd3e0 	bl	fd8000001a70 <pt_get>
    return (1ULL << pt->dscr->lvl_wdt[lvl]) >> pt->dscr->lvl_off[lvl];
    fd800000caf4:	f94006a2 	ldr	x2, [x21, #8]
    fd800000caf8:	a9408442 	ldp	x2, x1, [x2, #8]
    fd800000cafc:	8b1a0024 	add	x4, x1, x26
    fd800000cb00:	8b1a005a 	add	x26, x2, x26
    fd800000cb04:	f8747821 	ldr	x1, [x1, x20, lsl #3]
    fd800000cb08:	f8747842 	ldr	x2, [x2, x20, lsl #3]
    fd800000cb0c:	9ac12361 	lsl	x1, x27, x1
    fd800000cb10:	9ac22421 	lsr	x1, x1, x2
    for (size_t i = 0; i < pt_nentries(&as->pt, lvl + 1); i++) {
    fd800000cb14:	b4000161 	cbz	x1, fd800000cb40 <mem_expand_pte.part.0+0x140>
    fd800000cb18:	d2800001 	mov	x1, #0x0                   	// #0
    fd800000cb1c:	d503201f 	nop
        temp_pt[i] = pte_dflt_val;
    fd800000cb20:	f8217813 	str	x19, [x0, x1, lsl #3]
    for (size_t i = 0; i < pt_nentries(&as->pt, lvl + 1); i++) {
    fd800000cb24:	91000421 	add	x1, x1, #0x1
    fd800000cb28:	f9400083 	ldr	x3, [x4]
    fd800000cb2c:	f9400342 	ldr	x2, [x26]
    fd800000cb30:	9ac32363 	lsl	x3, x27, x3
    fd800000cb34:	9ac22463 	lsr	x3, x3, x2
    fd800000cb38:	eb03003f 	cmp	x1, x3
    fd800000cb3c:	54ffff23 	b.cc	fd800000cb20 <mem_expand_pte.part.0+0x120>  // b.lo, b.ul, b.last
        if (vld || rsv) {
    fd800000cb40:	7100033f 	cmp	w25, #0x0
    fd800000cb44:	7a400b00 	ccmp	w24, #0x0, #0x0, eq	// eq = none
    fd800000cb48:	54000101 	b.ne	fd800000cb68 <mem_expand_pte.part.0+0x168>  // b.any
}
    fd800000cb4c:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd800000cb50:	a9425bf5 	ldp	x21, x22, [sp, #32]
    fd800000cb54:	a94363f7 	ldp	x23, x24, [sp, #48]
    fd800000cb58:	a9446bf9 	ldp	x25, x26, [sp, #64]
    fd800000cb5c:	f9402bfb 	ldr	x27, [sp, #80]
    fd800000cb60:	a8c87bfd 	ldp	x29, x30, [sp], #128
    fd800000cb64:	d65f03c0 	ret

#include <mem.h>

static inline void tlb_inv_va(struct addr_space* as, vaddr_t va)
{
    if (as->type == AS_HYP) {
    fd800000cb68:	d2800202 	mov	x2, #0x10                  	// #16
    fd800000cb6c:	f2dfc002 	movk	x2, #0xfe00, lsl #32
    fd800000cb70:	b9402041 	ldr	w1, [x2, #32]
    fd800000cb74:	34000621 	cbz	w1, fd800000cc38 <mem_expand_pte.part.0+0x238>
        tlb_hyp_inv_va(va);
    } else if (as->type == AS_VM) {
    fd800000cb78:	7100043f 	cmp	w1, #0x1
    fd800000cb7c:	540006a0 	b.eq	fd800000cc50 <mem_expand_pte.part.0+0x250>  // b.none
}

static inline paddr_t pte_addr(pte_t* pte)
{
    return (paddr_t)(*pte & PTE_ADDR_MSK);
    fd800000cb80:	f94006a2 	ldr	x2, [x21, #8]
    fd800000cb84:	d2800024 	mov	x4, #0x1                   	// #1
            pte_flags_t flags = (as->type == AS_HYP ? PTE_HYP_FLAGS : PTE_VM_FLAGS);
    fd800000cb88:	b94022aa 	ldr	w10, [x21, #32]
    return (lvl == pt->dscr->lvls - 1) ? PTE_PAGE : PTE_SUPERPAGE;
    fd800000cb8c:	d2800066 	mov	x6, #0x3                   	// #3
            pte_flags_t flags = (as->type == AS_HYP ? PTE_HYP_FLAGS : PTE_VM_FLAGS);
    fd800000cb90:	d2809f85 	mov	x5, #0x4fc                 	// #1276
    fd800000cb94:	d280e889 	mov	x9, #0x744                 	// #1860
    fd800000cb98:	a9408447 	ldp	x7, x1, [x2, #8]
    fd800000cb9c:	92748ef7 	and	x23, x23, #0xfffffffff000
    fd800000cba0:	12000318 	and	w24, w24, #0x1
    fd800000cba4:	f8747823 	ldr	x3, [x1, x20, lsl #3]
            while (entry < nentries) {
    fd800000cba8:	d2800001 	mov	x1, #0x0                   	// #0
    fd800000cbac:	f87478e8 	ldr	x8, [x7, x20, lsl #3]
    return (lvl == pt->dscr->lvls - 1) ? PTE_PAGE : PTE_SUPERPAGE;
    fd800000cbb0:	f9400047 	ldr	x7, [x2]
    fd800000cbb4:	9ac32083 	lsl	x3, x4, x3
    fd800000cbb8:	9ac82463 	lsr	x3, x3, x8
    return pt_nentries(pt, lvl) * sizeof(pte_t);
    fd800000cbbc:	d37df062 	lsl	x2, x3, #3
    fd800000cbc0:	d10004e7 	sub	x7, x7, #0x1
    return (size_t)(((size_t)pte) & (pt_size(pt, lvl) - 1)) / sizeof(pte_t);
    fd800000cbc4:	d1000442 	sub	x2, x2, #0x1
    fd800000cbc8:	eb1400ff 	cmp	x7, x20
    fd800000cbcc:	8a020002 	and	x2, x0, x2
    fd800000cbd0:	9a861086 	csel	x6, x4, x6, ne	// ne = any
            pte_flags_t flags = (as->type == AS_HYP ? PTE_HYP_FLAGS : PTE_VM_FLAGS);
    fd800000cbd4:	7100015f 	cmp	w10, #0x0
    return 1ULL << pt->dscr->lvl_off[lvl];
    fd800000cbd8:	9ac82084 	lsl	x4, x4, x8
    fd800000cbdc:	9a8910a5 	csel	x5, x5, x9, ne	// ne = any
    return (size_t)(((size_t)pte) & (pt_size(pt, lvl) - 1)) / sizeof(pte_t);
    fd800000cbe0:	d343fc42 	lsr	x2, x2, #3
            while (entry < nentries) {
    fd800000cbe4:	eb03005f 	cmp	x2, x3
    *pte = (addr & PTE_ADDR_MSK) | ((type | flags) & PTE_FLAGS_MSK);
    fd800000cbe8:	aa0600a5 	orr	x5, x5, x6
    fd800000cbec:	cb020063 	sub	x3, x3, x2
    fd800000cbf0:	540001a2 	b.cs	fd800000cc24 <mem_expand_pte.part.0+0x224>  // b.hs, b.nlast
    fd800000cbf4:	d503201f 	nop
    fd800000cbf8:	92748ee2 	and	x2, x23, #0xfffffffff000
    fd800000cbfc:	aa0200a2 	orr	x2, x5, x2
                if (vld) {
    fd800000cc00:	35000098 	cbnz	w24, fd800000cc10 <mem_expand_pte.part.0+0x210>
    *pte = (*pte & ~PTE_RSW_MSK) | (flag & PTE_RSW_MSK);
    fd800000cc04:	f8617802 	ldr	x2, [x0, x1, lsl #3]
    fd800000cc08:	9245ec42 	and	x2, x2, #0xf87fffffffffffff
    fd800000cc0c:	b2490442 	orr	x2, x2, #0x180000000000000
    *pte = (addr & PTE_ADDR_MSK) | ((type | flags) & PTE_FLAGS_MSK);
    fd800000cc10:	f8217802 	str	x2, [x0, x1, lsl #3]
            while (entry < nentries) {
    fd800000cc14:	91000421 	add	x1, x1, #0x1
    fd800000cc18:	eb03003f 	cmp	x1, x3
                paddr += lvlsz;
    fd800000cc1c:	8b0402f7 	add	x23, x23, x4
            while (entry < nentries) {
    fd800000cc20:	54fffec1 	b.ne	fd800000cbf8 <mem_expand_pte.part.0+0x1f8>  // b.any
    fd800000cc24:	d5033a9f 	dsb	ishst
}
    fd800000cc28:	a94363f7 	ldp	x23, x24, [sp, #48]
    fd800000cc2c:	a9446bf9 	ldp	x25, x26, [sp, #64]
    fd800000cc30:	f9402bfb 	ldr	x27, [sp, #80]
    fd800000cc34:	17ffff84 	b	fd800000ca44 <mem_expand_pte.part.0+0x44>
    DSB(ish);
    fd800000cc38:	d5033b9f 	dsb	ish
}

static inline void arm_tlbi_vae2is(vaddr_t vaddr)
{
    asm volatile("tlbi vae2is, %0" ::"r"(vaddr >> 12));
    fd800000cc3c:	d34cfed6 	lsr	x22, x22, #12
    fd800000cc40:	d50c8336 	tlbi	vae2is, x22
    DSB(ish);
    fd800000cc44:	d5033b9f 	dsb	ish
    ISB();
    fd800000cc48:	d5033fdf 	isb
}
    fd800000cc4c:	17ffffcd 	b	fd800000cb80 <mem_expand_pte.part.0+0x180>
        tlb_vm_inv_va(as->id, va);
    fd800000cc50:	f9401841 	ldr	x1, [x2, #48]
SYSREG_GEN_ACCESSORS(vttbr_el2);
    fd800000cc54:	d53c2102 	mrs	x2, vttbr_el2
BIT_OPS_GEN(bit64, uint64_t, UINT64_C(1), BIT64_MASK);
    fd800000cc58:	d370dc42 	ubfx	x2, x2, #48, #8
    asm volatile("tlbi vae2is, %0" ::"r"(vaddr >> 12));
    fd800000cc5c:	d34cfed6 	lsr	x22, x22, #12
    if (switch_vmid) {
    fd800000cc60:	eb02003f 	cmp	x1, x2
    fd800000cc64:	54000120 	b.eq	fd800000cc88 <mem_expand_pte.part.0+0x288>  // b.none
        sysreg_vttbr_el2_write(((uint64_t)vmid << VTTBR_VMID_OFF) & VTTBR_VMID_MSK);
    fd800000cc68:	d3501c21 	ubfiz	x1, x1, #48, #8
SYSREG_GEN_ACCESSORS(vttbr_el2);
    fd800000cc6c:	d51c2101 	msr	vttbr_el2, x1
        DSB(ish);
    fd800000cc70:	d5033b9f 	dsb	ish
        ISB();
    fd800000cc74:	d5033fdf 	isb
}

static inline void arm_tlbi_ipas2e1is(vaddr_t vaddr)
{
    asm volatile("tlbi ipas2e1is, %0" ::"r"(vaddr >> 12));
    fd800000cc78:	d50c8036 	tlbi	ipas2e1is, x22
        DSB(ish);
    fd800000cc7c:	d5033b9f 	dsb	ish
SYSREG_GEN_ACCESSORS(vttbr_el2);
    fd800000cc80:	d51c2101 	msr	vttbr_el2, x1
    fd800000cc84:	17ffffbf 	b	fd800000cb80 <mem_expand_pte.part.0+0x180>
    asm volatile("tlbi ipas2e1is, %0" ::"r"(vaddr >> 12));
    fd800000cc88:	d50c8036 	tlbi	ipas2e1is, x22
    if (switch_vmid) {
    fd800000cc8c:	17ffffbd 	b	fd800000cb80 <mem_expand_pte.part.0+0x180>

0000fd800000cc90 <mem_inflate_pt>:

static void mem_inflate_pt(struct addr_space* as, vaddr_t va, size_t length)
{
    fd800000cc90:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    fd800000cc94:	910003fd 	mov	x29, sp

    /**
     * For each level in the pt, expand each entry in the specified range as a next level page
     * table.
     */
    for (size_t lvl = 0; lvl < as->pt.dscr->lvls - 1; lvl++) {
    fd800000cc98:	f9400404 	ldr	x4, [x0, #8]
{
    fd800000cc9c:	a90363f7 	stp	x23, x24, [sp, #48]
        vaddr_t vaddr = va;
        size_t lvlsz = pt_lvlsize(&as->pt, lvl);
        while (vaddr < (va + length)) {
    fd800000cca0:	8b020037 	add	x23, x1, x2
    for (size_t lvl = 0; lvl < as->pt.dscr->lvls - 1; lvl++) {
    fd800000cca4:	f9400083 	ldr	x3, [x4]
{
    fd800000cca8:	f90023f9 	str	x25, [sp, #64]
    return 1ULL << pt->dscr->lvl_off[lvl];
    fd800000ccac:	d2800039 	mov	x25, #0x1                   	// #1
    for (size_t lvl = 0; lvl < as->pt.dscr->lvls - 1; lvl++) {
    fd800000ccb0:	eb19007f 	cmp	x3, x25
    fd800000ccb4:	540003c0 	b.eq	fd800000cd2c <mem_inflate_pt+0x9c>  // b.none
    fd800000ccb8:	aa0103f8 	mov	x24, x1
    fd800000ccbc:	d1000463 	sub	x3, x3, #0x1
    fd800000ccc0:	a9025bf5 	stp	x21, x22, [sp, #32]
    fd800000ccc4:	aa0003f5 	mov	x21, x0
    fd800000ccc8:	a90153f3 	stp	x19, x20, [sp, #16]
    fd800000cccc:	d2800014 	mov	x20, #0x0                   	// #0
        while (vaddr < (va + length)) {
    fd800000ccd0:	eb17031f 	cmp	x24, x23
    fd800000ccd4:	f9400480 	ldr	x0, [x4, #8]
    fd800000ccd8:	f8747816 	ldr	x22, [x0, x20, lsl #3]
    fd800000ccdc:	9ad62336 	lsl	x22, x25, x22
    fd800000cce0:	540001c2 	b.cs	fd800000cd18 <mem_inflate_pt+0x88>  // b.hs, b.nlast
        vaddr_t vaddr = va;
    fd800000cce4:	aa1803f3 	mov	x19, x24
    if (as->pt.dscr->lvls - 1 <= lvl) {
    fd800000cce8:	aa1403e2 	mov	x2, x20
    fd800000ccec:	aa1303e1 	mov	x1, x19
    fd800000ccf0:	aa1503e0 	mov	x0, x21
    fd800000ccf4:	eb14007f 	cmp	x3, x20
    fd800000ccf8:	540000a9 	b.ls	fd800000cd0c <mem_inflate_pt+0x7c>  // b.plast
    fd800000ccfc:	97ffff41 	bl	fd800000ca00 <mem_expand_pte.part.0>
    for (size_t lvl = 0; lvl < as->pt.dscr->lvls - 1; lvl++) {
    fd800000cd00:	f94006a4 	ldr	x4, [x21, #8]
    fd800000cd04:	f9400083 	ldr	x3, [x4]
    fd800000cd08:	d1000463 	sub	x3, x3, #0x1
            mem_expand_pte(as, vaddr, lvl);
            vaddr += lvlsz;
    fd800000cd0c:	8b160273 	add	x19, x19, x22
        while (vaddr < (va + length)) {
    fd800000cd10:	eb17027f 	cmp	x19, x23
    fd800000cd14:	54fffea3 	b.cc	fd800000cce8 <mem_inflate_pt+0x58>  // b.lo, b.ul, b.last
    for (size_t lvl = 0; lvl < as->pt.dscr->lvls - 1; lvl++) {
    fd800000cd18:	91000694 	add	x20, x20, #0x1
    fd800000cd1c:	eb03029f 	cmp	x20, x3
    fd800000cd20:	54fffd83 	b.cc	fd800000ccd0 <mem_inflate_pt+0x40>  // b.lo, b.ul, b.last
    fd800000cd24:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd800000cd28:	a9425bf5 	ldp	x21, x22, [sp, #32]
        }
    }
}
    fd800000cd2c:	a94363f7 	ldp	x23, x24, [sp, #48]
    fd800000cd30:	f94023f9 	ldr	x25, [sp, #64]
    fd800000cd34:	a8c57bfd 	ldp	x29, x30, [sp], #80
    fd800000cd38:	d65f03c0 	ret
    fd800000cd3c:	d503201f 	nop

0000fd800000cd40 <mem_cpu_boot_alloc_size>:
    for (size_t i = 0; i < cpu()->as.pt.dscr->lvls; i++) {
    fd800000cd40:	d2dfc000 	mov	x0, #0xfe0000000000        	// #279275953455104
    fd800000cd44:	f9400c00 	ldr	x0, [x0, #24]
    fd800000cd48:	f9400004 	ldr	x4, [x0]
    fd800000cd4c:	b4000224 	cbz	x4, fd800000cd90 <mem_cpu_boot_alloc_size+0x50>
    return (1ULL << pt->dscr->lvl_wdt[lvl]) >> pt->dscr->lvl_off[lvl];
    fd800000cd50:	a9409807 	ldp	x7, x6, [x0, #8]
    fd800000cd54:	d2800002 	mov	x2, #0x0                   	// #0
    fd800000cd58:	d2800025 	mov	x5, #0x1                   	// #1
    size_t size = ALIGN(sizeof(struct cpu), PAGE_SIZE);
    fd800000cd5c:	d2840000 	mov	x0, #0x2000                	// #8192
    fd800000cd60:	f86278c1 	ldr	x1, [x6, x2, lsl #3]
    fd800000cd64:	f86278e3 	ldr	x3, [x7, x2, lsl #3]
    for (size_t i = 0; i < cpu()->as.pt.dscr->lvls; i++) {
    fd800000cd68:	91000442 	add	x2, x2, #0x1
    fd800000cd6c:	9ac120a1 	lsl	x1, x5, x1
    fd800000cd70:	eb04005f 	cmp	x2, x4
    fd800000cd74:	9ac32421 	lsr	x1, x1, x3
    return pt_nentries(pt, lvl) * sizeof(pte_t);
    fd800000cd78:	d37df021 	lsl	x1, x1, #3
        size += ALIGN(pt_size(&cpu()->as.pt, i), PAGE_SIZE);
    fd800000cd7c:	913ffc21 	add	x1, x1, #0xfff
    fd800000cd80:	9274cc21 	and	x1, x1, #0xfffffffffffff000
    fd800000cd84:	8b010000 	add	x0, x0, x1
    for (size_t i = 0; i < cpu()->as.pt.dscr->lvls; i++) {
    fd800000cd88:	54fffec1 	b.ne	fd800000cd60 <mem_cpu_boot_alloc_size+0x20>  // b.any
}
    fd800000cd8c:	d65f03c0 	ret
    size_t size = ALIGN(sizeof(struct cpu), PAGE_SIZE);
    fd800000cd90:	d2840000 	mov	x0, #0x2000                	// #8192
}
    fd800000cd94:	d65f03c0 	ret
    fd800000cd98:	d503201f 	nop
    fd800000cd9c:	d503201f 	nop

0000fd800000cda0 <pp_alloc_clr>:
{
    fd800000cda0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    spin_lock(&pool->lock);
    fd800000cda4:	9100c00f 	add	x15, x0, #0x30
{
    fd800000cda8:	aa0003ee 	mov	x14, x0
    fd800000cdac:	910003fd 	mov	x29, sp
    __asm__ volatile(
    fd800000cdb0:	910011e6 	add	x6, x15, #0x4
    ppages->colors = colors;
    fd800000cdb4:	a900887f 	stp	xzr, x2, [x3, #8]
    fd800000cdb8:	885ffde0 	ldaxr	w0, [x15]
    fd800000cdbc:	11000404 	add	w4, w0, #0x1
    fd800000cdc0:	88057de4 	stxr	w5, w4, [x15]
    fd800000cdc4:	35ffffa5 	cbnz	w5, fd800000cdb8 <pp_alloc_clr+0x18>
    fd800000cdc8:	88dffcc4 	ldar	w4, [x6]
    fd800000cdcc:	6b04001f 	cmp	w0, w4
    fd800000cdd0:	54000060 	b.eq	fd800000cddc <pp_alloc_clr+0x3c>  // b.none
    fd800000cdd4:	d503205f 	wfe
    fd800000cdd8:	17fffffc 	b	fd800000cdc8 <pp_alloc_clr+0x28>
    size_t clr_offset = (base / PAGE_SIZE) % (COLOR_NUM * COLOR_SIZE);
    fd800000cddc:	b0000000 	adrp	x0, fd800000d000 <pp_alloc_clr+0x260>
    fd800000cde0:	f9400404 	ldr	x4, [x0, #8]
    fd800000cde4:	b0000000 	adrp	x0, fd800000d000 <pp_alloc_clr+0x260>
    fd800000cde8:	f9400800 	ldr	x0, [x0, #16]
    fd800000cdec:	f9400087 	ldr	x7, [x4]
    fd800000cdf0:	f9400009 	ldr	x9, [x0]
    size_t index = pp_next_clr(pool->base, pool->last, colors);
    fd800000cdf4:	f94005d1 	ldr	x17, [x14, #8]
    size_t clr_offset = (base / PAGE_SIZE) % (COLOR_NUM * COLOR_SIZE);
    fd800000cdf8:	9b097ce0 	mul	x0, x7, x9
    size_t index = pp_next_clr(pool->base, pool->last, colors);
    fd800000cdfc:	f94011ca 	ldr	x10, [x14, #32]
    size_t clr_offset = (base / PAGE_SIZE) % (COLOR_NUM * COLOR_SIZE);
    fd800000ce00:	d34cfe24 	lsr	x4, x17, #12
    fd800000ce04:	9ac00888 	udiv	x8, x4, x0
    fd800000ce08:	9b009108 	msub	x8, x8, x0, x4
    fd800000ce0c:	14000002 	b	fd800000ce14 <pp_alloc_clr+0x74>
        index++;
    fd800000ce10:	9100054a 	add	x10, x10, #0x1
    while (!((colors >> ((index + clr_offset) / COLOR_SIZE % COLOR_NUM)) & 1)) {
    fd800000ce14:	8b080144 	add	x4, x10, x8
    fd800000ce18:	9ac90884 	udiv	x4, x4, x9
    fd800000ce1c:	9ac70880 	udiv	x0, x4, x7
    fd800000ce20:	9b079000 	msub	x0, x0, x7, x4
    fd800000ce24:	9ac02440 	lsr	x0, x2, x0
    fd800000ce28:	3607ff40 	tbz	w0, #0, fd800000ce10 <pp_alloc_clr+0x70>
    size_t top = pool->size;
    fd800000ce2c:	f94009cb 	ldr	x11, [x14, #16]
    fd800000ce30:	d2800050 	mov	x16, #0x2                   	// #2
    size_t first_index = 0;
    fd800000ce34:	d2800005 	mov	x5, #0x0                   	// #0
    size_t allocated = 0;
    fd800000ce38:	d2800012 	mov	x18, #0x0                   	// #0
    return (map[bit / BITMAP_GRANULE_LEN] & (ONE << (bit % BITMAP_GRANULE_LEN))) ? 1U : 0U;
    fd800000ce3c:	5280002d 	mov	w13, #0x1                   	// #1
        while ((allocated < n) && (index < top)) {
    fd800000ce40:	eb12003f 	cmp	x1, x18
    fd800000ce44:	1a9f97e0 	cset	w0, hi	// hi = pmore
    fd800000ce48:	eb0a017f 	cmp	x11, x10
    fd800000ce4c:	1a9f97e4 	cset	w4, hi	// hi = pmore
    fd800000ce50:	6a04001f 	tst	w0, w4
    fd800000ce54:	0a040000 	and	w0, w0, w4
    fd800000ce58:	540004a0 	b.eq	fd800000ceec <pp_alloc_clr+0x14c>  // b.none
    fd800000ce5c:	d503201f 	nop
            while ((index < top) && bitmap_get(pool->bitmap, index)) {
    fd800000ce60:	eb0a017f 	cmp	x11, x10
    fd800000ce64:	54000769 	b.ls	fd800000cf50 <pp_alloc_clr+0x1b0>  // b.plast
    fd800000ce68:	f94015cc 	ldr	x12, [x14, #40]
    fd800000ce6c:	d345fd45 	lsr	x5, x10, #5
    fd800000ce70:	1aca21a4 	lsl	w4, w13, w10
    fd800000ce74:	b8657985 	ldr	w5, [x12, x5, lsl #2]
    fd800000ce78:	6a05009f 	tst	w4, w5
    fd800000ce7c:	54000561 	b.ne	fd800000cf28 <pp_alloc_clr+0x188>  // b.any
            while ((index < top) && (bitmap_get(pool->bitmap, index) == 0) && (allocated < n)) {
    fd800000ce80:	aa0a03e4 	mov	x4, x10
    fd800000ce84:	d2800012 	mov	x18, #0x0                   	// #0
                index = pp_next_clr(pool->base, ++index, colors);
    fd800000ce88:	91000484 	add	x4, x4, #0x1
                allocated++;
    fd800000ce8c:	91000652 	add	x18, x18, #0x1
    fd800000ce90:	14000002 	b	fd800000ce98 <pp_alloc_clr+0xf8>
        index++;
    fd800000ce94:	91000484 	add	x4, x4, #0x1
    while (!((colors >> ((index + clr_offset) / COLOR_SIZE % COLOR_NUM)) & 1)) {
    fd800000ce98:	8b080086 	add	x6, x4, x8
    fd800000ce9c:	9ac908c6 	udiv	x6, x6, x9
    fd800000cea0:	9ac708c5 	udiv	x5, x6, x7
    fd800000cea4:	9b0798a5 	msub	x5, x5, x7, x6
    fd800000cea8:	9ac52445 	lsr	x5, x2, x5
    fd800000ceac:	3607ff45 	tbz	w5, #0, fd800000ce94 <pp_alloc_clr+0xf4>
            while ((index < top) && (bitmap_get(pool->bitmap, index) == 0) && (allocated < n)) {
    fd800000ceb0:	eb12003f 	cmp	x1, x18
    fd800000ceb4:	1a9f97fe 	cset	w30, hi	// hi = pmore
    fd800000ceb8:	eb04017f 	cmp	x11, x4
    fd800000cebc:	540000e9 	b.ls	fd800000ced8 <pp_alloc_clr+0x138>  // b.plast
    fd800000cec0:	d345fc86 	lsr	x6, x4, #5
    fd800000cec4:	1ac421a5 	lsl	w5, w13, w4
    fd800000cec8:	b8667986 	ldr	w6, [x12, x6, lsl #2]
    fd800000cecc:	6a0600bf 	tst	w5, w6
    fd800000ced0:	7a400bc4 	ccmp	w30, #0x0, #0x4, eq	// eq = none
    fd800000ced4:	54fffda1 	b.ne	fd800000ce88 <pp_alloc_clr+0xe8>  // b.any
    fd800000ced8:	aa0a03e5 	mov	x5, x10
            index++;
    fd800000cedc:	9100048a 	add	x10, x4, #0x1
        while ((allocated < n) && (index < top)) {
    fd800000cee0:	710003df 	cmp	w30, #0x0
    fd800000cee4:	fa4a1160 	ccmp	x11, x10, #0x0, ne	// ne = any
    fd800000cee8:	54fffbc8 	b.hi	fd800000ce60 <pp_alloc_clr+0xc0>  // b.pmore
        if (allocated == n) {
    fd800000ceec:	eb12003f 	cmp	x1, x18
    fd800000cef0:	54000540 	b.eq	fd800000cf98 <pp_alloc_clr+0x1f8>  // b.none
    for (size_t i = 0; i < 2 && !ok; i++) {
    fd800000cef4:	f100061f 	cmp	x16, #0x1
    fd800000cef8:	d280000a 	mov	x10, #0x0                   	// #0
    fd800000cefc:	540003c0 	b.eq	fd800000cf74 <pp_alloc_clr+0x1d4>  // b.none
    fd800000cf00:	d2800030 	mov	x16, #0x1                   	// #1
    fd800000cf04:	17ffffcf 	b	fd800000ce40 <pp_alloc_clr+0xa0>
            while ((index < top) && bitmap_get(pool->bitmap, index)) {
    fd800000cf08:	eb04017f 	cmp	x11, x4
    fd800000cf0c:	540002c9 	b.ls	fd800000cf64 <pp_alloc_clr+0x1c4>  // b.plast
    fd800000cf10:	d345fc86 	lsr	x6, x4, #5
    fd800000cf14:	1ac421a5 	lsl	w5, w13, w4
    fd800000cf18:	aa0403ea 	mov	x10, x4
    fd800000cf1c:	b8667986 	ldr	w6, [x12, x6, lsl #2]
    fd800000cf20:	6a0600bf 	tst	w5, w6
    fd800000cf24:	54fffae0 	b.eq	fd800000ce80 <pp_alloc_clr+0xe0>  // b.none
                index = pp_next_clr(pool->base, ++index, colors);
    fd800000cf28:	91000544 	add	x4, x10, #0x1
    fd800000cf2c:	14000002 	b	fd800000cf34 <pp_alloc_clr+0x194>
        index++;
    fd800000cf30:	91000484 	add	x4, x4, #0x1
    while (!((colors >> ((index + clr_offset) / COLOR_SIZE % COLOR_NUM)) & 1)) {
    fd800000cf34:	8b080086 	add	x6, x4, x8
    fd800000cf38:	9ac908c6 	udiv	x6, x6, x9
    fd800000cf3c:	9ac708c5 	udiv	x5, x6, x7
    fd800000cf40:	9b0798a5 	msub	x5, x5, x7, x6
    fd800000cf44:	9ac52445 	lsr	x5, x2, x5
    fd800000cf48:	3607ff45 	tbz	w5, #0, fd800000cf30 <pp_alloc_clr+0x190>
    fd800000cf4c:	17ffffef 	b	fd800000cf08 <pp_alloc_clr+0x168>
            while ((index < top) && bitmap_get(pool->bitmap, index)) {
    fd800000cf50:	aa0a03e5 	mov	x5, x10
    fd800000cf54:	2a0003fe 	mov	w30, w0
    fd800000cf58:	aa0a03e4 	mov	x4, x10
    fd800000cf5c:	d2800012 	mov	x18, #0x0                   	// #0
    fd800000cf60:	17ffffdf 	b	fd800000cedc <pp_alloc_clr+0x13c>
    fd800000cf64:	2a0003fe 	mov	w30, w0
    fd800000cf68:	aa0403e5 	mov	x5, x4
    fd800000cf6c:	d2800012 	mov	x18, #0x0                   	// #0
    fd800000cf70:	17ffffdb 	b	fd800000cedc <pp_alloc_clr+0x13c>
    bool ok = false;
    fd800000cf74:	52800000 	mov	w0, #0x0                   	// #0
    __asm__ volatile(
    fd800000cf78:	910011e2 	add	x2, x15, #0x4
    fd800000cf7c:	b9400041 	ldr	w1, [x2]
    fd800000cf80:	11000421 	add	w1, w1, #0x1
    fd800000cf84:	889ffc41 	stlr	w1, [x2]
    fd800000cf88:	d5033b9f 	dsb	ish
    fd800000cf8c:	d503209f 	sev
}
    fd800000cf90:	a8c17bfd 	ldp	x29, x30, [sp], #16
    fd800000cf94:	d65f03c0 	ret
            ppages->base = pool->base + (first_index * PAGE_SIZE);
    fd800000cf98:	8b053231 	add	x17, x17, x5, lsl #12
            ppages->num_pages = n;
    fd800000cf9c:	a9000471 	stp	x17, x1, [x3]
            for (size_t i = 0; i < n; i++) {
    fd800000cfa0:	b40002a1 	cbz	x1, fd800000cff4 <pp_alloc_clr+0x254>
                bitmap_set(pool->bitmap, first_index++);
    fd800000cfa4:	f94015c6 	ldr	x6, [x14, #40]
            for (size_t i = 0; i < n; i++) {
    fd800000cfa8:	d2800004 	mov	x4, #0x0                   	// #0
    map[bit / BITMAP_GRANULE_LEN] |= ONE << (bit % BITMAP_GRANULE_LEN);
    fd800000cfac:	5280002b 	mov	w11, #0x1                   	// #1
    fd800000cfb0:	14000002 	b	fd800000cfb8 <pp_alloc_clr+0x218>
        index++;
    fd800000cfb4:	910004a5 	add	x5, x5, #0x1
    while (!((colors >> ((index + clr_offset) / COLOR_SIZE % COLOR_NUM)) & 1)) {
    fd800000cfb8:	8b050103 	add	x3, x8, x5
    fd800000cfbc:	9ac90863 	udiv	x3, x3, x9
    fd800000cfc0:	9ac70860 	udiv	x0, x3, x7
    fd800000cfc4:	9b078c00 	msub	x0, x0, x7, x3
    fd800000cfc8:	9ac02440 	lsr	x0, x2, x0
    fd800000cfcc:	3607ff40 	tbz	w0, #0, fd800000cfb4 <pp_alloc_clr+0x214>
    fd800000cfd0:	d345fca3 	lsr	x3, x5, #5
    fd800000cfd4:	1ac5216a 	lsl	w10, w11, w5
            for (size_t i = 0; i < n; i++) {
    fd800000cfd8:	91000484 	add	x4, x4, #0x1
                bitmap_set(pool->bitmap, first_index++);
    fd800000cfdc:	910004a5 	add	x5, x5, #0x1
            for (size_t i = 0; i < n; i++) {
    fd800000cfe0:	eb04003f 	cmp	x1, x4
    fd800000cfe4:	b86378c0 	ldr	w0, [x6, x3, lsl #2]
    fd800000cfe8:	2a0a0000 	orr	w0, w0, w10
    fd800000cfec:	b82378c0 	str	w0, [x6, x3, lsl #2]
    fd800000cff0:	54fffe41 	b.ne	fd800000cfb8 <pp_alloc_clr+0x218>  // b.any
            pool->free -= n;
    fd800000cff4:	f9400dc2 	ldr	x2, [x14, #24]
            ok = true;
    fd800000cff8:	52800020 	mov	w0, #0x1                   	// #1
            pool->free -= n;
    fd800000cffc:	cb010041 	sub	x1, x2, x1
            pool->last = first_index;
    fd800000d000:	a90195c1 	stp	x1, x5, [x14, #24]
            break;
    fd800000d004:	17ffffdd 	b	fd800000cf78 <pp_alloc_clr+0x1d8>
    fd800000d008:	00012828 	.word	0x00012828
    fd800000d00c:	0000fd80 	.word	0x0000fd80
    fd800000d010:	00012820 	.word	0x00012820
    fd800000d014:	0000fd80 	.word	0x0000fd80
    fd800000d018:	d503201f 	nop
    fd800000d01c:	d503201f 	nop

0000fd800000d020 <mem_alloc_vpage>:

vaddr_t mem_alloc_vpage(struct addr_space* as, enum AS_SEC section, vaddr_t at, size_t n)
{
    fd800000d020:	a9b37bfd 	stp	x29, x30, [sp, #-208]!
    pte_t* pte = NULL;
    bool failed = false;

    // TODO: maybe some bound checking here would be nice
    struct section* sec = &sections[as->type].sec[section];
    if (at != INVALID_VA) {
    fd800000d024:	b100045f 	cmn	x2, #0x1
    struct section* sec = &sections[as->type].sec[section];
    fd800000d028:	937b7c21 	sbfiz	x1, x1, #5, #32
{
    fd800000d02c:	910003fd 	mov	x29, sp
    fd800000d030:	a9025bf5 	stp	x21, x22, [sp, #32]
    fd800000d034:	aa0003f5 	mov	x21, x0
    struct section* sec = &sections[as->type].sec[section];
    fd800000d038:	b9402000 	ldr	w0, [x0, #32]
    fd800000d03c:	90000004 	adrp	x4, fd800000d000 <pp_alloc_clr+0x260>
    fd800000d040:	f9429484 	ldr	x4, [x4, #1320]
    fd800000d044:	d37cec00 	lsl	x0, x0, #4
{
    fd800000d048:	a9046bf9 	stp	x25, x26, [sp, #64]
    fd800000d04c:	aa0203f9 	mov	x25, x2
    struct section* sec = &sections[as->type].sec[section];
    fd800000d050:	8b000082 	add	x2, x4, x0
    fd800000d054:	f8606880 	ldr	x0, [x4, x0]
{
    fd800000d058:	aa0303fa 	mov	x26, x3
    fd800000d05c:	a90153f3 	stp	x19, x20, [sp, #16]
    struct section* sec = &sections[as->type].sec[section];
    fd800000d060:	8b010003 	add	x3, x0, x1
    fd800000d064:	f90053e3 	str	x3, [sp, #160]
    if (at != INVALID_VA) {
    fd800000d068:	54001881 	b.ne	fd800000d378 <mem_alloc_vpage+0x358>  // b.any
        if (sec != mem_find_sec(as, at)) {
            return INVALID_VA;
        }
        addr = at;
    } else {
        addr = sec->beg;
    fd800000d06c:	f8616814 	ldr	x20, [x0, x1]
    }
    top = sec->end;
    fd800000d070:	f94053e4 	ldr	x4, [sp, #160]
    fd800000d074:	f9400480 	ldr	x0, [x4, #8]

    if (addr > top || !IS_ALIGNED(addr, PAGE_SIZE)) {
    fd800000d078:	eb00029f 	cmp	x20, x0
    fd800000d07c:	54001a68 	b.hi	fd800000d3c8 <mem_alloc_vpage+0x3a8>  // b.pmore
    fd800000d080:	92402e81 	and	x1, x20, #0xfff
    fd800000d084:	b5001a21 	cbnz	x1, fd800000d3c8 <mem_alloc_vpage+0x3a8>
        return INVALID_VA;
    }

    spin_lock(&as->lock);
    fd800000d088:	9100e2a1 	add	x1, x21, #0x38
    fd800000d08c:	f90057e1 	str	x1, [sp, #168]
    __asm__ volatile(
    fd800000d090:	aa0103e5 	mov	x5, x1
    fd800000d094:	91001026 	add	x6, x1, #0x4
    fd800000d098:	885ffca1 	ldaxr	w1, [x5]
    fd800000d09c:	11000422 	add	w2, w1, #0x1
    fd800000d0a0:	88037ca2 	stxr	w3, w2, [x5]
    fd800000d0a4:	35ffffa3 	cbnz	w3, fd800000d098 <mem_alloc_vpage+0x78>
    fd800000d0a8:	88dffcc2 	ldar	w2, [x6]
    fd800000d0ac:	6b02003f 	cmp	w1, w2
    fd800000d0b0:	54000060 	b.eq	fd800000d0bc <mem_alloc_vpage+0x9c>  // b.none
    fd800000d0b4:	d503205f 	wfe
    fd800000d0b8:	17fffffc 	b	fd800000d0a8 <mem_alloc_vpage+0x88>
    if (sec->shared) {
    fd800000d0bc:	39404081 	ldrb	w1, [x4, #16]
    fd800000d0c0:	37001d41 	tbnz	w1, #0, fd800000d468 <mem_alloc_vpage+0x448>
        spin_lock(&sec->lock);
    }

    while (count < n && !failed) {
    fd800000d0c4:	b40021da 	cbz	x26, fd800000d4fc <mem_alloc_vpage+0x4dc>
        // Check if there is still enough space in the address space. The corner case of top being
        // the highest address in the address space and the target address being 0 is handled
        // separate
        size_t full_as = (addr == 0) && (top == MAX_VA);
        if (!full_as && (((top + 1 - addr) / PAGE_SIZE) < n)) {
    fd800000d0c8:	b1000400 	adds	x0, x0, #0x1
    fd800000d0cc:	f9004fe0 	str	x0, [sp, #152]
        size_t full_as = (addr == 0) && (top == MAX_VA);
    fd800000d0d0:	1a9f17e0 	cset	w0, eq	// eq = none
    fd800000d0d4:	d2800016 	mov	x22, #0x0                   	// #0
    fd800000d0d8:	a90363f7 	stp	x23, x24, [sp, #48]
    fd800000d0dc:	d2800017 	mov	x23, #0x0                   	// #0
    fd800000d0e0:	a90573fb 	stp	x27, x28, [sp, #80]
    fd800000d0e4:	b90097e0 	str	w0, [sp, #148]
    fd800000d0e8:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    fd800000d0ec:	f90037e0 	str	x0, [sp, #104]
        if (!full_as && (((top + 1 - addr) / PAGE_SIZE) < n)) {
    fd800000d0f0:	b94097e0 	ldr	w0, [sp, #148]
        size_t full_as = (addr == 0) && (top == MAX_VA);
    fd800000d0f4:	f100029f 	cmp	x20, #0x0
        if (!full_as && (((top + 1 - addr) / PAGE_SIZE) < n)) {
    fd800000d0f8:	7a400804 	ccmp	w0, #0x0, #0x4, eq	// eq = none
    fd800000d0fc:	540000a1 	b.ne	fd800000d110 <mem_alloc_vpage+0xf0>  // b.any
    fd800000d100:	f9404fe0 	ldr	x0, [sp, #152]
    fd800000d104:	cb140000 	sub	x0, x0, x20
    fd800000d108:	eb40335f 	cmp	x26, x0, lsr #12
    fd800000d10c:	54001fe8 	b.hi	fd800000d508 <mem_alloc_vpage+0x4e8>  // b.pmore
            vpage = INVALID_VA;
            failed = true;
            break;
        }

        pte = pt_get_pte(&as->pt, lvl, addr);
    fd800000d110:	aa1403e2 	mov	x2, x20
    fd800000d114:	aa1703e1 	mov	x1, x23
    fd800000d118:	aa1503e0 	mov	x0, x21
    fd800000d11c:	97ffd231 	bl	fd80000019e0 <pt_get_pte>
    return (1ULL << pt->dscr->lvl_wdt[lvl]) >> pt->dscr->lvl_off[lvl];
    fd800000d120:	d37df2e1 	lsl	x1, x23, #3
    fd800000d124:	f9003fe1 	str	x1, [sp, #120]
    fd800000d128:	f94006a1 	ldr	x1, [x21, #8]
    fd800000d12c:	aa0003fc 	mov	x28, x0
    fd800000d130:	a9408820 	ldp	x0, x2, [x1, #8]
    fd800000d134:	f8777853 	ldr	x19, [x2, x23, lsl #3]
    fd800000d138:	f8777818 	ldr	x24, [x0, x23, lsl #3]
    fd800000d13c:	d2800020 	mov	x0, #0x1                   	// #1
    fd800000d140:	9ad32013 	lsl	x19, x0, x19
    fd800000d144:	9ad82673 	lsr	x19, x19, x24
    return pt_nentries(pt, lvl) * sizeof(pte_t);
    fd800000d148:	d37df264 	lsl	x4, x19, #3
    return 1ULL << pt->dscr->lvl_off[lvl];
    fd800000d14c:	9ad82018 	lsl	x24, x0, x24
    return (size_t)(((size_t)pte) & (pt_size(pt, lvl) - 1)) / sizeof(pte_t);
    fd800000d150:	d1000484 	sub	x4, x4, #0x1
            } else if (!pte_valid(pte)) {
                if (pte_allocable(as, pte, lvl, n - count, addr)) {
                    if (count == 0) {
                        vpage = addr;
                    }
                    count += (lvlsze / PAGE_SIZE);
    fd800000d154:	d34cff00 	lsr	x0, x24, #12
    fd800000d158:	8a040384 	and	x4, x28, x4
    fd800000d15c:	f9003be0 	str	x0, [sp, #112]
    fd800000d160:	d343fc9b 	lsr	x27, x4, #3
        while ((entry < nentries) && (count < n) && !failed) {
    fd800000d164:	d503201f 	nop
    fd800000d168:	eb13037f 	cmp	x27, x19
    fd800000d16c:	fa5a32c2 	ccmp	x22, x26, #0x2, cc	// cc = lo, ul, last
    fd800000d170:	54000b62 	b.cs	fd800000d2dc <mem_alloc_vpage+0x2bc>  // b.hs, b.nlast
    return (*pte & PTE_RSW_MSK) == (flag & PTE_RSW_MSK);
    fd800000d174:	f9400380 	ldr	x0, [x28]
    fd800000d178:	d2490401 	eor	x1, x0, #0x180000000000000
            if (pte_check_rsw(pte, PTE_RSW_RSRV) ||
    fd800000d17c:	f2490c3f 	tst	x1, #0x780000000000000
    fd800000d180:	54001340 	b.eq	fd800000d3e8 <mem_alloc_vpage+0x3c8>  // b.none
    fd800000d184:	37001480 	tbnz	w0, #0, fd800000d414 <mem_alloc_vpage+0x3f4>
                if (pte_allocable(as, pte, lvl, n - count, addr)) {
    fd800000d188:	f94006a1 	ldr	x1, [x21, #8]
    return (lvl == (as->pt.dscr->lvls - 1)) ||
    fd800000d18c:	f9400020 	ldr	x0, [x1]
    fd800000d190:	d1000400 	sub	x0, x0, #0x1
    fd800000d194:	eb17001f 	cmp	x0, x23
    fd800000d198:	540014e0 	b.eq	fd800000d434 <mem_alloc_vpage+0x414>  // b.none
    return pt->dscr->lvl_term[lvl];
    fd800000d19c:	f9400c20 	ldr	x0, [x1, #24]
    return 1ULL << pt->dscr->lvl_off[lvl];
    fd800000d1a0:	f9400422 	ldr	x2, [x1, #8]
    fd800000d1a4:	38776800 	ldrb	w0, [x0, x23]
    fd800000d1a8:	36000180 	tbz	w0, #0, fd800000d1d8 <mem_alloc_vpage+0x1b8>
    fd800000d1ac:	f9403fe0 	ldr	x0, [sp, #120]
    fd800000d1b0:	d2800023 	mov	x3, #0x1                   	// #1
    fd800000d1b4:	f8606845 	ldr	x5, [x2, x0]
                if (pte_allocable(as, pte, lvl, n - count, addr)) {
    fd800000d1b8:	cb160340 	sub	x0, x26, x22
    fd800000d1bc:	9ac52066 	lsl	x6, x3, x5
        (pt_lvl_terminal(&as->pt, lvl) && !pte_valid(pte) &&
    fd800000d1c0:	eb0030df 	cmp	x6, x0, lsl #12
    fd800000d1c4:	540000a8 	b.hi	fd800000d1d8 <mem_alloc_vpage+0x1b8>  // b.pmore
            ((addr % pt_lvlsize(&as->pt, lvl)) == 0));
    fd800000d1c8:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    fd800000d1cc:	9ac52005 	lsl	x5, x0, x5
            (pt_lvlsize(&as->pt, lvl) <= (left * PAGE_SIZE)) &&
    fd800000d1d0:	ea25029f 	bics	xzr, x20, x5
    fd800000d1d4:	54001300 	b.eq	fd800000d434 <mem_alloc_vpage+0x414>  // b.none
    return (1ULL << pt->dscr->lvl_wdt[lvl]) >> pt->dscr->lvl_off[lvl];
    fd800000d1d8:	f9403fe0 	ldr	x0, [sp, #120]
    fd800000d1dc:	d2800023 	mov	x3, #0x1                   	// #1
    fd800000d1e0:	f9400821 	ldr	x1, [x1, #16]
    fd800000d1e4:	91002005 	add	x5, x0, #0x8
    struct ppages ppage = mem_alloc_ppages(as->colors, ptsize, ptsize > 1 ? true : false);
    fd800000d1e8:	f94016a0 	ldr	x0, [x21, #40]
    fd800000d1ec:	9102e3e8 	add	x8, sp, #0xb8
    fd800000d1f0:	f8656821 	ldr	x1, [x1, x5]
    fd800000d1f4:	f90043e5 	str	x5, [sp, #128]
    fd800000d1f8:	f8656842 	ldr	x2, [x2, x5]
    fd800000d1fc:	9ac12061 	lsl	x1, x3, x1
    fd800000d200:	9ac22421 	lsr	x1, x1, x2
    return pt_nentries(pt, lvl) * sizeof(pte_t);
    fd800000d204:	d37df021 	lsl	x1, x1, #3
    size_t ptsize = NUM_PAGES(pt_size(&as->pt, lvl + 1));
    fd800000d208:	913ffc21 	add	x1, x1, #0xfff
    fd800000d20c:	d34cfc21 	lsr	x1, x1, #12
    struct ppages ppage = mem_alloc_ppages(as->colors, ptsize, ptsize > 1 ? true : false);
    fd800000d210:	eb03003f 	cmp	x1, x3
    fd800000d214:	1a9f97e2 	cset	w2, hi	// hi = pmore
    fd800000d218:	97fff35e 	bl	fd8000009f90 <mem_alloc_ppages>
    if (ppage.num_pages == 0) {
    fd800000d21c:	f94063e0 	ldr	x0, [sp, #192]
    fd800000d220:	b40011c0 	cbz	x0, fd800000d458 <mem_alloc_vpage+0x438>
    *pte = (addr & PTE_ADDR_MSK) | ((type | flags) & PTE_FLAGS_MSK);
    fd800000d224:	f9405fe0 	ldr	x0, [sp, #184]
    fd800000d228:	d280e8e1 	mov	x1, #0x747                 	// #1863
    pte_t pte_dflt_val = PTE_INVALID | (*parent & PTE_RSW_MSK);
    fd800000d22c:	f9400387 	ldr	x7, [x28]
    fd800000d230:	92748c00 	and	x0, x0, #0xfffffffff000
    fd800000d234:	aa010000 	orr	x0, x0, x1
    fd800000d238:	f9000380 	str	x0, [x28]
    fd800000d23c:	92490ce7 	and	x7, x7, #0x780000000000000
    fd800000d240:	f90047e7 	str	x7, [sp, #136]
    DSB(ishst);
    fd800000d244:	d5033a9f 	dsb	ishst
    pte_t* temp_pt = pt_get(&as->pt, lvl + 1, addr);
    fd800000d248:	aa1403e2 	mov	x2, x20
    fd800000d24c:	910006e1 	add	x1, x23, #0x1
    fd800000d250:	aa1503e0 	mov	x0, x21
    fd800000d254:	97ffd207 	bl	fd8000001a70 <pt_get>
    return (1ULL << pt->dscr->lvl_wdt[lvl]) >> pt->dscr->lvl_off[lvl];
    fd800000d258:	f94006a6 	ldr	x6, [x21, #8]
    fd800000d25c:	d2800023 	mov	x3, #0x1                   	// #1
    for (size_t i = 0; i < pt_nentries(&as->pt, lvl + 1); i++) {
    fd800000d260:	a9481fe5 	ldp	x5, x7, [sp, #128]
    fd800000d264:	d2800002 	mov	x2, #0x0                   	// #0
    fd800000d268:	a94084c6 	ldp	x6, x1, [x6, #8]
    fd800000d26c:	8b050028 	add	x8, x1, x5
    fd800000d270:	f8656821 	ldr	x1, [x1, x5]
    fd800000d274:	f86568c9 	ldr	x9, [x6, x5]
    fd800000d278:	8b0500c6 	add	x6, x6, x5
    fd800000d27c:	9ac12061 	lsl	x1, x3, x1
    fd800000d280:	9ac92421 	lsr	x1, x1, x9
    fd800000d284:	b4000e61 	cbz	x1, fd800000d450 <mem_alloc_vpage+0x430>
        temp_pt[i] = pte_dflt_val;
    fd800000d288:	f8227807 	str	x7, [x0, x2, lsl #3]
    fd800000d28c:	d2800023 	mov	x3, #0x1                   	// #1
    for (size_t i = 0; i < pt_nentries(&as->pt, lvl + 1); i++) {
    fd800000d290:	91000442 	add	x2, x2, #0x1
    fd800000d294:	f9400101 	ldr	x1, [x8]
    fd800000d298:	f94000c5 	ldr	x5, [x6]
    fd800000d29c:	9ac12061 	lsl	x1, x3, x1
    fd800000d2a0:	9ac52421 	lsr	x1, x1, x5
    fd800000d2a4:	eb01005f 	cmp	x2, x1
    fd800000d2a8:	54ffff03 	b.cc	fd800000d288 <mem_alloc_vpage+0x268>  // b.lo, b.ul, b.last
    fd800000d2ac:	d503201f 	nop
                        ERROR("failed to alloc page table");
                    }
                }
            }

            if (pte_table(&as->pt, pte, lvl)) {
    fd800000d2b0:	aa1703e2 	mov	x2, x23
    fd800000d2b4:	aa1c03e1 	mov	x1, x28
    fd800000d2b8:	aa1503e0 	mov	x0, x21
    fd800000d2bc:	97ffd211 	bl	fd8000001b00 <pte_table>
    fd800000d2c0:	37000a60 	tbnz	w0, #0, fd800000d40c <mem_alloc_vpage+0x3ec>
                lvl++;
                break;
            } else {
                pte++;
                addr += lvlsze;
                if (++entry >= nentries) {
    fd800000d2c4:	9100077b 	add	x27, x27, #0x1
                pte++;
    fd800000d2c8:	9100239c 	add	x28, x28, #0x8
                if (++entry >= nentries) {
    fd800000d2cc:	eb13037f 	cmp	x27, x19
                addr += lvlsze;
    fd800000d2d0:	8b180294 	add	x20, x20, x24
                if (++entry >= nentries) {
    fd800000d2d4:	54fff4a3 	b.cc	fd800000d168 <mem_alloc_vpage+0x148>  // b.lo, b.ul, b.last
                    lvl = 0;
    fd800000d2d8:	d2800017 	mov	x23, #0x0                   	// #0
    while (count < n && !failed) {
    fd800000d2dc:	eb1a02df 	cmp	x22, x26
    fd800000d2e0:	54fff083 	b.cc	fd800000d0f0 <mem_alloc_vpage+0xd0>  // b.lo, b.ul, b.last
            }
        }
    }

    // mark page trable entries as reserved
    if (vpage != INVALID_VA && !failed) {
    fd800000d2e4:	f94037e0 	ldr	x0, [sp, #104]
    fd800000d2e8:	b100041f 	cmn	x0, #0x1
    fd800000d2ec:	540010e0 	b.eq	fd800000d508 <mem_alloc_vpage+0x4e8>  // b.none
        count = 0;
        addr = vpage;
        size_t lvl = 0;
        while (count < n) {
            for (lvl = 0; lvl < as->pt.dscr->lvls; lvl++) {
    fd800000d2f0:	f94006a1 	ldr	x1, [x21, #8]
        count = 0;
    fd800000d2f4:	d2800016 	mov	x22, #0x0                   	// #0
        addr = vpage;
    fd800000d2f8:	f94037f4 	ldr	x20, [sp, #104]
    return 1ULL << pt->dscr->lvl_off[lvl];
    fd800000d2fc:	d2800037 	mov	x23, #0x1                   	// #1
            for (lvl = 0; lvl < as->pt.dscr->lvls; lvl++) {
    fd800000d300:	f9400022 	ldr	x2, [x1]
    fd800000d304:	d2800013 	mov	x19, #0x0                   	// #0
    fd800000d308:	b50000c2 	cbnz	x2, fd800000d320 <mem_alloc_vpage+0x300>
    fd800000d30c:	14000084 	b	fd800000d51c <mem_alloc_vpage+0x4fc>
    fd800000d310:	f9400022 	ldr	x2, [x1]
    fd800000d314:	91000673 	add	x19, x19, #0x1
    fd800000d318:	eb13005f 	cmp	x2, x19
    fd800000d31c:	54000129 	b.ls	fd800000d340 <mem_alloc_vpage+0x320>  // b.plast
                pte = pt_get_pte(&as->pt, lvl, addr);
    fd800000d320:	aa1303e1 	mov	x1, x19
    fd800000d324:	aa1403e2 	mov	x2, x20
    fd800000d328:	aa1503e0 	mov	x0, x21
    fd800000d32c:	97ffd1ad 	bl	fd80000019e0 <pt_get_pte>
    fd800000d330:	aa0003fc 	mov	x28, x0
    return (*pte & PTE_VALID);
    fd800000d334:	f9400000 	ldr	x0, [x0]
            for (lvl = 0; lvl < as->pt.dscr->lvls; lvl++) {
    fd800000d338:	f94006a1 	ldr	x1, [x21, #8]
                if (!pte_valid(pte)) {
    fd800000d33c:	3707fea0 	tbnz	w0, #0, fd800000d310 <mem_alloc_vpage+0x2f0>
    fd800000d340:	d37df262 	lsl	x2, x19, #3
    fd800000d344:	f9400424 	ldr	x4, [x1, #8]
    *pte = (*pte & ~PTE_RSW_MSK) | (flag & PTE_RSW_MSK);
    fd800000d348:	9245ec00 	and	x0, x0, #0xf87fffffffffffff
    fd800000d34c:	b2490400 	orr	x0, x0, #0x180000000000000
    fd800000d350:	f9000380 	str	x0, [x28]
    fd800000d354:	f8626880 	ldr	x0, [x4, x2]
    fd800000d358:	9ac022e0 	lsl	x0, x23, x0
                    break;
                }
            }
            pte_set_rsw(pte, PTE_RSW_RSRV);
            addr += pt_lvlsize(&as->pt, lvl);
    fd800000d35c:	8b000294 	add	x20, x20, x0
            count += pt_lvlsize(&as->pt, lvl) / PAGE_SIZE;
    fd800000d360:	8b4032d6 	add	x22, x22, x0, lsr #12
        while (count < n) {
    fd800000d364:	eb16035f 	cmp	x26, x22
    fd800000d368:	54fffcc8 	b.hi	fd800000d300 <mem_alloc_vpage+0x2e0>  // b.pmore
    fd800000d36c:	a94363f7 	ldp	x23, x24, [sp, #48]
    fd800000d370:	a94573fb 	ldp	x27, x28, [sp, #80]
    fd800000d374:	1400004c 	b	fd800000d4a4 <mem_alloc_vpage+0x484>
    for (size_t i = 0; i < sections[as->type].sec_size; i++) {
    fd800000d378:	f9400444 	ldr	x4, [x2, #8]
    fd800000d37c:	b40001c4 	cbz	x4, fd800000d3b4 <mem_alloc_vpage+0x394>
    fd800000d380:	d2800001 	mov	x1, #0x0                   	// #0
    fd800000d384:	d503201f 	nop
        if ((va >= sections[as->type].sec[i].beg) && (va <= sections[as->type].sec[i].end)) {
    fd800000d388:	f9400002 	ldr	x2, [x0]
    for (size_t i = 0; i < sections[as->type].sec_size; i++) {
    fd800000d38c:	91000421 	add	x1, x1, #0x1
        if ((va >= sections[as->type].sec[i].beg) && (va <= sections[as->type].sec[i].end)) {
    fd800000d390:	aa0003e3 	mov	x3, x0
    fd800000d394:	eb02033f 	cmp	x25, x2
    fd800000d398:	54000083 	b.cc	fd800000d3a8 <mem_alloc_vpage+0x388>  // b.lo, b.ul, b.last
    fd800000d39c:	f9400402 	ldr	x2, [x0, #8]
    fd800000d3a0:	eb02033f 	cmp	x25, x2
    fd800000d3a4:	540000a9 	b.ls	fd800000d3b8 <mem_alloc_vpage+0x398>  // b.plast
    for (size_t i = 0; i < sections[as->type].sec_size; i++) {
    fd800000d3a8:	91008000 	add	x0, x0, #0x20
    fd800000d3ac:	eb04003f 	cmp	x1, x4
    fd800000d3b0:	54fffec1 	b.ne	fd800000d388 <mem_alloc_vpage+0x368>  // b.any
    return NULL;
    fd800000d3b4:	d2800003 	mov	x3, #0x0                   	// #0
        if (sec != mem_find_sec(as, at)) {
    fd800000d3b8:	f94053e0 	ldr	x0, [sp, #160]
        addr = at;
    fd800000d3bc:	aa1903f4 	mov	x20, x25
        if (sec != mem_find_sec(as, at)) {
    fd800000d3c0:	eb03001f 	cmp	x0, x3
    fd800000d3c4:	54ffe560 	b.eq	fd800000d070 <mem_alloc_vpage+0x50>  // b.none
            return INVALID_VA;
    fd800000d3c8:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    fd800000d3cc:	f90037e0 	str	x0, [sp, #104]
    }

    spin_unlock(&as->lock);

    return vpage;
}
    fd800000d3d0:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd800000d3d4:	a9425bf5 	ldp	x21, x22, [sp, #32]
    fd800000d3d8:	a9446bf9 	ldp	x25, x26, [sp, #64]
    fd800000d3dc:	f94037e0 	ldr	x0, [sp, #104]
    fd800000d3e0:	a8cd7bfd 	ldp	x29, x30, [sp], #208
    fd800000d3e4:	d65f03c0 	ret
                if (at != INVALID_VA) {
    fd800000d3e8:	b100073f 	cmn	x25, #0x1
    fd800000d3ec:	540008e1 	b.ne	fd800000d508 <mem_alloc_vpage+0x4e8>  // b.any
            if (pte_table(&as->pt, pte, lvl)) {
    fd800000d3f0:	aa1703e2 	mov	x2, x23
    fd800000d3f4:	aa1c03e1 	mov	x1, x28
    fd800000d3f8:	aa1503e0 	mov	x0, x21
                count = 0;
    fd800000d3fc:	d2800016 	mov	x22, #0x0                   	// #0
                vpage = INVALID_VA;
    fd800000d400:	f90037f9 	str	x25, [sp, #104]
            if (pte_table(&as->pt, pte, lvl)) {
    fd800000d404:	97ffd1bf 	bl	fd8000001b00 <pte_table>
    fd800000d408:	3607f5e0 	tbz	w0, #0, fd800000d2c4 <mem_alloc_vpage+0x2a4>
                lvl++;
    fd800000d40c:	910006f7 	add	x23, x23, #0x1
                break;
    fd800000d410:	17ffffb3 	b	fd800000d2dc <mem_alloc_vpage+0x2bc>
                (pte_valid(pte) && !pte_table(&as->pt, pte, lvl))) {
    fd800000d414:	aa1703e2 	mov	x2, x23
    fd800000d418:	aa1c03e1 	mov	x1, x28
    fd800000d41c:	aa1503e0 	mov	x0, x21
    fd800000d420:	97ffd1b8 	bl	fd8000001b00 <pte_table>
    fd800000d424:	3607fe20 	tbz	w0, #0, fd800000d3e8 <mem_alloc_vpage+0x3c8>
    return (*pte & PTE_VALID);
    fd800000d428:	f9400380 	ldr	x0, [x28]
            } else if (!pte_valid(pte)) {
    fd800000d42c:	3707f420 	tbnz	w0, #0, fd800000d2b0 <mem_alloc_vpage+0x290>
    fd800000d430:	17ffff56 	b	fd800000d188 <mem_alloc_vpage+0x168>
                    count += (lvlsze / PAGE_SIZE);
    fd800000d434:	f9403be0 	ldr	x0, [sp, #112]
                        vpage = addr;
    fd800000d438:	f10002df 	cmp	x22, #0x0
                    count += (lvlsze / PAGE_SIZE);
    fd800000d43c:	8b0002d6 	add	x22, x22, x0
                        vpage = addr;
    fd800000d440:	f94037e0 	ldr	x0, [sp, #104]
    fd800000d444:	9a941000 	csel	x0, x0, x20, ne	// ne = any
    fd800000d448:	f90037e0 	str	x0, [sp, #104]
                    count += (lvlsze / PAGE_SIZE);
    fd800000d44c:	17ffff99 	b	fd800000d2b0 <mem_alloc_vpage+0x290>
                    if (mem_alloc_pt(as, pte, lvl, addr) == NULL) {
    fd800000d450:	b5fff300 	cbnz	x0, fd800000d2b0 <mem_alloc_vpage+0x290>
    fd800000d454:	d503201f 	nop
                        ERROR("failed to alloc page table");
    fd800000d458:	90000000 	adrp	x0, fd800000d000 <pp_alloc_clr+0x260>
    fd800000d45c:	f9429800 	ldr	x0, [x0, #1328]
    fd800000d460:	97fffaf0 	bl	fd800000c020 <console_printk>
    fd800000d464:	14000000 	b	fd800000d464 <mem_alloc_vpage+0x444>
    fd800000d468:	f94053e1 	ldr	x1, [sp, #160]
    fd800000d46c:	91005024 	add	x4, x1, #0x14
    fd800000d470:	91006025 	add	x5, x1, #0x18
    fd800000d474:	885ffc81 	ldaxr	w1, [x4]
    fd800000d478:	11000422 	add	w2, w1, #0x1
    fd800000d47c:	88037c82 	stxr	w3, w2, [x4]
    fd800000d480:	35ffffa3 	cbnz	w3, fd800000d474 <mem_alloc_vpage+0x454>
    fd800000d484:	88dffca2 	ldar	w2, [x5]
    fd800000d488:	6b02003f 	cmp	w1, w2
    fd800000d48c:	54000060 	b.eq	fd800000d498 <mem_alloc_vpage+0x478>  // b.none
    fd800000d490:	d503205f 	wfe
    fd800000d494:	17fffffc 	b	fd800000d484 <mem_alloc_vpage+0x464>
    while (count < n && !failed) {
    fd800000d498:	b5ffe19a 	cbnz	x26, fd800000d0c8 <mem_alloc_vpage+0xa8>
    fd800000d49c:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    fd800000d4a0:	f90037e0 	str	x0, [sp, #104]
    if (sec->shared) {
    fd800000d4a4:	f94053e1 	ldr	x1, [sp, #160]
    fd800000d4a8:	39404020 	ldrb	w0, [x1, #16]
    fd800000d4ac:	360000e0 	tbz	w0, #0, fd800000d4c8 <mem_alloc_vpage+0x4a8>
    __asm__ volatile(
    fd800000d4b0:	91006021 	add	x1, x1, #0x18
    fd800000d4b4:	b9400020 	ldr	w0, [x1]
    fd800000d4b8:	11000400 	add	w0, w0, #0x1
    fd800000d4bc:	889ffc20 	stlr	w0, [x1]
    fd800000d4c0:	d5033b9f 	dsb	ish
    fd800000d4c4:	d503209f 	sev
    fd800000d4c8:	f94057e0 	ldr	x0, [sp, #168]
    fd800000d4cc:	91001001 	add	x1, x0, #0x4
    fd800000d4d0:	b9400020 	ldr	w0, [x1]
    fd800000d4d4:	11000400 	add	w0, w0, #0x1
    fd800000d4d8:	889ffc20 	stlr	w0, [x1]
    fd800000d4dc:	d5033b9f 	dsb	ish
    fd800000d4e0:	d503209f 	sev
}
    fd800000d4e4:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd800000d4e8:	a9425bf5 	ldp	x21, x22, [sp, #32]
    fd800000d4ec:	a9446bf9 	ldp	x25, x26, [sp, #64]
    fd800000d4f0:	f94037e0 	ldr	x0, [sp, #104]
    fd800000d4f4:	a8cd7bfd 	ldp	x29, x30, [sp], #208
    fd800000d4f8:	d65f03c0 	ret
    while (count < n && !failed) {
    fd800000d4fc:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    fd800000d500:	f90037e0 	str	x0, [sp, #104]
    fd800000d504:	17fffff1 	b	fd800000d4c8 <mem_alloc_vpage+0x4a8>
    fd800000d508:	a94363f7 	ldp	x23, x24, [sp, #48]
                    lvl = 0;
    fd800000d50c:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    fd800000d510:	a94573fb 	ldp	x27, x28, [sp, #80]
    fd800000d514:	f90037e0 	str	x0, [sp, #104]
    fd800000d518:	17ffffe3 	b	fd800000d4a4 <mem_alloc_vpage+0x484>
    *pte = (*pte & ~PTE_RSW_MSK) | (flag & PTE_RSW_MSK);
    fd800000d51c:	f9400380 	ldr	x0, [x28]
    fd800000d520:	17ffff89 	b	fd800000d344 <mem_alloc_vpage+0x324>
    fd800000d524:	d503201f 	nop
    fd800000d528:	00012860 	.word	0x00012860
    fd800000d52c:	0000fd80 	.word	0x0000fd80
    fd800000d530:	00010f50 	.word	0x00010f50
    fd800000d534:	0000fd80 	.word	0x0000fd80
    fd800000d538:	d503201f 	nop
    fd800000d53c:	d503201f 	nop

0000fd800000d540 <mem_unmap>:

void mem_unmap(struct addr_space* as, vaddr_t at, size_t num_pages, bool free_ppages)
{
    fd800000d540:	a9b67bfd 	stp	x29, x30, [sp, #-160]!
    fd800000d544:	910003fd 	mov	x29, sp
    fd800000d548:	a90153f3 	stp	x19, x20, [sp, #16]
    fd800000d54c:	aa0003f4 	mov	x20, x0
    fd800000d550:	12001c60 	and	w0, w3, #0xff
    fd800000d554:	b90077e0 	str	w0, [sp, #116]
    vaddr_t vaddr = at;
    vaddr_t top = at + (num_pages * PAGE_SIZE);
    size_t lvl = 0;

    spin_lock(&as->lock);
    fd800000d558:	9100e280 	add	x0, x20, #0x38
    __asm__ volatile(
    fd800000d55c:	aa0003e4 	mov	x4, x0
    fd800000d560:	91001005 	add	x5, x0, #0x4
{
    fd800000d564:	a9025bf5 	stp	x21, x22, [sp, #32]
    fd800000d568:	a90363f7 	stp	x23, x24, [sp, #48]
    fd800000d56c:	a9046bf9 	stp	x25, x26, [sp, #64]
    fd800000d570:	aa0103f9 	mov	x25, x1
    fd800000d574:	a90573fb 	stp	x27, x28, [sp, #80]
    spin_lock(&as->lock);
    fd800000d578:	f9003fe0 	str	x0, [sp, #120]
    fd800000d57c:	885ffc80 	ldaxr	w0, [x4]
    fd800000d580:	11000401 	add	w1, w0, #0x1
    fd800000d584:	88037c81 	stxr	w3, w1, [x4]
    fd800000d588:	35ffffa3 	cbnz	w3, fd800000d57c <mem_unmap+0x3c>
    fd800000d58c:	88dffca1 	ldar	w1, [x5]
    fd800000d590:	6b01001f 	cmp	w0, w1
    fd800000d594:	54000060 	b.eq	fd800000d5a0 <mem_unmap+0x60>  // b.none
    fd800000d598:	d503205f 	wfe
    fd800000d59c:	17fffffc 	b	fd800000d58c <mem_unmap+0x4c>
    for (size_t i = 0; i < sections[as->type].sec_size; i++) {
    fd800000d5a0:	b9402280 	ldr	w0, [x20, #32]
    fd800000d5a4:	90000001 	adrp	x1, fd800000d000 <pp_alloc_clr+0x260>
    fd800000d5a8:	f9445c21 	ldr	x1, [x1, #2232]
    fd800000d5ac:	d37cec00 	lsl	x0, x0, #4
    fd800000d5b0:	8b000023 	add	x3, x1, x0
    fd800000d5b4:	f9400463 	ldr	x3, [x3, #8]
    fd800000d5b8:	b40017a3 	cbz	x3, fd800000d8ac <mem_unmap+0x36c>
    fd800000d5bc:	f860683c 	ldr	x28, [x1, x0]
    fd800000d5c0:	d2800000 	mov	x0, #0x0                   	// #0
    fd800000d5c4:	14000005 	b	fd800000d5d8 <mem_unmap+0x98>
    fd800000d5c8:	91000400 	add	x0, x0, #0x1
    fd800000d5cc:	9100839c 	add	x28, x28, #0x20
    fd800000d5d0:	eb00007f 	cmp	x3, x0
    fd800000d5d4:	540016c0 	b.eq	fd800000d8ac <mem_unmap+0x36c>  // b.none
        if ((va >= sections[as->type].sec[i].beg) && (va <= sections[as->type].sec[i].end)) {
    fd800000d5d8:	f9400381 	ldr	x1, [x28]
    fd800000d5dc:	eb01033f 	cmp	x25, x1
    fd800000d5e0:	54ffff43 	b.cc	fd800000d5c8 <mem_unmap+0x88>  // b.lo, b.ul, b.last
    fd800000d5e4:	f9400781 	ldr	x1, [x28, #8]
    fd800000d5e8:	eb01033f 	cmp	x25, x1
    fd800000d5ec:	54fffee8 	b.hi	fd800000d5c8 <mem_unmap+0x88>  // b.pmore

    struct section* sec = mem_find_sec(as, at);
    if (sec->shared) {
    fd800000d5f0:	39404380 	ldrb	w0, [x28, #16]
    vaddr_t top = at + (num_pages * PAGE_SIZE);
    fd800000d5f4:	8b023335 	add	x21, x25, x2, lsl #12
    if (sec->shared) {
    fd800000d5f8:	370012e0 	tbnz	w0, #0, fd800000d854 <mem_unmap+0x314>
        spin_lock(&sec->lock);
    }

    while (vaddr < top) {
    fd800000d5fc:	eb15033f 	cmp	x25, x21
    fd800000d600:	54000462 	b.cs	fd800000d68c <mem_unmap+0x14c>  // b.hs, b.nlast
    for (size_t i = 0; i < sections[as->type].sec_size; i++) {
    fd800000d604:	d2800013 	mov	x19, #0x0                   	// #0
    fd800000d608:	14000009 	b	fd800000d62c <mem_unmap+0xec>
    fd800000d60c:	f9400680 	ldr	x0, [x20, #8]
    fd800000d610:	d2800021 	mov	x1, #0x1                   	// #1
    fd800000d614:	f9400400 	ldr	x0, [x0, #8]
    fd800000d618:	f8737800 	ldr	x0, [x0, x19, lsl #3]
    fd800000d61c:	9ac02020 	lsl	x0, x1, x0
        pte_t* pte = pt_get_pte(&as->pt, lvl, vaddr);
        if (pte == NULL) {
            ERROR("invalid pte while freeing vpages");
        } else if (!pte_valid(pte)) {
            size_t lvlsz = pt_lvlsize(&as->pt, lvl);
            vaddr += lvlsz;
    fd800000d620:	8b000339 	add	x25, x25, x0
    while (vaddr < top) {
    fd800000d624:	eb15033f 	cmp	x25, x21
    fd800000d628:	54000222 	b.cs	fd800000d66c <mem_unmap+0x12c>  // b.hs, b.nlast
        pte_t* pte = pt_get_pte(&as->pt, lvl, vaddr);
    fd800000d62c:	aa1903e2 	mov	x2, x25
    fd800000d630:	aa1303e1 	mov	x1, x19
    fd800000d634:	aa1403e0 	mov	x0, x20
    fd800000d638:	97ffd0ea 	bl	fd80000019e0 <pt_get_pte>
    fd800000d63c:	aa0003fa 	mov	x26, x0
        if (pte == NULL) {
    fd800000d640:	b4000ee0 	cbz	x0, fd800000d81c <mem_unmap+0x2dc>
    return (*pte & PTE_VALID);
    fd800000d644:	f9400000 	ldr	x0, [x0]
        } else if (!pte_valid(pte)) {
    fd800000d648:	3607fe20 	tbz	w0, #0, fd800000d60c <mem_unmap+0xcc>
        } else if (pte_table(&as->pt, pte, lvl)) {
    fd800000d64c:	aa1303e2 	mov	x2, x19
    fd800000d650:	aa1a03e1 	mov	x1, x26
    fd800000d654:	aa1403e0 	mov	x0, x20
    fd800000d658:	97ffd12a 	bl	fd8000001b00 <pte_table>
    fd800000d65c:	36000340 	tbz	w0, #0, fd800000d6c4 <mem_unmap+0x184>
            lvl++;
    fd800000d660:	91000673 	add	x19, x19, #0x1
    while (vaddr < top) {
    fd800000d664:	eb15033f 	cmp	x25, x21
    fd800000d668:	54fffe23 	b.cc	fd800000d62c <mem_unmap+0xec>  // b.lo, b.ul, b.last
             * TODO: check if the current pt is now empty and if so, free it too up to the root.
             */
        }
    }

    if (sec->shared) {
    fd800000d66c:	39404380 	ldrb	w0, [x28, #16]
    fd800000d670:	360000e0 	tbz	w0, #0, fd800000d68c <mem_unmap+0x14c>
    __asm__ volatile(
    fd800000d674:	91006381 	add	x1, x28, #0x18
    fd800000d678:	b9400020 	ldr	w0, [x1]
    fd800000d67c:	11000400 	add	w0, w0, #0x1
    fd800000d680:	889ffc20 	stlr	w0, [x1]
    fd800000d684:	d5033b9f 	dsb	ish
    fd800000d688:	d503209f 	sev
    fd800000d68c:	f9403fe0 	ldr	x0, [sp, #120]
    fd800000d690:	91001001 	add	x1, x0, #0x4
    fd800000d694:	b9400020 	ldr	w0, [x1]
    fd800000d698:	11000400 	add	w0, w0, #0x1
    fd800000d69c:	889ffc20 	stlr	w0, [x1]
    fd800000d6a0:	d5033b9f 	dsb	ish
    fd800000d6a4:	d503209f 	sev
        spin_unlock(&sec->lock);
    }

    spin_unlock(&as->lock);
}
    fd800000d6a8:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd800000d6ac:	a9425bf5 	ldp	x21, x22, [sp, #32]
    fd800000d6b0:	a94363f7 	ldp	x23, x24, [sp, #48]
    fd800000d6b4:	a9446bf9 	ldp	x25, x26, [sp, #64]
    fd800000d6b8:	a94573fb 	ldp	x27, x28, [sp, #80]
    fd800000d6bc:	a8ca7bfd 	ldp	x29, x30, [sp], #160
    fd800000d6c0:	d65f03c0 	ret
    return (size_t)(((size_t)pte) & (pt_size(pt, lvl) - 1)) / sizeof(pte_t);
    fd800000d6c4:	f9400680 	ldr	x0, [x20, #8]
    return (1ULL << pt->dscr->lvl_wdt[lvl]) >> pt->dscr->lvl_off[lvl];
    fd800000d6c8:	d2800036 	mov	x22, #0x1                   	// #1
    fd800000d6cc:	a9408800 	ldp	x0, x2, [x0, #8]
    fd800000d6d0:	f8737857 	ldr	x23, [x2, x19, lsl #3]
    fd800000d6d4:	f8737800 	ldr	x0, [x0, x19, lsl #3]
    fd800000d6d8:	9ad722d7 	lsl	x23, x22, x23
    fd800000d6dc:	9ac026f7 	lsr	x23, x23, x0
    return pt_nentries(pt, lvl) * sizeof(pte_t);
    fd800000d6e0:	d37df2e3 	lsl	x3, x23, #3
    return 1ULL << pt->dscr->lvl_off[lvl];
    fd800000d6e4:	9ac022d6 	lsl	x22, x22, x0
    return (size_t)(((size_t)pte) & (pt_size(pt, lvl) - 1)) / sizeof(pte_t);
    fd800000d6e8:	d1000463 	sub	x3, x3, #0x1
    fd800000d6ec:	8a030343 	and	x3, x26, x3
    fd800000d6f0:	d343fc7b 	lsr	x27, x3, #3
            while ((entry < nentries) && (vaddr < top)) {
    fd800000d6f4:	eb17037f 	cmp	x27, x23
    fd800000d6f8:	fa5932a0 	ccmp	x21, x25, #0x0, cc	// cc = lo, ul, last
    fd800000d6fc:	54000789 	b.ls	fd800000d7ec <mem_unmap+0x2ac>  // b.plast
                        struct ppages ppages = mem_ppages_get(paddr, lvlsz / PAGE_SIZE);
    fd800000d700:	d34cfec0 	lsr	x0, x22, #12
    fd800000d704:	f90037e0 	str	x0, [sp, #104]
                    vaddr_t vpage_base = vaddr & ~(lvlsz - 1);
    fd800000d708:	cb1603e0 	neg	x0, x22
    fd800000d70c:	f90033e0 	str	x0, [sp, #96]
                    if (free_ppages) {
    fd800000d710:	b94077e0 	ldr	w0, [sp, #116]
    if (as->type == AS_HYP) {
    fd800000d714:	d2800218 	mov	x24, #0x10                  	// #16
    fd800000d718:	f2dfc018 	movk	x24, #0xfe00, lsl #32
    fd800000d71c:	12000000 	and	w0, w0, #0x1
    fd800000d720:	b90073e0 	str	w0, [sp, #112]
    fd800000d724:	1400000c 	b	fd800000d754 <mem_unmap+0x214>
    DSB(ish);
    fd800000d728:	d5033b9f 	dsb	ish
    asm volatile("tlbi vae2is, %0" ::"r"(vaddr >> 12));
    fd800000d72c:	d34cff20 	lsr	x0, x25, #12
    fd800000d730:	d50c8320 	tlbi	vae2is, x0
    DSB(ish);
    fd800000d734:	d5033b9f 	dsb	ish
    ISB();
    fd800000d738:	d5033fdf 	isb
                entry++;
    fd800000d73c:	9100077b 	add	x27, x27, #0x1
                vaddr += lvlsz;
    fd800000d740:	8b160339 	add	x25, x25, x22
            while ((entry < nentries) && (vaddr < top)) {
    fd800000d744:	eb17037f 	cmp	x27, x23
                pte++;
    fd800000d748:	9100235a 	add	x26, x26, #0x8
            while ((entry < nentries) && (vaddr < top)) {
    fd800000d74c:	fa5932a0 	ccmp	x21, x25, #0x0, cc	// cc = lo, ul, last
    fd800000d750:	540004e9 	b.ls	fd800000d7ec <mem_unmap+0x2ac>  // b.plast
                if (!pte_table(&as->pt, pte, lvl)) {
    fd800000d754:	aa1303e2 	mov	x2, x19
    fd800000d758:	aa1a03e1 	mov	x1, x26
    fd800000d75c:	aa1403e0 	mov	x0, x20
    fd800000d760:	97ffd0e8 	bl	fd8000001b00 <pte_table>
    fd800000d764:	37000440 	tbnz	w0, #0, fd800000d7ec <mem_unmap+0x2ac>
                    vaddr_t vpage_base = vaddr & ~(lvlsz - 1);
    fd800000d768:	f94033e0 	ldr	x0, [sp, #96]
    fd800000d76c:	8a190000 	and	x0, x0, x25
                    if (vaddr > vpage_base || top < (vpage_base + lvlsz)) {
    fd800000d770:	eb19001f 	cmp	x0, x25
    fd800000d774:	540005c3 	b.cc	fd800000d82c <mem_unmap+0x2ec>  // b.lo, b.ul, b.last
    fd800000d778:	8b160000 	add	x0, x0, x22
    fd800000d77c:	eb15001f 	cmp	x0, x21
    fd800000d780:	54000568 	b.hi	fd800000d82c <mem_unmap+0x2ec>  // b.pmore
                    if (free_ppages) {
    fd800000d784:	b94073e0 	ldr	w0, [sp, #112]
    fd800000d788:	350003a0 	cbnz	w0, fd800000d7fc <mem_unmap+0x2bc>
    fd800000d78c:	b9402300 	ldr	w0, [x24, #32]
                    *pte = 0;
    fd800000d790:	f900035f 	str	xzr, [x26]
    fd800000d794:	34fffca0 	cbz	w0, fd800000d728 <mem_unmap+0x1e8>
    } else if (as->type == AS_VM) {
    fd800000d798:	7100041f 	cmp	w0, #0x1
    fd800000d79c:	54fffd01 	b.ne	fd800000d73c <mem_unmap+0x1fc>  // b.any
        tlb_vm_inv_va(as->id, va);
    fd800000d7a0:	f9401b00 	ldr	x0, [x24, #48]
SYSREG_GEN_ACCESSORS(vttbr_el2);
    fd800000d7a4:	d53c2102 	mrs	x2, vttbr_el2
    fd800000d7a8:	d370dc42 	ubfx	x2, x2, #48, #8
    asm volatile("tlbi vae2is, %0" ::"r"(vaddr >> 12));
    fd800000d7ac:	d34cff26 	lsr	x6, x25, #12
    if (switch_vmid) {
    fd800000d7b0:	eb02001f 	cmp	x0, x2
    fd800000d7b4:	540006c0 	b.eq	fd800000d88c <mem_unmap+0x34c>  // b.none
        sysreg_vttbr_el2_write(((uint64_t)vmid << VTTBR_VMID_OFF) & VTTBR_VMID_MSK);
    fd800000d7b8:	d3501c00 	ubfiz	x0, x0, #48, #8
SYSREG_GEN_ACCESSORS(vttbr_el2);
    fd800000d7bc:	d51c2100 	msr	vttbr_el2, x0
        DSB(ish);
    fd800000d7c0:	d5033b9f 	dsb	ish
        ISB();
    fd800000d7c4:	d5033fdf 	isb
    asm volatile("tlbi ipas2e1is, %0" ::"r"(vaddr >> 12));
    fd800000d7c8:	d50c8026 	tlbi	ipas2e1is, x6
        DSB(ish);
    fd800000d7cc:	d5033b9f 	dsb	ish
SYSREG_GEN_ACCESSORS(vttbr_el2);
    fd800000d7d0:	d51c2100 	msr	vttbr_el2, x0
                entry++;
    fd800000d7d4:	9100077b 	add	x27, x27, #0x1
                vaddr += lvlsz;
    fd800000d7d8:	8b160339 	add	x25, x25, x22
            while ((entry < nentries) && (vaddr < top)) {
    fd800000d7dc:	eb17037f 	cmp	x27, x23
                pte++;
    fd800000d7e0:	9100235a 	add	x26, x26, #0x8
            while ((entry < nentries) && (vaddr < top)) {
    fd800000d7e4:	fa5932a0 	ccmp	x21, x25, #0x0, cc	// cc = lo, ul, last
    fd800000d7e8:	54fffb68 	b.hi	fd800000d754 <mem_unmap+0x214>  // b.pmore
                lvl--;
    fd800000d7ec:	eb17037f 	cmp	x27, x23
    fd800000d7f0:	9a9f17e0 	cset	x0, eq	// eq = none
    fd800000d7f4:	cb000273 	sub	x19, x19, x0
    fd800000d7f8:	17ffff8b 	b	fd800000d624 <mem_unmap+0xe4>
    return (paddr_t)(*pte & PTE_ADDR_MSK);
    fd800000d7fc:	f9400342 	ldr	x2, [x26]
                        mem_free_ppages(&ppages);
    fd800000d800:	910223e0 	add	x0, sp, #0x88
    return (struct ppages){ .colors = 0, .base = base, .num_pages = num_pages };
    fd800000d804:	f94037e1 	ldr	x1, [sp, #104]
    fd800000d808:	92748c42 	and	x2, x2, #0xfffffffff000
    fd800000d80c:	a90887e2 	stp	x2, x1, [sp, #136]
    fd800000d810:	f9004fff 	str	xzr, [sp, #152]
    fd800000d814:	97fffc1b 	bl	fd800000c880 <mem_free_ppages>
    fd800000d818:	17ffffdd 	b	fd800000d78c <mem_unmap+0x24c>
            ERROR("invalid pte while freeing vpages");
    fd800000d81c:	90000000 	adrp	x0, fd800000d000 <pp_alloc_clr+0x260>
    fd800000d820:	f9446000 	ldr	x0, [x0, #2240]
    fd800000d824:	97fff9ff 	bl	fd800000c020 <console_printk>
    fd800000d828:	14000000 	b	fd800000d828 <mem_unmap+0x2e8>
    if (as->pt.dscr->lvls - 1 <= lvl) {
    fd800000d82c:	f9400680 	ldr	x0, [x20, #8]
    fd800000d830:	f9400000 	ldr	x0, [x0]
    fd800000d834:	d1000400 	sub	x0, x0, #0x1
    fd800000d838:	eb00027f 	cmp	x19, x0
    fd800000d83c:	540002c3 	b.cc	fd800000d894 <mem_unmap+0x354>  // b.lo, b.ul, b.last
                        lvl++;
    fd800000d840:	91000673 	add	x19, x19, #0x1
                lvl--;
    fd800000d844:	eb17037f 	cmp	x27, x23
    fd800000d848:	9a9f17e0 	cset	x0, eq	// eq = none
    fd800000d84c:	cb000273 	sub	x19, x19, x0
    fd800000d850:	17ffff75 	b	fd800000d624 <mem_unmap+0xe4>
    __asm__ volatile(
    fd800000d854:	91005383 	add	x3, x28, #0x14
    fd800000d858:	91006384 	add	x4, x28, #0x18
    fd800000d85c:	885ffc60 	ldaxr	w0, [x3]
    fd800000d860:	11000401 	add	w1, w0, #0x1
    fd800000d864:	88027c61 	stxr	w2, w1, [x3]
    fd800000d868:	35ffffa2 	cbnz	w2, fd800000d85c <mem_unmap+0x31c>
    fd800000d86c:	88dffc81 	ldar	w1, [x4]
    fd800000d870:	6b01001f 	cmp	w0, w1
    fd800000d874:	54000060 	b.eq	fd800000d880 <mem_unmap+0x340>  // b.none
    fd800000d878:	d503205f 	wfe
    fd800000d87c:	17fffffc 	b	fd800000d86c <mem_unmap+0x32c>
    while (vaddr < top) {
    fd800000d880:	eb15033f 	cmp	x25, x21
    fd800000d884:	54ffec03 	b.cc	fd800000d604 <mem_unmap+0xc4>  // b.lo, b.ul, b.last
    fd800000d888:	17ffff79 	b	fd800000d66c <mem_unmap+0x12c>
    asm volatile("tlbi ipas2e1is, %0" ::"r"(vaddr >> 12));
    fd800000d88c:	d50c8026 	tlbi	ipas2e1is, x6
    if (switch_vmid) {
    fd800000d890:	17ffffab 	b	fd800000d73c <mem_unmap+0x1fc>
    fd800000d894:	aa1303e2 	mov	x2, x19
    fd800000d898:	aa1903e1 	mov	x1, x25
    fd800000d89c:	aa1403e0 	mov	x0, x20
                        lvl++;
    fd800000d8a0:	91000673 	add	x19, x19, #0x1
    fd800000d8a4:	97fffc57 	bl	fd800000ca00 <mem_expand_pte.part.0>
                        break;
    fd800000d8a8:	17ffffe7 	b	fd800000d844 <mem_unmap+0x304>
    if (sec->shared) {
    fd800000d8ac:	d2800000 	mov	x0, #0x0                   	// #0
    fd800000d8b0:	39404000 	ldrb	w0, [x0, #16]
    fd800000d8b4:	d4207d00 	brk	#0x3e8
    fd800000d8b8:	00012860 	.word	0x00012860
    fd800000d8bc:	0000fd80 	.word	0x0000fd80
    fd800000d8c0:	00010f78 	.word	0x00010f78
    fd800000d8c4:	0000fd80 	.word	0x0000fd80
    fd800000d8c8:	d503201f 	nop
    fd800000d8cc:	d503201f 	nop

0000fd800000d8d0 <mem_map>:

bool mem_map(struct addr_space* as, vaddr_t va, struct ppages* ppages, size_t num_pages,
    mem_flags_t flags)
{
    fd800000d8d0:	a9b17bfd 	stp	x29, x30, [sp, #-240]!
    fd800000d8d4:	910003fd 	mov	x29, sp
    fd800000d8d8:	a90363f7 	stp	x23, x24, [sp, #48]
    fd800000d8dc:	aa0003f7 	mov	x23, x0
    for (size_t i = 0; i < sections[as->type].sec_size; i++) {
    fd800000d8e0:	b9402000 	ldr	w0, [x0, #32]
    fd800000d8e4:	90000005 	adrp	x5, fd800000d000 <pp_alloc_clr+0x260>
    fd800000d8e8:	f947f4a5 	ldr	x5, [x5, #4072]
    fd800000d8ec:	d37cec00 	lsl	x0, x0, #4
{
    fd800000d8f0:	a90573fb 	stp	x27, x28, [sp, #80]
    size_t count = 0;
    pte_t* pte = NULL;
    vaddr_t vaddr = va & ~(PAGE_SIZE - 1);
    fd800000d8f4:	9274cc3c 	and	x28, x1, #0xfffffffffffff000
    for (size_t i = 0; i < sections[as->type].sec_size; i++) {
    fd800000d8f8:	8b0000a1 	add	x1, x5, x0
{
    fd800000d8fc:	a9068be3 	stp	x3, x2, [sp, #104]
    for (size_t i = 0; i < sections[as->type].sec_size; i++) {
    fd800000d900:	f9400423 	ldr	x3, [x1, #8]
{
    fd800000d904:	f9003fe4 	str	x4, [sp, #120]
    for (size_t i = 0; i < sections[as->type].sec_size; i++) {
    fd800000d908:	b40001c3 	cbz	x3, fd800000d940 <mem_map+0x70>
    fd800000d90c:	f86068a1 	ldr	x1, [x5, x0]
    fd800000d910:	d2800000 	mov	x0, #0x0                   	// #0
        if ((va >= sections[as->type].sec[i].beg) && (va <= sections[as->type].sec[i].end)) {
    fd800000d914:	aa0103f8 	mov	x24, x1
    fd800000d918:	f9400302 	ldr	x2, [x24]
    for (size_t i = 0; i < sections[as->type].sec_size; i++) {
    fd800000d91c:	91000400 	add	x0, x0, #0x1
        if ((va >= sections[as->type].sec[i].beg) && (va <= sections[as->type].sec[i].end)) {
    fd800000d920:	eb02039f 	cmp	x28, x2
    fd800000d924:	54000083 	b.cc	fd800000d934 <mem_map+0x64>  // b.lo, b.ul, b.last
    fd800000d928:	f9400702 	ldr	x2, [x24, #8]
    fd800000d92c:	eb02039f 	cmp	x28, x2
    fd800000d930:	54000129 	b.ls	fd800000d954 <mem_map+0x84>  // b.plast
    for (size_t i = 0; i < sections[as->type].sec_size; i++) {
    fd800000d934:	91008318 	add	x24, x24, #0x20
    fd800000d938:	eb03001f 	cmp	x0, x3
    fd800000d93c:	54fffee1 	b.ne	fd800000d918 <mem_map+0x48>  // b.any

    struct section* sec = mem_find_sec(as, vaddr);

    if ((sec == NULL) || (sec != mem_find_sec(as, vaddr + num_pages * PAGE_SIZE - 1))) {
        return false;
    fd800000d940:	52800000 	mov	w0, #0x0                   	// #0
        // TODO tlb shootdown?
    }
    spin_unlock(&as->lock);

    return true;
}
    fd800000d944:	a94363f7 	ldp	x23, x24, [sp, #48]
    fd800000d948:	a94573fb 	ldp	x27, x28, [sp, #80]
    fd800000d94c:	a8cf7bfd 	ldp	x29, x30, [sp], #240
    fd800000d950:	d65f03c0 	ret
    if ((sec == NULL) || (sec != mem_find_sec(as, vaddr + num_pages * PAGE_SIZE - 1))) {
    fd800000d954:	f94037e0 	ldr	x0, [sp, #104]
    fd800000d958:	a90153f3 	stp	x19, x20, [sp, #16]
    fd800000d95c:	d374cc14 	lsl	x20, x0, #12
    for (size_t i = 0; i < sections[as->type].sec_size; i++) {
    fd800000d960:	d2800000 	mov	x0, #0x0                   	// #0
    if ((sec == NULL) || (sec != mem_find_sec(as, vaddr + num_pages * PAGE_SIZE - 1))) {
    fd800000d964:	d1000684 	sub	x4, x20, #0x1
    fd800000d968:	8b1c0084 	add	x4, x4, x28
    for (size_t i = 0; i < sections[as->type].sec_size; i++) {
    fd800000d96c:	d503201f 	nop
        if ((va >= sections[as->type].sec[i].beg) && (va <= sections[as->type].sec[i].end)) {
    fd800000d970:	f9400022 	ldr	x2, [x1]
    for (size_t i = 0; i < sections[as->type].sec_size; i++) {
    fd800000d974:	91000400 	add	x0, x0, #0x1
        if ((va >= sections[as->type].sec[i].beg) && (va <= sections[as->type].sec[i].end)) {
    fd800000d978:	eb02009f 	cmp	x4, x2
    fd800000d97c:	54000083 	b.cc	fd800000d98c <mem_map+0xbc>  // b.lo, b.ul, b.last
    fd800000d980:	f9400422 	ldr	x2, [x1, #8]
    fd800000d984:	eb02009f 	cmp	x4, x2
    fd800000d988:	54000149 	b.ls	fd800000d9b0 <mem_map+0xe0>  // b.plast
    for (size_t i = 0; i < sections[as->type].sec_size; i++) {
    fd800000d98c:	91008021 	add	x1, x1, #0x20
    fd800000d990:	eb03001f 	cmp	x0, x3
    fd800000d994:	54fffee1 	b.ne	fd800000d970 <mem_map+0xa0>  // b.any
    fd800000d998:	a94153f3 	ldp	x19, x20, [sp, #16]
        return false;
    fd800000d99c:	52800000 	mov	w0, #0x0                   	// #0
}
    fd800000d9a0:	a94363f7 	ldp	x23, x24, [sp, #48]
    fd800000d9a4:	a94573fb 	ldp	x27, x28, [sp, #80]
    fd800000d9a8:	a8cf7bfd 	ldp	x29, x30, [sp], #240
    fd800000d9ac:	d65f03c0 	ret
    if ((sec == NULL) || (sec != mem_find_sec(as, vaddr + num_pages * PAGE_SIZE - 1))) {
    fd800000d9b0:	eb01031f 	cmp	x24, x1
    fd800000d9b4:	54ffff21 	b.ne	fd800000d998 <mem_map+0xc8>  // b.any
    spin_lock(&as->lock);
    fd800000d9b8:	9100e2e0 	add	x0, x23, #0x38
    fd800000d9bc:	a9025bf5 	stp	x21, x22, [sp, #32]
    fd800000d9c0:	aa0003e3 	mov	x3, x0
    fd800000d9c4:	91001004 	add	x4, x0, #0x4
    fd800000d9c8:	f9004fe0 	str	x0, [sp, #152]
    fd800000d9cc:	885ffc60 	ldaxr	w0, [x3]
    fd800000d9d0:	11000401 	add	w1, w0, #0x1
    fd800000d9d4:	88027c61 	stxr	w2, w1, [x3]
    fd800000d9d8:	35ffffa2 	cbnz	w2, fd800000d9cc <mem_map+0xfc>
    fd800000d9dc:	88dffc81 	ldar	w1, [x4]
    fd800000d9e0:	6b01001f 	cmp	w0, w1
    fd800000d9e4:	54000060 	b.eq	fd800000d9f0 <mem_map+0x120>  // b.none
    fd800000d9e8:	d503205f 	wfe
    fd800000d9ec:	17fffffc 	b	fd800000d9dc <mem_map+0x10c>
    if (sec->shared) {
    fd800000d9f0:	39404300 	ldrb	w0, [x24, #16]
    fd800000d9f4:	37000e40 	tbnz	w0, #0, fd800000dbbc <mem_map+0x2ec>
    colormap_t mask = (((colormap_t)1) << COLOR_NUM) - 1;
    fd800000d9f8:	90000000 	adrp	x0, fd800000d000 <pp_alloc_clr+0x260>
    fd800000d9fc:	f947f813 	ldr	x19, [x0, #4080]
    if (ppages == NULL && !all_clrs(as->colors)) {
    fd800000da00:	f9403be0 	ldr	x0, [sp, #112]
    fd800000da04:	f9400263 	ldr	x3, [x19]
    fd800000da08:	b4000f20 	cbz	x0, fd800000dbec <mem_map+0x31c>
    colormap_t masked_colors = clrs & mask;
    fd800000da0c:	f9403be1 	ldr	x1, [sp, #112]
    colormap_t mask = (((colormap_t)1) << COLOR_NUM) - 1;
    fd800000da10:	d2800020 	mov	x0, #0x1                   	// #1
    fd800000da14:	f9400262 	ldr	x2, [x19]
    colormap_t masked_colors = clrs & mask;
    fd800000da18:	f9400821 	ldr	x1, [x1, #16]
    colormap_t mask = (((colormap_t)1) << COLOR_NUM) - 1;
    fd800000da1c:	9ac22000 	lsl	x0, x0, x2
    fd800000da20:	d1000400 	sub	x0, x0, #0x1
    return (masked_colors == 0) || (masked_colors == mask);
    fd800000da24:	ea010001 	ands	x1, x0, x1
    if (ppages && !all_clrs(ppages->colors)) {
    fd800000da28:	fa401024 	ccmp	x1, x0, #0x4, ne	// ne = any
    fd800000da2c:	54001f61 	b.ne	fd800000de18 <mem_map+0x548>  // b.any
        paddr_t paddr = ppages ? ppages->base : 0;
    fd800000da30:	f9403be0 	ldr	x0, [sp, #112]
    fd800000da34:	f9400015 	ldr	x21, [x0]
    pte_t* pte = NULL;
    fd800000da38:	d2800016 	mov	x22, #0x0                   	// #0
        while (count < num_pages) {
    fd800000da3c:	f94037e0 	ldr	x0, [sp, #104]
    size_t count = 0;
    fd800000da40:	d2800014 	mov	x20, #0x0                   	// #0
    return !pte_valid(pte) && (pt_lvlsize(&as->pt, lvl) <= (left * PAGE_SIZE)) &&
    fd800000da44:	d2800033 	mov	x19, #0x1                   	// #1
        while (count < num_pages) {
    fd800000da48:	b4001c00 	cbz	x0, fd800000ddc8 <mem_map+0x4f8>
    fd800000da4c:	a9046bf9 	stp	x25, x26, [sp, #64]
            for (lvl = 0; lvl < as->pt.dscr->lvls; lvl++) {
    fd800000da50:	f94006e5 	ldr	x5, [x23, #8]
    fd800000da54:	f94000bb 	ldr	x27, [x5]
    fd800000da58:	b4002b1b 	cbz	x27, fd800000dfb8 <mem_map+0x6e8>
    fd800000da5c:	f9403be0 	ldr	x0, [sp, #112]
    return !pte_valid(pte) && (pt_lvlsize(&as->pt, lvl) <= (left * PAGE_SIZE)) &&
    fd800000da60:	d2800119 	mov	x25, #0x8                   	// #8
    fd800000da64:	f100001f 	cmp	x0, #0x0
                    if (pt_pte_mappable(as, pte, lvl, num_pages - count, vaddr,
    fd800000da68:	f94037e0 	ldr	x0, [sp, #104]
    fd800000da6c:	9a9f12ba 	csel	x26, x21, xzr, ne	// ne = any
    fd800000da70:	aa1c0341 	orr	x1, x26, x28
    return !pte_valid(pte) && (pt_lvlsize(&as->pt, lvl) <= (left * PAGE_SIZE)) &&
    fd800000da74:	d280003a 	mov	x26, #0x1                   	// #1
                    if (pt_pte_mappable(as, pte, lvl, num_pages - count, vaddr,
    fd800000da78:	cb140000 	sub	x0, x0, x20
    return !pte_valid(pte) && (pt_lvlsize(&as->pt, lvl) <= (left * PAGE_SIZE)) &&
    fd800000da7c:	d374cc00 	lsl	x0, x0, #12
    fd800000da80:	a90807e0 	stp	x0, x1, [sp, #128]
    fd800000da84:	d503201f 	nop
    fd800000da88:	d100075b 	sub	x27, x26, #0x1
                pte = pt_get_pte(&as->pt, lvl, vaddr);
    fd800000da8c:	aa1c03e2 	mov	x2, x28
    fd800000da90:	aa1b03e1 	mov	x1, x27
    fd800000da94:	aa1703e0 	mov	x0, x23
    fd800000da98:	97ffcfd2 	bl	fd80000019e0 <pt_get_pte>
    return pt->dscr->lvl_term[lvl];
    fd800000da9c:	f94006e5 	ldr	x5, [x23, #8]
    fd800000daa0:	aa0003f6 	mov	x22, x0
    fd800000daa4:	f9400ca0 	ldr	x0, [x5, #24]
                if (pt_lvl_terminal(&as->pt, lvl)) {
    fd800000daa8:	387b6800 	ldrb	w0, [x0, x27]
    fd800000daac:	360007a0 	tbz	w0, #0, fd800000dba0 <mem_map+0x2d0>
    return (*pte & PTE_VALID);
    fd800000dab0:	f94002c0 	ldr	x0, [x22]
        (((size_t)vaddr % pt_lvlsize(&as->pt, lvl)) == 0) &&
    fd800000dab4:	37000cc0 	tbnz	w0, #0, fd800000dc4c <mem_map+0x37c>
    return 1ULL << pt->dscr->lvl_off[lvl];
    fd800000dab8:	f94004a2 	ldr	x2, [x5, #8]
    fd800000dabc:	d1002328 	sub	x8, x25, #0x8
    return !pte_valid(pte) && (pt_lvlsize(&as->pt, lvl) <= (left * PAGE_SIZE)) &&
    fd800000dac0:	f94043e3 	ldr	x3, [sp, #128]
    fd800000dac4:	f8686841 	ldr	x1, [x2, x8]
    fd800000dac8:	2a0103e0 	mov	w0, w1
    fd800000dacc:	9ac1226c 	lsl	x12, x19, x1
    fd800000dad0:	eb03019f 	cmp	x12, x3
    fd800000dad4:	540000c8 	b.hi	fd800000daec <mem_map+0x21c>  // b.pmore
        (((size_t)vaddr % pt_lvlsize(&as->pt, lvl)) == 0) &&
    fd800000dad8:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
    fd800000dadc:	9ac12061 	lsl	x1, x3, x1
    fd800000dae0:	f94047e3 	ldr	x3, [sp, #136]
    fd800000dae4:	ea21007f 	bics	xzr, x3, x1
    fd800000dae8:	54000d40 	b.eq	fd800000dc90 <mem_map+0x3c0>  // b.none
    return (1ULL << pt->dscr->lvl_wdt[lvl]) >> pt->dscr->lvl_off[lvl];
    fd800000daec:	f94008a0 	ldr	x0, [x5, #16]
    struct ppages ppage = mem_alloc_ppages(as->colors, ptsize, ptsize > 1 ? true : false);
    fd800000daf0:	910363e8 	add	x8, sp, #0xd8
    fd800000daf4:	f8796842 	ldr	x2, [x2, x25]
    fd800000daf8:	f8796801 	ldr	x1, [x0, x25]
    fd800000dafc:	f94016e0 	ldr	x0, [x23, #40]
    fd800000db00:	9ac12261 	lsl	x1, x19, x1
    fd800000db04:	9ac22421 	lsr	x1, x1, x2
    return pt_nentries(pt, lvl) * sizeof(pte_t);
    fd800000db08:	d37df021 	lsl	x1, x1, #3
    size_t ptsize = NUM_PAGES(pt_size(&as->pt, lvl + 1));
    fd800000db0c:	913ffc21 	add	x1, x1, #0xfff
    fd800000db10:	d34cfc21 	lsr	x1, x1, #12
    struct ppages ppage = mem_alloc_ppages(as->colors, ptsize, ptsize > 1 ? true : false);
    fd800000db14:	f100043f 	cmp	x1, #0x1
    fd800000db18:	1a9f97e2 	cset	w2, hi	// hi = pmore
    fd800000db1c:	97fff11d 	bl	fd8000009f90 <mem_alloc_ppages>
    if (ppage.num_pages == 0) {
    fd800000db20:	f94073e0 	ldr	x0, [sp, #224]
    fd800000db24:	b40009e0 	cbz	x0, fd800000dc60 <mem_map+0x390>
    *pte = (addr & PTE_ADDR_MSK) | ((type | flags) & PTE_FLAGS_MSK);
    fd800000db28:	f9406fe0 	ldr	x0, [sp, #216]
    fd800000db2c:	d280e8e1 	mov	x1, #0x747                 	// #1863
    pte_t pte_dflt_val = PTE_INVALID | (*parent & PTE_RSW_MSK);
    fd800000db30:	f94002c8 	ldr	x8, [x22]
    fd800000db34:	92748c00 	and	x0, x0, #0xfffffffff000
    fd800000db38:	aa010000 	orr	x0, x0, x1
    fd800000db3c:	f90002c0 	str	x0, [x22]
    fd800000db40:	92490d1b 	and	x27, x8, #0x780000000000000
    fd800000db44:	d5033a9f 	dsb	ishst
    pte_t* temp_pt = pt_get(&as->pt, lvl + 1, addr);
    fd800000db48:	aa1c03e2 	mov	x2, x28
    fd800000db4c:	aa1a03e1 	mov	x1, x26
    fd800000db50:	aa1703e0 	mov	x0, x23
    fd800000db54:	97ffcfc7 	bl	fd8000001a70 <pt_get>
    return (1ULL << pt->dscr->lvl_wdt[lvl]) >> pt->dscr->lvl_off[lvl];
    fd800000db58:	f94006e5 	ldr	x5, [x23, #8]
    fd800000db5c:	a94084a2 	ldp	x2, x1, [x5, #8]
    fd800000db60:	8b19002c 	add	x12, x1, x25
    fd800000db64:	8b19004d 	add	x13, x2, x25
    fd800000db68:	f8796821 	ldr	x1, [x1, x25]
    fd800000db6c:	f8796842 	ldr	x2, [x2, x25]
    fd800000db70:	9ac12261 	lsl	x1, x19, x1
    fd800000db74:	9ac22421 	lsr	x1, x1, x2
    for (size_t i = 0; i < pt_nentries(&as->pt, lvl + 1); i++) {
    fd800000db78:	b4000141 	cbz	x1, fd800000dba0 <mem_map+0x2d0>
    fd800000db7c:	d2800003 	mov	x3, #0x0                   	// #0
        temp_pt[i] = pte_dflt_val;
    fd800000db80:	f823781b 	str	x27, [x0, x3, lsl #3]
    for (size_t i = 0; i < pt_nentries(&as->pt, lvl + 1); i++) {
    fd800000db84:	91000463 	add	x3, x3, #0x1
    fd800000db88:	f9400182 	ldr	x2, [x12]
    fd800000db8c:	f94001a1 	ldr	x1, [x13]
    fd800000db90:	9ac22262 	lsl	x2, x19, x2
    fd800000db94:	9ac12442 	lsr	x2, x2, x1
    fd800000db98:	eb02007f 	cmp	x3, x2
    fd800000db9c:	54ffff23 	b.cc	fd800000db80 <mem_map+0x2b0>  // b.lo, b.ul, b.last
            for (lvl = 0; lvl < as->pt.dscr->lvls; lvl++) {
    fd800000dba0:	f94000a0 	ldr	x0, [x5]
    fd800000dba4:	91002339 	add	x25, x25, #0x8
    fd800000dba8:	91000741 	add	x1, x26, #0x1
    fd800000dbac:	eb00035f 	cmp	x26, x0
    fd800000dbb0:	54000642 	b.cs	fd800000dc78 <mem_map+0x3a8>  // b.hs, b.nlast
    fd800000dbb4:	aa0103fa 	mov	x26, x1
    fd800000dbb8:	17ffffb4 	b	fd800000da88 <mem_map+0x1b8>
    fd800000dbbc:	91005303 	add	x3, x24, #0x14
    fd800000dbc0:	91006304 	add	x4, x24, #0x18
    fd800000dbc4:	885ffc60 	ldaxr	w0, [x3]
    fd800000dbc8:	11000401 	add	w1, w0, #0x1
    fd800000dbcc:	88027c61 	stxr	w2, w1, [x3]
    fd800000dbd0:	35ffffa2 	cbnz	w2, fd800000dbc4 <mem_map+0x2f4>
    fd800000dbd4:	88dffc81 	ldar	w1, [x4]
    fd800000dbd8:	6b01001f 	cmp	w0, w1
    fd800000dbdc:	54000060 	b.eq	fd800000dbe8 <mem_map+0x318>  // b.none
    fd800000dbe0:	d503205f 	wfe
    fd800000dbe4:	17fffffc 	b	fd800000dbd4 <mem_map+0x304>
}
    fd800000dbe8:	17ffff84 	b	fd800000d9f8 <mem_map+0x128>
    if (ppages == NULL && !all_clrs(as->colors)) {
    fd800000dbec:	f94016e0 	ldr	x0, [x23, #40]
    colormap_t masked_colors = clrs & mask;
    fd800000dbf0:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
    colormap_t mask = (((colormap_t)1) << COLOR_NUM) - 1;
    fd800000dbf4:	d2800022 	mov	x2, #0x1                   	// #1
    colormap_t masked_colors = clrs & mask;
    fd800000dbf8:	9ac32021 	lsl	x1, x1, x3
    colormap_t mask = (((colormap_t)1) << COLOR_NUM) - 1;
    fd800000dbfc:	9ac32042 	lsl	x2, x2, x3
    return (masked_colors == 0) || (masked_colors == mask);
    fd800000dc00:	ea210001 	bics	x1, x0, x1
    colormap_t mask = (((colormap_t)1) << COLOR_NUM) - 1;
    fd800000dc04:	d1000442 	sub	x2, x2, #0x1
        paddr_t paddr = ppages ? ppages->base : 0;
    fd800000dc08:	d2800015 	mov	x21, #0x0                   	// #0
    if (ppages == NULL && !all_clrs(as->colors)) {
    fd800000dc0c:	fa411044 	ccmp	x2, x1, #0x4, ne	// ne = any
    fd800000dc10:	54fff140 	b.eq	fd800000da38 <mem_map+0x168>  // b.none
        temp_ppages = mem_alloc_ppages(as->colors, num_pages, false);
    fd800000dc14:	f94037f5 	ldr	x21, [sp, #104]
    fd800000dc18:	9102a3e8 	add	x8, sp, #0xa8
    fd800000dc1c:	52800002 	mov	w2, #0x0                   	// #0
    fd800000dc20:	aa1503e1 	mov	x1, x21
    fd800000dc24:	97fff0db 	bl	fd8000009f90 <mem_alloc_ppages>
        if (temp_ppages.num_pages < num_pages) {
    fd800000dc28:	f9405be0 	ldr	x0, [sp, #176]
        ppages = &temp_ppages;
    fd800000dc2c:	9102a3e1 	add	x1, sp, #0xa8
    fd800000dc30:	f9003be1 	str	x1, [sp, #112]
        if (temp_ppages.num_pages < num_pages) {
    fd800000dc34:	eb15001f 	cmp	x0, x21
    fd800000dc38:	54ffeea2 	b.cs	fd800000da0c <mem_map+0x13c>  // b.hs, b.nlast
            ERROR("failed to alloc colored physical pages");
    fd800000dc3c:	90000000 	adrp	x0, fd800000d000 <pp_alloc_clr+0x260>
    fd800000dc40:	f947fc00 	ldr	x0, [x0, #4088]
    fd800000dc44:	97fff8f7 	bl	fd800000c020 <console_printk>
    fd800000dc48:	14000000 	b	fd800000dc48 <mem_map+0x378>
                    } else if (!pte_table(&as->pt, pte, lvl)) {
    fd800000dc4c:	aa1b03e2 	mov	x2, x27
    fd800000dc50:	aa1603e1 	mov	x1, x22
    fd800000dc54:	aa1703e0 	mov	x0, x23
    fd800000dc58:	97ffcfaa 	bl	fd8000001b00 <pte_table>
    fd800000dc5c:	360008e0 	tbz	w0, #0, fd800000dd78 <mem_map+0x4a8>
            for (lvl = 0; lvl < as->pt.dscr->lvls; lvl++) {
    fd800000dc60:	f94006e5 	ldr	x5, [x23, #8]
    fd800000dc64:	91002339 	add	x25, x25, #0x8
    fd800000dc68:	91000741 	add	x1, x26, #0x1
    fd800000dc6c:	f94000a0 	ldr	x0, [x5]
    fd800000dc70:	eb00035f 	cmp	x26, x0
    fd800000dc74:	54fffa03 	b.cc	fd800000dbb4 <mem_map+0x2e4>  // b.lo, b.ul, b.last
    fd800000dc78:	f94004a0 	ldr	x0, [x5, #8]
    fd800000dc7c:	d37df348 	lsl	x8, x26, #3
    return 1ULL << pt->dscr->lvl_off[lvl];
    fd800000dc80:	aa1a03fb 	mov	x27, x26
    return (1ULL << pt->dscr->lvl_wdt[lvl]) >> pt->dscr->lvl_off[lvl];
    fd800000dc84:	f87a780c 	ldr	x12, [x0, x26, lsl #3]
    fd800000dc88:	2a0c03e0 	mov	w0, w12
    return 1ULL << pt->dscr->lvl_off[lvl];
    fd800000dc8c:	9acc226c 	lsl	x12, x19, x12
    return (1ULL << pt->dscr->lvl_wdt[lvl]) >> pt->dscr->lvl_off[lvl];
    fd800000dc90:	f94008a1 	ldr	x1, [x5, #16]
            while ((entry < nentries) && (count < num_pages) &&
    fd800000dc94:	f94037e2 	ldr	x2, [sp, #104]
    fd800000dc98:	f8686821 	ldr	x1, [x1, x8]
    fd800000dc9c:	eb14005f 	cmp	x2, x20
    fd800000dca0:	9ac12261 	lsl	x1, x19, x1
    fd800000dca4:	9ac02423 	lsr	x3, x1, x0
    return pt_nentries(pt, lvl) * sizeof(pte_t);
    fd800000dca8:	d37df079 	lsl	x25, x3, #3
    return (size_t)(((size_t)pte) & (pt_size(pt, lvl) - 1)) / sizeof(pte_t);
    fd800000dcac:	d1000739 	sub	x25, x25, #0x1
    fd800000dcb0:	8a1902d9 	and	x25, x22, x25
    fd800000dcb4:	d343ff39 	lsr	x25, x25, #3
    fd800000dcb8:	fa438322 	ccmp	x25, x3, #0x2, hi	// hi = pmore
    fd800000dcbc:	540007e2 	b.cs	fd800000ddb8 <mem_map+0x4e8>  // b.hs, b.nlast
                (num_pages - count >= lvlsz / PAGE_SIZE)) {
    fd800000dcc0:	cb14005a 	sub	x26, x2, x20
    fd800000dcc4:	d34cfd81 	lsr	x1, x12, #12
            while ((entry < nentries) && (count < num_pages) &&
    fd800000dcc8:	eb1a003f 	cmp	x1, x26
    fd800000dccc:	54ffec28 	b.hi	fd800000da50 <mem_map+0x180>  // b.pmore
    fd800000dcd0:	cb01035a 	sub	x26, x26, x1
    return (lvl == pt->dscr->lvls - 1) ? PTE_PAGE : PTE_SUPERPAGE;
    fd800000dcd4:	d2800065 	mov	x5, #0x3                   	// #3
    fd800000dcd8:	14000018 	b	fd800000dd38 <mem_map+0x468>
    fd800000dcdc:	f94006e0 	ldr	x0, [x23, #8]
    fd800000dce0:	92748ea8 	and	x8, x21, #0xfffffffff000
                entry++;
    fd800000dce4:	91000739 	add	x25, x25, #0x1
                count += lvlsz / PAGE_SIZE;
    fd800000dce8:	8b010294 	add	x20, x20, x1
                vaddr += lvlsz;
    fd800000dcec:	8b0c039c 	add	x28, x28, x12
                paddr += lvlsz;
    fd800000dcf0:	8b0c02b5 	add	x21, x21, x12
    return (lvl == pt->dscr->lvls - 1) ? PTE_PAGE : PTE_SUPERPAGE;
    fd800000dcf4:	f9400000 	ldr	x0, [x0]
            while ((entry < nentries) && (count < num_pages) &&
    fd800000dcf8:	cb01034a 	sub	x10, x26, x1
    return (lvl == pt->dscr->lvls - 1) ? PTE_PAGE : PTE_SUPERPAGE;
    fd800000dcfc:	d1000400 	sub	x0, x0, #0x1
    fd800000dd00:	eb1b001f 	cmp	x0, x27
    fd800000dd04:	f9403fe0 	ldr	x0, [sp, #120]
    fd800000dd08:	9a851262 	csel	x2, x19, x5, ne	// ne = any
            while ((entry < nentries) && (count < num_pages) &&
    fd800000dd0c:	eb03033f 	cmp	x25, x3
    fd800000dd10:	aa020002 	orr	x2, x0, x2
    fd800000dd14:	f94037e0 	ldr	x0, [sp, #104]
    fd800000dd18:	92506c42 	and	x2, x2, #0xffff000000000fff
    fd800000dd1c:	aa080042 	orr	x2, x2, x8
    fd800000dd20:	f80086c2 	str	x2, [x22], #8
    fd800000dd24:	fa543000 	ccmp	x0, x20, #0x0, cc	// cc = lo, ul, last
    fd800000dd28:	54000489 	b.ls	fd800000ddb8 <mem_map+0x4e8>  // b.plast
    fd800000dd2c:	eb1a003f 	cmp	x1, x26
    fd800000dd30:	aa0a03fa 	mov	x26, x10
    fd800000dd34:	54ffe8e8 	b.hi	fd800000da50 <mem_map+0x180>  // b.pmore
                if (ppages == NULL) {
    fd800000dd38:	f9403be0 	ldr	x0, [sp, #112]
    fd800000dd3c:	b5fffd00 	cbnz	x0, fd800000dcdc <mem_map+0x40c>
                    struct ppages temp = mem_alloc_ppages(as->colors, lvlsz / PAGE_SIZE, true);
    fd800000dd40:	f94016e0 	ldr	x0, [x23, #40]
    fd800000dd44:	910303e8 	add	x8, sp, #0xc0
    fd800000dd48:	52800022 	mov	w2, #0x1                   	// #1
    fd800000dd4c:	a90833e1 	stp	x1, x12, [sp, #128]
    fd800000dd50:	f9004be3 	str	x3, [sp, #144]
    fd800000dd54:	97fff08f 	bl	fd8000009f90 <mem_alloc_ppages>
                    if (temp.num_pages < lvlsz / PAGE_SIZE) {
    fd800000dd58:	a94833e1 	ldp	x1, x12, [sp, #128]
    fd800000dd5c:	d2800065 	mov	x5, #0x3                   	// #3
    fd800000dd60:	f94067e0 	ldr	x0, [sp, #200]
    fd800000dd64:	f9404be3 	ldr	x3, [sp, #144]
    fd800000dd68:	eb00003f 	cmp	x1, x0
    fd800000dd6c:	540000e8 	b.hi	fd800000dd88 <mem_map+0x4b8>  // b.pmore
                    paddr = temp.base;
    fd800000dd70:	f94063f5 	ldr	x21, [sp, #192]
    fd800000dd74:	17ffffda 	b	fd800000dcdc <mem_map+0x40c>
                        ERROR("trying to override previous mapping");
    fd800000dd78:	b0000000 	adrp	x0, fd800000e000 <mem_map+0x730>
    fd800000dd7c:	f9400400 	ldr	x0, [x0, #8]
    fd800000dd80:	97fff8a8 	bl	fd800000c020 <console_printk>
    fd800000dd84:	14000000 	b	fd800000dd84 <mem_map+0x4b4>
                        if (lvl == (as->pt.dscr->lvls - 1)) {
    fd800000dd88:	f94006e0 	ldr	x0, [x23, #8]
    fd800000dd8c:	f9400000 	ldr	x0, [x0]
    fd800000dd90:	d1000400 	sub	x0, x0, #0x1
    fd800000dd94:	eb1b001f 	cmp	x0, x27
    fd800000dd98:	540011e0 	b.eq	fd800000dfd4 <mem_map+0x704>  // b.none
                            pte = pt_get_pte(&as->pt, lvl, vaddr);
    fd800000dd9c:	aa1c03e2 	mov	x2, x28
    fd800000dda0:	aa1b03e1 	mov	x1, x27
    fd800000dda4:	aa1703e0 	mov	x0, x23
    fd800000dda8:	97ffcf0e 	bl	fd80000019e0 <pt_get_pte>
    fd800000ddac:	aa0003f6 	mov	x22, x0
    return (*pte & PTE_VALID);
    fd800000ddb0:	f9400000 	ldr	x0, [x0]
                            if (!pte_valid(pte)) {
    fd800000ddb4:	36000960 	tbz	w0, #0, fd800000dee0 <mem_map+0x610>
        while (count < num_pages) {
    fd800000ddb8:	f94037e0 	ldr	x0, [sp, #104]
    fd800000ddbc:	eb14001f 	cmp	x0, x20
    fd800000ddc0:	54ffe488 	b.hi	fd800000da50 <mem_map+0x180>  // b.pmore
    fd800000ddc4:	a9446bf9 	ldp	x25, x26, [sp, #64]
    DSB(ishld);
}

static inline void fence_sync()
{
    DSB(ish);
    fd800000ddc8:	d5033b9f 	dsb	ish
    if (sec->shared) {
    fd800000ddcc:	39404300 	ldrb	w0, [x24, #16]
    fd800000ddd0:	360000e0 	tbz	w0, #0, fd800000ddec <mem_map+0x51c>
    __asm__ volatile(
    fd800000ddd4:	91006301 	add	x1, x24, #0x18
    fd800000ddd8:	b9400020 	ldr	w0, [x1]
    fd800000dddc:	11000400 	add	w0, w0, #0x1
    fd800000dde0:	889ffc20 	stlr	w0, [x1]
    fd800000dde4:	d5033b9f 	dsb	ish
    fd800000dde8:	d503209f 	sev
    fd800000ddec:	f9404fe0 	ldr	x0, [sp, #152]
    fd800000ddf0:	91001001 	add	x1, x0, #0x4
    fd800000ddf4:	b9400020 	ldr	w0, [x1]
    fd800000ddf8:	11000400 	add	w0, w0, #0x1
    fd800000ddfc:	889ffc20 	stlr	w0, [x1]
    fd800000de00:	d5033b9f 	dsb	ish
    fd800000de04:	d503209f 	sev
    return true;
    fd800000de08:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd800000de0c:	52800020 	mov	w0, #0x1                   	// #1
    fd800000de10:	a9425bf5 	ldp	x21, x22, [sp, #32]
    fd800000de14:	17fffecc 	b	fd800000d944 <mem_map+0x74>
        mem_inflate_pt(as, vaddr, num_pages * PAGE_SIZE);
    fd800000de18:	aa1703e0 	mov	x0, x23
    fd800000de1c:	aa1403e2 	mov	x2, x20
    fd800000de20:	aa1c03e1 	mov	x1, x28
    fd800000de24:	97fffb9b 	bl	fd800000cc90 <mem_inflate_pt>
        for (size_t i = 0; i < ppages->num_pages; i++) {
    fd800000de28:	f9403be0 	ldr	x0, [sp, #112]
    fd800000de2c:	f9400400 	ldr	x0, [x0, #8]
    fd800000de30:	b4fffcc0 	cbz	x0, fd800000ddc8 <mem_map+0x4f8>
    fd800000de34:	b0000000 	adrp	x0, fd800000e000 <mem_map+0x730>
    fd800000de38:	f9400014 	ldr	x20, [x0]
    fd800000de3c:	a9046bf9 	stp	x25, x26, [sp, #64]
    fd800000de40:	d2800016 	mov	x22, #0x0                   	// #0
    fd800000de44:	f9403fe0 	ldr	x0, [sp, #120]
        size_t index = 0;
    fd800000de48:	d2800015 	mov	x21, #0x0                   	// #0
    fd800000de4c:	92506c19 	and	x25, x0, #0xffff000000000fff
            pte = pt_get_pte(&as->pt, as->pt.dscr->lvls - 1, vaddr);
    fd800000de50:	f94006e1 	ldr	x1, [x23, #8]
    fd800000de54:	aa1c03e2 	mov	x2, x28
    fd800000de58:	aa1703e0 	mov	x0, x23
    fd800000de5c:	f9400021 	ldr	x1, [x1]
    fd800000de60:	d1000421 	sub	x1, x1, #0x1
    fd800000de64:	97ffcedf 	bl	fd80000019e0 <pt_get_pte>
            index = pp_next_clr(ppages->base, index, ppages->colors);
    fd800000de68:	f9403be2 	ldr	x2, [sp, #112]
    size_t clr_offset = (base / PAGE_SIZE) % (COLOR_NUM * COLOR_SIZE);
    fd800000de6c:	f9400263 	ldr	x3, [x19]
    fd800000de70:	f9400285 	ldr	x5, [x20]
            index = pp_next_clr(ppages->base, index, ppages->colors);
    fd800000de74:	f9400048 	ldr	x8, [x2]
    size_t clr_offset = (base / PAGE_SIZE) % (COLOR_NUM * COLOR_SIZE);
    fd800000de78:	9b057c61 	mul	x1, x3, x5
            index = pp_next_clr(ppages->base, index, ppages->colors);
    fd800000de7c:	f940084a 	ldr	x10, [x2, #16]
    size_t clr_offset = (base / PAGE_SIZE) % (COLOR_NUM * COLOR_SIZE);
    fd800000de80:	d34cfd02 	lsr	x2, x8, #12
    fd800000de84:	9ac10844 	udiv	x4, x2, x1
    fd800000de88:	9b018884 	msub	x4, x4, x1, x2
    fd800000de8c:	14000002 	b	fd800000de94 <mem_map+0x5c4>
        index++;
    fd800000de90:	910006b5 	add	x21, x21, #0x1
    while (!((colors >> ((index + clr_offset) / COLOR_SIZE % COLOR_NUM)) & 1)) {
    fd800000de94:	8b150082 	add	x2, x4, x21
    fd800000de98:	9ac50842 	udiv	x2, x2, x5
    fd800000de9c:	9ac30841 	udiv	x1, x2, x3
    fd800000dea0:	9b038821 	msub	x1, x1, x3, x2
    fd800000dea4:	9ac12541 	lsr	x1, x10, x1
    fd800000dea8:	3607ff41 	tbz	w1, #0, fd800000de90 <mem_map+0x5c0>
            paddr_t paddr = ppages->base + (index * PAGE_SIZE);
    fd800000deac:	8b153101 	add	x1, x8, x21, lsl #12
        for (size_t i = 0; i < ppages->num_pages; i++) {
    fd800000deb0:	910006d6 	add	x22, x22, #0x1
    *pte = (addr & PTE_ADDR_MSK) | ((type | flags) & PTE_FLAGS_MSK);
    fd800000deb4:	92748c21 	and	x1, x1, #0xfffffffff000
            vaddr += PAGE_SIZE;
    fd800000deb8:	9140079c 	add	x28, x28, #0x1, lsl #12
    fd800000debc:	aa190021 	orr	x1, x1, x25
            index++;
    fd800000dec0:	910006b5 	add	x21, x21, #0x1
    fd800000dec4:	b2400421 	orr	x1, x1, #0x3
    fd800000dec8:	f9000001 	str	x1, [x0]
        for (size_t i = 0; i < ppages->num_pages; i++) {
    fd800000decc:	f9403be0 	ldr	x0, [sp, #112]
    fd800000ded0:	f9400400 	ldr	x0, [x0, #8]
    fd800000ded4:	eb16001f 	cmp	x0, x22
    fd800000ded8:	54fffbc8 	b.hi	fd800000de50 <mem_map+0x580>  // b.pmore
    fd800000dedc:	17ffffba 	b	fd800000ddc4 <mem_map+0x4f4>
    size_t ptsize = NUM_PAGES(pt_size(&as->pt, lvl + 1));
    fd800000dee0:	f94006e1 	ldr	x1, [x23, #8]
    fd800000dee4:	91000763 	add	x3, x27, #0x1
    return (1ULL << pt->dscr->lvl_wdt[lvl]) >> pt->dscr->lvl_off[lvl];
    fd800000dee8:	d280003a 	mov	x26, #0x1                   	// #1
    struct ppages ppage = mem_alloc_ppages(as->colors, ptsize, ptsize > 1 ? true : false);
    fd800000deec:	910363e8 	add	x8, sp, #0xd8
    fd800000def0:	f94016e0 	ldr	x0, [x23, #40]
    fd800000def4:	d37df079 	lsl	x25, x3, #3
    fd800000def8:	a9409422 	ldp	x2, x5, [x1, #8]
    fd800000defc:	f90043e3 	str	x3, [sp, #128]
    fd800000df00:	f86378a1 	ldr	x1, [x5, x3, lsl #3]
    fd800000df04:	f8637842 	ldr	x2, [x2, x3, lsl #3]
    fd800000df08:	9ac12341 	lsl	x1, x26, x1
    fd800000df0c:	9ac22421 	lsr	x1, x1, x2
    return pt_nentries(pt, lvl) * sizeof(pte_t);
    fd800000df10:	d37df021 	lsl	x1, x1, #3
    size_t ptsize = NUM_PAGES(pt_size(&as->pt, lvl + 1));
    fd800000df14:	913ffc21 	add	x1, x1, #0xfff
    fd800000df18:	d34cfc21 	lsr	x1, x1, #12
    struct ppages ppage = mem_alloc_ppages(as->colors, ptsize, ptsize > 1 ? true : false);
    fd800000df1c:	eb1a003f 	cmp	x1, x26
    fd800000df20:	1a9f97e2 	cset	w2, hi	// hi = pmore
    fd800000df24:	97fff01b 	bl	fd8000009f90 <mem_alloc_ppages>
    if (ppage.num_pages == 0) {
    fd800000df28:	f94073e0 	ldr	x0, [sp, #224]
    fd800000df2c:	b4fff460 	cbz	x0, fd800000ddb8 <mem_map+0x4e8>
    fd800000df30:	f9406fe0 	ldr	x0, [sp, #216]
    fd800000df34:	d280e8e1 	mov	x1, #0x747                 	// #1863
    pte_t pte_dflt_val = PTE_INVALID | (*parent & PTE_RSW_MSK);
    fd800000df38:	f94002db 	ldr	x27, [x22]
    fd800000df3c:	92748c00 	and	x0, x0, #0xfffffffff000
    fd800000df40:	aa010000 	orr	x0, x0, x1
    fd800000df44:	f90002c0 	str	x0, [x22]
    fd800000df48:	92490f7b 	and	x27, x27, #0x780000000000000
    DSB(ishst);
    fd800000df4c:	d5033a9f 	dsb	ishst
    pte_t* temp_pt = pt_get(&as->pt, lvl + 1, addr);
    fd800000df50:	f94043e3 	ldr	x3, [sp, #128]
    fd800000df54:	aa1c03e2 	mov	x2, x28
    fd800000df58:	aa1703e0 	mov	x0, x23
    fd800000df5c:	aa0303e1 	mov	x1, x3
    fd800000df60:	97ffcec4 	bl	fd8000001a70 <pt_get>
    fd800000df64:	aa0003e5 	mov	x5, x0
    return (1ULL << pt->dscr->lvl_wdt[lvl]) >> pt->dscr->lvl_off[lvl];
    fd800000df68:	f94006e1 	ldr	x1, [x23, #8]
    fd800000df6c:	f94043e3 	ldr	x3, [sp, #128]
    fd800000df70:	a9408021 	ldp	x1, x0, [x1, #8]
    fd800000df74:	8b190008 	add	x8, x0, x25
    fd800000df78:	8b190039 	add	x25, x1, x25
    fd800000df7c:	f8637800 	ldr	x0, [x0, x3, lsl #3]
    fd800000df80:	f8637821 	ldr	x1, [x1, x3, lsl #3]
    fd800000df84:	9ac02340 	lsl	x0, x26, x0
    fd800000df88:	9ac12400 	lsr	x0, x0, x1
    for (size_t i = 0; i < pt_nentries(&as->pt, lvl + 1); i++) {
    fd800000df8c:	b4fff160 	cbz	x0, fd800000ddb8 <mem_map+0x4e8>
    fd800000df90:	d2800001 	mov	x1, #0x0                   	// #0
        temp_pt[i] = pte_dflt_val;
    fd800000df94:	f82178bb 	str	x27, [x5, x1, lsl #3]
    for (size_t i = 0; i < pt_nentries(&as->pt, lvl + 1); i++) {
    fd800000df98:	91000421 	add	x1, x1, #0x1
    fd800000df9c:	f9400100 	ldr	x0, [x8]
    fd800000dfa0:	f9400322 	ldr	x2, [x25]
    fd800000dfa4:	9ac02340 	lsl	x0, x26, x0
    fd800000dfa8:	9ac22400 	lsr	x0, x0, x2
    fd800000dfac:	eb00003f 	cmp	x1, x0
    fd800000dfb0:	54ffff23 	b.cc	fd800000df94 <mem_map+0x6c4>  // b.lo, b.ul, b.last
    fd800000dfb4:	17ffff81 	b	fd800000ddb8 <mem_map+0x4e8>
    fd800000dfb8:	f94004a0 	ldr	x0, [x5, #8]
    return 1ULL << pt->dscr->lvl_off[lvl];
    fd800000dfbc:	d280002c 	mov	x12, #0x1                   	// #1
    fd800000dfc0:	d2800008 	mov	x8, #0x0                   	// #0
    return (1ULL << pt->dscr->lvl_wdt[lvl]) >> pt->dscr->lvl_off[lvl];
    fd800000dfc4:	f9400001 	ldr	x1, [x0]
    fd800000dfc8:	2a0103e0 	mov	w0, w1
    return 1ULL << pt->dscr->lvl_off[lvl];
    fd800000dfcc:	9ac1218c 	lsl	x12, x12, x1
    fd800000dfd0:	17ffff30 	b	fd800000dc90 <mem_map+0x3c0>
                            ERROR("failed to alloc physical pages");
    fd800000dfd4:	b0000000 	adrp	x0, fd800000e000 <mem_map+0x730>
    fd800000dfd8:	f9400800 	ldr	x0, [x0, #16]
    fd800000dfdc:	97fff811 	bl	fd800000c020 <console_printk>
    fd800000dfe0:	14000000 	b	fd800000dfe0 <mem_map+0x710>
    fd800000dfe4:	d503201f 	nop
    fd800000dfe8:	00012860 	.word	0x00012860
    fd800000dfec:	0000fd80 	.word	0x0000fd80
    fd800000dff0:	00012828 	.word	0x00012828
    fd800000dff4:	0000fd80 	.word	0x0000fd80
    fd800000dff8:	00010fa8 	.word	0x00010fa8
    fd800000dffc:	0000fd80 	.word	0x0000fd80
    fd800000e000:	00012820 	.word	0x00012820
    fd800000e004:	0000fd80 	.word	0x0000fd80
    fd800000e008:	00010fe0 	.word	0x00010fe0
    fd800000e00c:	0000fd80 	.word	0x0000fd80
    fd800000e010:	00011010 	.word	0x00011010
    fd800000e014:	0000fd80 	.word	0x0000fd80
    fd800000e018:	d503201f 	nop
    fd800000e01c:	d503201f 	nop

0000fd800000e020 <mem_map_reclr>:

bool mem_map_reclr(struct addr_space* as, vaddr_t va, struct ppages* ppages, size_t num_pages,
    mem_flags_t flags)
{
    fd800000e020:	a9b37bfd 	stp	x29, x30, [sp, #-208]!
    fd800000e024:	910003fd 	mov	x29, sp
    fd800000e028:	a90153f3 	stp	x19, x20, [sp, #16]
    fd800000e02c:	a9025bf5 	stp	x21, x22, [sp, #32]
    fd800000e030:	a90363f7 	stp	x23, x24, [sp, #48]
    fd800000e034:	a9046bf9 	stp	x25, x26, [sp, #64]
    fd800000e038:	a90573fb 	stp	x27, x28, [sp, #80]
    if (ppages == NULL) {
    fd800000e03c:	b4001be2 	cbz	x2, fd800000e3b8 <mem_map_reclr+0x398>

    /**
     * Count how many pages are not colored in original images. Allocate the necessary colored
     * pages. Mapped onto hypervisor address space.
     */
    size_t reclrd_num = num_pages / (COLOR_NUM * COLOR_SIZE) * COLOR_SIZE *
    fd800000e040:	aa0003fb 	mov	x27, x0
    fd800000e044:	90000000 	adrp	x0, fd800000e000 <mem_map+0x730>
    fd800000e048:	f941e816 	ldr	x22, [x0, #976]
    fd800000e04c:	90000000 	adrp	x0, fd800000e000 <mem_map+0x730>
    fd800000e050:	f941ec17 	ldr	x23, [x0, #984]
    fd800000e054:	aa0403f4 	mov	x20, x4
    fd800000e058:	f94002c4 	ldr	x4, [x22]
    fd800000e05c:	aa0103f8 	mov	x24, x1
    fd800000e060:	f94002e9 	ldr	x9, [x23]
    fd800000e064:	aa0303f3 	mov	x19, x3
        bit_count(~(as->colors & BIT_MASK(0, COLOR_NUM)));
    fd800000e068:	51000480 	sub	w0, w4, #0x1
    fd800000e06c:	d2800023 	mov	x3, #0x1                   	// #1
    fd800000e070:	f9401768 	ldr	x8, [x27, #40]
    size_t reclrd_num = num_pages / (COLOR_NUM * COLOR_SIZE) * COLOR_SIZE *
    fd800000e074:	9b097c81 	mul	x1, x4, x9
        bit_count(~(as->colors & BIT_MASK(0, COLOR_NUM)));
    fd800000e078:	9ac02066 	lsl	x6, x3, x0
    fd800000e07c:	aa0203f5 	mov	x21, x2
    fd800000e080:	cb0607e6 	neg	x6, x6, lsl #1
BIT_OPS_GEN(bit, unsigned long, (1UL), BIT_MASK);
    fd800000e084:	aa0303e2 	mov	x2, x3
    fd800000e088:	aa2800c6 	orn	x6, x6, x8
    fd800000e08c:	d2800005 	mov	x5, #0x0                   	// #0
    size_t reclrd_num = num_pages / (COLOR_NUM * COLOR_SIZE) * COLOR_SIZE *
    fd800000e090:	9ac10a60 	udiv	x0, x19, x1
        bit_count(~(as->colors & BIT_MASK(0, COLOR_NUM)));
    fd800000e094:	52800803 	mov	w3, #0x40                  	// #64
    size_t reclrd_num = num_pages / (COLOR_NUM * COLOR_SIZE) * COLOR_SIZE *
    fd800000e098:	9b097c0a 	mul	x10, x0, x9
    fd800000e09c:	d503201f 	nop
    fd800000e0a0:	ea0200df 	tst	x6, x2
    fd800000e0a4:	8b020042 	add	x2, x2, x2
    fd800000e0a8:	9a8504a5 	cinc	x5, x5, ne	// ne = any
    fd800000e0ac:	71000463 	subs	w3, w3, #0x1
    fd800000e0b0:	54ffff81 	b.ne	fd800000e0a0 <mem_map_reclr+0x80>  // b.any
    size_t clr_offset = (ppages->base / PAGE_SIZE) % (COLOR_NUM * COLOR_SIZE);
    fd800000e0b4:	f94002a2 	ldr	x2, [x21]
    for (size_t i = 0; i < (num_pages % (COLOR_NUM * COLOR_SIZE)); i++) {
    fd800000e0b8:	9b01cc00 	msub	x0, x0, x1, x19
    size_t reclrd_num = num_pages / (COLOR_NUM * COLOR_SIZE) * COLOR_SIZE *
    fd800000e0bc:	9b057d5c 	mul	x28, x10, x5
    size_t clr_offset = (ppages->base / PAGE_SIZE) % (COLOR_NUM * COLOR_SIZE);
    fd800000e0c0:	d34cfc42 	lsr	x2, x2, #12
    fd800000e0c4:	9ac10846 	udiv	x6, x2, x1
    fd800000e0c8:	9b0188da 	msub	x26, x6, x1, x2
    for (size_t i = 0; i < (num_pages % (COLOR_NUM * COLOR_SIZE)); i++) {
    fd800000e0cc:	b40001c0 	cbz	x0, fd800000e104 <mem_map_reclr+0xe4>
    fd800000e0d0:	8b000343 	add	x3, x26, x0
    fd800000e0d4:	aa1a03e1 	mov	x1, x26
    fd800000e0d8:	d280002a 	mov	x10, #0x1                   	// #1
    fd800000e0dc:	d503201f 	nop
        if (!bit_get(as->colors, (i + clr_offset) / COLOR_SIZE % COLOR_NUM)) {
    fd800000e0e0:	9ac90822 	udiv	x2, x1, x9
    for (size_t i = 0; i < (num_pages % (COLOR_NUM * COLOR_SIZE)); i++) {
    fd800000e0e4:	91000421 	add	x1, x1, #0x1
        if (!bit_get(as->colors, (i + clr_offset) / COLOR_SIZE % COLOR_NUM)) {
    fd800000e0e8:	9ac40840 	udiv	x0, x2, x4
    fd800000e0ec:	9b048800 	msub	x0, x0, x4, x2
    fd800000e0f0:	9ac02140 	lsl	x0, x10, x0
            reclrd_num++;
    fd800000e0f4:	ea08001f 	tst	x0, x8
    fd800000e0f8:	9a9c179c 	cinc	x28, x28, eq	// eq = none
    for (size_t i = 0; i < (num_pages % (COLOR_NUM * COLOR_SIZE)); i++) {
    fd800000e0fc:	eb03003f 	cmp	x1, x3
    fd800000e100:	54ffff01 	b.ne	fd800000e0e0 <mem_map_reclr+0xc0>  // b.any
    fd800000e104:	d2800020 	mov	x0, #0x1                   	// #1
    fd800000e108:	9ac42000 	lsl	x0, x0, x4
    fd800000e10c:	d1000400 	sub	x0, x0, #0x1

    /**
     * If the address space was not assigned any specific color, or there are no pages to recolor
     * defer to vanilla mapping.
     */
    if (all_clrs(as->colors) || (reclrd_num == 0)) {
    fd800000e110:	ea000108 	ands	x8, x8, x0
    fd800000e114:	fa481004 	ccmp	x0, x8, #0x4, ne	// ne = any
    fd800000e118:	fa401b84 	ccmp	x28, #0x0, #0x4, ne	// ne = any
    fd800000e11c:	540001a1 	b.ne	fd800000e150 <mem_map_reclr+0x130>  // b.any

    mem_unmap(&cpu()->as, reclrd_va_base, reclrd_num, false);
    mem_unmap(&cpu()->as, phys_va_base, num_pages, false);

    return true;
}
    fd800000e120:	a9446bf9 	ldp	x25, x26, [sp, #64]
        return mem_map(as, va, ppages, num_pages, flags);
    fd800000e124:	aa1403e4 	mov	x4, x20
    fd800000e128:	aa1303e3 	mov	x3, x19
    fd800000e12c:	aa1503e2 	mov	x2, x21
}
    fd800000e130:	a94153f3 	ldp	x19, x20, [sp, #16]
        return mem_map(as, va, ppages, num_pages, flags);
    fd800000e134:	aa1803e1 	mov	x1, x24
}
    fd800000e138:	a9425bf5 	ldp	x21, x22, [sp, #32]
        return mem_map(as, va, ppages, num_pages, flags);
    fd800000e13c:	aa1b03e0 	mov	x0, x27
}
    fd800000e140:	a94363f7 	ldp	x23, x24, [sp, #48]
    fd800000e144:	a94573fb 	ldp	x27, x28, [sp, #80]
    fd800000e148:	a8cd7bfd 	ldp	x29, x30, [sp], #208
        return mem_map(as, va, ppages, num_pages, flags);
    fd800000e14c:	17fffde1 	b	fd800000d8d0 <mem_map>
    vaddr_t reclrd_va_base = mem_alloc_vpage(&cpu()->as, SEC_HYP_VM, INVALID_VA, reclrd_num);
    fd800000e150:	d2800200 	mov	x0, #0x10                  	// #16
    fd800000e154:	aa1c03e3 	mov	x3, x28
    fd800000e158:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
    fd800000e15c:	52800061 	mov	w1, #0x3                   	// #3
    fd800000e160:	f2dfc000 	movk	x0, #0xfe00, lsl #32
    fd800000e164:	97fffbaf 	bl	fd800000d020 <mem_alloc_vpage>
    fd800000e168:	aa0003f9 	mov	x25, x0
    struct ppages reclrd_ppages = mem_alloc_ppages(as->colors, reclrd_num, false);
    fd800000e16c:	910283e8 	add	x8, sp, #0xa0
    fd800000e170:	f9401760 	ldr	x0, [x27, #40]
    fd800000e174:	aa1c03e1 	mov	x1, x28
    fd800000e178:	52800002 	mov	w2, #0x0                   	// #0
    vaddr_t reclrd_va_base = mem_alloc_vpage(&cpu()->as, SEC_HYP_VM, INVALID_VA, reclrd_num);
    fd800000e17c:	f9004bf9 	str	x25, [sp, #144]
    vaddr_t vaddr = va & ~(PAGE_SIZE - 1);
    fd800000e180:	9274cf18 	and	x24, x24, #0xfffffffffffff000
    struct ppages reclrd_ppages = mem_alloc_ppages(as->colors, reclrd_num, false);
    fd800000e184:	97ffef83 	bl	fd8000009f90 <mem_alloc_ppages>
    mem_map(&cpu()->as, reclrd_va_base, &reclrd_ppages, reclrd_num, PTE_HYP_FLAGS);
    fd800000e188:	d2800200 	mov	x0, #0x10                  	// #16
    fd800000e18c:	aa1903e1 	mov	x1, x25
    fd800000e190:	d280e884 	mov	x4, #0x744                 	// #1860
    fd800000e194:	910283e2 	add	x2, sp, #0xa0
    fd800000e198:	aa1c03e3 	mov	x3, x28
    fd800000e19c:	f2dfc000 	movk	x0, #0xfe00, lsl #32
    fd800000e1a0:	97fffdcc 	bl	fd800000d8d0 <mem_map>
    vaddr_t phys_va_base = mem_alloc_vpage(&cpu()->as, SEC_HYP_VM, INVALID_VA, num_pages);
    fd800000e1a4:	d2800200 	mov	x0, #0x10                  	// #16
    fd800000e1a8:	aa1303e3 	mov	x3, x19
    fd800000e1ac:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
    fd800000e1b0:	52800061 	mov	w1, #0x3                   	// #3
    fd800000e1b4:	f2dfc000 	movk	x0, #0xfe00, lsl #32
    fd800000e1b8:	97fffb9a 	bl	fd800000d020 <mem_alloc_vpage>
    mem_map(&cpu()->as, phys_va_base, ppages, num_pages, PTE_HYP_FLAGS);
    fd800000e1bc:	aa1303e3 	mov	x3, x19
    vaddr_t phys_va_base = mem_alloc_vpage(&cpu()->as, SEC_HYP_VM, INVALID_VA, num_pages);
    fd800000e1c0:	aa0003e1 	mov	x1, x0
    mem_map(&cpu()->as, phys_va_base, ppages, num_pages, PTE_HYP_FLAGS);
    fd800000e1c4:	d280e884 	mov	x4, #0x744                 	// #1860
    fd800000e1c8:	d2800200 	mov	x0, #0x10                  	// #16
    fd800000e1cc:	aa1503e2 	mov	x2, x21
    fd800000e1d0:	f2dfc000 	movk	x0, #0xfe00, lsl #32
    vaddr_t phys_va_base = mem_alloc_vpage(&cpu()->as, SEC_HYP_VM, INVALID_VA, num_pages);
    fd800000e1d4:	f9004fe1 	str	x1, [sp, #152]
    mem_map(&cpu()->as, phys_va_base, ppages, num_pages, PTE_HYP_FLAGS);
    fd800000e1d8:	97fffdbe 	bl	fd800000d8d0 <mem_map>
    paddr_t paddr = ppages->base;
    fd800000e1dc:	f94002b9 	ldr	x25, [x21]
    mem_inflate_pt(as, vaddr, num_pages * PAGE_SIZE);
    fd800000e1e0:	aa1803e1 	mov	x1, x24
    fd800000e1e4:	d374ce62 	lsl	x2, x19, #12
    fd800000e1e8:	aa1b03e0 	mov	x0, x27
    fd800000e1ec:	97fffaa9 	bl	fd800000cc90 <mem_inflate_pt>
    for (size_t i = 0; i < num_pages; i++) {
    fd800000e1f0:	b4000a73 	cbz	x19, fd800000e33c <mem_map_reclr+0x31c>
    fd800000e1f4:	cb180320 	sub	x0, x25, x24
    fd800000e1f8:	f9003fe0 	str	x0, [sp, #120]
            memcpy((void*)clrd_vaddr, (void*)phys_va, PAGE_SIZE);
    fd800000e1fc:	f9404fe0 	ldr	x0, [sp, #152]
    fd800000e200:	92506e94 	and	x20, x20, #0xffff000000000fff
    size_t index = 0;
    fd800000e204:	d2800019 	mov	x25, #0x0                   	// #0
            memcpy((void*)clrd_vaddr, (void*)phys_va, PAGE_SIZE);
    fd800000e208:	cb180000 	sub	x0, x0, x24
    fd800000e20c:	f90047e0 	str	x0, [sp, #136]
    fd800000e210:	8b1a0260 	add	x0, x19, x26
    fd800000e214:	f9003be0 	str	x0, [sp, #112]
    vaddr_t clrd_vaddr = reclrd_va_base;
    fd800000e218:	f9404be0 	ldr	x0, [sp, #144]
    fd800000e21c:	f90037e0 	str	x0, [sp, #104]
    fd800000e220:	1400000c 	b	fd800000e250 <mem_map_reclr+0x230>
    fd800000e224:	f9403fe0 	ldr	x0, [sp, #120]
    for (size_t i = 0; i < num_pages; i++) {
    fd800000e228:	9100075a 	add	x26, x26, #0x1
    fd800000e22c:	8b000301 	add	x1, x24, x0
        vaddr += PAGE_SIZE;
    fd800000e230:	91400718 	add	x24, x24, #0x1, lsl #12
    fd800000e234:	92748c21 	and	x1, x1, #0xfffffffff000
    for (size_t i = 0; i < num_pages; i++) {
    fd800000e238:	f9403be0 	ldr	x0, [sp, #112]
    fd800000e23c:	aa140021 	orr	x1, x1, x20
    fd800000e240:	b2400421 	orr	x1, x1, #0x3
    fd800000e244:	f9000101 	str	x1, [x8]
    fd800000e248:	eb1a001f 	cmp	x0, x26
    fd800000e24c:	54000780 	b.eq	fd800000e33c <mem_map_reclr+0x31c>  // b.none
        pte = pt_get_pte(&as->pt, as->pt.dscr->lvls - 1, vaddr);
    fd800000e250:	f9400761 	ldr	x1, [x27, #8]
    fd800000e254:	aa1803e2 	mov	x2, x24
    fd800000e258:	aa1b03e0 	mov	x0, x27
    fd800000e25c:	f9400021 	ldr	x1, [x1]
    fd800000e260:	d1000421 	sub	x1, x1, #0x1
    fd800000e264:	97ffcddf 	bl	fd80000019e0 <pt_get_pte>
        if (bit_get(as->colors, ((i + clr_offset) / COLOR_SIZE % COLOR_NUM))) {
    fd800000e268:	f94002e1 	ldr	x1, [x23]
        pte = pt_get_pte(&as->pt, as->pt.dscr->lvls - 1, vaddr);
    fd800000e26c:	aa0003e8 	mov	x8, x0
        if (bit_get(as->colors, ((i + clr_offset) / COLOR_SIZE % COLOR_NUM))) {
    fd800000e270:	f94002c2 	ldr	x2, [x22]
    fd800000e274:	9ac10b41 	udiv	x1, x26, x1
    fd800000e278:	f9401769 	ldr	x9, [x27, #40]
    fd800000e27c:	9ac20820 	udiv	x0, x1, x2
    fd800000e280:	9b028400 	msub	x0, x0, x2, x1
    fd800000e284:	d2800021 	mov	x1, #0x1                   	// #1
    fd800000e288:	9ac02020 	lsl	x0, x1, x0
    fd800000e28c:	ea09001f 	tst	x0, x9
    fd800000e290:	54fffca1 	b.ne	fd800000e224 <mem_map_reclr+0x204>  // b.any
            memcpy((void*)clrd_vaddr, (void*)phys_va, PAGE_SIZE);
    fd800000e294:	f94047e0 	ldr	x0, [sp, #136]
    fd800000e298:	d2820002 	mov	x2, #0x1000                	// #4096
    fd800000e29c:	f90043e8 	str	x8, [sp, #128]
    fd800000e2a0:	8b180001 	add	x1, x0, x24
    fd800000e2a4:	f94037e0 	ldr	x0, [sp, #104]
    fd800000e2a8:	97ffe9fa 	bl	fd8000008a90 <memcpy>
    size_t clr_offset = (base / PAGE_SIZE) % (COLOR_NUM * COLOR_SIZE);
    fd800000e2ac:	f94002c9 	ldr	x9, [x22]
    fd800000e2b0:	f94002eb 	ldr	x11, [x23]
            index = pp_next_clr(reclrd_ppages.base, index, as->colors);
    fd800000e2b4:	f94053e0 	ldr	x0, [sp, #160]
    size_t clr_offset = (base / PAGE_SIZE) % (COLOR_NUM * COLOR_SIZE);
    fd800000e2b8:	9b0b7d21 	mul	x1, x9, x11
            index = pp_next_clr(reclrd_ppages.base, index, as->colors);
    fd800000e2bc:	f940176c 	ldr	x12, [x27, #40]
    size_t clr_offset = (base / PAGE_SIZE) % (COLOR_NUM * COLOR_SIZE);
    fd800000e2c0:	d34cfc02 	lsr	x2, x0, #12
    while (!((colors >> ((index + clr_offset) / COLOR_SIZE % COLOR_NUM)) & 1)) {
    fd800000e2c4:	f94043e8 	ldr	x8, [sp, #128]
    size_t clr_offset = (base / PAGE_SIZE) % (COLOR_NUM * COLOR_SIZE);
    fd800000e2c8:	9ac1084a 	udiv	x10, x2, x1
    fd800000e2cc:	9b01894a 	msub	x10, x10, x1, x2
    while (!((colors >> ((index + clr_offset) / COLOR_SIZE % COLOR_NUM)) & 1)) {
    fd800000e2d0:	8b190142 	add	x2, x10, x25
    fd800000e2d4:	9acb0842 	udiv	x2, x2, x11
    fd800000e2d8:	9ac90841 	udiv	x1, x2, x9
    fd800000e2dc:	9b098821 	msub	x1, x1, x9, x2
    fd800000e2e0:	9ac12581 	lsr	x1, x12, x1
    fd800000e2e4:	37000101 	tbnz	w1, #0, fd800000e304 <mem_map_reclr+0x2e4>
        index++;
    fd800000e2e8:	91000739 	add	x25, x25, #0x1
    while (!((colors >> ((index + clr_offset) / COLOR_SIZE % COLOR_NUM)) & 1)) {
    fd800000e2ec:	8b190142 	add	x2, x10, x25
    fd800000e2f0:	9acb0842 	udiv	x2, x2, x11
    fd800000e2f4:	9ac90841 	udiv	x1, x2, x9
    fd800000e2f8:	9b098821 	msub	x1, x1, x9, x2
    fd800000e2fc:	9ac12581 	lsr	x1, x12, x1
    fd800000e300:	3607ff41 	tbz	w1, #0, fd800000e2e8 <mem_map_reclr+0x2c8>
            paddr_t clrd_paddr = reclrd_ppages.base + (index * PAGE_SIZE);
    fd800000e304:	8b193001 	add	x1, x0, x25, lsl #12
    for (size_t i = 0; i < num_pages; i++) {
    fd800000e308:	9100075a 	add	x26, x26, #0x1
            clrd_vaddr += PAGE_SIZE;
    fd800000e30c:	f94037e0 	ldr	x0, [sp, #104]
    fd800000e310:	92748c21 	and	x1, x1, #0xfffffffff000
    fd800000e314:	aa140021 	orr	x1, x1, x20
            index++;
    fd800000e318:	91000739 	add	x25, x25, #0x1
            clrd_vaddr += PAGE_SIZE;
    fd800000e31c:	91400400 	add	x0, x0, #0x1, lsl #12
    fd800000e320:	f90037e0 	str	x0, [sp, #104]
    for (size_t i = 0; i < num_pages; i++) {
    fd800000e324:	f9403be0 	ldr	x0, [sp, #112]
    fd800000e328:	b2400421 	orr	x1, x1, #0x3
    fd800000e32c:	f9000101 	str	x1, [x8]
        vaddr += PAGE_SIZE;
    fd800000e330:	91400718 	add	x24, x24, #0x1, lsl #12
    for (size_t i = 0; i < num_pages; i++) {
    fd800000e334:	eb1a001f 	cmp	x0, x26
    fd800000e338:	54fff8c1 	b.ne	fd800000e250 <mem_map_reclr+0x230>  // b.any
    cache_flush_range(reclrd_va_base, reclrd_num * PAGE_SIZE);
    fd800000e33c:	f9404bf4 	ldr	x20, [sp, #144]
    fd800000e340:	d374cf81 	lsl	x1, x28, #12
    fd800000e344:	aa1403e0 	mov	x0, x20
    fd800000e348:	97ffd38e 	bl	fd8000003180 <cache_flush_range>
        .colors = ~as->colors };
    fd800000e34c:	f9401761 	ldr	x1, [x27, #40]
    mem_free_ppages(&unused_pages);
    fd800000e350:	9102e3e0 	add	x0, sp, #0xb8
    struct ppages unused_pages = { .base = ppages->base,
    fd800000e354:	f94002a2 	ldr	x2, [x21]
        .colors = ~as->colors };
    fd800000e358:	aa2103e1 	mvn	x1, x1
    struct ppages unused_pages = { .base = ppages->base,
    fd800000e35c:	a90bf3e2 	stp	x2, x28, [sp, #184]
    fd800000e360:	f90067e1 	str	x1, [sp, #200]
    mem_free_ppages(&unused_pages);
    fd800000e364:	97fff947 	bl	fd800000c880 <mem_free_ppages>
    mem_unmap(&cpu()->as, reclrd_va_base, reclrd_num, false);
    fd800000e368:	d2800200 	mov	x0, #0x10                  	// #16
    fd800000e36c:	aa1c03e2 	mov	x2, x28
    fd800000e370:	aa1403e1 	mov	x1, x20
    fd800000e374:	f2dfc000 	movk	x0, #0xfe00, lsl #32
    fd800000e378:	52800003 	mov	w3, #0x0                   	// #0
    fd800000e37c:	97fffc71 	bl	fd800000d540 <mem_unmap>
    mem_unmap(&cpu()->as, phys_va_base, num_pages, false);
    fd800000e380:	f9404fe1 	ldr	x1, [sp, #152]
    fd800000e384:	d2800200 	mov	x0, #0x10                  	// #16
    fd800000e388:	aa1303e2 	mov	x2, x19
    fd800000e38c:	f2dfc000 	movk	x0, #0xfe00, lsl #32
    fd800000e390:	52800003 	mov	w3, #0x0                   	// #0
    fd800000e394:	97fffc6b 	bl	fd800000d540 <mem_unmap>
}
    fd800000e398:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd800000e39c:	52800020 	mov	w0, #0x1                   	// #1
    fd800000e3a0:	a9425bf5 	ldp	x21, x22, [sp, #32]
    fd800000e3a4:	a94363f7 	ldp	x23, x24, [sp, #48]
    fd800000e3a8:	a9446bf9 	ldp	x25, x26, [sp, #64]
    fd800000e3ac:	a94573fb 	ldp	x27, x28, [sp, #80]
    fd800000e3b0:	a8cd7bfd 	ldp	x29, x30, [sp], #208
    fd800000e3b4:	d65f03c0 	ret
        ERROR("no indication on what to recolor");
    fd800000e3b8:	90000000 	adrp	x0, fd800000e000 <mem_map+0x730>
    fd800000e3bc:	f941e400 	ldr	x0, [x0, #968]
    fd800000e3c0:	97fff718 	bl	fd800000c020 <console_printk>
    fd800000e3c4:	14000000 	b	fd800000e3c4 <mem_map_reclr+0x3a4>
    fd800000e3c8:	00011040 	.word	0x00011040
    fd800000e3cc:	0000fd80 	.word	0x0000fd80
    fd800000e3d0:	00012828 	.word	0x00012828
    fd800000e3d4:	0000fd80 	.word	0x0000fd80
    fd800000e3d8:	00012820 	.word	0x00012820
    fd800000e3dc:	0000fd80 	.word	0x0000fd80

0000fd800000e3e0 <mem_map_cpy>:

vaddr_t mem_map_cpy(struct addr_space* ass, struct addr_space* asd, vaddr_t vas, vaddr_t vad,
    size_t num_pages)
{
    fd800000e3e0:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
    fd800000e3e4:	910003fd 	mov	x29, sp
    fd800000e3e8:	a90153f3 	stp	x19, x20, [sp, #16]
    fd800000e3ec:	aa0003f4 	mov	x20, x0
    vaddr_t _vad = mem_alloc_vpage(asd, SEC_HYP_GLOBAL, vad, num_pages);
    fd800000e3f0:	aa0103e0 	mov	x0, x1
{
    fd800000e3f4:	a9025bf5 	stp	x21, x22, [sp, #32]
    fd800000e3f8:	aa0203f5 	mov	x21, x2
    vaddr_t _vad = mem_alloc_vpage(asd, SEC_HYP_GLOBAL, vad, num_pages);
    fd800000e3fc:	aa0303e2 	mov	x2, x3
    fd800000e400:	aa0403e3 	mov	x3, x4
{
    fd800000e404:	a9046bf9 	stp	x25, x26, [sp, #64]
    fd800000e408:	aa0103fa 	mov	x26, x1
    fd800000e40c:	aa0403f9 	mov	x25, x4
    vaddr_t _vad = mem_alloc_vpage(asd, SEC_HYP_GLOBAL, vad, num_pages);
    fd800000e410:	52800001 	mov	w1, #0x0                   	// #0
    fd800000e414:	97fffb03 	bl	fd800000d020 <mem_alloc_vpage>
    fd800000e418:	f90037e0 	str	x0, [sp, #104]
    size_t base_vad = _vad;
    size_t count = 0;
    size_t to_map = num_pages * PAGE_SIZE;

    while (count < num_pages) {
    fd800000e41c:	b40006f9 	cbz	x25, fd800000e4f8 <mem_map_cpy+0x118>
    fd800000e420:	d374cf36 	lsl	x22, x25, #12
    fd800000e424:	a90363f7 	stp	x23, x24, [sp, #48]
    vaddr_t _vad = mem_alloc_vpage(asd, SEC_HYP_GLOBAL, vad, num_pages);
    fd800000e428:	aa0003f8 	mov	x24, x0
    size_t count = 0;
    fd800000e42c:	d2800017 	mov	x23, #0x0                   	// #0
    fd800000e430:	a90573fb 	stp	x27, x28, [sp, #80]
    fd800000e434:	d280003b 	mov	x27, #0x1                   	// #1
        size_t lvl = 0;
        pte_t* pte = pt_get_pte(&ass->pt, lvl, vas);
    fd800000e438:	aa1503e2 	mov	x2, x21
    fd800000e43c:	aa1403e0 	mov	x0, x20
    fd800000e440:	d2800001 	mov	x1, #0x0                   	// #0
        size_t lvl = 0;
    fd800000e444:	d2800013 	mov	x19, #0x0                   	// #0
        pte_t* pte = pt_get_pte(&ass->pt, lvl, vas);
    fd800000e448:	97ffcd66 	bl	fd80000019e0 <pt_get_pte>
    fd800000e44c:	aa0003fc 	mov	x28, x0
        while (!pte_page(&ass->pt, pte, lvl)) {
    fd800000e450:	14000005 	b	fd800000e464 <mem_map_cpy+0x84>
            lvl += 1;
    fd800000e454:	91000673 	add	x19, x19, #0x1
            pte = pt_get_pte(&ass->pt, lvl, vas);
    fd800000e458:	aa1303e1 	mov	x1, x19
    fd800000e45c:	97ffcd61 	bl	fd80000019e0 <pt_get_pte>
    fd800000e460:	aa0003fc 	mov	x28, x0
        while (!pte_page(&ass->pt, pte, lvl)) {
    fd800000e464:	aa1303e2 	mov	x2, x19
    fd800000e468:	aa1c03e1 	mov	x1, x28
    fd800000e46c:	aa1403e0 	mov	x0, x20
    fd800000e470:	97ffcd94 	bl	fd8000001ac0 <pte_page>
            pte = pt_get_pte(&ass->pt, lvl, vas);
    fd800000e474:	aa1503e2 	mov	x2, x21
        while (!pte_page(&ass->pt, pte, lvl)) {
    fd800000e478:	2a0003e3 	mov	w3, w0
            pte = pt_get_pte(&ass->pt, lvl, vas);
    fd800000e47c:	aa1403e0 	mov	x0, x20
        while (!pte_page(&ass->pt, pte, lvl)) {
    fd800000e480:	3607fea3 	tbz	w3, #0, fd800000e454 <mem_map_cpy+0x74>
    fd800000e484:	f9400680 	ldr	x0, [x20, #8]
            size = to_map;
        }
        size_t npages = NUM_PAGES(size);
        paddr_t pa = pte_addr(pte) + (vas - ALIGN_FLOOR(vas, lvl_size));
        struct ppages pages = mem_ppages_get(pa, npages);
        mem_map(asd, _vad, &pages, npages, PTE_HYP_FLAGS);
    fd800000e488:	aa1803e1 	mov	x1, x24
    return (paddr_t)(*pte & PTE_ADDR_MSK);
    fd800000e48c:	f9400387 	ldr	x7, [x28]
    fd800000e490:	9101e3e2 	add	x2, sp, #0x78
    fd800000e494:	f9400403 	ldr	x3, [x0, #8]
    fd800000e498:	92748ce7 	and	x7, x7, #0xfffffffff000
    fd800000e49c:	aa1a03e0 	mov	x0, x26
    fd800000e4a0:	d280e884 	mov	x4, #0x744                 	// #1860
    return (struct ppages){ .colors = 0, .base = base, .num_pages = num_pages };
    fd800000e4a4:	f90047ff 	str	xzr, [sp, #136]
    fd800000e4a8:	f8737863 	ldr	x3, [x3, x19, lsl #3]
    fd800000e4ac:	9ac32363 	lsl	x3, x27, x3
        if (to_map < lvl_size) {
    fd800000e4b0:	eb16007f 	cmp	x3, x22
        paddr_t pa = pte_addr(pte) + (vas - ALIGN_FLOOR(vas, lvl_size));
    fd800000e4b4:	d1000465 	sub	x5, x3, #0x1
        if (to_map < lvl_size) {
    fd800000e4b8:	9a96907c 	csel	x28, x3, x22, ls	// ls = plast
        paddr_t pa = pte_addr(pte) + (vas - ALIGN_FLOOR(vas, lvl_size));
    fd800000e4bc:	8a1500a5 	and	x5, x5, x21
        size_t npages = NUM_PAGES(size);
    fd800000e4c0:	913fff93 	add	x19, x28, #0xfff
        paddr_t pa = pte_addr(pte) + (vas - ALIGN_FLOOR(vas, lvl_size));
    fd800000e4c4:	8b0700a5 	add	x5, x5, x7
        _vad += size;
    fd800000e4c8:	8b1c0318 	add	x24, x24, x28
        size_t npages = NUM_PAGES(size);
    fd800000e4cc:	d34cfe73 	lsr	x19, x19, #12
    fd800000e4d0:	a907cfe5 	stp	x5, x19, [sp, #120]
        mem_map(asd, _vad, &pages, npages, PTE_HYP_FLAGS);
    fd800000e4d4:	aa1303e3 	mov	x3, x19
        vas += size;
        count += npages;
    fd800000e4d8:	8b1302f7 	add	x23, x23, x19
        mem_map(asd, _vad, &pages, npages, PTE_HYP_FLAGS);
    fd800000e4dc:	97fffcfd 	bl	fd800000d8d0 <mem_map>
        vas += size;
    fd800000e4e0:	8b1c02b5 	add	x21, x21, x28
        to_map -= size;
    fd800000e4e4:	cb1c02d6 	sub	x22, x22, x28
    while (count < num_pages) {
    fd800000e4e8:	eb17033f 	cmp	x25, x23
    fd800000e4ec:	54fffa68 	b.hi	fd800000e438 <mem_map_cpy+0x58>  // b.pmore
    fd800000e4f0:	a94363f7 	ldp	x23, x24, [sp, #48]
    fd800000e4f4:	a94573fb 	ldp	x27, x28, [sp, #80]
    }

    return base_vad;
}
    fd800000e4f8:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd800000e4fc:	a9425bf5 	ldp	x21, x22, [sp, #32]
    fd800000e500:	a9446bf9 	ldp	x25, x26, [sp, #64]
    fd800000e504:	f94037e0 	ldr	x0, [sp, #104]
    fd800000e508:	a8c97bfd 	ldp	x29, x30, [sp], #144
    fd800000e50c:	d65f03c0 	ret

0000fd800000e510 <copy_space>:

void* copy_space(void* base, const size_t size, struct ppages* pages)
{
    fd800000e510:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    fd800000e514:	910003fd 	mov	x29, sp
    fd800000e518:	a9025bf5 	stp	x21, x22, [sp, #32]
    *pages = mem_alloc_ppages(cpu()->as.colors, NUM_PAGES(size), false);
    fd800000e51c:	d2dfc015 	mov	x21, #0xfe0000000000        	// #279275953455104
    fd800000e520:	913ffc36 	add	x22, x1, #0xfff
{
    fd800000e524:	a90363f7 	stp	x23, x24, [sp, #48]
    fd800000e528:	aa0003f8 	mov	x24, x0
    *pages = mem_alloc_ppages(cpu()->as.colors, NUM_PAGES(size), false);
    fd800000e52c:	d34cfed6 	lsr	x22, x22, #12
    fd800000e530:	f9401ea0 	ldr	x0, [x21, #56]
{
    fd800000e534:	a90153f3 	stp	x19, x20, [sp, #16]
    fd800000e538:	aa0203f3 	mov	x19, x2
    *pages = mem_alloc_ppages(cpu()->as.colors, NUM_PAGES(size), false);
    fd800000e53c:	910103e8 	add	x8, sp, #0x40
{
    fd800000e540:	aa0103f7 	mov	x23, x1
    *pages = mem_alloc_ppages(cpu()->as.colors, NUM_PAGES(size), false);
    fd800000e544:	52800002 	mov	w2, #0x0                   	// #0
    fd800000e548:	aa1603e1 	mov	x1, x22
    fd800000e54c:	97ffee91 	bl	fd8000009f90 <mem_alloc_ppages>
    vaddr_t va = mem_alloc_vpage(&cpu()->as, SEC_HYP_PRIVATE, INVALID_VA, NUM_PAGES(size));
    fd800000e550:	910042b5 	add	x21, x21, #0x10
    *pages = mem_alloc_ppages(cpu()->as.colors, NUM_PAGES(size), false);
    fd800000e554:	f94023e0 	ldr	x0, [sp, #64]
    fd800000e558:	f9000260 	str	x0, [x19]
    vaddr_t va = mem_alloc_vpage(&cpu()->as, SEC_HYP_PRIVATE, INVALID_VA, NUM_PAGES(size));
    fd800000e55c:	aa1603e3 	mov	x3, x22
    fd800000e560:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
    *pages = mem_alloc_ppages(cpu()->as.colors, NUM_PAGES(size), false);
    fd800000e564:	f94027e0 	ldr	x0, [sp, #72]
    fd800000e568:	f9000660 	str	x0, [x19, #8]
    vaddr_t va = mem_alloc_vpage(&cpu()->as, SEC_HYP_PRIVATE, INVALID_VA, NUM_PAGES(size));
    fd800000e56c:	52800041 	mov	w1, #0x2                   	// #2
    *pages = mem_alloc_ppages(cpu()->as.colors, NUM_PAGES(size), false);
    fd800000e570:	f9402be0 	ldr	x0, [sp, #80]
    fd800000e574:	f9000a60 	str	x0, [x19, #16]
    vaddr_t va = mem_alloc_vpage(&cpu()->as, SEC_HYP_PRIVATE, INVALID_VA, NUM_PAGES(size));
    fd800000e578:	aa1503e0 	mov	x0, x21
    fd800000e57c:	97fffaa9 	bl	fd800000d020 <mem_alloc_vpage>
    fd800000e580:	aa0003f4 	mov	x20, x0
    mem_map(&cpu()->as, va, pages, NUM_PAGES(size), PTE_HYP_FLAGS);
    fd800000e584:	aa1603e3 	mov	x3, x22
    fd800000e588:	d280e884 	mov	x4, #0x744                 	// #1860
    fd800000e58c:	aa1303e2 	mov	x2, x19
    fd800000e590:	aa1403e1 	mov	x1, x20
    fd800000e594:	aa1503e0 	mov	x0, x21
    fd800000e598:	97fffcce 	bl	fd800000d8d0 <mem_map>
    memcpy((void*)va, base, size);
    fd800000e59c:	aa1703e2 	mov	x2, x23
    fd800000e5a0:	aa1803e1 	mov	x1, x24
    fd800000e5a4:	aa1403e0 	mov	x0, x20
    fd800000e5a8:	97ffe93a 	bl	fd8000008a90 <memcpy>

    return (void*)va;
}
    fd800000e5ac:	a9425bf5 	ldp	x21, x22, [sp, #32]
    fd800000e5b0:	aa1403e0 	mov	x0, x20
    fd800000e5b4:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd800000e5b8:	a94363f7 	ldp	x23, x24, [sp, #48]
    fd800000e5bc:	a8c67bfd 	ldp	x29, x30, [sp], #96
    fd800000e5c0:	d65f03c0 	ret
    fd800000e5c4:	d503201f 	nop
    fd800000e5c8:	d503201f 	nop
    fd800000e5cc:	d503201f 	nop

0000fd800000e5d0 <as_init>:
    memset((void*)va, 0, p_cpu.num_pages * PAGE_SIZE);
    mem_unmap(&cpu()->as, va, p_cpu.num_pages, false);
}

void as_init(struct addr_space* as, enum AS_TYPE type, asid_t id, pte_t* root_pt, colormap_t colors)
{
    fd800000e5d0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    as->type = type;
    as->pt.dscr = type == AS_HYP || type == AS_HYP_CPY ? hyp_pt_dscr : vm_pt_dscr;
    fd800000e5d4:	721e7825 	ands	w5, w1, #0xfffffffd
{
    fd800000e5d8:	910003fd 	mov	x29, sp
    fd800000e5dc:	a90153f3 	stp	x19, x20, [sp, #16]
    fd800000e5e0:	aa0003f3 	mov	x19, x0
    fd800000e5e4:	aa0303f4 	mov	x20, x3
    as->type = type;
    fd800000e5e8:	b9002001 	str	w1, [x0, #32]
    as->pt.dscr = type == AS_HYP || type == AS_HYP_CPY ? hyp_pt_dscr : vm_pt_dscr;
    fd800000e5ec:	540001a1 	b.ne	fd800000e620 <as_init+0x50>  // b.any
    fd800000e5f0:	90000000 	adrp	x0, fd800000e000 <mem_map+0x730>
    fd800000e5f4:	f9435000 	ldr	x0, [x0, #1696]
    fd800000e5f8:	f9400001 	ldr	x1, [x0]
    fd800000e5fc:	f9000661 	str	x1, [x19, #8]
    as->colors = colors;
    as->lock = SPINLOCK_INITVAL;
    as->id = id;
    fd800000e600:	a9028a64 	stp	x4, x2, [x19, #40]
    as->lock = SPINLOCK_INITVAL;
    fd800000e604:	f9001e7f 	str	xzr, [x19, #56]

    if (root_pt == NULL) {
    fd800000e608:	b40001b4 	cbz	x20, fd800000e63c <as_init+0x6c>
        size_t n = NUM_PAGES(pt_size(&as->pt, 0));
        root_pt = (pte_t*)mem_alloc_page(n,
            type == AS_HYP || type == AS_HYP_CPY ? SEC_HYP_PRIVATE : SEC_HYP_VM, true);
        memset((void*)root_pt, 0, n * PAGE_SIZE);
    }
    as->pt.root = root_pt;
    fd800000e60c:	f9000274 	str	x20, [x19]

    as_arch_init(as);
    fd800000e610:	aa1303e0 	mov	x0, x19
}
    fd800000e614:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd800000e618:	a8c27bfd 	ldp	x29, x30, [sp], #32
    as_arch_init(as);
    fd800000e61c:	17ffcd45 	b	fd8000001b30 <as_arch_init>
    as->pt.dscr = type == AS_HYP || type == AS_HYP_CPY ? hyp_pt_dscr : vm_pt_dscr;
    fd800000e620:	90000000 	adrp	x0, fd800000e000 <mem_map+0x730>
    fd800000e624:	f9435400 	ldr	x0, [x0, #1704]
    fd800000e628:	f9400001 	ldr	x1, [x0]
    fd800000e62c:	f9000661 	str	x1, [x19, #8]
    as->id = id;
    fd800000e630:	a9028a64 	stp	x4, x2, [x19, #40]
    as->lock = SPINLOCK_INITVAL;
    fd800000e634:	f9001e7f 	str	xzr, [x19, #56]
    if (root_pt == NULL) {
    fd800000e638:	b5fffeb4 	cbnz	x20, fd800000e60c <as_init+0x3c>
    return (1ULL << pt->dscr->lvl_wdt[lvl]) >> pt->dscr->lvl_off[lvl];
    fd800000e63c:	a9408c22 	ldp	x2, x3, [x1, #8]
    fd800000e640:	d2800020 	mov	x0, #0x1                   	// #1
    as->pt.dscr = type == AS_HYP || type == AS_HYP_CPY ? hyp_pt_dscr : vm_pt_dscr;
    fd800000e644:	710000bf 	cmp	w5, #0x0
    fd800000e648:	1a9f17e1 	cset	w1, eq	// eq = none
    fd800000e64c:	f9400064 	ldr	x4, [x3]
    fd800000e650:	f9400043 	ldr	x3, [x2]
        root_pt = (pte_t*)mem_alloc_page(n,
    fd800000e654:	2a0003e2 	mov	w2, w0
    fd800000e658:	9ac42000 	lsl	x0, x0, x4
    fd800000e65c:	52800064 	mov	w4, #0x3                   	// #3
    fd800000e660:	4b010081 	sub	w1, w4, w1
    fd800000e664:	9ac32400 	lsr	x0, x0, x3
    return pt_nentries(pt, lvl) * sizeof(pte_t);
    fd800000e668:	d37df014 	lsl	x20, x0, #3
        size_t n = NUM_PAGES(pt_size(&as->pt, 0));
    fd800000e66c:	913ffe94 	add	x20, x20, #0xfff
    fd800000e670:	d34cfe94 	lsr	x20, x20, #12
        root_pt = (pte_t*)mem_alloc_page(n,
    fd800000e674:	aa1403e0 	mov	x0, x20
    fd800000e678:	97ffee82 	bl	fd800000a080 <mem_alloc_page>
        memset((void*)root_pt, 0, n * PAGE_SIZE);
    fd800000e67c:	d374ce82 	lsl	x2, x20, #12
    fd800000e680:	52800001 	mov	w1, #0x0                   	// #0
        root_pt = (pte_t*)mem_alloc_page(n,
    fd800000e684:	aa0003f4 	mov	x20, x0
        memset((void*)root_pt, 0, n * PAGE_SIZE);
    fd800000e688:	97ffe92a 	bl	fd8000008b30 <memset>
    as->pt.root = root_pt;
    fd800000e68c:	f9000274 	str	x20, [x19]
    as_arch_init(as);
    fd800000e690:	aa1303e0 	mov	x0, x19
}
    fd800000e694:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd800000e698:	a8c27bfd 	ldp	x29, x30, [sp], #32
    as_arch_init(as);
    fd800000e69c:	17ffcd25 	b	fd8000001b30 <as_arch_init>
    fd800000e6a0:	00012018 	.word	0x00012018
    fd800000e6a4:	0000fd80 	.word	0x0000fd80
    fd800000e6a8:	00012010 	.word	0x00012010
    fd800000e6ac:	0000fd80 	.word	0x0000fd80

0000fd800000e6b0 <mem_color_hypervisor>:
{
    fd800000e6b0:	a9b07bfd 	stp	x29, x30, [sp, #-256]!
    fd800000e6b4:	910003fd 	mov	x29, sp
    fd800000e6b8:	a90153f3 	stp	x19, x20, [sp, #16]
    fd800000e6bc:	aa0103f3 	mov	x19, x1
        (root_pool->size / (8 * PAGE_SIZE) + !!(root_pool->size % (8 * PAGE_SIZE) != 0)) *
    fd800000e6c0:	91004273 	add	x19, x19, #0x10
{
    fd800000e6c4:	a9025bf5 	stp	x21, x22, [sp, #32]
    fd800000e6c8:	a90363f7 	stp	x23, x24, [sp, #48]
    fd800000e6cc:	aa0003f7 	mov	x23, x0
    fd800000e6d0:	a9046bf9 	stp	x25, x26, [sp, #64]
    cpu()->as.colors = config.hyp.colors;
    fd800000e6d4:	d2dfc01a 	mov	x26, #0xfe0000000000        	// #279275953455104
{
    fd800000e6d8:	a90573fb 	stp	x27, x28, [sp, #80]
    size_t cpu_boot_size = mem_cpu_boot_alloc_size();
    fd800000e6dc:	97fff999 	bl	fd800000cd40 <mem_cpu_boot_alloc_size>
    colormap_t colors = config.hyp.colors;
    fd800000e6e0:	90000001 	adrp	x1, fd800000e000 <mem_map+0x730>
    fd800000e6e4:	f946a021 	ldr	x1, [x1, #3392]
    cpu_new = copy_space((void*)BAO_CPU_BASE, sizeof(struct cpu), &p_cpu);
    fd800000e6e8:	910283e2 	add	x2, sp, #0xa0
        (root_pool->size / (8 * PAGE_SIZE) + !!(root_pool->size % (8 * PAGE_SIZE) != 0)) *
    fd800000e6ec:	f9400a79 	ldr	x25, [x19, #16]
    size_t cpu_boot_size = mem_cpu_boot_alloc_size();
    fd800000e6f0:	aa0003f6 	mov	x22, x0
    colormap_t colors = config.hyp.colors;
    fd800000e6f4:	f9400838 	ldr	x24, [x1, #16]
    cpu()->as.colors = config.hyp.colors;
    fd800000e6f8:	f9001f58 	str	x24, [x26, #56]
    cpu_new = copy_space((void*)BAO_CPU_BASE, sizeof(struct cpu), &p_cpu);
    fd800000e6fc:	d2840001 	mov	x1, #0x2000                	// #8192
    fd800000e700:	aa1a03e0 	mov	x0, x26
    fd800000e704:	97ffff83 	bl	fd800000e510 <copy_space>
    as_init(&cpu_new->as, AS_HYP_CPY, HYP_ASID, NULL, colors);
    fd800000e708:	91004014 	add	x20, x0, #0x10
    fd800000e70c:	aa1803e4 	mov	x4, x24
    fd800000e710:	d2800003 	mov	x3, #0x0                   	// #0
    fd800000e714:	d2800002 	mov	x2, #0x0                   	// #0
    fd800000e718:	52800041 	mov	w1, #0x2                   	// #2
    cpu_new = copy_space((void*)BAO_CPU_BASE, sizeof(struct cpu), &p_cpu);
    fd800000e71c:	aa0003f5 	mov	x21, x0
    as_init(&cpu_new->as, AS_HYP_CPY, HYP_ASID, NULL, colors);
    fd800000e720:	aa1403e0 	mov	x0, x20
    fd800000e724:	97ffffab 	bl	fd800000e5d0 <as_init>
    va = mem_alloc_vpage(&cpu_new->as, SEC_HYP_PRIVATE, (vaddr_t)BAO_CPU_BASE,
    fd800000e728:	d2800043 	mov	x3, #0x2                   	// #2
    fd800000e72c:	aa1a03e2 	mov	x2, x26
    fd800000e730:	aa1403e0 	mov	x0, x20
    fd800000e734:	2a0303e1 	mov	w1, w3
    fd800000e738:	97fffa3a 	bl	fd800000d020 <mem_alloc_vpage>
    if (va != (vaddr_t)BAO_CPU_BASE) {
    fd800000e73c:	eb1a001f 	cmp	x0, x26
    fd800000e740:	540000a0 	b.eq	fd800000e754 <mem_color_hypervisor+0xa4>  // b.none
        ERROR("Can't allocate virtual address for cpuspace");
    fd800000e744:	90000000 	adrp	x0, fd800000e000 <mem_map+0x730>
    fd800000e748:	f946a400 	ldr	x0, [x0, #3400]
    fd800000e74c:	97fff635 	bl	fd800000c020 <console_printk>
    fd800000e750:	14000000 	b	fd800000e750 <mem_color_hypervisor+0xa0>
    fd800000e754:	aa0003fb 	mov	x27, x0
    size_t image_load_size = (size_t)(&_image_load_end - &_image_start);
    fd800000e758:	90000001 	adrp	x1, fd800000e000 <mem_map+0x730>
    fd800000e75c:	f946ac22 	ldr	x2, [x1, #3416]
    fd800000e760:	90000000 	adrp	x0, fd800000e000 <mem_map+0x730>
    fd800000e764:	f946a800 	ldr	x0, [x0, #3408]
    size_t image_noload_size = (size_t)(&_image_end - &_image_load_end);
    fd800000e768:	90000001 	adrp	x1, fd800000e000 <mem_map+0x730>
    fd800000e76c:	f946b021 	ldr	x1, [x1, #3424]
    size_t image_load_size = (size_t)(&_image_load_end - &_image_start);
    fd800000e770:	cb020005 	sub	x5, x0, x2
    mem_map(&cpu_new->as, va, &p_cpu, NUM_PAGES(sizeof(struct cpu)), PTE_HYP_FLAGS);
    fd800000e774:	d280e884 	mov	x4, #0x744                 	// #1860
    fd800000e778:	d2800043 	mov	x3, #0x2                   	// #2
    size_t image_noload_size = (size_t)(&_image_end - &_image_load_end);
    fd800000e77c:	cb000020 	sub	x0, x1, x0
    mem_map(&cpu_new->as, va, &p_cpu, NUM_PAGES(sizeof(struct cpu)), PTE_HYP_FLAGS);
    fd800000e780:	aa1b03e1 	mov	x1, x27
    size_t image_size = image_load_size + image_noload_size;
    fd800000e784:	8b0000ba 	add	x26, x5, x0
    size_t image_load_size = (size_t)(&_image_load_end - &_image_start);
    fd800000e788:	f90033e2 	str	x2, [sp, #96]
    mem_map(&cpu_new->as, va, &p_cpu, NUM_PAGES(sizeof(struct cpu)), PTE_HYP_FLAGS);
    fd800000e78c:	910283e2 	add	x2, sp, #0xa0
    size_t image_noload_size = (size_t)(&_image_end - &_image_load_end);
    fd800000e790:	a90703e5 	stp	x5, x0, [sp, #112]
    mem_map(&cpu_new->as, va, &p_cpu, NUM_PAGES(sizeof(struct cpu)), PTE_HYP_FLAGS);
    fd800000e794:	aa1403e0 	mov	x0, x20
    fd800000e798:	97fffc4e 	bl	fd800000d8d0 <mem_map>
    return (1ULL << pt->dscr->lvl_wdt[lvl]) >> pt->dscr->lvl_off[lvl];
    fd800000e79c:	f9400683 	ldr	x3, [x20, #8]
    fd800000e7a0:	d2800025 	mov	x5, #0x1                   	// #1
    mem_translate(&cpu()->as, (vaddr_t)cpu_new->as.pt.root, &p_root_pt_addr);
    fd800000e7a4:	f9400aa1 	ldr	x1, [x21, #16]
    fd800000e7a8:	910263e2 	add	x2, sp, #0x98
    fd800000e7ac:	a9409864 	ldp	x4, x6, [x3, #8]
    fd800000e7b0:	91004360 	add	x0, x27, #0x10
    fd800000e7b4:	f94000c3 	ldr	x3, [x6]
    fd800000e7b8:	f9400084 	ldr	x4, [x4]
    fd800000e7bc:	9ac320a3 	lsl	x3, x5, x3
    fd800000e7c0:	9ac42463 	lsr	x3, x3, x4
    return pt_nentries(pt, lvl) * sizeof(pte_t);
    fd800000e7c4:	d37df063 	lsl	x3, x3, #3
    size_t root_pt_num_pages = NUM_PAGES(pt_size(&cpu_new->as.pt, 0));
    fd800000e7c8:	913ffc63 	add	x3, x3, #0xfff
    fd800000e7cc:	d34cfc7c 	lsr	x28, x3, #12
    mem_translate(&cpu()->as, (vaddr_t)cpu_new->as.pt.root, &p_root_pt_addr);
    fd800000e7d0:	97ffcce8 	bl	fd8000001b70 <mem_translate>
    v_root_pt_addr = mem_alloc_vpage(&cpu_new->as, SEC_HYP_PRIVATE, INVALID_VA, root_pt_num_pages);
    fd800000e7d4:	aa1c03e3 	mov	x3, x28
    fd800000e7d8:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
    fd800000e7dc:	52800041 	mov	w1, #0x2                   	// #2
    fd800000e7e0:	aa1403e0 	mov	x0, x20
    fd800000e7e4:	97fffa0f 	bl	fd800000d020 <mem_alloc_vpage>
    fd800000e7e8:	aa0003e4 	mov	x4, x0
    fd800000e7ec:	f9404fe1 	ldr	x1, [sp, #152]
    mem_map(&cpu_new->as, v_root_pt_addr, &p_root_pt_pages, root_pt_num_pages, PTE_HYP_FLAGS);
    fd800000e7f0:	aa1c03e3 	mov	x3, x28
    fd800000e7f4:	9103a3e2 	add	x2, sp, #0xe8
    fd800000e7f8:	aa1403e0 	mov	x0, x20
    v_root_pt_addr = mem_alloc_vpage(&cpu_new->as, SEC_HYP_PRIVATE, INVALID_VA, root_pt_num_pages);
    fd800000e7fc:	f90037e4 	str	x4, [sp, #104]
    fd800000e800:	a90ef3e1 	stp	x1, x28, [sp, #232]
    mem_map(&cpu_new->as, v_root_pt_addr, &p_root_pt_pages, root_pt_num_pages, PTE_HYP_FLAGS);
    fd800000e804:	aa0403e1 	mov	x1, x4
    fd800000e808:	d280e884 	mov	x4, #0x744                 	// #1860
    fd800000e80c:	f9007fff 	str	xzr, [sp, #248]
    fd800000e810:	97fffc30 	bl	fd800000d8d0 <mem_map>
    if (cpu()->id == CPU_MASTER) {
    fd800000e814:	90000000 	adrp	x0, fd800000e000 <mem_map+0x730>
    fd800000e818:	f946b41c 	ldr	x28, [x0, #3432]
    fd800000e81c:	f9400361 	ldr	x1, [x27]
    fd800000e820:	f9400380 	ldr	x0, [x28]
    fd800000e824:	eb00003f 	cmp	x1, x0
    fd800000e828:	540018a0 	b.eq	fd800000eb3c <mem_color_hypervisor+0x48c>  // b.none
        pte_t* image_pte = pt_get_pte(&cpu_new->as.pt, 0, (vaddr_t)&_image_start);
    fd800000e82c:	f94033e2 	ldr	x2, [sp, #96]
    fd800000e830:	d2800001 	mov	x1, #0x0                   	// #0
    fd800000e834:	aa1403e0 	mov	x0, x20
    fd800000e838:	97ffcc6a 	bl	fd80000019e0 <pt_get_pte>
    fd800000e83c:	90000001 	adrp	x1, fd800000e000 <mem_map+0x730>
    fd800000e840:	f946bc26 	ldr	x6, [x1, #3448]
    fd800000e844:	aa0003e1 	mov	x1, x0
        while (shared_pte == 0) { }
    fd800000e848:	f94000c0 	ldr	x0, [x6]
    fd800000e84c:	b4ffffe0 	cbz	x0, fd800000e848 <mem_color_hypervisor+0x198>
        pte_set(image_pte, (paddr_t)shared_pte, PTE_TABLE, PTE_HYP_FLAGS);
    fd800000e850:	f94000c0 	ldr	x0, [x6]
    *pte = (addr & PTE_ADDR_MSK) | ((type | flags) & PTE_FLAGS_MSK);
    fd800000e854:	d280e8e2 	mov	x2, #0x747                 	// #1863
    fd800000e858:	92748c00 	and	x0, x0, #0xfffffffff000
    fd800000e85c:	aa020000 	orr	x0, x0, x2
    fd800000e860:	f9000020 	str	x0, [x1]
    fd800000e864:	90000000 	adrp	x0, fd800000e000 <mem_map+0x730>
    fd800000e868:	f946c005 	ldr	x5, [x0, #3456]
    fd800000e86c:	d503201f 	nop
    fd800000e870:	394040a0 	ldrb	w0, [x5, #16]
    fd800000e874:	3607ffe0 	tbz	w0, #0, fd800000e870 <mem_color_hypervisor+0x1c0>
    __asm__ volatile(
    fd800000e878:	910010a3 	add	x3, x5, #0x4
    fd800000e87c:	885ffca0 	ldaxr	w0, [x5]
    fd800000e880:	11000401 	add	w1, w0, #0x1
    fd800000e884:	88027ca1 	stxr	w2, w1, [x5]
    fd800000e888:	35ffffa2 	cbnz	w2, fd800000e87c <mem_color_hypervisor+0x1cc>
    fd800000e88c:	88dffc61 	ldar	w1, [x3]
    fd800000e890:	6b01001f 	cmp	w0, w1
    fd800000e894:	54000060 	b.eq	fd800000e8a0 <mem_color_hypervisor+0x1f0>  // b.none
    fd800000e898:	d503205f 	wfe
    fd800000e89c:	17fffffc 	b	fd800000e88c <mem_color_hypervisor+0x1dc>
    token->count++;
    fd800000e8a0:	f9400ca0 	ldr	x0, [x5, #24]
    fd800000e8a4:	91000400 	add	x0, x0, #0x1
    fd800000e8a8:	f9000ca0 	str	x0, [x5, #24]
    next_count = ALIGN(token->count, token->n);
    fd800000e8ac:	f9400ca0 	ldr	x0, [x5, #24]
    fd800000e8b0:	f94004a1 	ldr	x1, [x5, #8]
    fd800000e8b4:	f94004a2 	ldr	x2, [x5, #8]
    fd800000e8b8:	8b010000 	add	x0, x0, x1
    fd800000e8bc:	d1000400 	sub	x0, x0, #0x1
    fd800000e8c0:	f94004a1 	ldr	x1, [x5, #8]
    fd800000e8c4:	9ac20800 	udiv	x0, x0, x2
    fd800000e8c8:	9b017c00 	mul	x0, x0, x1
    __asm__ volatile(
    fd800000e8cc:	b9400061 	ldr	w1, [x3]
    fd800000e8d0:	11000421 	add	w1, w1, #0x1
    fd800000e8d4:	889ffc61 	stlr	w1, [x3]
    fd800000e8d8:	d5033b9f 	dsb	ish
    fd800000e8dc:	d503209f 	sev
    while (token->count < next_count) { }
    fd800000e8e0:	f9400ca1 	ldr	x1, [x5, #24]
    fd800000e8e4:	eb01001f 	cmp	x0, x1
    fd800000e8e8:	54ffffc8 	b.hi	fd800000e8e0 <mem_color_hypervisor+0x230>  // b.pmore
    if (cpu()->id == CPU_MASTER) {
    fd800000e8ec:	d2dfc000 	mov	x0, #0xfe0000000000        	// #279275953455104
        (root_pool->size / (8 * PAGE_SIZE) + !!(root_pool->size % (8 * PAGE_SIZE) != 0)) *
    fd800000e8f0:	92403b22 	and	x2, x25, #0x7fff
    if (cpu()->id == CPU_MASTER) {
    fd800000e8f4:	f9400381 	ldr	x1, [x28]
        (root_pool->size / (8 * PAGE_SIZE) + !!(root_pool->size % (8 * PAGE_SIZE) != 0)) *
    fd800000e8f8:	f100005f 	cmp	x2, #0x0
    if (cpu()->id == CPU_MASTER) {
    fd800000e8fc:	f9400002 	ldr	x2, [x0]
        (root_pool->size / (8 * PAGE_SIZE) + !!(root_pool->size % (8 * PAGE_SIZE) != 0)) *
    fd800000e900:	d34fff20 	lsr	x0, x25, #15
    fd800000e904:	9a800400 	cinc	x0, x0, ne	// ne = any
    if (cpu()->id == CPU_MASTER) {
    fd800000e908:	eb01005f 	cmp	x2, x1
    size_t bitmap_size =
    fd800000e90c:	d374cc19 	lsl	x25, x0, #12
    if (cpu()->id == CPU_MASTER) {
    fd800000e910:	54000dc0 	b.eq	fd800000eac8 <mem_color_hypervisor+0x418>  // b.none
    fd800000e914:	d503201f 	nop
    while (!token->ready) { }
    fd800000e918:	394040a0 	ldrb	w0, [x5, #16]
    fd800000e91c:	3607ffe0 	tbz	w0, #0, fd800000e918 <mem_color_hypervisor+0x268>
    __asm__ volatile(
    fd800000e920:	910010a3 	add	x3, x5, #0x4
    fd800000e924:	885ffca0 	ldaxr	w0, [x5]
    fd800000e928:	11000401 	add	w1, w0, #0x1
    fd800000e92c:	88027ca1 	stxr	w2, w1, [x5]
    fd800000e930:	35ffffa2 	cbnz	w2, fd800000e924 <mem_color_hypervisor+0x274>
    fd800000e934:	88dffc61 	ldar	w1, [x3]
    fd800000e938:	6b01001f 	cmp	w0, w1
    fd800000e93c:	54000060 	b.eq	fd800000e948 <mem_color_hypervisor+0x298>  // b.none
    fd800000e940:	d503205f 	wfe
    fd800000e944:	17fffffc 	b	fd800000e934 <mem_color_hypervisor+0x284>
    token->count++;
    fd800000e948:	f9400ca0 	ldr	x0, [x5, #24]
    fd800000e94c:	91000400 	add	x0, x0, #0x1
    fd800000e950:	f9000ca0 	str	x0, [x5, #24]
    next_count = ALIGN(token->count, token->n);
    fd800000e954:	f9400ca0 	ldr	x0, [x5, #24]
    fd800000e958:	f94004a1 	ldr	x1, [x5, #8]
    fd800000e95c:	f94004a2 	ldr	x2, [x5, #8]
    fd800000e960:	8b010000 	add	x0, x0, x1
    fd800000e964:	d1000400 	sub	x0, x0, #0x1
    fd800000e968:	f94004a1 	ldr	x1, [x5, #8]
    fd800000e96c:	9ac20800 	udiv	x0, x0, x2
    fd800000e970:	9b017c00 	mul	x0, x0, x1
    __asm__ volatile(
    fd800000e974:	b9400061 	ldr	w1, [x3]
    fd800000e978:	11000421 	add	w1, w1, #0x1
    fd800000e97c:	889ffc61 	stlr	w1, [x3]
    fd800000e980:	d5033b9f 	dsb	ish
    fd800000e984:	d503209f 	sev
    while (token->count < next_count) { }
    fd800000e988:	f9400ca1 	ldr	x1, [x5, #24]
    fd800000e98c:	eb01001f 	cmp	x0, x1
    fd800000e990:	54ffffc8 	b.hi	fd800000e988 <mem_color_hypervisor+0x2d8>  // b.pmore
    switch_space(cpu_new, p_root_pt_addr);
    fd800000e994:	f9404fe1 	ldr	x1, [sp, #152]
    fd800000e998:	aa1503e0 	mov	x0, x21
    fd800000e99c:	f90043e6 	str	x6, [sp, #128]
    fd800000e9a0:	97ffd0c5 	bl	fd8000002cb4 <switch_space>
    cache_flush_range((vaddr_t)&_image_start, image_size);
    fd800000e9a4:	f94033e0 	ldr	x0, [sp, #96]
    fd800000e9a8:	aa1a03e1 	mov	x1, x26
    fd800000e9ac:	97ffd1f5 	bl	fd8000003180 <cache_flush_range>
    cache_flush_range((vaddr_t)&_cpu_private_beg, sizeof(struct cpu));
    fd800000e9b0:	90000000 	adrp	x0, fd800000e000 <mem_map+0x730>
    fd800000e9b4:	d2840001 	mov	x1, #0x2000                	// #8192
    fd800000e9b8:	f946c800 	ldr	x0, [x0, #3472]
    fd800000e9bc:	97ffd1f1 	bl	fd8000003180 <cache_flush_range>
    if (cpu()->id == CPU_MASTER) {
    fd800000e9c0:	d2dfc001 	mov	x1, #0xfe0000000000        	// #279275953455104
    fd800000e9c4:	f9400380 	ldr	x0, [x28]
    fd800000e9c8:	f9400021 	ldr	x1, [x1]
    fd800000e9cc:	f94043e6 	ldr	x6, [sp, #128]
    fd800000e9d0:	eb00003f 	cmp	x1, x0
    fd800000e9d4:	90000000 	adrp	x0, fd800000e000 <mem_map+0x730>
    fd800000e9d8:	91360000 	add	x0, x0, #0xd80
    fd800000e9dc:	f9400005 	ldr	x5, [x0]
    fd800000e9e0:	540009a0 	b.eq	fd800000eb14 <mem_color_hypervisor+0x464>  // b.none
    fd800000e9e4:	d503201f 	nop
        while (shared_pte != 0) { }
    fd800000e9e8:	f94000c0 	ldr	x0, [x6]
    fd800000e9ec:	b5ffffe0 	cbnz	x0, fd800000e9e8 <mem_color_hypervisor+0x338>
    as_init(&cpu()->as, AS_HYP, HYP_ASID, (void*)v_root_pt_addr, colors);
    fd800000e9f0:	f94037e3 	ldr	x3, [sp, #104]
    size_t vm_image_size = (size_t)(&_vm_image_end - &_vm_image_start);
    fd800000e9f4:	90000000 	adrp	x0, fd800000e000 <mem_map+0x730>
    fd800000e9f8:	f946d002 	ldr	x2, [x0, #3488]
    fd800000e9fc:	90000000 	adrp	x0, fd800000e000 <mem_map+0x730>
    fd800000ea00:	f946d401 	ldr	x1, [x0, #3496]
    if (cpu()->id == CPU_MASTER) {
    fd800000ea04:	d2dfc015 	mov	x21, #0xfe0000000000        	// #279275953455104
    as_init(&cpu()->as, AS_HYP, HYP_ASID, (void*)v_root_pt_addr, colors);
    fd800000ea08:	d2800200 	mov	x0, #0x10                  	// #16
    fd800000ea0c:	aa1803e4 	mov	x4, x24
    fd800000ea10:	f2dfc000 	movk	x0, #0xfe00, lsl #32
    size_t vm_image_size = (size_t)(&_vm_image_end - &_vm_image_start);
    fd800000ea14:	cb010058 	sub	x24, x2, x1
    as_init(&cpu()->as, AS_HYP, HYP_ASID, (void*)v_root_pt_addr, colors);
    fd800000ea18:	52800001 	mov	w1, #0x0                   	// #0
    fd800000ea1c:	d2800002 	mov	x2, #0x0                   	// #0
    fd800000ea20:	97fffeec 	bl	fd800000e5d0 <as_init>
        p_bitmap = mem_ppages_get(load_addr + image_size + vm_image_size +
    fd800000ea24:	8b170353 	add	x19, x26, x23
    if (cpu()->id == CPU_MASTER) {
    fd800000ea28:	f94002a0 	ldr	x0, [x21]
        p_bitmap = mem_ppages_get(load_addr + image_size + vm_image_size +
    fd800000ea2c:	8b180273 	add	x19, x19, x24
    if (cpu()->id == CPU_MASTER) {
    fd800000ea30:	f9400381 	ldr	x1, [x28]
    fd800000ea34:	eb01001f 	cmp	x0, x1
    fd800000ea38:	54000a80 	b.eq	fd800000eb88 <mem_color_hypervisor+0x4d8>  // b.none
    p_cpu = mem_ppages_get(load_addr + image_size + vm_image_size + (cpu_boot_size * cpu()->id),
    fd800000ea3c:	9b004ec4 	madd	x4, x22, x0, x19
    fd800000ea40:	d34cfed4 	lsr	x20, x22, #12
    va = mem_alloc_vpage(&cpu()->as, SEC_HYP_PRIVATE, INVALID_VA, p_cpu.num_pages);
    fd800000ea44:	d2800200 	mov	x0, #0x10                  	// #16
    fd800000ea48:	aa1403e3 	mov	x3, x20
    fd800000ea4c:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
    fd800000ea50:	52800041 	mov	w1, #0x2                   	// #2
    fd800000ea54:	f2dfc000 	movk	x0, #0xfe00, lsl #32
    p_cpu = mem_ppages_get(load_addr + image_size + vm_image_size + (cpu_boot_size * cpu()->id),
    fd800000ea58:	a90a53e4 	stp	x4, x20, [sp, #160]
    fd800000ea5c:	f9005bff 	str	xzr, [sp, #176]
    va = mem_alloc_vpage(&cpu()->as, SEC_HYP_PRIVATE, INVALID_VA, p_cpu.num_pages);
    fd800000ea60:	97fff970 	bl	fd800000d020 <mem_alloc_vpage>
    mem_map(&cpu()->as, va, &p_cpu, p_cpu.num_pages, PTE_HYP_FLAGS);
    fd800000ea64:	aa1403e3 	mov	x3, x20
    va = mem_alloc_vpage(&cpu()->as, SEC_HYP_PRIVATE, INVALID_VA, p_cpu.num_pages);
    fd800000ea68:	aa0003f3 	mov	x19, x0
    mem_map(&cpu()->as, va, &p_cpu, p_cpu.num_pages, PTE_HYP_FLAGS);
    fd800000ea6c:	d280e884 	mov	x4, #0x744                 	// #1860
    fd800000ea70:	d2800200 	mov	x0, #0x10                  	// #16
    fd800000ea74:	910283e2 	add	x2, sp, #0xa0
    fd800000ea78:	aa1303e1 	mov	x1, x19
    fd800000ea7c:	f2dfc000 	movk	x0, #0xfe00, lsl #32
    fd800000ea80:	97fffb94 	bl	fd800000d8d0 <mem_map>
    memset((void*)va, 0, p_cpu.num_pages * PAGE_SIZE);
    fd800000ea84:	9274cec2 	and	x2, x22, #0xfffffffffffff000
    fd800000ea88:	aa1303e0 	mov	x0, x19
    fd800000ea8c:	52800001 	mov	w1, #0x0                   	// #0
    fd800000ea90:	97ffe828 	bl	fd8000008b30 <memset>
    mem_unmap(&cpu()->as, va, p_cpu.num_pages, false);
    fd800000ea94:	d2800200 	mov	x0, #0x10                  	// #16
    fd800000ea98:	aa1403e2 	mov	x2, x20
    fd800000ea9c:	aa1303e1 	mov	x1, x19
    fd800000eaa0:	f2dfc000 	movk	x0, #0xfe00, lsl #32
    fd800000eaa4:	52800003 	mov	w3, #0x0                   	// #0
    fd800000eaa8:	97fffaa6 	bl	fd800000d540 <mem_unmap>
}
    fd800000eaac:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd800000eab0:	a9425bf5 	ldp	x21, x22, [sp, #32]
    fd800000eab4:	a94363f7 	ldp	x23, x24, [sp, #48]
    fd800000eab8:	a9446bf9 	ldp	x25, x26, [sp, #64]
    fd800000eabc:	a94573fb 	ldp	x27, x28, [sp, #80]
    fd800000eac0:	a8d07bfd 	ldp	x29, x30, [sp], #256
    fd800000eac4:	d65f03c0 	ret
        copy_space((void*)root_pool->bitmap, bitmap_size, &p_bitmap);
    fd800000eac8:	f9401660 	ldr	x0, [x19, #40]
    fd800000eacc:	910343e2 	add	x2, sp, #0xd0
    fd800000ead0:	aa1903e1 	mov	x1, x25
    fd800000ead4:	f90047e6 	str	x6, [sp, #136]
    fd800000ead8:	97fffe8e 	bl	fd800000e510 <copy_space>
        va = mem_alloc_vpage(&cpu_new->as, SEC_HYP_GLOBAL, (vaddr_t)root_pool->bitmap,
    fd800000eadc:	f9401662 	ldr	x2, [x19, #40]
    fd800000eae0:	d34cff23 	lsr	x3, x25, #12
    fd800000eae4:	52800001 	mov	w1, #0x0                   	// #0
    fd800000eae8:	aa1403e0 	mov	x0, x20
    fd800000eaec:	f90043e3 	str	x3, [sp, #128]
    fd800000eaf0:	97fff94c 	bl	fd800000d020 <mem_alloc_vpage>
        if (va != (vaddr_t)root_pool->bitmap) {
    fd800000eaf4:	f9401661 	ldr	x1, [x19, #40]
    fd800000eaf8:	a9481be3 	ldp	x3, x6, [sp, #128]
    fd800000eafc:	eb00003f 	cmp	x1, x0
    fd800000eb00:	540010a0 	b.eq	fd800000ed14 <mem_color_hypervisor+0x664>  // b.none
            ERROR("Can't allocate address for cpu interface");
    fd800000eb04:	90000000 	adrp	x0, fd800000e000 <mem_map+0x730>
    fd800000eb08:	f946c400 	ldr	x0, [x0, #3464]
    fd800000eb0c:	97fff545 	bl	fd800000c020 <console_printk>
    fd800000eb10:	14000000 	b	fd800000eb10 <mem_color_hypervisor+0x460>
        cpu_sync_init(&cpu_glb_sync, platform.cpu_num);
    fd800000eb14:	90000000 	adrp	x0, fd800000e000 <mem_map+0x730>
    fd800000eb18:	f946cc01 	ldr	x1, [x0, #3480]
    token->ready = true;
    fd800000eb1c:	52800020 	mov	w0, #0x1                   	// #1
    token->lock = SPINLOCK_INITVAL;
    fd800000eb20:	f90000bf 	str	xzr, [x5]
    fd800000eb24:	f9400021 	ldr	x1, [x1]
    token->n = n;
    fd800000eb28:	f90004a1 	str	x1, [x5, #8]
    token->count = 0;
    fd800000eb2c:	f9000cbf 	str	xzr, [x5, #24]
    token->ready = true;
    fd800000eb30:	390040a0 	strb	w0, [x5, #16]
        shared_pte = 0;
    fd800000eb34:	f90000df 	str	xzr, [x6]
    fd800000eb38:	17ffffae 	b	fd800000e9f0 <mem_color_hypervisor+0x340>
        copy_space(&_image_start, image_size, &p_image);
    fd800000eb3c:	f94033fb 	ldr	x27, [sp, #96]
    fd800000eb40:	aa1a03e1 	mov	x1, x26
    fd800000eb44:	9102e3e2 	add	x2, sp, #0xb8
    fd800000eb48:	aa1b03e0 	mov	x0, x27
    fd800000eb4c:	97fffe71 	bl	fd800000e510 <copy_space>
            NUM_PAGES(image_size));
    fd800000eb50:	913fff43 	add	x3, x26, #0xfff
        va = mem_alloc_vpage(&cpu_new->as, SEC_HYP_IMAGE, (vaddr_t)&_image_start,
    fd800000eb54:	aa1b03e2 	mov	x2, x27
    fd800000eb58:	aa1403e0 	mov	x0, x20
    fd800000eb5c:	52800021 	mov	w1, #0x1                   	// #1
    fd800000eb60:	d34cfc63 	lsr	x3, x3, #12
    fd800000eb64:	f90043e3 	str	x3, [sp, #128]
    fd800000eb68:	97fff92e 	bl	fd800000d020 <mem_alloc_vpage>
        if (va != (vaddr_t)&_image_start) {
    fd800000eb6c:	eb00037f 	cmp	x27, x0
    fd800000eb70:	f94043e3 	ldr	x3, [sp, #128]
    fd800000eb74:	54000b00 	b.eq	fd800000ecd4 <mem_color_hypervisor+0x624>  // b.none
            ERROR("Can't allocate virtual address for Bao Image");
    fd800000eb78:	90000000 	adrp	x0, fd800000e000 <mem_map+0x730>
    fd800000eb7c:	f946b800 	ldr	x0, [x0, #3440]
    fd800000eb80:	97fff528 	bl	fd800000c020 <console_printk>
    fd800000eb84:	14000000 	b	fd800000eb84 <mem_color_hypervisor+0x4d4>
        p_image = mem_ppages_get(load_addr, NUM_PAGES(image_load_size));
    fd800000eb88:	f9403bfb 	ldr	x27, [sp, #112]
        va = mem_alloc_vpage(&cpu()->as, SEC_HYP_GLOBAL, INVALID_VA, p_image.num_pages);
    fd800000eb8c:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
    fd800000eb90:	52800001 	mov	w1, #0x0                   	// #0
    fd800000eb94:	910042a0 	add	x0, x21, #0x10
        p_image = mem_ppages_get(load_addr, NUM_PAGES(image_load_size));
    fd800000eb98:	913fff74 	add	x20, x27, #0xfff
    fd800000eb9c:	f90067ff 	str	xzr, [sp, #200]
        p_bitmap = mem_ppages_get(load_addr + image_size + vm_image_size +
    fd800000eba0:	d34cff39 	lsr	x25, x25, #12
        p_image = mem_ppages_get(load_addr, NUM_PAGES(image_load_size));
    fd800000eba4:	d34cfe94 	lsr	x20, x20, #12
    fd800000eba8:	a90bd3f7 	stp	x23, x20, [sp, #184]
        va = mem_alloc_vpage(&cpu()->as, SEC_HYP_GLOBAL, INVALID_VA, p_image.num_pages);
    fd800000ebac:	aa1403e3 	mov	x3, x20
    fd800000ebb0:	97fff91c 	bl	fd800000d020 <mem_alloc_vpage>
    fd800000ebb4:	aa0003fa 	mov	x26, x0
        mem_map(&cpu()->as, va, &p_image, p_image.num_pages, PTE_HYP_FLAGS);
    fd800000ebb8:	aa1403e3 	mov	x3, x20
    fd800000ebbc:	d280e884 	mov	x4, #0x744                 	// #1860
    fd800000ebc0:	9102e3e2 	add	x2, sp, #0xb8
    fd800000ebc4:	aa1a03e1 	mov	x1, x26
    fd800000ebc8:	910042a0 	add	x0, x21, #0x10
    fd800000ebcc:	97fffb41 	bl	fd800000d8d0 <mem_map>
        memset((void*)va, 0, p_image.num_pages * PAGE_SIZE);
    fd800000ebd0:	d374ce82 	lsl	x2, x20, #12
    fd800000ebd4:	52800001 	mov	w1, #0x0                   	// #0
    fd800000ebd8:	aa1a03e0 	mov	x0, x26
    fd800000ebdc:	97ffe7d5 	bl	fd8000008b30 <memset>
        mem_unmap(&cpu()->as, va, p_image.num_pages, true);
    fd800000ebe0:	aa1403e2 	mov	x2, x20
    fd800000ebe4:	aa1a03e1 	mov	x1, x26
    fd800000ebe8:	910042a0 	add	x0, x21, #0x10
    fd800000ebec:	52800023 	mov	w3, #0x1                   	// #1
    fd800000ebf0:	97fffa54 	bl	fd800000d540 <mem_unmap>
            NUM_PAGES(image_noload_size));
    fd800000ebf4:	f9403fe0 	ldr	x0, [sp, #120]
        p_image = mem_ppages_get(load_addr + image_load_size + vm_image_size,
    fd800000ebf8:	8b180364 	add	x4, x27, x24
    fd800000ebfc:	8b170084 	add	x4, x4, x23
        va = mem_alloc_vpage(&cpu()->as, SEC_HYP_GLOBAL, INVALID_VA, p_image.num_pages);
    fd800000ec00:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
            NUM_PAGES(image_noload_size));
    fd800000ec04:	913ffc14 	add	x20, x0, #0xfff
        va = mem_alloc_vpage(&cpu()->as, SEC_HYP_GLOBAL, INVALID_VA, p_image.num_pages);
    fd800000ec08:	52800001 	mov	w1, #0x0                   	// #0
    fd800000ec0c:	910042a0 	add	x0, x21, #0x10
        p_image = mem_ppages_get(load_addr + image_load_size + vm_image_size,
    fd800000ec10:	d34cfe94 	lsr	x20, x20, #12
    fd800000ec14:	a90bd3e4 	stp	x4, x20, [sp, #184]
        va = mem_alloc_vpage(&cpu()->as, SEC_HYP_GLOBAL, INVALID_VA, p_image.num_pages);
    fd800000ec18:	aa1403e3 	mov	x3, x20
    fd800000ec1c:	97fff901 	bl	fd800000d020 <mem_alloc_vpage>
    fd800000ec20:	aa0003f7 	mov	x23, x0
        mem_map(&cpu()->as, va, &p_image, p_image.num_pages, PTE_HYP_FLAGS);
    fd800000ec24:	aa1403e3 	mov	x3, x20
    fd800000ec28:	d280e884 	mov	x4, #0x744                 	// #1860
    fd800000ec2c:	9102e3e2 	add	x2, sp, #0xb8
    fd800000ec30:	aa1703e1 	mov	x1, x23
    fd800000ec34:	910042a0 	add	x0, x21, #0x10
    fd800000ec38:	97fffb26 	bl	fd800000d8d0 <mem_map>
        memset((void*)va, 0, p_image.num_pages * PAGE_SIZE);
    fd800000ec3c:	d374ce82 	lsl	x2, x20, #12
    fd800000ec40:	52800001 	mov	w1, #0x0                   	// #0
    fd800000ec44:	aa1703e0 	mov	x0, x23
    fd800000ec48:	97ffe7ba 	bl	fd8000008b30 <memset>
        mem_unmap(&cpu()->as, va, p_image.num_pages, true);
    fd800000ec4c:	aa1403e2 	mov	x2, x20
    fd800000ec50:	aa1703e1 	mov	x1, x23
    fd800000ec54:	910042a0 	add	x0, x21, #0x10
    fd800000ec58:	52800023 	mov	w3, #0x1                   	// #1
    fd800000ec5c:	97fffa39 	bl	fd800000d540 <mem_unmap>
        p_bitmap = mem_ppages_get(load_addr + image_size + vm_image_size +
    fd800000ec60:	f90073ff 	str	xzr, [sp, #224]
                (cpu_boot_size * platform.cpu_num),
    fd800000ec64:	90000000 	adrp	x0, fd800000e000 <mem_map+0x730>
    fd800000ec68:	f946cc04 	ldr	x4, [x0, #3480]
        va = mem_alloc_vpage(&cpu()->as, SEC_HYP_GLOBAL, INVALID_VA, p_bitmap.num_pages);
    fd800000ec6c:	aa1903e3 	mov	x3, x25
    fd800000ec70:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
    fd800000ec74:	52800001 	mov	w1, #0x0                   	// #0
    fd800000ec78:	910042a0 	add	x0, x21, #0x10
                (cpu_boot_size * platform.cpu_num),
    fd800000ec7c:	f9400084 	ldr	x4, [x4]
        p_bitmap = mem_ppages_get(load_addr + image_size + vm_image_size +
    fd800000ec80:	9b044ec4 	madd	x4, x22, x4, x19
    fd800000ec84:	a90d67e4 	stp	x4, x25, [sp, #208]
        va = mem_alloc_vpage(&cpu()->as, SEC_HYP_GLOBAL, INVALID_VA, p_bitmap.num_pages);
    fd800000ec88:	97fff8e6 	bl	fd800000d020 <mem_alloc_vpage>
    fd800000ec8c:	aa0003f4 	mov	x20, x0
        mem_map(&cpu()->as, va, &p_bitmap, p_bitmap.num_pages, PTE_HYP_FLAGS);
    fd800000ec90:	aa1903e3 	mov	x3, x25
    fd800000ec94:	d280e884 	mov	x4, #0x744                 	// #1860
    fd800000ec98:	910343e2 	add	x2, sp, #0xd0
    fd800000ec9c:	aa1403e1 	mov	x1, x20
    fd800000eca0:	910042a0 	add	x0, x21, #0x10
    fd800000eca4:	97fffb0b 	bl	fd800000d8d0 <mem_map>
        memset((void*)va, 0, p_bitmap.num_pages * PAGE_SIZE);
    fd800000eca8:	d374cf22 	lsl	x2, x25, #12
    fd800000ecac:	52800001 	mov	w1, #0x0                   	// #0
    fd800000ecb0:	aa1403e0 	mov	x0, x20
    fd800000ecb4:	97ffe79f 	bl	fd8000008b30 <memset>
        mem_unmap(&cpu()->as, va, p_bitmap.num_pages, true);
    fd800000ecb8:	910042a0 	add	x0, x21, #0x10
    fd800000ecbc:	aa1903e2 	mov	x2, x25
    fd800000ecc0:	aa1403e1 	mov	x1, x20
    fd800000ecc4:	52800023 	mov	w3, #0x1                   	// #1
    fd800000ecc8:	97fffa1e 	bl	fd800000d540 <mem_unmap>
    p_cpu = mem_ppages_get(load_addr + image_size + vm_image_size + (cpu_boot_size * cpu()->id),
    fd800000eccc:	f94002a0 	ldr	x0, [x21]
    fd800000ecd0:	17ffff5b 	b	fd800000ea3c <mem_color_hypervisor+0x38c>
        mem_map(&cpu_new->as, va, &p_image, NUM_PAGES(image_size), PTE_HYP_FLAGS);
    fd800000ecd4:	f94033fb 	ldr	x27, [sp, #96]
    fd800000ecd8:	d280e884 	mov	x4, #0x744                 	// #1860
    fd800000ecdc:	9102e3e2 	add	x2, sp, #0xb8
    fd800000ece0:	aa1403e0 	mov	x0, x20
    fd800000ece4:	aa1b03e1 	mov	x1, x27
    fd800000ece8:	97fffafa 	bl	fd800000d8d0 <mem_map>
        shared_pte = pte_addr(pt_get_pte(&cpu_new->as.pt, 0, (vaddr_t)&_image_start));
    fd800000ecec:	d2800001 	mov	x1, #0x0                   	// #0
    fd800000ecf0:	aa1b03e2 	mov	x2, x27
    fd800000ecf4:	aa1403e0 	mov	x0, x20
    fd800000ecf8:	97ffcb3a 	bl	fd80000019e0 <pt_get_pte>
    fd800000ecfc:	90000001 	adrp	x1, fd800000e000 <mem_map+0x730>
    fd800000ed00:	f946bc26 	ldr	x6, [x1, #3448]
    return (paddr_t)(*pte & PTE_ADDR_MSK);
    fd800000ed04:	f9400000 	ldr	x0, [x0]
    fd800000ed08:	92748c00 	and	x0, x0, #0xfffffffff000
    fd800000ed0c:	f90000c0 	str	x0, [x6]
    fd800000ed10:	17fffed5 	b	fd800000e864 <mem_color_hypervisor+0x1b4>
        mem_map(&cpu_new->as, va, &p_bitmap, NUM_PAGES(bitmap_size), PTE_HYP_FLAGS);
    fd800000ed14:	910343e2 	add	x2, sp, #0xd0
    fd800000ed18:	aa1403e0 	mov	x0, x20
    fd800000ed1c:	d280e884 	mov	x4, #0x744                 	// #1860
    fd800000ed20:	f90043e6 	str	x6, [sp, #128]
    fd800000ed24:	97fffaeb 	bl	fd800000d8d0 <mem_map>
    fd800000ed28:	90000000 	adrp	x0, fd800000e000 <mem_map+0x730>
    fd800000ed2c:	91360000 	add	x0, x0, #0xd80
    fd800000ed30:	f94043e6 	ldr	x6, [sp, #128]
    fd800000ed34:	f9400005 	ldr	x5, [x0]
    fd800000ed38:	17fffef8 	b	fd800000e918 <mem_color_hypervisor+0x268>
    fd800000ed3c:	d503201f 	nop
    fd800000ed40:	00012bf0 	.word	0x00012bf0
    fd800000ed44:	0000fd80 	.word	0x0000fd80
    fd800000ed48:	00011070 	.word	0x00011070
    fd800000ed4c:	0000fd80 	.word	0x0000fd80
    fd800000ed50:	00013000 	.word	0x00013000
    fd800000ed54:	0000fd80 	.word	0x0000fd80
    fd800000ed58:	00000000 	.word	0x00000000
    fd800000ed5c:	0000fd80 	.word	0x0000fd80
    fd800000ed60:	00020000 	.word	0x00020000
    fd800000ed64:	0000fd80 	.word	0x0000fd80
    fd800000ed68:	00012348 	.word	0x00012348
    fd800000ed6c:	0000fd80 	.word	0x0000fd80
    fd800000ed70:	000110a8 	.word	0x000110a8
    fd800000ed74:	0000fd80 	.word	0x0000fd80
    fd800000ed78:	0001bd90 	.word	0x0001bd90
    fd800000ed7c:	0000fd80 	.word	0x0000fd80
    fd800000ed80:	00016000 	.word	0x00016000
    fd800000ed84:	0000fd80 	.word	0x0000fd80
    fd800000ed88:	000110e8 	.word	0x000110e8
    fd800000ed8c:	0000fd80 	.word	0x0000fd80
    fd800000ed90:	00000000 	.word	0x00000000
    fd800000ed94:	0000fe00 	.word	0x0000fe00
    fd800000ed98:	00012930 	.word	0x00012930
    fd800000ed9c:	0000fd80 	.word	0x0000fd80
    fd800000eda0:	03562000 	.word	0x03562000
    fd800000eda4:	0000fd80 	.word	0x0000fd80
    fd800000eda8:	00013000 	.word	0x00013000
    fd800000edac:	0000fd80 	.word	0x0000fd80

0000fd800000edb0 <mem_prot_init>:

void mem_prot_init()
{
    pte_t* root_pt = (pte_t*)ALIGN(((vaddr_t)cpu()) + sizeof(struct cpu), PAGE_SIZE);
    as_init(&cpu()->as, AS_HYP, HYP_ASID, root_pt, config.hyp.colors);
    fd800000edb0:	90000000 	adrp	x0, fd800000e000 <mem_map+0x730>
    fd800000edb4:	f946f801 	ldr	x1, [x0, #3568]
    as->pt.dscr = type == AS_HYP || type == AS_HYP_CPY ? hyp_pt_dscr : vm_pt_dscr;
    fd800000edb8:	90000002 	adrp	x2, fd800000e000 <mem_map+0x730>
    fd800000edbc:	f946fc42 	ldr	x2, [x2, #3576]
    as->type = type;
    fd800000edc0:	d2800200 	mov	x0, #0x10                  	// #16
    as_init(&cpu()->as, AS_HYP, HYP_ASID, root_pt, config.hyp.colors);
    fd800000edc4:	f9400821 	ldr	x1, [x1, #16]
    as->type = type;
    fd800000edc8:	f2dfc000 	movk	x0, #0xfe00, lsl #32
    as->pt.dscr = type == AS_HYP || type == AS_HYP_CPY ? hyp_pt_dscr : vm_pt_dscr;
    fd800000edcc:	f9400042 	ldr	x2, [x2]
    as->pt.root = root_pt;
    fd800000edd0:	d2840003 	mov	x3, #0x2000                	// #8192
    fd800000edd4:	f2dfc003 	movk	x3, #0xfe00, lsl #32
    as->pt.dscr = type == AS_HYP || type == AS_HYP_CPY ? hyp_pt_dscr : vm_pt_dscr;
    fd800000edd8:	a9000803 	stp	x3, x2, [x0]
    as->type = type;
    fd800000eddc:	b900201f 	str	wzr, [x0, #32]
    as->id = id;
    fd800000ede0:	a902fc01 	stp	x1, xzr, [x0, #40]
    as->lock = SPINLOCK_INITVAL;
    fd800000ede4:	f9001c1f 	str	xzr, [x0, #56]
    as_arch_init(as);
    fd800000ede8:	17ffcb52 	b	fd8000001b30 <as_arch_init>
    fd800000edec:	d503201f 	nop
    fd800000edf0:	00012bf0 	.word	0x00012bf0
    fd800000edf4:	0000fd80 	.word	0x0000fd80
    fd800000edf8:	00012018 	.word	0x00012018
    fd800000edfc:	0000fd80 	.word	0x0000fd80

0000fd800000ee00 <mem_alloc_map>:
}

vaddr_t mem_alloc_map(struct addr_space* as, enum AS_SEC section, struct ppages* page, vaddr_t at,
    size_t num_pages, mem_flags_t flags)
{
    fd800000ee00:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    fd800000ee04:	910003fd 	mov	x29, sp
    fd800000ee08:	a90153f3 	stp	x19, x20, [sp, #16]
    fd800000ee0c:	aa0403f4 	mov	x20, x4
    fd800000ee10:	a9025bf5 	stp	x21, x22, [sp, #32]
    fd800000ee14:	aa0203f6 	mov	x22, x2
    fd800000ee18:	aa0003f5 	mov	x21, x0
    vaddr_t address = mem_alloc_vpage(as, section, at, num_pages);
    fd800000ee1c:	aa0303e2 	mov	x2, x3
    fd800000ee20:	aa0403e3 	mov	x3, x4
{
    fd800000ee24:	f9001bf7 	str	x23, [sp, #48]
    fd800000ee28:	aa0503f7 	mov	x23, x5
    vaddr_t address = mem_alloc_vpage(as, section, at, num_pages);
    fd800000ee2c:	97fff87d 	bl	fd800000d020 <mem_alloc_vpage>
    fd800000ee30:	aa0003f3 	mov	x19, x0
    if (address != INVALID_VA) {
    fd800000ee34:	b100041f 	cmn	x0, #0x1
    fd800000ee38:	540000e0 	b.eq	fd800000ee54 <mem_alloc_map+0x54>  // b.none
        mem_map(as, address, page, num_pages, flags);
    fd800000ee3c:	aa1703e4 	mov	x4, x23
    fd800000ee40:	aa1403e3 	mov	x3, x20
    fd800000ee44:	aa1603e2 	mov	x2, x22
    fd800000ee48:	aa1503e0 	mov	x0, x21
    fd800000ee4c:	aa1303e1 	mov	x1, x19
    fd800000ee50:	97fffaa0 	bl	fd800000d8d0 <mem_map>
    }
    return address;
}
    fd800000ee54:	a9425bf5 	ldp	x21, x22, [sp, #32]
    fd800000ee58:	aa1303e0 	mov	x0, x19
    fd800000ee5c:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd800000ee60:	f9401bf7 	ldr	x23, [sp, #48]
    fd800000ee64:	a8c47bfd 	ldp	x29, x30, [sp], #64
    fd800000ee68:	d65f03c0 	ret
    fd800000ee6c:	d503201f 	nop

0000fd800000ee70 <mem_alloc_map_dev>:

vaddr_t mem_alloc_map_dev(struct addr_space* as, enum AS_SEC section, vaddr_t at, paddr_t pa,
    size_t num_pages)
{
    fd800000ee70:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    fd800000ee74:	910003fd 	mov	x29, sp
    fd800000ee78:	a90153f3 	stp	x19, x20, [sp, #16]
    fd800000ee7c:	aa0403f4 	mov	x20, x4
    fd800000ee80:	a9025bf5 	stp	x21, x22, [sp, #32]
    fd800000ee84:	aa0303f6 	mov	x22, x3
    fd800000ee88:	aa0003f5 	mov	x21, x0
    vaddr_t address = mem_alloc_vpage(as, section, at, num_pages);
    fd800000ee8c:	aa0403e3 	mov	x3, x4
    fd800000ee90:	97fff864 	bl	fd800000d020 <mem_alloc_vpage>
    fd800000ee94:	aa0003f3 	mov	x19, x0
    if (address != INVALID_VA) {
    fd800000ee98:	b100041f 	cmn	x0, #0x1
    fd800000ee9c:	540001c0 	b.eq	fd800000eed4 <mem_alloc_map_dev+0x64>  // b.none
        struct ppages pages = mem_ppages_get(pa, num_pages);
        mem_flags_t flags = as->type == AS_HYP ? PTE_HYP_DEV_FLAGS : PTE_VM_DEV_FLAGS;
    fd800000eea0:	b94022a1 	ldr	w1, [x21, #32]
    fd800000eea4:	d2809984 	mov	x4, #0x4cc                 	// #1228
        mem_map(as, address, &pages, num_pages, flags);
    fd800000eea8:	aa1403e3 	mov	x3, x20
    fd800000eeac:	aa1503e0 	mov	x0, x21
        mem_flags_t flags = as->type == AS_HYP ? PTE_HYP_DEV_FLAGS : PTE_VM_DEV_FLAGS;
    fd800000eeb0:	7100003f 	cmp	w1, #0x0
    fd800000eeb4:	d280e901 	mov	x1, #0x748                 	// #1864
    fd800000eeb8:	f2e00801 	movk	x1, #0x40, lsl #48
        mem_map(as, address, &pages, num_pages, flags);
    fd800000eebc:	9100e3e2 	add	x2, sp, #0x38
    fd800000eec0:	9a811084 	csel	x4, x4, x1, ne	// ne = any
    fd800000eec4:	aa1303e1 	mov	x1, x19
    fd800000eec8:	a903d3f6 	stp	x22, x20, [sp, #56]
    fd800000eecc:	f90027ff 	str	xzr, [sp, #72]
    fd800000eed0:	97fffa80 	bl	fd800000d8d0 <mem_map>
    }

    return address;
}
    fd800000eed4:	a9425bf5 	ldp	x21, x22, [sp, #32]
    fd800000eed8:	aa1303e0 	mov	x0, x19
    fd800000eedc:	a94153f3 	ldp	x19, x20, [sp, #16]
    fd800000eee0:	a8c57bfd 	ldp	x29, x30, [sp], #80
    fd800000eee4:	d65f03c0 	ret
	...

0000fd800000eef0 <io_init>:
};

/* Mainly for HW initialization. */
void io_init()
{
    iommu_arch_init();
    fd800000eef0:	17ffcecc 	b	fd8000002a20 <iommu_arch_init>
    fd800000eef4:	d503201f 	nop
    fd800000eef8:	d503201f 	nop
    fd800000eefc:	d503201f 	nop

0000fd800000ef00 <io_vm_init>:
}

/* Configure architecture dependent stuff. */
bool io_vm_init(struct vm* vm, const struct vm_config* config)
{
    return iommu_arch_vm_init(vm, config);
    fd800000ef00:	17ffcee4 	b	fd8000002a90 <iommu_arch_vm_init>
    fd800000ef04:	d503201f 	nop
    fd800000ef08:	d503201f 	nop
    fd800000ef0c:	d503201f 	nop

0000fd800000ef10 <io_vm_add_device>:

    /*
     * If dev_id == 0 assume global mask includes the relevant devices for this VM.
     *
     * Assume there's no device id = 0 */
    if (dev_id != 0) {
    fd800000ef10:	35000061 	cbnz	w1, fd800000ef1c <io_vm_add_device+0xc>
        /* Stream id is valid. Match this device with this VM specifically. */
        res = iommu_arch_vm_add_device(vm, dev_id);
    }

    return res;
}
    fd800000ef14:	52800000 	mov	w0, #0x0                   	// #0
    fd800000ef18:	d65f03c0 	ret
        res = iommu_arch_vm_add_device(vm, dev_id);
    fd800000ef1c:	17ffced9 	b	fd8000002a80 <iommu_arch_vm_add_device>

0000fd800000ef20 <vmm_io_init>:
#include <vmm.h>
#include <io.h>

void vmm_io_init()
{
    io_init();
    fd800000ef20:	17fffff4 	b	fd800000eef0 <io_init>
    fd800000ef24:	d503201f 	nop
    fd800000ef28:	d503201f 	nop
    fd800000ef2c:	d503201f 	nop

0000fd800000ef30 <vmm_get_vm_install_info>:
}

struct vm_install_info vmm_get_vm_install_info(struct vm_allocation* vm_alloc)
{
    fd800000ef30:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    fd800000ef34:	aa0003e2 	mov	x2, x0
    struct vm_install_info info = {
        .base = vm_alloc->base,
        .vm_section_pte = *pt_get_pte(&cpu()->as.pt, 0, vm_alloc->base),
    fd800000ef38:	d2800001 	mov	x1, #0x0                   	// #0
{
    fd800000ef3c:	910003fd 	mov	x29, sp
    fd800000ef40:	f9000bf3 	str	x19, [sp, #16]
        .vm_section_pte = *pt_get_pte(&cpu()->as.pt, 0, vm_alloc->base),
    fd800000ef44:	d2800200 	mov	x0, #0x10                  	// #16
        .base = vm_alloc->base,
    fd800000ef48:	f9400053 	ldr	x19, [x2]
        .vm_section_pte = *pt_get_pte(&cpu()->as.pt, 0, vm_alloc->base),
    fd800000ef4c:	f2dfc000 	movk	x0, #0xfe00, lsl #32
    fd800000ef50:	aa1303e2 	mov	x2, x19
    fd800000ef54:	97ffcaa3 	bl	fd80000019e0 <pt_get_pte>
    fd800000ef58:	aa0003e1 	mov	x1, x0
    };
    return info;
}
    fd800000ef5c:	aa1303e0 	mov	x0, x19
    fd800000ef60:	f9400bf3 	ldr	x19, [sp, #16]
    fd800000ef64:	f9400021 	ldr	x1, [x1]
    fd800000ef68:	a8c37bfd 	ldp	x29, x30, [sp], #48
    fd800000ef6c:	d65f03c0 	ret

0000fd800000ef70 <vmm_vm_install>:

void vmm_vm_install(struct vm_install_info* install_info)
{
    fd800000ef70:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    pte_t* pte = pt_get_pte(&cpu()->as.pt, 0, (vaddr_t)install_info->base);
    fd800000ef74:	d2800001 	mov	x1, #0x0                   	// #0
{
    fd800000ef78:	910003fd 	mov	x29, sp
    fd800000ef7c:	f9000bf3 	str	x19, [sp, #16]
    fd800000ef80:	aa0003f3 	mov	x19, x0
    pte_t* pte = pt_get_pte(&cpu()->as.pt, 0, (vaddr_t)install_info->base);
    fd800000ef84:	d2800200 	mov	x0, #0x10                  	// #16
    fd800000ef88:	f2dfc000 	movk	x0, #0xfe00, lsl #32
    fd800000ef8c:	f9400262 	ldr	x2, [x19]
    fd800000ef90:	97ffca94 	bl	fd80000019e0 <pt_get_pte>
    *pte = install_info->vm_section_pte;
    fd800000ef94:	f9400661 	ldr	x1, [x19, #8]
}
    fd800000ef98:	f9400bf3 	ldr	x19, [sp, #16]
    *pte = install_info->vm_section_pte;
    fd800000ef9c:	f9000001 	str	x1, [x0]
}
    fd800000efa0:	a8c27bfd 	ldp	x29, x30, [sp], #32
    fd800000efa4:	d65f03c0 	ret
	...

0000fd800000efb0 <vm_mem_prot_init>:

#include <config.h>
#include <mem.h>

void vm_mem_prot_init(struct vm* vm, const struct vm_config* config)
{
    fd800000efb0:	aa0103e2 	mov	x2, x1
    as_init(&vm->as, AS_VM, vm->id, NULL, config->colors);
    fd800000efb4:	d2800003 	mov	x3, #0x0                   	// #0
    fd800000efb8:	52800021 	mov	w1, #0x1                   	// #1
    fd800000efbc:	f9401844 	ldr	x4, [x2, #48]
    fd800000efc0:	f8458402 	ldr	x2, [x0], #88
    fd800000efc4:	17fffd83 	b	fd800000e5d0 <as_init>
	...

0000fd800000efd0 <uart_disable>:

#include <drivers/pl011_uart.h>

void uart_disable(volatile struct Pl011_Uart_hw* ptr_uart)
{
    uint32_t ctrl_reg = ptr_uart->control;
    fd800000efd0:	b9403001 	ldr	w1, [x0, #48]
    ctrl_reg &= ((~UART_CR_UARTEN) | (~UART_CR_TXE) | (~UART_CR_RXE));
    ptr_uart->control = ctrl_reg;
    fd800000efd4:	b9003001 	str	w1, [x0, #48]
}
    fd800000efd8:	d65f03c0 	ret
    fd800000efdc:	d503201f 	nop

0000fd800000efe0 <uart_enable>:

void uart_enable(volatile struct Pl011_Uart_hw* ptr_uart)
{
    uint32_t ctrl_reg = ptr_uart->control;
    fd800000efe0:	b9403001 	ldr	w1, [x0, #48]
    ctrl_reg |= (UART_CR_UARTEN | UART_CR_TXE | UART_CR_RXE);
    fd800000efe4:	52806022 	mov	w2, #0x301                 	// #769
    fd800000efe8:	2a020021 	orr	w1, w1, w2
    ptr_uart->control = ctrl_reg;
    fd800000efec:	b9003001 	str	w1, [x0, #48]
}
    fd800000eff0:	d65f03c0 	ret
    fd800000eff4:	d503201f 	nop
    fd800000eff8:	d503201f 	nop
    fd800000effc:	d503201f 	nop

0000fd800000f000 <uart_set_baud_rate>:
    uint32_t temp;
    uint32_t ibrd;
    uint32_t mod;
    uint32_t fbrd;

    if (baud_rate == 0) {
    fd800000f000:	34000161 	cbz	w1, fd800000f02c <uart_set_baud_rate+0x2c>
        baud_rate = UART_BAUD_RATE;
    }

    /* Set baud rate, IBRD = UART_CLK / (16 * BAUD_RATE)
    FBRD = ROUND((64 * MOD(UART_CLK,(16 * BAUD_RATE))) / (16 * BAUD_RATE)) */
    temp = 16 * baud_rate;
    fd800000f004:	531c6c22 	lsl	w2, w1, #4
    ibrd = UART_CLK / temp;
    fd800000f008:	529f0004 	mov	w4, #0xf800                	// #63488
    fd800000f00c:	72a02484 	movk	w4, #0x124, lsl #16
    fd800000f010:	1ac20883 	udiv	w3, w4, w2
    mod = UART_CLK % temp;
    fd800000f014:	1b029062 	msub	w2, w3, w2, w4
    fbrd = (4 * mod) / baud_rate;

    /* Set the values of the baudrate divisors */
    ptr_uart->integer_br = ibrd;
    fd800000f018:	b9002403 	str	w3, [x0, #36]
    fbrd = (4 * mod) / baud_rate;
    fd800000f01c:	531e7442 	lsl	w2, w2, #2
    fd800000f020:	1ac10841 	udiv	w1, w2, w1
    ptr_uart->fractional_br = fbrd;
    fd800000f024:	b9002801 	str	w1, [x0, #40]
}
    fd800000f028:	d65f03c0 	ret
    fd800000f02c:	52800143 	mov	w3, #0xa                   	// #10
    ptr_uart->integer_br = ibrd;
    fd800000f030:	b9002403 	str	w3, [x0, #36]
    ptr_uart->fractional_br = fbrd;
    fd800000f034:	52800341 	mov	w1, #0x1a                  	// #26
    fd800000f038:	b9002801 	str	w1, [x0, #40]
}
    fd800000f03c:	d65f03c0 	ret

0000fd800000f040 <uart_init>:
void uart_init(volatile struct Pl011_Uart_hw* ptr_uart /*, uint32_t baud_rate*/)
{
    uint32_t lcrh_reg;

    /* First, disable everything */
    ptr_uart->control = 0x0;
    fd800000f040:	b900301f 	str	wzr, [x0, #48]
    ptr_uart->integer_br = ibrd;
    fd800000f044:	52800146 	mov	w6, #0xa                   	// #10
    ptr_uart->fractional_br = fbrd;
    fd800000f048:	52800345 	mov	w5, #0x1a                  	// #26
    /* Default baudrate = 115200 */
    uint32_t baud_rate = UART_BAUD_RATE;
    uart_set_baud_rate(ptr_uart, baud_rate);

    /* Set the UART to be 8 bits, 1 stop bit and no parity, FIFOs enable*/
    ptr_uart->line_control = (UART_LCR_WLEN_8 | UART_LCR_FEN);
    fd800000f04c:	52800e04 	mov	w4, #0x70                  	// #112
    lcrh_reg = ptr_uart->line_control;
    fd800000f050:	b9402c01 	ldr	w1, [x0, #44]

    /* Enable the UART, enable TX and enable loop back*/
    ptr_uart->control = (UART_CR_UARTEN | UART_CR_TXE | UART_CR_LBE);
    fd800000f054:	52803023 	mov	w3, #0x181                 	// #385

    /* Set the receive interrupt FIFO level to 1/2 full */
    ptr_uart->isr_fifo_level_sel = UART_IFLS_RXIFLSEL_1_2;
    fd800000f058:	52800202 	mov	w2, #0x10                  	// #16
    lcrh_reg &= ~UART_LCR_FEN;
    fd800000f05c:	121b7821 	and	w1, w1, #0xffffffef
    ptr_uart->line_control = lcrh_reg;
    fd800000f060:	b9002c01 	str	w1, [x0, #44]
    ptr_uart->integer_br = ibrd;
    fd800000f064:	b9002406 	str	w6, [x0, #36]
    ptr_uart->fractional_br = fbrd;
    fd800000f068:	b9002805 	str	w5, [x0, #40]
    ptr_uart->line_control = (UART_LCR_WLEN_8 | UART_LCR_FEN);
    fd800000f06c:	b9002c04 	str	w4, [x0, #44]
    ptr_uart->control = (UART_CR_UARTEN | UART_CR_TXE | UART_CR_LBE);
    fd800000f070:	b9003003 	str	w3, [x0, #48]
    ptr_uart->isr_fifo_level_sel = UART_IFLS_RXIFLSEL_1_2;
    fd800000f074:	b9003402 	str	w2, [x0, #52]

    ptr_uart->data = 0x0;
    fd800000f078:	b900001f 	str	wzr, [x0]
    while (ptr_uart->flag & UART_FR_BUSY) { }
    fd800000f07c:	d503201f 	nop
    fd800000f080:	b9401801 	ldr	w1, [x0, #24]
    fd800000f084:	371fffe1 	tbnz	w1, #3, fd800000f080 <uart_init+0x40>

    /* Enable RX */
    ptr_uart->control = (UART_CR_UARTEN | UART_CR_RXE | UART_CR_TXE);
    fd800000f088:	52806021 	mov	w1, #0x301                 	// #769
    fd800000f08c:	b9003001 	str	w1, [x0, #48]

    /* Clear interrupts */
    ptr_uart->isr_clear = (UART_ICR_OEIC | UART_ICR_BEIC | UART_ICR_PEIC | UART_ICR_FEIC);
    fd800000f090:	5280f001 	mov	w1, #0x780                 	// #1920
    fd800000f094:	b9004401 	str	w1, [x0, #68]

    /* Enable receive and receive timeout interrupts */
    ptr_uart->isr_mask = (UART_MIS_RXMIS | UART_MIS_RTMIS);
    fd800000f098:	52800a01 	mov	w1, #0x50                  	// #80
    fd800000f09c:	b9003801 	str	w1, [x0, #56]
}
    fd800000f0a0:	d65f03c0 	ret
    fd800000f0a4:	d503201f 	nop
    fd800000f0a8:	d503201f 	nop
    fd800000f0ac:	d503201f 	nop

0000fd800000f0b0 <uart_getc>:
uint32_t uart_getc(volatile struct Pl011_Uart_hw* ptr_uart)
{
    uint32_t data = 0;

    // wait until there is data in FIFO
    while (!(ptr_uart->flag & UART_FR_RXFE)) { }
    fd800000f0b0:	b9401801 	ldr	w1, [x0, #24]
    fd800000f0b4:	3627ffe1 	tbz	w1, #4, fd800000f0b0 <uart_getc>

    data = ptr_uart->data;
    fd800000f0b8:	b9400000 	ldr	w0, [x0]
    return data;
}
    fd800000f0bc:	d65f03c0 	ret

0000fd800000f0c0 <uart_putc>:

void uart_putc(volatile struct Pl011_Uart_hw* ptr_uart, int8_t c)
{
    fd800000f0c0:	13001c21 	sxtb	w1, w1
    // wait until txFIFO is not full
    while (ptr_uart->flag & UART_FR_TXFF) { }
    fd800000f0c4:	d503201f 	nop
    fd800000f0c8:	b9401802 	ldr	w2, [x0, #24]
    fd800000f0cc:	372fffe2 	tbnz	w2, #5, fd800000f0c8 <uart_putc+0x8>

    ptr_uart->data = c;
    fd800000f0d0:	b9000001 	str	w1, [x0]
}
    fd800000f0d4:	d65f03c0 	ret
